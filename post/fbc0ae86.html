<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>24.多线程 | 星仔极客</title><meta name="keywords" content="Java语言"><meta name="author" content="星仔极客"><meta name="copyright" content="星仔极客"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="24.多线程"><meta name="application-name" content="24.多线程"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="24.多线程"><meta property="og:url" content="https://xinzaigeek.68565200.xyz/post/fbc0ae86.html"><meta property="og:site_name" content="星仔极客"><meta property="og:description" content="知识点一：Thread线程基础 有一个场景：在一个程序中即可以玩游戏又可以播放音乐？ 以现在编程手段而言 —》 提供编程结构【顺序、分支、循环】 代码是要遵守顺序执行，代码需要遵守从上至下逐行执行，利用分支和循环修改循环执行一些操作，选择性执行某代码或者是让某些代码重复执行，无论如何操作代码依旧要顺"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp"><meta property="article:author" content="星仔极客"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp"><meta name="description" content="知识点一：Thread线程基础 有一个场景：在一个程序中即可以玩游戏又可以播放音乐？ 以现在编程手段而言 —》 提供编程结构【顺序、分支、循环】 代码是要遵守顺序执行，代码需要遵守从上至下逐行执行，利用分支和循环修改循环执行一些操作，选择性执行某代码或者是让某些代码重复执行，无论如何操作代码依旧要顺"><link rel="shortcut icon" href="https://img.picgo.net/2024/09/24/811513a1eaacadb85ae79568d39c3337b8b87d11b124d4ab.png"><link rel="canonical" href="https://xinzaigeek.68565200.xyz/post/fbc0ae86"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: undefined,
  diytitle: undefined,
  LA51: {"enable":true,"ck":"3HZ1UVjhMEV6g7Lg","LingQueMonitorID":"3HZ1UVjhMEV6g7Lg"},
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: undefined,
  friends_vue_info: undefined,
  navMusic: false,
  mainTone: {"mode":"api","api":"https://api.qjqq.cn/api/Imgcolor?img=","cover_change":true},
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 星仔极客","link":"链接: ","source":"来源: 星仔极客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '星仔极客',
  title: '24.多线程',
  postAI: '',
  pageFillDescription: '知识点一：Thread线程基础, 知识点二：并行和并发, 知识点三：线程和进程, 知识点四：Java程序中实现线程的方式, 1、线程创建方式之继承Thread类, 2、线程创建方式之实现Runnable接口, 3、Thread类创建线程和Runnable接口创建线程, 4、start方法和run方法, 5、使用匿名内部类或Lambda表达式便捷的创建线程对象并执行（了解）, 知识点五：线程常用方法, 1、线程状态getState, 2、线程优先级setPriority, 3、更改和获取线程的名字, 4、线程休眠sleep【使用几率极高】, 5、线程礼让yield（了解）, 6、线程合并join, 7、线程中断(标记), 知识点六：火车售票问题, GetInstance, 1、如何解决多线程并发访问临界资源保证资源安全问题, 2、synchronized关键字, 3、同步方法/对象同步方法/成员同步方法, 4、类锁/类同步代码块/类同步方法/静态同步方法, 知识点七：线程通信, 1、完成生产者和消费者通信模型v1版本, 2、完成生产者和消费者通信模型v2版本, 3、分析执行流程, 知识点八：多对多通信模型, 1、负数问题, 2、死等待问题, 3、扩展：Lock接口【显示锁】, 知识点九：线程声明周期, 知识点十：拓展, 1、线程池【重点】, （1）线程池概念, （2）线程池实现原理, （3）线程池中常见的类, （4）Callable接口, （5）Future接口, （6）读写锁, （7）重入锁, （8）公平锁知识点一线程基础有一个场景在一个程序中即可以玩游戏又可以播放音乐以现在编程手段而言提供编程结构顺序分支循环代码是要遵守顺序执行代码需要遵守从上至下逐行执行利用分支和循环修改循环执行一些操作选择性执行某代码或者是让某些代码重复执行无论如何操作代码依旧要顺序执行没有办法让两段代交替执行此时为了解决这样的问题提供一个操作这个操作就叫做线程可以在代码中使用多线程形式来完成这个操作现在电脑基本上都是多核所以每个人电脑上运行线程程序结果可能都不一样这是一个非常正常现象多线程运行时是一个不可预知状态程序猿可以通过代码干预线程运行以达到我们运行效果知识点二并行和并发这两个概念在宏观的角度而言他们是一样相似的但是在微观的角度而言他们是有区别并行就是同时执行并发就是在交替执行在操作系统中安装了很多程序并发指的是在一段时间内宏观上多个程序同时执行这个在单个系统中每一个时刻只有一个程序执行即微观上这些程序是分时交替的执行只不过给人感觉是在同时运行因为分时交替运行时间非常短暂现在而言都是多核则这些并发执行程序可以分配到不同的处理器上实现多个任务并行执行即利用每个处理器来处理一个可以并发执行的程序这样多个程序就可以同时执行了你的电脑核心越多你电脑的性能就相对更加强悍单核处理的计算机肯定是不能并行处理多个任务只能是多个任务在单个上并发需要运行同理线程也是一样的从宏观的角度而言线程并行运行从微观角度看就是串行运行即线程是一个一个去执行的当系统只有一个是线程会以某种顺序执行多个线程这个情况称之线程调度线程提供时间争抢知识点三线程和进程进程进程是程序的一次执行过程是系统运行程序的基本单元系统运行一个程序即在运行一个进程从创建运行消亡的一个过程每一个进程都有自己一个独立的空间内存空间一个应用程序进程可以同时运行多个线程特点进程是一个独立程序单元并且拥有自己独立空间一个进程中可以同时运行多个线程进程是可以完成多个任务交替执行的可以开发一个音乐软件音乐网易云音乐酷狗音乐也可以开发一个打游戏软件吃鸡战场只要运行这两个进程程序就可以完成一边听音乐一边打游戏这样做开发成本高进行是独立的进程与进程之间是无法进行通信的线程线程是进程中一个内部执行单元负责当前进程中的程序执行一个进程中至少有一个线程一个进程可以有多个线程这些线程在进程中被称之为多线程进程就可以利用这些多线程去完成不同操作特点线程是在进程的内部执行并且可以存在多个彼此之间共享进程的内存区域线程与线程之间彼此独立但是可以进行通信可以利用这个轻量级的开发完成一个进程内部程序交替执行效果线程并发执行总结进程与线程的区别进程有独立的内存空间进程中数据存放的空间是独立的并且至少有一个线程线程堆空间是共享的栈空间是独立的线程消耗的资源要比进程小并且可以多个线程存在同一个进程中需要知道了解的知识点因为一个程序中有多个线程并发运行那么从微观的角度而言是有先后顺序的那么线程执行的顺序是取决于的调度线程争抢时间片程序猿只能进行干涉在不加干涉前提下线程执行就会出现很多随机性程序进程中最少包含两个线程一个是主线程就是方法它在执行方法是或者执行程序时它的优先级永远最高另外一个垃圾回收机制线程守护线程每当执行一个类的时候实际上都会启动一个每一个实际上就是在操作系统中启动了一个线程本身就被垃圾回收机制所守护所运行时至少启动了两个线程由于创建一个线程开销远比创建一个进程开销要小很多那么我们在开发多任务运行时通常会优先考虑创建多线程而不是多进程所有的线程轮流使用每一个线程都会得到分配的时间片这个分配尽量平均分配资源但是这个效果不一定能达到所以同优先级的线程对时间的争抢是存在随机性的可以对线程进行优先级设置来概念获取时间片的几率优先级越高几率越大优先级越低几率越小知识点四程序中实现线程的方式在中主要创建线程方式有四种继承类此时子类就是线程类实现接口此时实现类不是线程类使用类才可成为线程无论是上述两种方式中那种方式都需必须重写方法实现线程逻辑实现接口此实现方方式并不是线程类主要针对的是线程池提供线程池可以帮组我们创建线程并进行管理操作如果实现线程需要继承或实现接口但是无论是那种都需要实现一个必要核心方法这个方法是提供线程实现的核心逻辑需要线程什么样需求代码就将将代码写入到这个线程中使用实现接口的对象创建一个线程时启动该线程将导致在独立执行的线程中调用对象的方法通过观察可以发现这个方法是没有参数和返回值类型所以这个不能通过方法接收参数和返回数据值线程创建方式之继承类步骤定义一个普通类继承与类在子类中重新给父类中方法并提供线程实现逻辑在测试类中方法中通过线程子类或这个父类创建线程对象并执行线程启动完成调用方法中逻辑执行因为本身就是线程类所以继承类子类也是线程类具备父类中所提供的所有操作者线程方法需求使用继承类方法是完成边打游戏和边听音乐为了演示效果方便观察写在同一个文件中此时继承与类所以就是线程类必须重写父类中的方法提供这个线程需要的执行逻辑打游戏此时继承与类所以就是线程类必须重写父类中的方法提供这个线程需要的执行逻辑听音乐提供一个测试类完成线程创建与调用方法本身一个线程主线线程优先级最高如何创建线程对象下面两种创建线程方式并没有指定线程优先级所以都是默认优先级和的优先级相同使用多态的效果是子线程类父类所以可以使用方式创建线程对象的名字子线程类直接使用继承线程子类创建对象子线程类线程对象的名字子线程类启动线程执行调用类中提供方法而不是调用方法线程创建方式之实现接口实现接口的类并不是线程类只是实现接口并提供方法的重写需要配合使用类创建线程对象此时线程才可以操作因为接口中提供方法的实现实现接口的类传入到类中时就会覆盖类中方法所以提供创建线程对象就会执行重写接口中方法就会得到线程的效果步骤定义一个普通类实现接口实现接口的类必须重写方法提供线程需要执行的逻辑在测试类中方法中使用创建线程对象完成线程操作需求使用继承类方法是完成边打游戏和边听音乐为了演示效果方便观察写在同一个文件中此类就是实现接口并提供方法实现类打游戏听音乐创建接口实现类作为线程对象操作需要将接口的对象传递到这个类中先创建接口实现类的对象然后再传递到类中进行线程对象创建使用匿名对象的方式进行构造方法参数传递启动线程类创建线程和接口创建线程两种方式皆可因为都要实现方法但是从类的扩展角度而言建议使用实现接口方式来完成作因为中类是单一继承所以如果继承类就无法在继承其他类所以就会影响类的扩展但是如果实现接口方式完成不仅可以继承一个类还可以实现多个接口所以就比较推荐实现接口继承效果没有办法让在继承不仅可以作为线程类操作而且还可以进行继承其他类方法和方法创建完毕线程对象之后线程执行需要调用的是方法而不是方法方法用方法来启动线程真正的实现了线程运行通过类中给提供来启动一个线程此时线程会进入到准备就绪状态但是真正运行一旦线程获取到时间片此时线程才会真正的执行执行调用提供方法完成线程逻辑方法方法只是一个普通方法只是在方法中实现线程执行逻辑如果外界直接调用方法线程是没有启动只不过是在方法调用了方法执行执行出方法提供操作和线程一点关系都没有使用匿名内部类或表达式便捷的创建线程对象并执行了解这种方式线程是现创建现使用只会使用一次即可针对类提供匿名内部类创建只支持匿名内部类听音乐在最外侧的大括号中调用方法针对接口提供匿名内部类和表达式实现打游戏在最外侧的大括号中调用方法吃饭在最外侧的大括号中调用方法知识点五线程常用方法线程状态这个方法可以返回线程运行状态有一个静态属性中给返回类型时错误的它不是静态类他是一个枚举使用方法进行求和操作是子类所以会得到所有方法进入方法是当前线程状态在启动线程之前方法之前线程状态方法之后线程状态可以表示线程状态说明出生新生至今尚未启动的线程就是这种状态准备就绪和执行中提供类并没有提供准备就绪的状态描述所以就有两个概念调用方法时是准备就绪执行方法时是执行阻塞或睡眠方法当线程出现阻塞状态当前线程就会出现让出时间片的操作等待后续执行等待等待是无限期等待只有进行唤醒之后等待效果才会消失等待不是阻塞状态时间等待在设置等待状态时设置一个时间只要在时间范围内都是等待状态如果到了并且在等待时期并没有进行唤醒从操作等待线程会自动唤醒消亡死亡线程都执行完毕不会在执行就出现这个状态线程结束线程优先级理论上线程优先级越高获取时间片的几率越大反之获取几率越小但是优先级只是相当于给一个暗示先由我开始但是是否会决定将时间片给当前线程是决定所有在没有修改优先级之前的线程默认优先级都是相同在中使用之间数字表示线程优先级数值越大优先级越高所有在没有修改优先级之前默认优先级是中提供三个静态常量方便对优先级的定义线程可以具有的最高优先级等级线程可以具有的最低优先级等级分配给线程的默认优先级等级获取线程名字的数值利用线程创建两个线程对象使用默认优先级可能会出现先执行或先执行修改优先级只要优先级的差别较大就可以的得到先执行和后执行效果只要优先级等级差别不是很大比较接近执行效果就不是很明显了更改和获取线程的名字线程是有默认名字组成方式使用到一个关键字数字数字的从开始随着线程创建而逐渐增多随着线程的减少而逐渐减少默认名字数字在编写线程程序时可以通过方法获取线程名字但是如果创建线程过多使用默认名字看到效果就不是很明显中提供线程名字修改方式有三种在创建出线程对象之后调用线程新的名字使用类实现接口并使用类创建线程对象调用两个参数版本构造方法进行名字设置接口实现类的对象线程名字使用类继承与类子类中提供一个仿照父类生成构造方法这个方法参数是子类只需要实现这个构造方法即可在创建线程对象时只需要调用有参构造方法就可以指定线程名字方式一线程方式二线程方式三线程多态你好实现接口不是线程类所以不能在实现接口类中调用类中方法线程的名字如何在实现接口的类中获取当前线程类中提供一个静态方法可以获取当前线程对象通过静态访获取到线程对象你好子类只要仿照生成一个带有类型参数方法即可线程休眠使用几率极高这个方法是静态方法它可以让线程进入到阻塞状态即让线程进行到休眠时间进入休眠之后线程会让出时间片给其他的线程进行争抢当休眠时间到了之后恢复之后线程会继续和其线程进行时间片的争抢方法的参数是毫秒值毫秒等于秒线程如果触发方法会有两种方式可以醒来自然醒来睡眠时间到了自动醒来中断醒来会通过类中添加中断标记强行让醒来所以方法在调用时候会有一个编译时异常中断异常特别注意如果方法被调用在同步锁对象锁同步监听器同步代码块中方法休眠之后是不会让出当前系统时间片虽然会睡眠时间片也会释放但是外界线程是无法获取需求通过方法来实现以下交替执行效果只要值可以对整除当前线程在方法中调用方法是不可以异常只能抓取创建线程对象子线程程序会默认提供两个线程一个是和一个是方法主线程作为线程操作在主线程中提供和类中一样的操作当前线程方法确实可以让线程进入到休眠状态并且释放出时间片但是时间无法正确把控就会造成无法使用方法进行代码的交替执行线程礼让了解礼让线程的作用就是在调用方法的线程中让出时间片相当于通知不急着执行让出之后会不会回收时间片取决于礼让原则是线程优先级越高礼让效果就是会明显一些和方法是有一定区别的是立即让出时间片在睡眠时间内是不会争抢时间片方法执行之后礼让线程会进入准备就绪礼让线程可能会再次持有时间片线程的名字让线程礼让创建两个线程对象线程线程线程合并合并线程是一个效果非常明显操作合并线程是一个线程正处于运行阶段此时这个线程达到某个条件时可以让其他线程合并到这个执行线程中只要使用合并合并线程必然会得到时间片被合并的线程需要等待合并线程执行完毕之后才会继续运行需求妹子在看葫芦娃级当看到级汉子要看喜洋洋妹子正在看精钢葫芦娃大战蛇精启动另外一个线程进行合并操作合并之前必要前提要合并线程必须进入准备就绪状态即调用方法汉子正在看喜羊羊与灰太狼线程合并必然是让出时间片时间片会的线程线程必须是启动状态调用线程中断标记在这个类中提供让线程停止方法方法但是这个方法被进行过时处理所以就不建议在线程中进行使用了所以就提供一个替代方法的方法方法线程中执行值是停止线程过时的方法中断线程使用这个线程中断标记方法向线程中添加中断标记只有被含有中断异常方法检测到这个标记就会终止方法的执行效果明显和不明显直接在线程调用这个方法是无用的只是添加标记不会停止线程配合中所提供的一个方法来使用作用检查线程中是否存在中断标记如果存在着返回不存在则返回正确使用方式线程中执行值是使用替代方法中断线程时当遇到某个条件要终止线程时检查中断标记停止线程向线程中添加中断标记强行终止睡眠进入线程没有被中断正常睡眠苏醒中断睡眠苏醒线程结束为了效果让主线程休眠秒之后在触发中断标记如果检查到中断标记就会强行终止睡眠知识点六火车售票问题需求火车站买票一共有且仅有张票个窗口同时贩卖临界资源就是这个票多个线程访问保证票有且仅有张开个线程同时买张票其实这个卖票案例就是多线程下同时操作一个资源临界资源如何保证线程操作资源安全不出现以下情况买票不会出现重票线程卖出第张票线程卖出张票错误票线程卖出第张票线程卖出张票这个是对但是线程卖出张票负数票某个线程买完最后一张票的时候剩余线程就不能在卖票票秒卖一张有且仅有张不要卖出张票数问题如何将票固定在张而不是每个线程都卖出张票如何做到所有的线程都共享这一个资源将票作为成员变量作为成员变量之后需要保证这个提供票的类在外界创建对象必须是唯一的如果不唯一的就会出现你创建票的对象每个对象都会唯一一个成员变量个对象就是个成员变量此时相当于张票单例设计模式单例设计模式的原则保证外界无论如何获取对象都是唯一的基础版本版本不要让类继承与继承必然要提供四个线程对象这样就会出现无法控制票张建议实现以实现类方式创建线程处理提供成成员变量存储票的信息执行买票操作提供一个循环这个循环执行次提供买票的逻辑证明还票可以出售休眠秒在买票买票当前售票员第票如果提供的是成员变量保证存储成员变量的这个类所得到对象是必须唯一出现张票问题在构建线程对象时提供四个接口实现类对象创建刘德华张学友郭富城吴奇隆在外界只创建一个接口实现类对象保证对象是唯一的只会维护一份的票对象张利用这个对象初始化创建个线程对象刘德华张学友郭富城吴奇隆在主函数开始时调用返回一个实例化对象此对象是的在内存中保留着它的引用即内存中有一块区域专门用来存放静态方法和变量可以直接使用调用多次返回同一个对象与区别如这时候就必须要知道有第二个的存在而第二个也常常是在当前的应用程序域中的可以被直接调用的提供了成员变量提供成员变量变量是存储票信息单设计模式的原则保证在外界获取对象时都是同一个对象地址也是相同的私有化构造方法提供一个私有化静态变量并对静态变量进行赋值类型是本类类型提供对象创建提供一个静态共有方法可以获取本类对象的唯一途径使用本类类型创建对象执行买票操作提供一个循环这个循环执行次提供买票的逻辑证明还票可以出售休眠秒在买票买票当前售票员第票提供了静态变量这个类的创建对象方式就无所谓刘德华张学友郭富城吴奇隆定义一个变量保证所有对象共享无论外界如何创建线程对象实现还是继承类这里都可以保证所有兑现共享这个变量可以提供一个修饰变量即静态变量版本提供了静态变量提供静态成员变量存储票的信息执行买票操作提供一个循环这个循环执行次提供买票的逻辑证明还票可以出售休眠秒在买票买票当前售票员第票提供了静态变量这个类的创建对象方式就无所谓刘德华张学友郭富城吴奇隆问题在买票的时候会出现重票错票排序顺序的混乱的问题这个问题产生就是多线程并发争抢临界资源出现里临界资源不安全问题如何解决多线程并发访问临界资源保证资源安全问题此时为了保证多线程并发访问临界资源线程安全问题提供了一个处理机制可以在处理临界资源代码中添加同步锁对象锁同步代码块同步监听器这里四个名称都是指的是同一个操作可以添加锁机制保证在同一个时刻的只有一个线程操作临界资源保证临界资源安全关键字翻译意思同步使用关键字进行同步操作使用组成同步操作叫做同步锁对象锁同步代码块语法资源锁对象提供操作临界资源的代码执行原理利用了同一时间内只能有一个线程对象持有当前资源锁对象只要线程不释放这个所资源对象外界线程是无法执行线程逻辑资源代码在同步代码块中执行线程进行休眠是不会释放时间片到外界给其他线程因为方法是不会释放锁资源需要注意还需要保证资源锁对象必须是唯一的不唯一锁对象数无法进行同步操作如果保证资源锁对象是唯一的个人建议十分不推荐使用作为锁资源对象可能锁不了代表的是当前对象那么就意味着这个提供临界支援类必须是创建唯一的对象才可以这样才可以保证是唯一的替代方案一在静态资源处理线程类中提供一个全局静态常量锁资源提供操作临界资源的代码替代方案二推荐天生对象就是唯一的中这个对象无论你如何操作就可以保证他是唯一的地址都是同一个字符串类直接使用字符串对象即可使用双引号创建提供字符串空串处理即提供字符串空串对象提供操作临界资源的代码使用同步代码块修改买票的案例的版本提供了静态变量和同步代码块执行买票操作提供静态成员变量存储票的信息执行买票操作提供一个循环这个循环执行次提供买票的逻辑同步代码块证明还票可以出售休眠秒在买票买票当前售票员第票提供了静态变量这个类的创建对象方式就无所谓刘德华张学友郭富城吴奇隆同步方法对象同步方法成员同步方法使用关键字进行成员方法的修饰这个方法就会成为同步方法将操作资源代码写入到这个方法中就可以进行同步操作了语法访问权限修饰符返回值类型方法名参数列表方法体特别注意使用是同步方法所以这个方法使用锁资源对象是提供同步方法的这个类所创建对象必须是唯一的才可以锁住资源到目前位置方法定义中其他修饰符就已经全部介绍完毕类中方法可以使用接口中方法可以使用修饰同步方法是该买票案例版本提供了静态变量和同步方法进行买票提供静态成员变量存储票的信息执行买票操作提供一个循环这个循环执行次提供买票的逻辑调用同步方法即可同步方法这个锁资源对象是提供就是线程处理临界资源操作证明还票可以出售休眠秒在买票买票当前售票员第票提供了静态变量这个类的创建对象方式就无所谓同步方法提供类如果是线程类需要保证线程类对象是唯一的这是保证线程类对象唯一刘德华张学友郭富城吴奇隆类锁类同步代码块类同步方法静态同步方法如果使用是同步代码块的语法就是将资源锁对象从当前对象替换成类对象通过类的方式获取对象通反射获取静态同步方法就是使用和同时修饰方法类锁类同步代码块类名类锁对象操作临界资源代码即可类同步方法静态同步方法访问权限修饰符返回值类型方法名参数列表方法代码版本提供了静态变量和静态同步操作提供静态成员变量存储票的信息执行买票操作提供一个循环这个循环执行次提供买票的逻辑调用同步方法即可类锁证明还票可以出售休眠秒在买票买票当前售票员第票静态同步方法这个锁资源就是当前类的对象是唯一的通过类获取即类提供就是线程处理临界资源操操作证明还票可以出售休眠秒再买票卖票当前售票员第票提供了静态变量这个类的创建对象方式就无所谓同步方法提供类如果是线程类需要保证线程类对象是唯一的刘德华张学友郭富城吴奇隆总结在开发中常用肯定是对象锁同步代码块但是这个代码块的范围不要太大不然的话会影响执行效率在什么位置对资源操作就在什么位置添加同步代码块使用关键字之后线程就会变成安全间接就将并行线程修改为串行线程使用锁机制将线程变成一个一个站排执行效果知识点七线程通信到现目前位置线程与线程之间依旧是彼此独立就算使用同步代码块也是让线程执行有一定顺序但是还是没有进行通信操作如果需要遇到某个线程执行完毕之后需要通知另外一个线程继续执行此时就需要使用到线程通信可以在一个进程中开发多个线程每个线程之间可以进行通信操作从而协调性的完成某个进程中需要执行逻辑线程通信有一个标准的通信模型生产者与消费者模式完成生产者和消费者通信模型版本银行类提供数据维护与使用基础的第一个版本提供临界资源并提供操作临界资源一共有两种提供方式提供成员变量和提供静态变量存储前的临界变量外界无论如何创建类对象都需要是唯一的不然的话成员变量会跟着对象多少而进行创建提供对象唯一创建方式单例设计模式单例设计模式可以保证外界无论如何操作得到对象都是唯一单例设计模式的实现一定要私有化构造方法防止外界调用构造方法创建对象提供一个私有静态常量对象这个对象就是单例类唯一创建对象提供一个静态方法获取这个创建好的对象得到实例外界只能通过这个方法获取对象生产者向共享资源中存储数据的方法生产存储钱存了余额是消费者向共享资源中存储数据的方法消费消费钱取了余额是生产者是一个线程提供数据存储操作生产者提供银行属性提供线程存储钱的操作存储十次每次元消费者是一个线程提供数据获取操作消费者提供银行属性提供线程存获取的操作获取十次每次元提供一个测试类进行测试操作通过单例获取银行对象创建线程对象并启动操作花花菲菲问题现在执行速度太快了看不到交替执行效果让线程休眠秒操作问题虽然让线程休眠之后出现了一个执行错乱的问题因为多线程并发访问临界资源出现线程挣抢的问题所以出现临界资源部不安全问题添加同步代码块银行类需要修改为基础的第一个版本提供临界资源并提供操作临界资源一共有两种提供方式提供成员变量和提供静态变量存储前的临界变量外界无论如何创建类对象都需要是唯一的不然的话成员变量会跟着对象多少而进行创建提供对象唯一创建方式单例设计模式单例设计模式可以保证外界无论如何操作得到对象都是唯一单例设计模式的实现一定要私有化构造方法防止外界调用构造方法创建对象提供一个私有静态常量对象这个对象就是单例类唯一创建对象提供一个静态方法获取这个创建好的对象得到实例外界只能通过这个方法获取对象生产者向共享资源中存储数据的方法生产存储钱存了余额是消费者向共享资源中存储数据的方法消费消费钱取了余额是完成生产者和消费者通信模型版本使用了同步代码块方法虽然让程序执行有序了也保证线程中操作临界资源过程也安全了但是还是无法保证线程可以做到交替执行的效果即生产者生产完数据之后通知消费者可以进行消费消费者消费完数据之后通知生产者可以生产所以如何完成这个通信操作呢此时就需要使用中类中提供三个方法了线程通信方法方法说明执行该方法的线程对象会释放同步锁资源会把当前线程放到等待池中等待其他线程唤醒操作执行该方法的线程对象会在等待池随机唤醒一个等待的线程把线程转移到锁池中等待再次获取资源执行该方法的线程对象会在等地池中唤醒所有的线程把线程转移到锁池中等待再次获取资源就可以利用这三个方法进行线程通信操作了特别注意调用通信方法必须是锁资源对象否则会出现异常提示信息在哪里调用等待方法就在位置被唤醒线程通信执行流程假设线程和线程共同操作一个锁对象线程可以通过锁对象调用和方法进行如下线程通信操作当线程执行到锁对象时线程持有锁对象线程是没有执行机会的线程在对象的等待锁池中线程在同步代码块种执行到方法时线程会释放对象所资源线程会进入到对象的等待锁池中线程就会在等待锁池中得到线程释放的资源锁对象线程就开始执行操作线程在同步代码块中执行到方法时把线程从对象等待池中移动到等待对象锁资源中得到锁资源线程执行完毕之后释放锁资源线程就有机会获取到锁继续执行同步方法修改类提供线程通信操作者通信的版本提供临界资源并提供操作添加线程通信和同步代码块方法临界资源一共有两种提供方式提供成员变量和提供静态变量存储前的临界变量外界无论如何创建类对象都需要是唯一的不然的话成员变量会跟着对象多少而进行创建提供对象唯一创建方式单例设计模式单例设计模式可以保证外界无论如何操作得到对象都是唯一单例设计模式的实现一定要私有化构造方法防止外界调用构造方法创建对象提供一个私有静态常量对象这个对象就是单例类唯一创建对象提供一个静态方法获取这个创建好的对象得到实例外界只能通过这个方法获取对象在外界创建生产者与消费者线程对象中都是可以获取到资源但是问题在于如果消费者先获取到资源但是没有数据不能消费所以就提供一个变量来存储状态的通过对这个状态的判断决定执行哪个线程生产者向共享资源中存储数据的方法生产存储钱添加线程通信操作如果条件为值就证明现在有数据无需生产生产这个就进入到等待状态因为没有执行就证明没有数据可以生产存了余额是生产数据完毕之后需要修改状态信息执行唤醒操作消费者向共享资源中存储数据的方法消费消费钱增加线程通信操作状态值代表没有数据代表有属性没有数据的时候不能执行消费等待生产没有数据值是取非操作就执行等待有数据值是取非操作就不执行等待进行消费分支语句不执行就证明有数据进行消费操作取了余额是修改状态数据进行唤醒操作分析执行流程现有的两个线程生产者花花和消费者菲菲默认初始状态都是消费者菲菲先获取到时间片持有所资源判断分支条件为消费者菲菲就会释放锁资源并且进入到等待池中等待池生产者花花等待池中生产者花花就会或得到执行时间片并且获取到锁资源判断分支条件证明没有数据生产数据并且唤醒等待池中菲菲修改值生产者线程就执行完毕了等待池消费者菲菲此时生产者花花和消费者菲菲就会再次同时争抢时间片和锁资源对象假如生产者花花再次获取哦到时间片和锁资源对象执行线程逻辑判断分支条件为此时花花就会释放资源进入到等待池中等待池生产者花花消费者菲菲必然获取到时间片执行操作逻辑判断条件得到是就执行消费并且修改状态为唤醒等待池中生产者这样就完成交替执行效果以上这些操作就是典型的一对一生产者与消费者模型知识点八多对多通信模型提供线程对象创建操作这里从原有一对一的模式变成多对多的模式原来的一个生产者对应一个消费者修改为了多个生产者对应多个消费者通过单例获取银行对象创建线程对象并启动操作花花菲菲花花菲菲当将线程对象增多之后执行多线程同时操作就出现两个问题负数问题和死等待问题负数问题现有线程花花存菲菲取花花存菲菲取模拟一个执行流程菲菲先抢到线程不能取所以进入到等待队列中释放时间片和释放锁资源菲菲抢到线程资源不能取所以进入到等待列中释放时间片和释放锁资源等待队列菲菲菲菲花花抢到线程存储了数据修改标记为值并唤醒等待队列中的线程的线程对象现在使用唤醒机制方法随机唤醒一个等待队列汇总线程对象假设唤醒了菲菲等待队列中菲菲外部争抢操作的时间片花花花花菲菲临界资源中存储数据是菲菲抢到了线程在哪里等待就在哪里被唤醒而且分支语句特点只会执行一次判断即分支条件判断完成之后不添加循环前提只会执行一次判断菲菲正好是在分支语句中进行等待操作醒来之后机会继续向后执行它是不会在判断分支语句菲菲进行正常消费修改标记为需要执行唤醒等待队列菲菲菲菲这个线程是通过进入到等待状态它已经执行了判断等待队列中空外部增强操作者时间片花花菲菲从等待状态恢复而来花花菲菲临界资源中存储的数据是因为菲菲消费了菲菲抢到了执行权会在分支语句继续执行操作此时虽然标记已经修改为正常而言不应该消费的但是分支语句已经被执行过所以不会进行判断继续执行进行消费修改标记执行唤醒但是现在的数据是在执行消费出现数据就是为了保证线程通信可以正常执行建议在开发的时候不要书写作为状态判断操作建议使用循环语句替代分支循环语句只有条件为才不执行否者就继续执行这样就可以让等待位置线程在次被唤醒之后可以再次判断状态操作以防出现错误数据通信的版本多对多提供临界资源并提供操作添加线程通信和同步代码块方法临界资源一共有两种提供方式提供成员变量和提供静态变量存储前的临界变量外界无论如何创建类对象都需要是唯一的不然的话成员变量会跟着对象多少而进行创建提供对象唯一创建方式单例设计模式单例设计模式可以保证外界无论如何操作得到对象都是唯一单例设计模式的实现一定要私有化构造方法防止外界调用构造方法创建对象提供一个私有静态常量对象这个对象就是单例类唯一创建对象提供一个静态方法获取这个创建好的对象得到实例外界只能通过这个方法获取对象在外界创建生产者与消费者线程对象中都是可以获取到资源但是问题在于如果消费者先获取到资源但是没有数据不能消费所以就提供一个变量来存储状态的通过对这个状态的判断决定执行哪个线程生产者向共享资源中存储数据的方法生产存储钱添加线程通信操作只需要将修改为即可如果条件为值就证明现在有数据无需生产生产这个就进入到等待状态因为没有执行就证明没有数据可以生产存了余额是生产数据完毕之后需要修改状态信息执行唤醒操作消费者向共享资源中存储数据的方法消费消费钱增加线程通信操作状态值代表没有数据代表有属性只需要将修改为即可没有数据的时候不能执行消费等待生产没有数据值是取非操作就执行等待有数据值是取非操作就不执行等待进行消费分支语句不执行就证明有数据进行消费操作取了余额是修改状态数据进行唤醒操作死等待问题所有线程都进入到等待池中无人唤醒这个效果是需要特殊情况下才会出现它属于一个极端情况这个原因的产生就是使用随机唤醒机制现有线程花花存菲菲取花花存菲菲取模拟一个执行流程菲菲先抢到线程不能取所以进入到等待池中释放锁和时间片菲菲抢到线程不能取所以进入到等待池中释放锁和时间片等待队列中菲菲菲菲花花抢到线程存储数据修改标记为并进行唤醒操作随机唤醒等待队列中菲菲争抢资源花花花花菲菲花花在次获取线程不能存储所以要进入到等待队列中释放锁和时间片等待队列中菲菲花花争抢资源花花菲菲花花抢到线程不能存储所以要进入到等待队列中释放锁和时间片等待队列中菲菲花花花花争抢资源菲菲菲菲抢到线程取钱消费修改标记为并进入唤醒操作随机唤醒菲菲唤醒等待队列汇总花花花花争抢资源菲菲菲菲现在状态时生产者都在等待队列中外部都是消费这个现在状态时等待队列中花花花花菲菲菲菲所有线程都进入到等待队列中无人唤醒就出现死的等待问题之所以会出现死等待原因就因为使用了的操作它是随机唤醒等待池中两个消费外界两个生产生产完毕状态修改无法唤醒或等待池中两个生产外界两个消费消费完毕状态修改无法唤醒建议使用替换进行全部唤醒然后再进行条件判断执行操作决定好是否存储与消费通信的版本提供临界资源并提供操作添加线程通信和同步代码块方法临界资源一共有两种提供方式提供成员变量和提供静态变量存储前的临界变量外界无论如何创建类对象都需要是唯一的不然的话成员变量会跟着对象多少而进行创建提供对象唯一创建方式单例设计模式单例设计模式可以保证外界无论如何操作得到对象都是唯一单例设计模式的实现一定要私有化构造方法防止外界调用构造方法创建对象提供一个私有静态常量对象这个对象就是单例类唯一创建对象提供一个静态方法获取这个创建好的对象得到实例外界只能通过这个方法获取对象在外界创建生产者与消费者线程对象中都是可以获取到资源但是问题在于如果消费者先获取到资源但是没有数据不能消费所以就提供一个变量来存储状态的通过对这个状态的判断决定执行哪个线程生产者向共享资源中存储数据的方法生产存储钱添加线程通信操作如果条件为值就证明现在有数据无需生产生产这个就进入到等待状态因为没有执行就证明没有数据可以生产存了余额是生产数据完毕之后需要修改状态信息执行唤醒操作进行全部唤醒操作消费者向共享资源中存储数据的方法消费消费钱增加线程通信操作状态值代表没有数据代表有属性没有数据的时候不能执行消费等待生产没有数据值是取非操作就执行等待有数据值是取非操作就不执行等待进行消费分支语句不执行就证明有数据进行消费操作取了余额是修改状态数据进行唤醒操作修改为全部唤醒总结如果在日后的开发中出现线程通信操作建议判断状态标签的位置使用关键字而不是进行唤醒操作建议使用而不是扩展接口显示锁接口是中新加入与比较操作它属于显示定义结构更加灵活提供了一个更加便捷的操作相对比更加简洁易用这个锁资源虽然语法更加简洁易用但是它不能定义锁对象使用锁对象是使用时就需要保证的唯一性了锁如何操作是一个接口所以需要使用到他实现类进行锁的操作提供两常用操作锁方法说明添加锁对象上锁释放锁对象所释放以为是一个显示锁对象所有不能调用类中提供方法进行线程通信所以系统就提供了一个和锁一起使用线程通信接口通信方法说明线程等待释放锁资源和时间片唤醒等待池中某一个线程对象随机唤醒唤醒等待池中所有线程对象使用锁替代同步代码块进行数据操作通信的版本多对多提供临界资源并提供操作添加线程锁方法线程通信临界资源一共有两种提供方式提供成员变量和提供静态变量存储前的临界变量外界无论如何创建类对象都需要是唯一的不然的话成员变量会跟着对象多少而进行创建提供对象唯一创建方式单例设计模式单例设计模式可以保证外界无论如何操作得到对象都是唯一单例设计模式的实现一定要私有化构造方法防止外界调用构造方法创建对象提供一个私有静态常量对象这个对象就是单例类唯一创建对象提供一个静态方法获取这个创建好的对象得到实例外界只能通过这个方法获取对象提供锁资源对象提供线程通信资源对象它是接口不能使用对象调用创建在外界创建生产者与消费者线程对象中都是可以获取到资源但是问题在于如果消费者先获取到资源但是没有数据不能消费所以就提供一个变量来存储状态的通过对这个状态的判断决定执行哪个线程生产者向共享资源中存储数据的方法生产存储钱替换成锁资源对象添加线程通信操作只需要将修改为即可如果条件为值就证明现在有数据无需生产生产这个就进入到等待状态使用通信资源创建对象因为没有执行就证明没有数据可以生产存了余额是生产数据完毕之后需要修改状态信息执行唤醒操作使用通信资源创建对象锁资源释放消费者向共享资源中存储数据的方法消费消费钱增加线程通信操作状态值代表没有数据代表有属性只需要将修改为即可没有数据的时候不能执行消费等待生产没有数据值是取非操作就执行等待有数据值是取非操作就不执行等待进行消费分支语句不执行就证明有数据进行消费操作取了余额是修改状态数据进行唤醒操作知识点九线程声明周期线程声明周期分为两条线基础线程声明周期新建准备就绪运行状态死亡状态对线程添加了一些操作造成线程阻塞现象的产生等等新建准备就绪运行状态阻塞状态准备就绪运行状态死亡状态在阻塞状态没有消失之前准备就绪运行状态阻塞状态准备就绪运行状态会一直重复执行新建状态使用创建一个线程对象仅仅在堆中分配内存空间在调用方法之前新建状态下线程压根就没有启动仅仅只是存在一个线程对象而已此时就属于新建状态当新建状态下的线程对象调用了方法此时从新建状态进入可运行状态线程对象的方法只能调用一次否则报错可运行状态分成两种状态和分别表示就绪状态和运行状态就绪状态线程对象调用方法之后等待的调度此时该线程并没有运行运行状态线程对象获得调度如果存在多个那么允许多个线程并行运行阻塞状态正在运行的线程因为某些原因放弃暂时停止运行就会进入阻塞状态此时不会给线程分配直到线程重新进入就绪状态才有机会转到运行状态阻塞状态只能先进入就绪状态不能直接进入运行状态阻塞状态的两种情况当线程处于运行过程时试图获取同步锁时却被线程获取此时把当前线程存到对象的锁池中线程进入阻塞状态当线程处于运行过程时发出了请求时此时进入阻塞状态等待状态等待状态只能被其他线程唤醒此时使用的无参数的方法当线程处于运行过程时调用了方法此时把当前线程存在对象等待池中计时等待状态使用了带参数的方法或者方法当线程处于运行过程时调用了方法此时把当前线程存在对象等待池中当前线程执行了方法终止状态通常称为死亡状态表示线程终止正常执行完方法而退出正常死亡遇到异常而退出出现异常之后程序就会中断意外死亡线程一旦终止就不能再重启启动否则报错在类中过时的方法因为存在线程安全问题所以弃用了真心好用绝对不能用暂停当前线程恢复当前线程结束当前线程知识点十拓展线程池重点线程池概念如果有非常的多的任务需要多线程来完成且每个线程执行时间不会太长这样频繁的创建和销毁线程频繁创建和销毁线程会比较耗性能有了线程池就不要创建更多的线程来完成任务因为线程可以重用线程池用维护者一个队列队列中保存着处于等待空闲状态的线程不用每次都创建新的线程线程池实现原理线程池中常见的类常用的线程池接口和类所在包线程池的顶级接口线程池接口可过提交任务代码工厂类通过此类可以获得一个线程池方法名描述获取固定数量的线程池参数指定线程池中线程的数量获得动态数量的线程池如不够则创建新的无上限创建方法一作者星仔描述永无创建一个线程池对象创建了一个固定数量个的线程池返回对象通过线程池对象调用方法来提交线程任务传入实现接口的类结束线程池创建方式二作者星仔描述永无创建一个线程池对象创建一个带缓存的连接池对象通过线程池对象提交线程任务并启动线程执行任务关闭连接池接口加入与接口类似实现之后代表一个线程任务具有泛型返回值可以声明异常如果不使用返回值和的作用一样作者星仔描述永无创建一个线程对象通过线程池对象提交线程任务并启动线程执行任务关闭线程对象接口的泛型表示方法返回值的类型使用返回值作者星仔描述永无创建一个线程对象通过线程池对象提交线程任务并启动线程执行任务保存线程的返回结果关闭线程对象这是方法返回值案例作者星仔描述永无需求线程计算线程最终得到结果结果为接口接口表示将要执行完任务的结果以阻塞形式等待中的异步处理结果的返回值接口和接口的区别这两个接口都可以当做线程任务提交并执行接口执行完线程任务之后有返回值而接口没有返回值接口中的方法已经抛出了异常而接口不能抛出编译异常接口用于接口线程任务的返回值方法当线程任务执行完成之后才能获取返回值这个方法是一个阻塞式的方法随堂案例使用两个线程并发计算的和一个线程计算另一个线程计算最终汇总结果创建线程池对象通过线程池提交线程并执行任务获取线程任务的返回值哈哈哈哈哈哈关闭线程池这是线程任务的返回值读写锁一种支持一写多读的同步锁读写分离可分别分配读锁写锁支持多次分配读锁使多个读操作可以并发执行互斥规则写写互斥阻塞读写互斥读阻塞写写阻塞读读读不互斥不阻塞在读操作远远高于写操作的环境中可在保障线程安全的情况下提高运行效率作者星仔描述永无记录开始时间创建线程池对象提交个读操作任务提交个写操作任务结束线程池获取当前线程池的状态如果线程池钟的任务执行结束那么返回否则返回我们希望以下的代码在线程任务执行结束之后再执行利用代码空转来判断记录结束时间耗时毫秒写线程读线程读写锁读锁写锁写操作读操作读和写都需要花一秒而读和读是不影响的读和写的互斥的写和写是互斥的写操作读操作重入锁重入锁在同步锁中可以继续加入同步锁锁对象是同一个和锁都可以实现锁的重入重入锁在同步锁中可以继续加入同步锁锁对象是同一个和锁都可以实现锁的重入启动线程当前锁对象为当前锁对象为公平锁公平锁和非公平锁非公平锁优先使用上一个线程接着执行下面的线程任务是非公平锁的实现无法实现公平锁锁默认是非公平锁如果想要实现公平锁那么需要在构造方法设置为公平锁让每个线程都公平去执行线程任务锁可以实现公平锁锁实现公平锁参数为表示是公平锁默认是表示非公平锁',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-11 09:27:40',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="星仔极客" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">星仔极客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 小伙伴</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://link3.cc/xinzai_x"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 个人资源</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="http://ainm.cc/c/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐网</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 常用文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://68565200.xyz/post/1f293ccb"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 资源搜索</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/32%E5%8D%95%E7%89%87%E6%9C%BA/" style="font-size: 1.05rem;">32单片机<sup>12</sup></a><a href="/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/" style="font-size: 1.05rem;">51单片机<sup>8</sup></a><a href="/tags/CubeIDE%E4%B8%8ECubeMX%E8%BD%AF%E4%BB%B6%E8%AE%BE%E7%BD%AE/" style="font-size: 1.05rem;">CubeIDE与CubeMX软件设置<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">C语言<sup>13</sup></a><a href="/tags/Java%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">Java语言<sup>12</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>5</sup></a><a href="/tags/MySQL/" style="font-size: 1.05rem;">MySQL<sup>3</sup></a><a href="/tags/RT-Thread/" style="font-size: 1.05rem;">RT-Thread<sup>6</sup></a><a href="/tags/Win11%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/" style="font-size: 1.05rem;">Win11相关设置<sup>1</sup></a><a href="/tags/springboot%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/" style="font-size: 1.05rem;">springboot相关配置<sup>1</sup></a><a href="/tags/ubuntu%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/" style="font-size: 1.05rem;">ubuntu相关设置<sup>1</sup></a><a href="/tags/%E4%BA%91%E5%9B%BE%E5%BA%8A/" style="font-size: 1.05rem;">云图床<sup>1</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2CDN%E8%A7%A3%E6%9E%90/" style="font-size: 1.05rem;">博客CDN解析<sup>1</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/" style="font-size: 1.05rem;">博客搭建相关<sup>1</sup></a><a href="/tags/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">图片压缩在线工具<sup>1</sup></a><a href="/tags/%E5%B0%8F%E7%8B%BC%E6%AF%AB%E8%BE%93%E5%85%A5%E6%B3%95/" style="font-size: 1.05rem;">小狼毫输入法<sup>1</sup></a><a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 1.05rem;">插件<sup>1</sup></a><a href="/tags/%E8%90%A5%E4%B8%9A%E6%89%A7%E7%85%A7/" style="font-size: 1.05rem;">营业执照<sup>1</sup></a><a href="/tags/%E8%B5%84%E6%BA%90%E6%90%9C%E7%B4%A2/" style="font-size: 1.05rem;">资源搜索<sup>1</sup></a><a href="/tags/%E9%B8%BF%E8%92%99NEXT%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/" style="font-size: 1.05rem;">鸿蒙NEXT应用开发<sup>4</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">16</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">10</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">21</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E8%AF%AD%E8%A8%80/" itemprop="url">Java语言</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Java%E8%AF%AD%E8%A8%80/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Java语言</span></a></span></div></div><h1 class="post-title" itemprop="name headline">24.多线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-12-30T05:11:26.000Z" title="发表于 2023-12-30 13:11:26">2023-12-30</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-10-11T01:27:40.393Z" title="更新于 2024-10-11 09:27:40">2024-10-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为揭阳"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>揭阳</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://xinzaigeek.68565200.xyz/post/fbc0ae86.html"><header><a class="post-meta-categories" href="/categories/Java%E8%AF%AD%E8%A8%80/" itemprop="url">Java语言</a><a href="/tags/Java%E8%AF%AD%E8%A8%80/" tabindex="-1" itemprop="url">Java语言</a><h1 id="CrawlerTitle" itemprop="name headline">24.多线程</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">星仔极客</span><time itemprop="dateCreated datePublished" datetime="2023-12-30T05:11:26.000Z" title="发表于 2023-12-30 13:11:26">2023-12-30</time><time itemprop="dateCreated datePublished" datetime="2024-10-11T01:27:40.393Z" title="更新于 2024-10-11 09:27:40">2024-10-11</time></header><h1><center>知识点一：Thread线程基础</center></h1>
<p>有一个场景：在一个程序中即可以玩游戏又可以播放音乐？</p>
<p>以现在编程手段而言 —》 提供编程结构【顺序、分支、循环】</p>
<p>代码是要遵守顺序执行，代码需要遵守从上至下逐行执行，利用分支和循环修改循环执行一些操作，选择性执行某代码或者是让某些代码重复执行，无论如何操作代码依旧要顺序执行，没有办法让两段代交替执行</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012202919.WebP" alt="线程流程" style="zoom: 50%;">
<p>此时Java为了解决这样的问题，提供一个操作，这个操作就叫做<strong>线程</strong>，可以在代码中使用多线程形式来完成这个操作</p>
<p>PS:现在电脑基本上都是多核CPU，所以每个人电脑上运行线程程序结果可能都不一样，这是一个非常正常现象，多线程运行时是一个不可预知状态，程序猿可以通过代码干预线程运行，以达到我们运行效果</p>
<h1><center>知识点二：并行和并发</center></h1>
<p>这两个概念在宏观的角度而言他们是一样(相似)的，但是在微观的角度而言他们是有区别</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012203194.WebP" alt="并行和并发" style="zoom:50%;">
<p><strong>并行就是同时执行，并发就是在交替执行</strong></p>
<p>    在操作系统中，安装了很多程序，并发指的是在一段时间内宏观上多个程序同时执行，这个在单个CPU系统中，每一个时刻只有一个程序执行，即微观上这些程序是分时交替的执行，只不过给人感觉是在同时运行，因为分时交替运行时间非常短暂</p>
<p>    现在而言都是多核CPU，则这些并发执行程序可以分配到不同的处理器上（CPU），实现多个任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序就可以同时执行了，你的电脑CPU核心越多你电脑的性能就相对更加强悍</p>
<p>PS:单核处理的计算机肯定是不能并行处理多个任务，只能是多个任务在单个CPU上并发需要运行，同理线程也是一样的从宏观的角度而言线程并行运行从微观角度看就是串行运行，即线程是一个一个去执行的，当系统只有一个CPU是，线程会以某种顺序执行多个线程，这个情况称之线程调度【线程提供CPU时间争抢】</p>
<h1><center>知识点三：线程和进程</center></h1>
<p><strong>进程</strong></p>
<p>    进程是程序的一次执行过程，是系统运行程序的基本单元，系统运行一个程序即在运行一个进程【从创建、运行、消亡的一个过程】，每一个进程都有自己一个独立的空间【内存空间】，一个应用程序(进程)可以同时运行多个线程</p>
<p>特点：</p>
<ol>
<li>进程是一个独立程序单元并且拥有自己独立空间</li>
<li>一个进程中可以同时运行多个线程</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012204035.WebP" alt="进程" style="zoom:50%;">
<p>进程是可以完成多个任务交替执行的，可以开发一个音乐软件（QQ音乐、网易云音乐、酷狗音乐），也可以开发一个打游戏软件（L0L、吃鸡战场、Dota2），只要运行这两个进程程序就可以完成一边听音乐，一边打游戏，这样做开发成本高，进行是独立的进程与进程之间是无法进行“<strong>通信</strong>”的</p>
<p><strong>线程</strong></p>
<p>    线程是进程中一个内部执行单元，负责当前进程中的程序执行，一个进程中至少有一个线程，一个进程可以有多个线程，这些线程在进程中被称之为“多线程”，进程就可以利用这些多线程，去完成不同操作</p>
<p>特点:</p>
<ol>
<li>线程是在进程的内部执行，并且可以存在多个，彼此之间共享进程的内存区域</li>
<li>线程与线程之间彼此独立，但是可以进行“通信”</li>
</ol>
<p>可以利用这个轻量级的开发完成一个进程内部程序交替执行效果（线程并发执行）</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012205517.WebP" alt="线程" style="zoom:50%;">
<p>总结进程与线程的区别：</p>
<p>    进程： 有独立的内存空间，进程中数据存放的空间是独立的并且至少有一个线程</p>
<p>    线程：堆空间是共享的，栈空间是独立的，线程消耗的资源要比进程小，并且可以多个线程存在同一个进程中</p>
<p>PS:需要知道了解的知识点：</p>
<ol>
<li>因为一个程序中有多个线程并发运行，那么从微观的角度而言是有先后顺序的，那么线程执行的顺序是取决于CPU的调度【线程争抢CPU时间片】，程序猿只能进行干涉，在不加干涉前提下线程执行就会出现很多随机性</li>
<li>Java程序进程中最少包含两个线程，一个是主线程就是main()方法【它在执行方法是或者执行程序时它的优先级永远最高】，另外一个垃圾回收机制线程(GC)【守护线程】，每当Java执行一个类的时候，实际上都会启动一个JVM，每一个JVM实际上就是在操作系统中启动了一个线程，Java本身就被垃圾回收机制所守护，所Java运行时至少启动了两个线程</li>
<li>由于创建一个线程开销远比创建一个进程开销要小很多，那么我们在开发多任务运行时，通常会优先考虑创建多线程，而不是多进程</li>
<li>所有的线程轮流使用CPU，每一个线程都会得到CPU分配的时间片，这个分配“尽量”平均分配CPU资源，但是这个效果不一定能达到，所以同优先级的线程对CPU时间的争抢是存在随机性的，可以对线程进行优先级设置来概念获取CPU时间片的几率，优先级越高几率越大，优先级越低几率越小</li>
</ol>
<h1><center>知识点四：Java程序中实现线程的方式</center></h1>
<p>在Java中主要创建线程方式有四种：</p>
<ol>
<li>继承Thread类，此时子类就是线程类</li>
<li>实现Runnable接口，此时实现类不是线程类，使用Thread类才可成为线程</li>
</ol>
<p><strong>无论是上述两种方式中那种方式都需必须重写run方法实现线程逻辑</strong></p>
<ol start="3">
<li>实现Callable接口， 此实现方方式并不是线程类，主要针对的是线程池提供</li>
<li>线程池可以帮组我们创建线程并进行管理操作</li>
</ol>
<p>如果实现线程需要继承Thread或实现Runnable接口，但是无论是那种都需要实现一个必要核心方法</p>
<p><strong>这个run方法是提供线程实现的核心逻辑，需要线程什么样需求代码，就将将代码写入到这个线程中</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">void</th>
<th style="text-align:center">run() 使用实现接口 Runnable 的对象创建一个线程时，启动该线程将导致在独立执行的线程中调用对象的 run方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><strong>PS：通过观察可以发现这个run方法是没有参数和返回值类型，所以这个run不能通过方法接收参数和返回数据值</strong></td>
</tr>
</tbody>
</table>
<h2 id="center-1-线程创建方式之继承thread类-center"><center>1、线程创建方式之继承Thread类</center></h2>
<p>步骤：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 定义一个普通类继承与`java.lang.Thread`类</span><br><span class="line"><span class="number">2.</span> 在子类中重新给父类Thread中run方法并提供线程实现逻辑</span><br><span class="line"><span class="number">3.</span> 在测试类中main方法中，通过线程子类或Thread这个父类创建线程对象并执行线程启动完成调用run方法中逻辑执行</span><br></pre></td></tr></table></figure>
<p>PS：因为Thread本身就是线程类，所以继承Thread类子类也是线程类，具备父类中Thread所提供的所有操作者线程方法</p>
<p>需求：使用继承Thread类方法是完成边打游戏和边听音乐</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了演示效果方便观察写在同一个文件中</span></span><br><span class="line"><span class="comment">//此时GameThread继承与Thread类所以GameThread就是线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//必须重写Thread父类中的run方法，提供这个线程需要的执行逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span> ; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;打游戏：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//此时MusicThread继承与Thread类所以GameThread就是线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MusicThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//必须重写Thread父类中的run方法，提供这个线程需要的执行逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span> ; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;听音乐：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//提供一个测试类完成线程创建与调用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//main方法本身一个线程，主线线程优先级最高</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如何创建线程对象</span></span><br><span class="line">        <span class="comment">//下面两种创建线程方式并没有指定线程优先级，所以都是默认优先级athread和bthread的优先级相同</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1. 使用多态的效果【Thread是子线程类父类，所以可以使用Thread方式创建】</span></span><br><span class="line"><span class="comment">                Thread 线程对象的名字 = new 子线程类();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GameThread</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            2. 直接使用继承线程子类创建对象</span></span><br><span class="line"><span class="comment">                子线程类 线程对象的名字 = new 子线程类();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">MusicThread</span> <span class="variable">bthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicThread</span>();</span><br><span class="line">        <span class="comment">//启动线程执行 ---》调用 Thread类中提供 start方法 ，而不是调用run方法</span></span><br><span class="line">        athread.start();</span><br><span class="line">        bthread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-2-线程创建方式之实现runnable接口-center"><center>2、线程创建方式之实现Runnable接口</center></h2>
<p>PS：<strong>实现Runnable接口的类并不是线程类，只是实现Runnable接口并提供run方法的重写，需要配合使用Thread类创建线程对象，此时线程才可以操作</strong>。因为Runnable接口中提供run方法的实现【实现Runnable接口的类】，传入到Thread类中时，就会覆盖Thread类中run方法，所以Thread提供创建线程对象就会执行重写Runnable接口中run方法，就会得到线程的效果</p>
<p>步骤:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 定义一个普通类实现Runnable接口</span><br><span class="line"><span class="number">2.</span> 实现Runnable接口的类必须重写run方法提供线程需要执行的逻辑</span><br><span class="line"><span class="number">3.</span> 在测试类中main方法中，使用Thread创建线程对象完成线程操作</span><br></pre></td></tr></table></figure>
<p>需求：使用继承Thread类方法是完成边打游戏和边听音乐</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Runnable;</span><br><span class="line"><span class="comment">//为了演示效果方便观察写在同一个文件中</span></span><br><span class="line"><span class="comment">//此类就是实现Runnable接口并提供run方法实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameRunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">1</span>; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;打游戏：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MusicRunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">1</span>; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;听音乐：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建Runnable接口实现类作为Thread线程对象操作</span></span><br><span class="line">        <span class="comment">//需要将Runnable接口的对象传递到Thread这个类中</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1. 先创建Runnable接口实现类的对象，然后再传递到Thread类中进行线程对象创建</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">GameRunnableImpl</span> <span class="variable">gri</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GameRunnableImpl</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(gri);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            2.使用匿名对象的方式进行Thread构造方法Runnable参数传递</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MusicRunnableImpl</span>());</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-3-thread类创建线程和runnable接口创建线程-center"><center>3、Thread类创建线程和Runnable接口创建线程</center></h2>
<p>    两种方式皆可，因为都要实现run方法，但是从类的扩展角度而言，建议使用实现Runnable接口方式来完成作，因为Java中类是单一继承，所以如果继承Thread类就无法在继承其他类，所以就会影响类的扩展，但是如果实现接口方式完成，不仅可以继承一个类还可以实现多个接口所以就比较推荐实现Runnable接口</p>
<p>继承效果：</p>
<p>    class A extends Thread{} //没有办法让A在继承</p>
<p>    class B extends XXXX implements Runnable{} // 不仅可以作为线程类操作而且还可以进行继承其他类</p>
<h2 id="center-4-start方法和run方法-center"><center>4、start方法和run方法</center></h2>
<p>PS：<strong>创建完毕线程对象之后，线程执行需要调用的是start方法而不是run方法</strong></p>
<p>start方法： 用start方法来启动线程，真正的实现了线程运行，通过Thread类中给提供start来启动一个线程，此时线程会进入到“<strong>准备就绪</strong>”状态，但是真正运行，一旦线程获取到CPU时间片，此时线程才会真正的执行，执行调用提供run方法完成线程逻辑</p>
<p>run方法：run方法只是一个普通方法，只是在run方法中实现线程执行逻辑，如果外界直接调用run方法，线程是没有启动，只不过是在main方法调用了run方法执行，执行出run方法提供操作，和线程一点关系都没有</p>
<h2 id="center-5-使用匿名内部类或lambda表达式便捷的创建线程对象并执行-了解-center"><center>5、使用匿名内部类或Lambda表达式便捷的创建线程对象并执行（了解）</center></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousAndLambdaThread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这种方式，线程是现创建现使用，只会使用一次即可</span></span><br><span class="line">        <span class="comment">//1.针对Thread类提供匿名内部类创建【只支持匿名内部类】</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">50</span>;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;听音乐：&quot;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();     <span class="comment">// 在最外侧的大括号中调用start方法</span></span><br><span class="line">        <span class="comment">//2.针对Runnable接口提供匿名内部类和Lambda表达式实现</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">50</span>;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;打游戏：&quot;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start(); <span class="comment">// 在最外侧的大括号中调用start方法</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">50</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;吃饭：&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start(); <span class="comment">// 在最外侧的大括号中调用start方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点五：线程常用方法</center></h1>
<h2 id="center-1-线程状态getstate-center"><center>1、线程状态getState</center></h2>
<p>这个方法可以返回线程运行状态</p>
<p>PS：API有一个静态属性 State【API中给返回类型时错误的，它不是静态类，他是一个枚举】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetStateDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用run方法进行求和操作【GetStateDemo 是 Thread子类</span></span><br><span class="line">        所以会得到所有方法】</span><br><span class="line">        System.out.println(<span class="string">&quot;进入run方法是当前线程状态：&quot;</span> + <span class="built_in">this</span>.getState());</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;=<span class="number">100</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;sum = &quot;</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetStateDemo</span>();</span><br><span class="line">        <span class="comment">//在启动线程之前</span></span><br><span class="line">        System.out.println(<span class="string">&quot;start方法之前线程状态：&quot;</span>+thread.getState());</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;start方法之后线程状态：&quot;</span>+thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以表示线程状态说明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 出生、新生</span></span><br><span class="line"><span class="comment">* 至今尚未启动的线程就是这种状态</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">NEW,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 准备就绪和执行</span></span><br><span class="line"><span class="comment">*PS：Java中提供Thread类并没有提供准备就绪的状态描述，所以RUNNABLE就有两个概念</span></span><br><span class="line"><span class="comment">* 调用start方法时是 ---&gt; 准备就绪</span></span><br><span class="line"><span class="comment">* 执行run方法时是 ---&gt; 执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">RUNNABLE,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 阻塞或睡眠 ---》 sleep方法</span></span><br><span class="line"><span class="comment">* 当线程出现【阻塞状态】，当前线程就会出现让出CPU时间片的操作等待后续执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">BLOCKED,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 等待 ---》 wait</span></span><br><span class="line"><span class="comment">* 等待是无限期等待只有进行唤醒之后等待效果才会消失【等待不是阻塞状态】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">WAITING,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 时间等待</span></span><br><span class="line"><span class="comment">* 在设置等待状态时设置一个时间，只要在时间范围内都是等待状</span></span><br><span class="line"><span class="comment">态，如果到了并且在等待时期并没有进行唤 </span></span><br><span class="line"><span class="comment">* 醒从操作，等待线程会自动唤醒</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">TIMED_WAITING,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 消亡，死亡</span></span><br><span class="line"><span class="comment">* 线程都执行完毕不会在执行就出现这个状态【线程结束】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">TERMINATED;</span><br></pre></td></tr></table></figure>
<h2 id="center-2-线程优先级setpriority-center"><center>2、线程优先级setPriority</center></h2>
<p>理论上线程优先级越高，获取CPU时间片的几率越大，反之获取几率越小</p>
<p>PS：但是优先级只是相当于给CPU一个暗示【先由我开始】，但是CPU是否会决定将时间片给当前线程，是CPU决定</p>
<p>所有在没有修改优先级之前的线程默认优先级都是相同，在Java中使用1~10之间数字表示线程优先级，数值越大优先级越高，所有在没有</p>
<p>修改优先级之前默认优先级是【5】API中提供三个静态常量方便对优先级的定义</p>
<table>
<thead>
<tr>
<th style="text-align:center">static int</th>
<th style="text-align:center">MAX_PRIORITY 线程可以具有的最高优先级【等级10】</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">static int</td>
<td style="text-align:center">MIN_PRIORITY 线程可以具有的最低优先级【等级1】</td>
</tr>
<tr>
<td style="text-align:center">static int</td>
<td style="text-align:center">NORM_PRIORITY 分配给线程的默认优先级【等级5】</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetPriorityDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span> ;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//getName()获取线程名字</span></span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;：i的数值：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//利用线程创建两个线程对象使用默认优先级</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SetPriorityDemo</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">bthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SetPriorityDemo</span>();</span><br><span class="line">        <span class="comment">//可能会出现Thread-0先执行 或 Thread-1先执行</span></span><br><span class="line">        <span class="comment">// athread.start(); // Thread-0</span></span><br><span class="line">        <span class="comment">// bthread.start(); // Thread-1</span></span><br><span class="line">        <span class="comment">//修改优先级</span></span><br><span class="line">        <span class="comment">// 【只要优先级的差别较大就可以的得到先执行和后执行效果】</span></span><br><span class="line">        <span class="comment">// 【只要优先级等级差别不是很大(比较接近)，执行效果就不是很明显了】</span></span><br><span class="line">        athread.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        bthread.setPriority(<span class="number">6</span>);</span><br><span class="line">        athread.start();     <span class="comment">// Thread-0</span></span><br><span class="line">        bthread.start();     <span class="comment">// Thread-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-3-更改和获取线程的名字-center"><center>3、更改和获取线程的名字</center></h2>
<p>线程是有默认名字组成方式 —》 使用到一个关键字“Thread” + “-” +“数字”，数字的从0开始，随着线程创建而逐渐增多，随着线程的减少而逐渐减少 —》 默认名字 【Thread-数字】</p>
<p>在编写线程程序时可以通过<strong>getName方法获取线程名字</strong>，但是如果创建线程过多使用默认名字看到效果就不是很明显</p>
<p>Java中提供线程名字修改方式有三种：</p>
<ol>
<li>在创建出线程对象之后调用setName(“线程新的名字&quot;)</li>
<li>使用类实现Runnable接口并使用Thread类创建线程对象，调用两个参数版本构造方法进行名字设置</li>
</ol>
<p>    Thread(Runnable接口实现类的对象，“线程名字”);</p>
<ol start="3">
<li>使用类继承与Thread类，子类中提供一个仿照父类生成构造方法，这个方法参数是String name，子类只	需要实现这个构造方法即可，在创建线程对象时只需要调用有参构造方法就可以指定线程名字</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetNameDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//方式一</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AThread</span>();</span><br><span class="line">        athread.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        System.out.println(athread.getName());</span><br><span class="line">        <span class="comment">//方式二</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">bthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">BThread</span>(),<span class="string">&quot;线程B&quot;</span>);</span><br><span class="line">        System.out.println(bthread.getName());</span><br><span class="line">        <span class="comment">//方式三</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">cthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CThread</span>(<span class="string">&quot;线程C&quot;</span>);    <span class="comment">//多态</span></span><br><span class="line">        System.out.println(cthread.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//实现Runnable接口不是线程类，所以不能在实现Runnable接口类中调用Thread类中方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;线程的名字：&quot;+getName());</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 如何在实现Runnable接口的类中获取当前线程</span></span><br><span class="line"><span class="comment">        * Thread类中提供一个静态方法currentThread() 可以获取当前线程对象</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;通过静态访获取到线程对象：&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//子类只要仿照生成一个带有String类型参数方法即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CThread</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-4-线程休眠sleep-使用几率极高-center"><center>4、线程休眠sleep【使用几率极高】</center></h2>
<p>sleep这个方法是静态方法，它可以让线程进入到【阻塞状态】即让线程进行到休眠时间，<strong>进入休眠之后线程会让出CPU时间片，给其他的线程进行争抢，当休眠时间到了之后恢复之后线程会继续和其线程进行CPU时间片的争抢</strong></p>
<p>sleep方法的参数是毫秒值 —》 1000毫秒 等于 1秒</p>
<p>线程如果触发sleep方法会有两种方式可以醒来：</p>
<ol>
<li>自然醒来【睡眠时间到了，自动醒来】</li>
<li>中断醒来【会通过Thread类中添加中断标记，强行让sleep醒来】</li>
</ol>
<p>所以sleep方法在调用时候会有一个编译时异常【InterruptedException(中断异常)】</p>
<p><strong>特别注意：如果sleep方法被调用在【同步锁、对象锁、同步监听器、同步代码块】中，sleep方法休眠之后是不会让出当前系统时间片【虽然会睡眠时间片也会释放，但是外界线程是无法获取】</strong></p>
<p>需求：通过sleep方法来实现以下交替执行效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">100</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">5</span> == <span class="number">0</span>)    <span class="comment">//只要i值可以对5整除</span></span><br><span class="line">            &#123; </span><br><span class="line">                System.out.println(<span class="string">&quot;当前线程:&quot;</span>+getName()+<span class="string">&quot;~~~~~~~~~&quot;</span>+i);</span><br><span class="line">                <span class="comment">//在run方法中调用sleep方法是不可以throws异常，只能try-catch抓取</span></span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SleepDemo</span>();</span><br><span class="line">        athread.setName(<span class="string">&quot;子线程&quot;</span>);</span><br><span class="line">        athread.start();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Java程序会默认提供两个线程一个是GC 和 一个是main方法【主线程作为线程操作】</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//在主线程中提供和SleepDemo类中一样的操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i&lt;=<span class="number">100</span> ;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">5</span> ==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前线程：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;~~~~~~~~~&quot;</span>+i);</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sleep方法确实可以让线程进入到休眠状态，并且释放出CPU时间片，但是时间无法正确把控就会造成无法使用sleep方法进行代码的交替执行</p>
<h2 id="center-5-线程礼让yield-了解-center"><center>5、线程礼让yield（了解）</center></h2>
<p>礼让线程的作用就是在调用yield方法的线程中，让出CPU时间片【相当于通知CPU不急着执行】，让出之后CPU会不会回收CPU时间片取决于CPU，礼让原则是：线程优先级越高礼让效果就是会明显一些</p>
<p>yield和sleep方法是有一定区别的，sleep是立即让出CPU时间片，在睡眠时间内是不会争抢CPU时间片，yield方法执行之后，礼让线程会进入“准备就绪”，礼让线程可能会再次持有CPU时间片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YieldDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程的名字：&quot;</span>+getName()+<span class="string">&quot;~~~~~~~~&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.<span class="keyword">yield</span>(); <span class="comment">//让线程礼让</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建两个线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YieldDemo</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">bthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YieldDemo</span>();</span><br><span class="line">        athread.setName(<span class="string">&quot;a线程&quot;</span>);</span><br><span class="line">        bthread.setName(<span class="string">&quot;b线程&quot;</span>);</span><br><span class="line">        athread.start();</span><br><span class="line">        bthread.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        bthread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-6-线程合并join-center"><center>6、线程合并join</center></h2>
<p>合并线程是一个效果非常明显操作，合并线程是一个线程正处于运行阶段，此时这个线程达到某个条件时，可以让其他线程合并到这个执行线程中，只要使用join合并，合并线程<strong>必然</strong>会得到CPU时间片，被合并的线程需要等待合并线程执行完毕之后才会继续运行</p>
<p>需求：妹子在看葫芦娃【50级】，当看到【10级】汉子要看喜洋洋</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Meizi</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Meizi</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;妹子正在看精钢葫芦娃大战蛇精：&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//启动另外一个线程进行合并操作</span></span><br><span class="line">                <span class="type">Hanzi</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hanzi</span>();</span><br><span class="line">                <span class="comment">//合并之前必要前提：要合并线程必须进入准备就绪状态，即调用start方法</span></span><br><span class="line">                thread.start();</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    thread.join();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hanzi</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;汉子正在看喜羊羊与灰太狼：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程合并必然是让出CPU时间片，CPU时间片会join的线程，线程必须是启动状态【调用start】</p>
<h2 id="center-7-线程中断-标记-center"><center>7、线程中断(标记)</center></h2>
<p>在Thread这个类中提供让线程停止方法 stop方法，但是这个方法被Java进行过时处理，所以就不建议在线程中进行使用了，所以Java就提供一个替代 stop方法的方法 —》interrupt方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptThreadDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">20</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;线程中执行i值是:&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//停止线程 --&gt;过时的stop方法</span></span><br><span class="line">                <span class="comment">// stop();</span></span><br><span class="line">                <span class="comment">//中断线程</span></span><br><span class="line">                interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InterruptThreadDemo</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这个线程中断标记方法向线程中添加【中断标记】，只有被含有中断异常方法检测到这个标记就会终止方法的执行效果【sleep明显 和join不明显】，<strong>直接在线程调用这个方法是无用的</strong>，只是添加标记不会停止线程，配合API中所提供的一个方法来使用【<strong>interrupted</strong>】，作用检查线程中是否存在中断标记，如果存在着返回true，不存在则返回false</p>
<p><strong>正确使用方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptThreadDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">20</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;线程中执行i值是:&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//使用替代stop方法中断线程时，当遇到某个条件要终止线程时，检查中断标记</span></span><br><span class="line">                <span class="keyword">if</span>(Thread.interrupted())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//停止线程</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">InterruptThreadDemo</span> <span class="variable">interruptThreadDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterruptThreadDemo</span>();</span><br><span class="line">        interruptThreadDemo.start();</span><br><span class="line">        <span class="comment">//向线程中添加中断标记</span></span><br><span class="line">        interruptThreadDemo.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>强行终止睡眠</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.ThreadMethod;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptThreadDemo2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入线程&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;没有被中断正常睡眠苏醒&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;中断睡眠苏醒&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">InterruptThreadDemo2</span> <span class="variable">interruptThreadDemo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterruptThreadDemo2</span>();</span><br><span class="line">        interruptThreadDemo2.start();</span><br><span class="line">        <span class="comment">//为了效果让主线程休眠2秒之后在触发中断标记</span></span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        interruptThreadDemo2.interrupt();  <span class="comment">//如果检查到中断标记就会强行终止睡眠</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点六：火车售票问题</center></h1>
<p>需求：火车站买票，一共有且仅有【100】张票，4个窗口同时贩卖临界资源就是这个票，多个线程访问保证票有且仅有100张，开4个线程同时买100张票</p>
<p>    其实这个卖票案例就是多线程下同时操作一个资源(临界资源),如何保证线程操作资源安全不出现以下情况</p>
<p>    买票不会出现重票 --&gt; 线程1 卖出第99张票 线程2 卖出99张票</p>
<p>    错误票 —&gt; 线程1 卖出第75张票. 线程2 卖出76张票 —&gt; 这个是对</p>
<p>    但是 线程2 卖出49张票</p>
<p>    负数票 —&gt; 某个线程买完最后一张票的时候 剩余线程就不能在卖票0 -1 -2…票</p>
<p>    1秒卖一张 —&gt; 有且仅有100张 —&gt;不要卖出400张票数</p>
<p><strong>问题1：如何将票固定在100张，而不是每个线程都卖出100张票</strong></p>
<p>    如何做到所有的线程都共享这一个资源？</p>
<ol>
<li>将票作为成员变量，作为成员变量之后，需要保证这个提供票的类在外界创建对象必须是唯一的，如果不唯一的，就会出现你创建票的对象每个对象都会唯一，一个成员变量，4个对象就是4个成员变量，此时相当于400张票【单例设计模式】</li>
</ol>
<p>PS：单例设计模式的原则：保证外界无论如何获取对象都是唯一的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1基础版本</span></span><br><span class="line"><span class="keyword">package</span> com.qfedu.Thread.SellTicket1;</span><br><span class="line"><span class="comment">//v1版本</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    不要让类继承与Thread，继承Thread必然要提供四个线程对象</span></span><br><span class="line"><span class="comment">    这样就会出现无法控制票100张</span></span><br><span class="line"><span class="comment">    建议实现Runnable，以Runnable实现类方式创建线程处理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供成成员变量存储票的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑</span></span><br><span class="line">            <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)    <span class="comment">//证明还票可以出售</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//买票</span></span><br><span class="line">                System.out.println(<span class="string">&quot;当前售票员[&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;]第&quot;</span>+<span class="string">&quot;[&quot;</span>+(tickets--)+<span class="string">&quot;]票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果提供的是成员变量【保证存储成员变量的这个类所得到对象是必须唯一】</span></span><br><span class="line">        <span class="comment">//出现400张票问题[在构建线程对象时，提供四个Runnable接口实现类对象创建]</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            Thread thread1 = new Thread(new SellTicket1(),&quot;刘德华&quot;);</span></span><br><span class="line"><span class="comment">            Thread thread2 = new Thread(new SellTicket1(),&quot;张学友&quot;);</span></span><br><span class="line"><span class="comment">            Thread thread3 = new Thread(new SellTicket1(),&quot;郭富城&quot;);</span></span><br><span class="line"><span class="comment">            Thread thread4 = new Thread(new SellTicket1(),&quot;吴奇隆&quot;);</span></span><br><span class="line"><span class="comment">            thread1.start();</span></span><br><span class="line"><span class="comment">            thread2.start();</span></span><br><span class="line"><span class="comment">            thread3.start();</span></span><br><span class="line"><span class="comment">            thread4.start();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//在外界只创建一个Runnable接口实现类对象，保证对象是唯一的</span></span><br><span class="line">        <span class="type">SellTicket1</span> <span class="variable">sellTicket1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket1</span>(); <span class="comment">//只会维护一份的票对象【100】张</span></span><br><span class="line">        <span class="comment">//利用这个对象初始化创建4个线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket1,<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket1,<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket1,<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket1,<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-getinstance-center"><center>GetInstance</center></h2>
<p>在主函数开始时调用，返回一个实例化对象，此对象是static的，在内存中保留着它的引用，即内存中有一块区域专门用来存放静态方法和变量，可以直接使用，调用多次返回同一个对象</p>
<p>GetInstance与new区别</p>
<p>    如Object object = new Object()，这时候，就必须要知道有第二个Object的存在，而第二个Object也常常是在当前的应用程序域中的，可以被直接调用的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.Demo03.test;</span><br><span class="line"><span class="comment">//提供了成员变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SellTicket2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供成员变量，变量是存储票信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    单设计模式的原则--》保证在外界获取对象时都是同一个对象【地址也是相同的】</span></span><br><span class="line"><span class="comment">    1.私有化构造方法</span></span><br><span class="line"><span class="comment">    2.提供一个私有化静态变量并对静态变量进行赋值【类型是本类类型提供对象创建】</span></span><br><span class="line"><span class="comment">    3.提供一个静态共有方法可以获取本类对象的唯一途径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SellTicket2</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">//使用本类类型创建对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SellTicket2</span> <span class="variable">sellTicket2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket2</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SellTicket2 <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> sellTicket2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑</span></span><br><span class="line">            <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)    <span class="comment">//证明还票可以出售</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//买票</span></span><br><span class="line">                System.out.println(<span class="string">&quot;当前售票员[&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;]第&quot;</span>+<span class="string">&quot;[&quot;</span>+(tickets--)+<span class="string">&quot;]票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提供了静态变量，这个类的创建对象方式就无所谓</span></span><br><span class="line">        <span class="type">SellTicket2</span> <span class="variable">sellTicket2</span> <span class="operator">=</span> SellTicket2.getInstance();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>定义一个变量保证所有对象共享，无论外界如何创建线程对象【实现Runnable还是继承Thread类】，这里都可以保证所有兑现共享这个变量，可以提供一个static修饰变量即静态变量</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.SellTicket1;</span><br><span class="line"><span class="comment">//v1.1版本 ---&gt; 提供了静态变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供静态成员变量存储票的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑</span></span><br><span class="line">            <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)    <span class="comment">//证明还票可以出售</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//买票</span></span><br><span class="line">                System.out.println(<span class="string">&quot;当前售票员[&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;]第&quot;</span>+<span class="string">&quot;[&quot;</span>+(tickets--)+<span class="string">&quot;]票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提供了静态变量，这个类的创建对象方式就无所谓</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket2</span>(),<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket2</span>(),<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket2</span>(),<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket2</span>(),<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题2：在买票的时候会出现、重票、错票、排序顺序的混乱的问题</p>
<p>    这个问题产生就是多线程并发争抢&quot;临界资源&quot;出现里临界资源不安全问题</p>
<h2 id="center-1-如何解决多线程并发访问临界资源-保证资源安全问题-center"><center>1、如何解决多线程并发访问临界资源，保证资源安全问题</center></h2>
<p>此时Java为了保证多线程并发访问临界资源线程安全问题，提供了一个处理机制，可以在处理临界资源代码中添加（同步锁/对象锁/同步代码块/同步监听器），这里四个名称都是指的是同一个操作，可以添加“锁机制”，保证在同一个时刻的只有一个线程操作临界资源，保证临界资源安全</p>
<h2 id="center-2-synchronized关键字-center"><center>2、synchronized关键字</center></h2>
<p>synchronized翻译意思：同步</p>
<p>使用synchronized关键字进行同步操作，使用synchronized组成同步操作叫做【同步锁/对象锁/同步代码块】</p>
<p>语法 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(资源锁对象)</span><br><span class="line">&#123;</span><br><span class="line">    提供操作临界资源的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行原理： 利用了同一时间内【只能有一个线程对象持有当前资源锁对象】，只要线程不释放这个所资源对象，外界线程是无法执行线程逻辑资源代码，在同步代码块中执行线程进行休眠是不会释放CPU时间片到外界给其他线程，因为sleep方法是不会释放锁资源</p>
<p>需要注意还需要保证【<strong>资源锁对象必须是唯一的</strong>】，不唯一锁对象数无法进行同步操作</p>
<p>如果保证资源锁对象是唯一的？</p>
<p>个人建议：十分不推荐使用 this 作为锁资源对象，this可能锁不了，this代表的是当前对象，那么就意味着这个提供临界支援类必须是创建唯一的对象才可以，这样才可以保证this是唯一的</p>
<p>替代方案一：</p>
<p>    在静态资源处理线程类中提供一个全局静态常量“锁资源”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">synchronized</span>(obj)</span><br><span class="line">&#123;</span><br><span class="line">    提供操作临界资源的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>替代方案二【推荐】</p>
<p>    天生对象就是唯一的，Java中这个对象无论你如何操作，就可以保证他是唯一的地址都是同一个，String字符串类，直接使用字符串对象即可----&gt;【使用 “” (双引号)创建】</p>
<p>提供字符串空串处理 —&gt; 即 提供字符串空串对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    提供操作临界资源的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用同步代码块修改买票的案例的</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.SynchronizedSellTicket1;</span><br><span class="line"><span class="comment">//v2版本 ---&gt; 提供了静态变量 和 同步代码块执行买票操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供静态成员变量存储票的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) <span class="comment">//同步代码块</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) <span class="comment">//证明还票可以出售</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">//买票</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;当前售票员[&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;]第&quot;</span></span><br><span class="line">                                                    + <span class="string">&quot;[&quot;</span> + (tickets--) + <span class="string">&quot;]票&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提供了静态变量，这个类的创建对象方式就无所谓</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket</span>(),<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket</span>(),<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket</span>(),<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket</span>(),<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-3-同步方法-对象同步方法-成员同步方法-center"><center>3、同步方法/对象同步方法/成员同步方法</center></h2>
<p>使用synchronized关键字进行成员方法的修饰，这个方法就会成为<strong>同步方法</strong>将操作资源代码写入到这个方法中就可以进行同步操作了</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">访问权限修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    方法体；</span><br><span class="line">    <span class="keyword">return</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>特别注意：使用是同步方法，所以这个方法使用锁资源对象是【this】，提供同步方法的这个类所创建对象必须是唯一的才可以锁住资源</strong></p>
<p>PS：到目前位置 方法定义中其他修饰符就已经全部介绍完毕</p>
<p>    类中方法可以使用：【static、final、abstract、synchronized】</p>
<p>    接口中方法可以使用：【abstract、static、default】</p>
<p><strong>修饰同步方法是该买票案例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.SynchronizedSellTicket1;</span><br><span class="line"><span class="comment">//v2.1版本 ---&gt; 提供了静态变量 和 同步方法进行买票</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供静态成员变量存储票的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑 ---》调用同步方法即可</span></span><br><span class="line">            seller();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同步方法 --&gt; 这个锁资源对象是this</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">seller</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供就是线程处理临界资源操作</span></span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) <span class="comment">//证明还票可以出售</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//买票</span></span><br><span class="line">            System.out.println(<span class="string">&quot;当前售票员[&quot;</span> +</span><br><span class="line">            Thread.currentThread().getName() + <span class="string">&quot;]第&quot;</span></span><br><span class="line">            + <span class="string">&quot;[&quot;</span> + (tickets--) + <span class="string">&quot;]票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提供了静态变量，这个类的创建对象方式就无所谓</span></span><br><span class="line">        <span class="comment">//同步方法提供类如果是线程类，需要保证线程类对象是唯一的</span></span><br><span class="line">        <span class="type">SellTicket2</span> <span class="variable">sellTicket2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket2</span>();   <span class="comment">//这是保证线程类对象唯一</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-4-类锁-类同步代码块-类同步方法-静态同步方法-center"><center>4、类锁/类同步代码块/类同步方法/静态同步方法</center></h2>
<p>如果使用是同步代码块的语法，就是将资源锁对象，从当前对象替换成类对象，通过类的方式获取对象【通反射获取】，静态同步方法就是使用static和synchronized同时修饰方法</p>
<p><strong>类锁/类同步代码块</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(类名.class)    <span class="comment">// 类锁对象</span></span><br><span class="line">&#123;</span><br><span class="line">    操作临界资源代码即可</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>类同步方法/静态同步方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">访问权限修饰符 <span class="keyword">static</span> <span class="keyword">synchronized</span> 返回值类型 方法名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    方法代码</span><br><span class="line">    <span class="keyword">return</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v2.2版本 ---&gt; 提供了静态变量 和 静态同步操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket3</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供静态成员变量存储票的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑 ---》调用同步方法即可</span></span><br><span class="line">            <span class="comment">//seller();</span></span><br><span class="line">            <span class="keyword">synchronized</span> (String.class)    <span class="comment">// 类锁</span></span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) <span class="comment">//证明还票可以出售</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">//买票</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;当前售票员[&quot;</span> +</span><br><span class="line">                    Thread.currentThread().getName() + <span class="string">&quot;]第&quot;</span></span><br><span class="line">                    + <span class="string">&quot;[&quot;</span> + (tickets--) + <span class="string">&quot;]票&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态同步方法 --&gt; 这个锁资源就是当前类的对象【是唯一的】，通过类获取即 类.class</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">seller</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供就是线程处理临界资源操操作</span></span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) <span class="comment">//证明还票可以出售</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//休眠1秒再买票</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//卖票</span></span><br><span class="line">            System.out.println(<span class="string">&quot;当前售票员[&quot;</span> +Thread.currentThread().getName() + <span class="string">&quot;]第&quot;</span> </span><br><span class="line">                                                        + <span class="string">&quot;[&quot;</span> + (tickets--) + <span class="string">&quot;]票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提供了静态变量，这个类的创建对象方式就无所谓</span></span><br><span class="line">        <span class="comment">//同步方法提供类如果是线程类，需要保证线程类对象是唯一的</span></span><br><span class="line">        <span class="type">SellTicket3</span> <span class="variable">sellTicket2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket3</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized总结：</p>
<ol>
<li>在开发中常用肯定是对象锁【同步代码块】但是这个代码块的范围不要太大，不然的话会影响执行效率</li>
</ol>
<p>    PS: 在什么位置对资源操作就在什么位置添加 同步代码块</p>
<ol start="2">
<li>使用synchronized关键字之后线程就会变成安全，间接就将并行线程修改为串行线程，使用锁机制将线程变	成 【一个一个站排执行效果】</li>
</ol>
<h1><center>知识点七：线程通信</center></h1>
<p>到现目前位置线程与线程之间依旧是彼此独立，就算使用同步代码块，也是让线程执行有一定顺序，但是还是没有进行通信操作，如果需要遇到某个线程执行完毕之后需要通知另外一个线程继续执行，此时就需要使用到线程通信，可以在一个进程中开发多个线程，每个线程之间可以进行通信操作，从而协调性的完成某个进程中需要执行逻辑</p>
<p><strong>线程通信有一个标准的通信模型【生产者与消费者模式】</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012227153.WebP" alt="线程通信" style="zoom:50%;">
<h2 id="center-1-完成生产者和消费者通信模型v1版本-center"><center>1、完成生产者和消费者通信模型v1版本</center></h2>
<p>Bank(银行类) —》 提供数据维护与使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基础的第一个版本 ---》 提供临界资源并提供操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;    <span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一单例设计模式的实现：</span></span><br><span class="line"><span class="comment">        1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        money = m+money;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span>+m+<span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        money = money-m;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取了&quot;</span>+m+<span class="string">&quot;余额是：&quot;</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生产者【是一个线程提供数据存储操作】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供银行属性</span></span><br><span class="line">    <span class="keyword">private</span> Bank bank;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Bank bank)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.bank = bank;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供线程存储钱的操作 存储十次 每次1000元</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            bank.pushMoney(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者【是一个线程提供数据获取操作】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供银行属性</span></span><br><span class="line">    <span class="keyword">private</span> Bank bank;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Bank bank)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.bank = bank;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供线程存获取的操作 获取十次 每次1000元</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            bank.popMoney(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提供一个测试类Test进行测试操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.waitAndnotfiny;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过单例获取银行对象</span></span><br><span class="line">        <span class="type">Bank</span> <span class="variable">bank1</span> <span class="operator">=</span> Bank.getInstance();</span><br><span class="line">        <span class="comment">//2.创建线程对象并启动操作</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(bank1),<span class="string">&quot;花花&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(bank1),<span class="string">&quot;菲菲&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题1：现在执行速度太快了，看不到交替执行效果，让线程休眠1秒操作</p>
<p>问题2：虽然让线程休眠之后，出现了一个执行错乱的问题，因为多线程并发访问临界资源money，出现线程挣抢的问题，所以出现临界资源部不安全问题，添加同步代码块</p>
<p>Bank银行类需要修改为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.waitAndnotfiny;</span><br><span class="line"><span class="comment">//基础的第一个版本 ---》 提供临界资源并提供操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;<span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一</span></span><br><span class="line"><span class="comment">        单例设计模式的实现：</span></span><br><span class="line"><span class="comment">        1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = m + money;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = money - m;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-2-完成生产者和消费者通信模型v2版本-center"><center>2、完成生产者和消费者通信模型v2版本</center></h2>
<p>使用了同步代码块+sleep方法，虽然让程序执行有序了也保证线程中操作临界资源过程也安全了，但是还是无法保证线程可以做到交替执行的效果【<strong>即生产者生产完数据之后通知消费者可以进行消费，消费者消费完数据之后通知生产者可以生产</strong>】，所以如何完成这个通信操作呢？</p>
<p>此时就需要使用Java中Object类中提供三个方法了</p>
<table>
<thead>
<tr>
<th style="text-align:center">线程通信方法</th>
<th style="text-align:center">方法说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">wait()</td>
<td style="text-align:center">执行该方法的线程对象会释放【同步锁资源】，JVM会把当前线程放到等待池中，等待其他线程唤醒操作</td>
</tr>
<tr>
<td style="text-align:center">notify()</td>
<td style="text-align:center">执行该方法的线程对象会在等待池【随机唤醒】一个等待的线程，把线程转移到锁池中等待，再次获取资源</td>
</tr>
<tr>
<td style="text-align:center">notifyAll()</td>
<td style="text-align:center">执行该方法的线程对象会在等地池中【唤醒所有的线程】，把线程转移到锁池中等待，再次获取资源</td>
</tr>
</tbody>
</table>
<p>    就可以利用这三个方法进行线程通信操作了，<strong>特别注意调用通信方法必须是锁资源对象，否则会出现异常提示信息【在哪里调用等待方法就在位置被唤醒】</strong></p>
<p>线程通信执行流程：</p>
<p>    假设<strong>A线程</strong>和<strong>B线程</strong>共同操作一个<strong>X锁对象</strong>，A、B线程可以通过X锁对象调用wait和notify方法进行如下线程通信操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当A线程执行到X锁对象时，A线程持有X锁对象，B线程是没有执行机会的，B线程在X对象的等待锁池中</span><br><span class="line">A线程在同步代码块种执行到X.wait方法时，A线程会释放X对象所资源，A线程会进入到X对象的等待锁池中</span><br><span class="line">B线程就会在等待锁池中得到A线程释放的X资源锁对象，B线程就开始执行操作</span><br><span class="line">B线程在同步代码块中执行到X.notify方法时，JVM把A线程从X对象等待池中，移动到等待X对象锁资源中得到锁资源</span><br><span class="line">B线程执行完毕之后释放锁资源，A线程就有机会获取到锁，继续执行同步方法</span><br></pre></td></tr></table></figure>
<p>修改Bank类提供线程通信操作者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.waitAndnotfiny.V2;</span><br><span class="line"><span class="comment">//通信的版本 ---》 提供临界资源并提供操作[添加线程通信和同步代码块+sleep方法]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;    <span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一</span></span><br><span class="line"><span class="comment">        单例设计模式的实现：</span></span><br><span class="line"><span class="comment">            1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">            2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">            3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在外界创建生产者与消费者线程对象中都是可以获取到CPU资源</span></span><br><span class="line"><span class="comment">        但是问题在于，如果消费者先获取到资源，但是没有数据不能消费</span></span><br><span class="line"><span class="comment">        所以就提供一个变量来存储状态的，通过对这个状态的判断决定执行哪个线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//添加线程通信操作</span></span><br><span class="line">                <span class="keyword">if</span>(isEmpty)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果条件为true值，就证明现在有数据，无需生产</span></span><br><span class="line">                    <span class="comment">//生产这个就进入到等待状态</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//因为if没有执行就证明，没有数据可以生产</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = m + money;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//生产数据完毕之后需要修改状态信息</span></span><br><span class="line">                isEmpty = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//执行唤醒操作</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notify();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 增加线程通信操作</span></span><br><span class="line">                <span class="comment">//isEmpty状态值 false代表没有数据 true代表有属性</span></span><br><span class="line">                <span class="keyword">if</span>(!isEmpty)    <span class="comment">//没有数据的时候不能执行消费，等待生产</span></span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        没有数据isEmpty值是false，取非操作 !false --》 true if就执行等待</span></span><br><span class="line"><span class="comment">                        有数据isEmpty值是true ，取非操作 !true --》false if就不执行等待，进行消费</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//if分支语句不执行就证明有数据，进行消费操作</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = money - m;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//修改状态数据</span></span><br><span class="line">                isEmpty = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//进行唤醒操作</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notify();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-3-分析执行流程-center"><center>3、分析执行流程</center></h2>
<ol>
<li>现有的两个线程生产者【花花】和消费者【菲菲】默认初始isEmpty状态都是false</li>
<li>消费者【菲菲】先获取到CPU时间片，持有所资源，判断if分支条件为!false,消费者【菲菲】就会释放锁资源并且进入到等待池中</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待池</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    生产者【花花】</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>等待池中生产者【花花】就会或得到执行CPU时间片，并且获取到锁资源，判断if分支条件false，证明没有数据，生产数据并且唤醒等待池中【菲菲】修改isEmpty值true，生产者线程就执行完毕了</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待池</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    消费者【菲菲】</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>此时生产者【花花】和消费者【菲菲】就会再次同时争抢CPU时间片和锁资源对象，假如生产者【花花】再次获取哦到CPU时间片和锁资源对象，执行线程逻辑，判断if分支条件为true，此时花花就会释放资源进入到等待池中</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待池</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    生产者【花花】</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>消费者【菲菲】必然获取到CPU时间片，执行操作逻辑判断条件!true 得到是false，就执行消费，并且修改状态为false，唤醒等待池中生产者，这样就完成交替执行效果</li>
</ol>
<p><strong>PS：以上这些操作就是典型的一对一生产者与消费者模型</strong></p>
<h1><center>知识点八：多对多通信模型</center></h1>
<p>提供线程对象创建操作， 这里从原有一对一的模式，变成多对多的模式，原来的一个生产者对应一个消费者，修改为了多个生产者对应多个消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过单例获取银行对象</span></span><br><span class="line">        <span class="type">Bank</span> <span class="variable">bank1</span> <span class="operator">=</span> Bank.getInstance();</span><br><span class="line">        <span class="comment">//2.创建线程对象并启动操作</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(bank1),<span class="string">&quot;花花1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(bank1),<span class="string">&quot;菲菲2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(bank1),<span class="string">&quot;花花3&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(bank1),<span class="string">&quot;菲菲4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当将线程对象增多之后，执行多线程同时操作就出现两个问题“<strong>负数问题和死等待问题</strong>”</p>
<h2 id="center-1-负数问题-center"><center>1、负数问题</center></h2>
<p>现有线程【花花1（存)、菲菲2（取）、花花3（存）、菲菲4（取）】，模拟一个执行流程</p>
<ol>
<li>菲菲2先抢到线程，不能取，所以进入到等待队列中，释放CPU时间片和释放锁资源</li>
<li>菲菲4抢到线程资源，不能取，所以进入到等待列中，释放CPU时间片和释放锁资源</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列 菲菲2、菲菲4</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>花花1抢到线程，存储了数据，修改标记为true值，并唤醒等待队列中的线程的线程对象，现在使用唤醒机制notify方法【随机唤醒一个等待队列汇总线程对象】，假设唤醒了菲菲4</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 菲菲2</span></span><br><span class="line"><span class="comment">//外部争抢CPU操作的时间片 花花1、花花3、菲菲4</span></span><br><span class="line"><span class="comment">//临界资源中存储数据是 ---》 1000</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>菲菲4抢到了线程，在哪里等待就在哪里被唤醒，而且if分支语句特点，只会执行一次判断即if分支条件判断完成之后【不添加循环前提】，只会执行一次判断，菲菲4正好是在if分支语句中进行等待操作，醒来之后机会继续向后执行【它是不会在判断if分支语句】，菲菲4进行正常消费，修改标记为false，需要执行notify，唤醒等待队列菲菲2【菲菲2这个线程是通过wait进入到等待状态，它已经执行了if判断】</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 空</span></span><br><span class="line"><span class="comment">// 外部增强CPU操作者时间片 花花1、菲菲2【从等待状态恢复而来】、花花3、菲菲4</span></span><br><span class="line"><span class="comment">// 临界资源中存储的数据是 ----》 0 【因为菲菲4消费了】</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>菲菲2抢到了执行权，会在if分支语句继续执行操作，此时虽然标记已经修改为false，正常而言不应该消费的，但是if分支语句已经被执行过，所以不会进行判断继续执行，进行消费，修改标记，执行唤醒</li>
</ol>
<p>但是现在的数据是 0 在执行消费出现数据就是 -1000</p>
<p><strong>为了保证线程通信可以正常执行，建议在开发的时候，不要书写if作为状态判断操作，建议使用while循环语句替代if分支，while循环语句只有条件为false，才不执行，否者就继续执行，这样就可以让等待位置线程在次被唤醒之后可以再次判断状态操作，以防出现错误数据</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.waitAndnotfiny.V3;</span><br><span class="line"><span class="comment">//通信的版本【多对多】 ---》 提供临界资源并提供操作[添加线程通信和同步代码块+sleep方法]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;<span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一</span></span><br><span class="line"><span class="comment">        单例设计模式的实现：</span></span><br><span class="line"><span class="comment">        1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在外界创建生产者与消费者线程对象中都是可以获取到CPU资源</span></span><br><span class="line"><span class="comment">        但是问题在于，如果消费者先获取到资源，但是没有数据不能消费</span></span><br><span class="line"><span class="comment">        所以就提供一个变量来存储状态的，通过对这个状态的判断决定执行哪个线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//添加线程通信操作</span></span><br><span class="line">                <span class="comment">//只需要将if修改为while即可</span></span><br><span class="line">                <span class="keyword">while</span>(isEmpty)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果条件为true值，就证明现在有数据，无需生产</span></span><br><span class="line">                    <span class="comment">//生产这个就进入到等待状态</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//因为if没有执行就证明，没有数据可以生产</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = m + money;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//生产数据完毕之后需要修改状态信息</span></span><br><span class="line">                isEmpty = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//执行唤醒操作</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notify();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 增加线程通信操作</span></span><br><span class="line">                <span class="comment">//isEmpty状态值 false代表没有数据 true代表有属性</span></span><br><span class="line">                <span class="comment">//只需要将if修改为while即可</span></span><br><span class="line">                <span class="keyword">while</span>(!isEmpty)    <span class="comment">//没有数据的时候不能执行消费，等待生产</span></span><br><span class="line">                &#123; </span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        没有数据isEmpty值是false，取非操作 !false --》 true if就执行等待</span></span><br><span class="line"><span class="comment">                        有数据isEmpty值是true ，取非操作 !true --》false if就不执行等待，进行消费</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//if分支语句不执行就证明有数据，进行消费操作</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = money - m;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//修改状态数据</span></span><br><span class="line">                isEmpty = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//进行唤醒操作</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notify();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-2-死等待问题-center"><center>2、死等待问题</center></h2>
<p>所有线程都进入到等待池中无人唤醒</p>
<p><strong>PS：这个效果是需要特殊情况下才会出现【它属于一个极端情况】</strong></p>
<p><strong>这个原因的产生就是使用notfiy随机唤醒机制</strong></p>
<p>现有线程【花花1（存)、菲菲2（取）、花花3（存）、菲菲4（取）】模拟一个执行流程</p>
<ol>
<li>菲菲2先抢到线程，不能取，所以进入到等待池中，释放锁和CPU时间片</li>
<li>菲菲4抢到线程，不能取，所以进入到等待池中，释放锁和CPU时间片</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 菲菲2、菲菲4</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>花花1抢到线程，存储数据，修改标记为true并进行唤醒操作【随机唤醒】</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 菲菲2</span></span><br><span class="line"><span class="comment">//争抢CPU资源 花花1、花花3、菲菲4</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>花花1在次获取线程，不能存储，所以要进入到等待队列中，释放锁和CPU时间片</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 菲菲2、花花1 //争抢CPU资源 花花3、菲菲4</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>花花3抢到线程，不能存储，所以要进入到等待队列中，释放锁和CPU时间片</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 菲菲2、花花1、花花3 //争抢CPU资源 菲菲4</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li>菲菲4抢到线程，取钱消费，修改标记为false，并进入唤醒操作【随机唤醒】 --》 菲菲2唤醒</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列汇总 花花1、花花3 //争抢CPU资源 菲菲4、菲菲2 ，现在状态时false</span></span><br></pre></td></tr></table></figure>
<ol start="7">
<li>生产者都在等待队列中，外部都是消费这个，现在状态时false</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 花花1、花花3、菲菲4、菲菲2</span></span><br></pre></td></tr></table></figure>
<p>所有线程都进入到等待队列中，无人唤醒就出现死的等待问题</p>
<p>    之所以会出现死等待原因就因为使用了notify的操作，它是随机唤醒，等待池中两个消费，外界两个生产【生产完毕，状态修改，无法唤醒】，或等待池中两个生产，外界两个消费【消费完毕，状态修改，无法唤醒】，<strong>建议使用notifyAll 替换 notfiy</strong>，进行全部唤醒，然后再进行条件判断执行操作，决定好是否存储与消费</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通信的版本 ---》 提供临界资源并提供操作[添加线程通信和同步代码块+sleep方法]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;<span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一</span></span><br><span class="line"><span class="comment">        单例设计模式的实现：</span></span><br><span class="line"><span class="comment">        1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在外界创建生产者与消费者线程对象中都是可以获取到CPU资源</span></span><br><span class="line"><span class="comment">        但是问题在于，如果消费者先获取到资源，但是没有数据不能消费</span></span><br><span class="line"><span class="comment">        所以就提供一个变量来存储状态的，通过对这个状态的判断决定执行哪个线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//添加线程通信操作</span></span><br><span class="line">                <span class="keyword">while</span>(isEmpty)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果条件为true值，就证明现在有数据，无需生产</span></span><br><span class="line">                    <span class="comment">//生产这个就进入到等待状态</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//因为if没有执行就证明，没有数据可以生产</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = m + money;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//生产数据完毕之后需要修改状态信息</span></span><br><span class="line">                isEmpty = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//执行唤醒操作进行全部唤醒操作</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notifyAll();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 增加线程通信操作</span></span><br><span class="line">                <span class="comment">//isEmpty状态值 false代表没有数据 true代表有属性</span></span><br><span class="line">                <span class="keyword">while</span>(!isEmpty)    <span class="comment">//没有数据的时候不能执行消费，等待生产</span></span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    没有数据isEmpty值是false，取非操作 !false --》 true if就执行等待</span></span><br><span class="line"><span class="comment">                    有数据isEmpty值是true ，取非操作 !true --》false if就不执行等待，进行消费</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//if分支语句不执行就证明有数据，进行消费操作</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = money - m;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//修改状态数据</span></span><br><span class="line">                isEmpty = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//进行唤醒操作修改为全部唤醒</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notifyAll();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：如果在日后的开发中出现线程通信操作，建议判断状态标签的位置使用while关键字而不是if，进行唤醒操作建议使用notfiyAll而不是notify</strong></p>
<h2 id="center-3-扩展：lock接口-显示锁-center"><center>3、扩展：Lock接口【显示锁】</center></h2>
<p>Lock接口是Java5中新加入与Synchronized比较操作，它属于显示定义，结构更加灵活，提供了一个更加便捷的操作，相对比synchronized更加简洁易用</p>
<p>PS：这个锁资源Lock虽然语法更加简洁易用，但是它不能定义锁对象，Lock使用锁对象是【this】，<strong>使用Lock时就需要保证this的唯一性了</strong></p>
<p><strong>Lock锁如何操作？</strong></p>
<p>    Lock是一个接口所以需要使用到他实现类进行锁的操作</p>
<p><strong>ReentrantLock</strong>提供两常用操作</p>
<table>
<thead>
<tr>
<th style="text-align:center">Lock锁方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">lock()</td>
<td style="text-align:center">添加锁(对象上锁)</td>
</tr>
<tr>
<td style="text-align:center">unlock()</td>
<td style="text-align:center">释放锁(对象所释放)</td>
</tr>
</tbody>
</table>
<p>    以为Lock是一个显示锁对象，所有不能调用Object类中提供wait、notify、notifyAll方法进行线程通信，所以系统就提供了<strong>一个和Lock锁一起使用线程通信接口Condititon</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">通信方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">await()</td>
<td style="text-align:center">线程等待释放锁资源和CPU时间片</td>
</tr>
<tr>
<td style="text-align:center">signal()</td>
<td style="text-align:center">唤醒等待池中某一个线程对象【随机唤醒】</td>
</tr>
<tr>
<td style="text-align:center">signalAll()</td>
<td style="text-align:center">唤醒等待池中所有线程对象</td>
</tr>
</tbody>
</table>
<p>使用Lock锁替代Synchronized同步代码块进行数据操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="comment">//通信的版本【多对多】 ---》 提供临界资源并提供操作[添加线程Lock锁+sleep方法+线程通信]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankLock</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;<span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一</span></span><br><span class="line"><span class="comment">        单例设计模式的实现：</span></span><br><span class="line"><span class="comment">        1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BankLock</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">BankLock</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BankLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BankLock <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供锁资源对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//提供线程通信资源对象【它是接口不能new，使用lock对象调用newCondition创建】</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在外界创建生产者与消费者线程对象中都是可以获取到CPU资源</span></span><br><span class="line"><span class="comment">        但是问题在于，如果消费者先获取到资源，但是没有数据不能消费</span></span><br><span class="line"><span class="comment">        所以就提供一个变量来存储状态的，通过对这个状态的判断决定执行哪个线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//synchronized (&quot;&quot;) //替换成lock锁资源对象</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//添加线程通信操作</span></span><br><span class="line">                <span class="comment">//只需要将if修改为while即可</span></span><br><span class="line">                <span class="keyword">while</span>(isEmpty)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果条件为true值，就证明现在有数据，无需生产</span></span><br><span class="line">                    <span class="comment">//生产这个就进入到等待状态</span></span><br><span class="line">                    <span class="comment">// &quot;&quot;.wait();</span></span><br><span class="line">                    condition.await();    <span class="comment">//使用通信资源创建对象</span></span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//因为if没有执行就证明，没有数据可以生产</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = m + money;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//生产数据完毕之后需要修改状态信息</span></span><br><span class="line">                isEmpty = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//执行唤醒操作</span></span><br><span class="line">                <span class="comment">//&quot;&quot;.notifyAll();</span></span><br><span class="line">                condition.signalAll();    <span class="comment">//使用通信资源创建对象</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> </span><br><span class="line">            &#123;</span><br><span class="line">                lock.unlock(); <span class="comment">//锁资源释放</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//synchronized (&quot;&quot;) </span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 增加线程通信操作</span></span><br><span class="line">                    <span class="comment">//isEmpty状态值 false代表没有数据 true代表有属性</span></span><br><span class="line">                    <span class="comment">//只需要将if修改为while即可</span></span><br><span class="line">                    <span class="keyword">while</span>(!isEmpty)    <span class="comment">//没有数据的时候不能执行消费，等待生产</span></span><br><span class="line">                    &#123; </span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                            没有数据isEmpty值是false，取非操作 !false --》 true if就执行等待</span></span><br><span class="line"><span class="comment">                            有数据isEmpty值是true ，取非操作 !true --》false if就不执行等待，进行消费</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        <span class="comment">//&quot;&quot;.wait();</span></span><br><span class="line">                        condition.await();</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">//if分支语句不执行就证明有数据，进行消费操作</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    money = money - m;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                    <span class="comment">//修改状态数据</span></span><br><span class="line">                    isEmpty = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">//进行唤醒操作</span></span><br><span class="line">                    <span class="comment">// &quot;&quot;.notifyAll();</span></span><br><span class="line">                    condition.signalAll();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点九：线程声明周期</center></h1>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012240972.WebP" alt="声明周期" style="zoom:50%;">
<p>线程声明周期分为两条线:</p>
<ol>
<li>基础线程声明周期： 新建 —》 准备就绪 —》 运行状态 —》 死亡状态</li>
<li>对线程添加了一些操作造成线程阻塞现象的产生【sleep、join、wait、synchronized等等】</li>
</ol>
<p>新建 —》 准备就绪 —》 运行状态 —》【 阻塞状态 —》 准备就绪 —》 运行状态】 —》 死亡状态</p>
<p>PS：在阻塞状态没有消失之前</p>
<p>准备就绪 —》 运行状态 —》阻塞状态 —》 准备就绪 —》 运行状态 … 【会一直重复执行】</p>
<p>1、新建状态(new):使用new创建一个线程对象,仅仅在堆中分配内存空间,在调用start方法之前.</p>
<p>    新建状态下,线程压根就没有启动,仅仅只是存在一个线程对象而已.</p>
<p>    Thread t = new Thread();//此时t就属于新建状态</p>
<p>    当新建状态下的线程对象调用了start方法,此时从新建状态进入可运行状态</p>
<p>    线程对象的start方法只能调用一次,否则报错:IllegalThreadStateException</p>
<p>2、可运行状态(runnable):分成两种状态，ready和running。分别表示就绪状态和运行状态</p>
<p>    就绪状态:线程对象调用start方法之后,等待JVM的调度(此时该线程并没有运行).</p>
<p>    运行状态:线程对象获得JVM调度,如果存在多个CPU,那么允许多个线程并行运行</p>
<p>3、阻塞状态(blocked):正在运行的线程因为某些原因放弃CPU,暂时停止运行,就会进入阻塞状态.</p>
<p>    此时JVM不会给线程分配CPU,直到线程重新进入就绪状态,才有机会转到运行状态.</p>
<p>    阻塞状态只能先进入就绪状态,不能直接进入运行状态</p>
<p>    阻塞状态的两种情况:</p>
<p>    （1）当A线程处于运行过程时,试图获取同步锁时,却被B线程获取.此时JVM把当前A线程存到对象的锁池中,A线程进入阻塞状态.</p>
<p>    （2）当线程处于运行过程时,发出了IO请求时,此时进入阻塞状态</p>
<p>4、等待状态(waiting)(等待状态只能被其他线程唤醒):此时使用的无参数的wait方法,</p>
<p>    （1）当线程处于运行过程时,调用了wait()方法,此时JVM把当前线程存在对象等待池中</p>
<p>5、计时等待状态(timed waiting)(使用了带参数的wait方法或者sleep方法)</p>
<p>    (1)当线程处于运行过程时,调用了wait(long time)方法,此时JVM把当前线程存在对象等待池中.</p>
<p>    (2)当前线程执行了sleep(long time)方法.</p>
<p>6、终止状态(terminated):通常称为死亡状态，表示线程终止.</p>
<p>    (1)正常执行完run方法而退出(正常死亡).</p>
<p>    (2)遇到异常而退出(出现异常之后,程序就会中断)(意外死亡)</p>
<p>线程一旦终止,就不能再重启启动,否则报错(IllegalThreadStateException).</p>
<p>在Thread类中过时的方法(因为存在线程安全问题,所以弃用了【真心好用，绝对不能用】)</p>
<p>    void suspend() :暂停当前线程</p>
<p>    void resume() :恢复当前线程</p>
<p>    void stop() :结束当前线程</p>
<h1><center>知识点十：拓展</center></h1>
<h2 id="center-1-线程池-重点-center"><center>1、线程池【重点】</center></h2>
<h3 id="1-线程池概念">（1）线程池概念</h3>
<p>如果有非常的多的任务需要多线程来完成，且每个线程执行时间不会太长，这样频繁的创建和销毁线程。</p>
<p>频繁创建和销毁线程会比较耗性能。有了线程池就不要创建更多的线程来完成任务，因为线程可以重用</p>
<p>线程池用维护者一个队列，队列中保存着处于等待（空闲）状态的线程。不用每次都创建新的线程</p>
<h3 id="2-线程池实现原理">（2）线程池实现原理</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012242641.WebP" alt="实现原理" style="zoom:50%;">
<h3 id="3-线程池中常见的类">（3）线程池中常见的类</h3>
<p>常用的线程池接口和类(所在包java.util.concurrent)</p>
<p>Executor：线程池的顶级接口。</p>
<p>ExecutorService：线程池接口，可过submit(Runnable task) 提交任务代码</p>
<p>Executors工厂类：通过此类可以获得一个线程池</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">newFixedThreadPool(int nThreads)</td>
<td style="text-align:center">获取固定数量的线程池。参数：指定线程池中线程的数量</td>
</tr>
<tr>
<td style="text-align:center">newCachedThreadPool()</td>
<td style="text-align:center">获得动态数量的线程池，如不够则创建新的，无上限</td>
</tr>
</tbody>
</table>
<p><strong>创建方法一：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建一个线程池对象   创建了一个固定数量3个的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);   <span class="comment">//返回ExecutorService对象</span></span><br><span class="line">        <span class="comment">//2.通过线程池对象调用sumit方法来提交线程任务</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable1</span>());   <span class="comment">//传入实现runnable接口的类</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable2</span>());</span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable3</span>());</span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable4</span>());</span><br><span class="line">        <span class="comment">//3.结束线程池</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable3</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable4</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">30</span>; i &lt; <span class="number">40</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建方式二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建一个线程池对象   创建一个带缓存的连接池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//2.通过线程池对象，提交线程任务，并启动线程执行任务</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-callable接口">（4）Callable接口</h3>
<p>JDK5加入，与Runnable接口类似，实现之后代表一个线程任务。</p>
<p>Callable具有泛型返回值、可以声明异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt; V &gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不使用返回值和Runnable的作用一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建一个线程对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//2.通过线程池对象提交线程任务，并启动线程执行任务</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.关闭线程对象</span></span><br><span class="line">        es.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>   <span class="comment">//Callable接口的泛型表示call方法返回值的类型</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread1;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建一个线程对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//2.通过线程池对象提交线程任务，并启动线程执行任务</span></span><br><span class="line">        Future&lt;String&gt; future = es.submit(<span class="keyword">new</span> <span class="title class_">MyCallable2</span>());   <span class="comment">//保存线程的返回结果</span></span><br><span class="line">        System.out.println(future.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.关闭线程对象</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable2</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是call方法返回值&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo03</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//需求：线程A 计算1~50 线程B 51~100  最终得到结果</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;Integer&gt; f1 = es.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">51</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Future&lt;Integer&gt; f2 = es.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">51</span>; i &lt; <span class="number">101</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;结果为:&quot;</span> + (f1.get() + f2.get()));</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-future接口">（5）Future接口</h3>
<p>Future接口表示将要执行完任务的结果。</p>
<p>get()以阻塞形式等待Future中的异步处理结果（call()的返回值）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCallable2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Runnable接口和Callable接口的区别？</span></span><br><span class="line"><span class="comment">    * 1、这两个接口都可以当做线程任务提交并执行</span></span><br><span class="line"><span class="comment">    * 2、Callable接口执行完线程任务之后有返回值，而Runnable接口没有返回值</span></span><br><span class="line"><span class="comment">    * 3、Callable接口中的call方法已经抛出了异常，而Runnable接口不能抛出编译异常</span></span><br><span class="line"><span class="comment">    * Future接口：</span></span><br><span class="line"><span class="comment">    * 用于接口Callable线程任务的返回值。</span></span><br><span class="line"><span class="comment">    * get()方法当线程任务执行完成之后才能获取返回值，这个方法是一个阻塞式的方法</span></span><br><span class="line"><span class="comment">    *随堂案例：</span></span><br><span class="line"><span class="comment">    * 使用两个线程，并发计算1-100的和， 一个线程计算1~50,另一个线程计算51~100， 最终汇总结果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,</span><br><span class="line">ExecutionException </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1、创建线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//2、通过线程池提交线程并执行任务</span></span><br><span class="line">        Future&lt;String&gt; future = es.submit(<span class="keyword">new</span> <span class="title class_">MyCallable1</span>());</span><br><span class="line">        <span class="comment">//获取线程任务的返回值</span></span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;哈哈哈哈哈哈&quot;</span>);</span><br><span class="line">        <span class="comment">//3、关闭线程池</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable1</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+i);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是Callable线程任务的返回值&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-读写锁">（6）读写锁</h3>
<p>ReentrantReadWriteLock：</p>
<p>    一种支持一写多读的同步锁，读写分离，可分别分配读锁、写锁。</p>
<p>    支持多次分配读锁，使多个读操作可以并发执行。</p>
<p>互斥规则：</p>
<p>    写-写：互斥，阻塞</p>
<p>    读-写：互斥，读阻塞写、写阻塞读。</p>
<p>    读-读：不互斥、不阻塞。</p>
<p>    在读操作远远高于写操作的环境中，可在保障线程安全的情况下，提高运行效率</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriterLockDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//记录开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//1.创建线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//2.提交8个读操作任务，提交2个写操作任务</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="type">ReadThread</span> <span class="variable">readThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReadThread</span>(user);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            es.submit(readThread);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="type">WriteThread</span> <span class="variable">writeThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WriteThread</span>(user);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            es.submit(writeThread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.结束线程池</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">        <span class="comment">//es.isTerminated();    获取当前线程池的状态，如果线程池钟的任务执行结束，那么返回true，否则返回false</span></span><br><span class="line">        <span class="comment">//System.out.println(es.isTerminated());</span></span><br><span class="line">        <span class="comment">//我们希望以下的代码在线程任务执行结束之后再执行.利用代码空转来判断</span></span><br><span class="line">        <span class="keyword">while</span> (!es.isTerminated())</span><br><span class="line">        &#123;&#125;</span><br><span class="line">        <span class="comment">//记录结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时&quot;</span> + (end-start) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写线程</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">WriteThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    User user;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WriteThread</span><span class="params">(User user)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        user.setName(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    User user;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReadThread</span><span class="params">(User user)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        user.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//读写锁</span></span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">rrwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">//读锁</span></span><br><span class="line">    ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> rrwl.readLock();</span><br><span class="line">    <span class="comment">//写锁</span></span><br><span class="line">    ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> rrwl.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读操作</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读和写都需要花一秒，而读和读是不影响的，读和写的互斥的，写和写是互斥的</span></span><br><span class="line"><span class="comment">//class User</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    private String name;</span></span><br><span class="line"><span class="comment">//    Lock lock = new ReentrantLock();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    //写操作</span></span><br><span class="line"><span class="comment">//    public void setName(String name)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        lock.lock();</span></span><br><span class="line"><span class="comment">//        try</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            Thread.sleep(1000);</span></span><br><span class="line"><span class="comment">//            this.name = name;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        catch (InterruptedException e)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        finally</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            lock.unlock();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    //读操作</span></span><br><span class="line"><span class="comment">//    public String getName()</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        lock.lock();</span></span><br><span class="line"><span class="comment">//        try</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            Thread.sleep(1000);</span></span><br><span class="line"><span class="comment">//            return name;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        catch (InterruptedException e)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        finally</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            lock.unlock();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return null;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="7-重入锁">（7）重入锁</h3>
<p>重入锁:在同步锁中可以继续加入同步锁(锁对象是同一个)</p>
<p>    synchronized和Lock锁都可以实现锁的重入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReentrantLock</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 重入锁:在同步锁中可以继续加入同步锁(锁对象是同一个)</span></span><br><span class="line"><span class="comment">    * synchronized和Lock锁都可以实现锁的重入</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        a();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//当前锁对象为this</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        b();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//当前锁对象为this</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        c();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-公平锁">（8）公平锁</h3>
<p>公平锁和非公平锁</p>
<p>    非公平锁：优先使用上一个线程接着执行下面的线程任务</p>
<p>        synchronized是非公平锁的实现，无法实现公平锁</p>
<p>        lock锁默认是非公平锁，如果想要实现公平锁，那么需要在构造方法设置为true</p>
<p>    公平锁：让每个线程都公平去执行线程任务</p>
<p>        lock锁可以实现公平锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Lock锁实现公平锁 参数为true表示是公平锁，默认是false表示非公平锁</span></span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://i.postimg.cc/wjTxDpBF/image.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://i.postimg.cc/wjTxDpBF/image.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">星仔极客</div><div class="post-copyright__author_desc">珍惜当下 不负此生</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://xinzaigeek.68565200.xyz/post/fbc0ae86.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://xinzaigeek.68565200.xyz/post/fbc0ae86.html')">24.多线程</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://xinzaigeek.68565200.xyz/post/fbc0ae86.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=24.多线程&amp;url=https://xinzaigeek.68565200.xyz/post/fbc0ae86.html&amp;pic=https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xinzaigeek.68565200.xyz" target="_blank">星仔极客</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Java%E8%AF%AD%E8%A8%80/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Java语言<span class="tagsPageCount">12</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://img.picgo.net/2024/11/13/c12889d56cf9e0078ed87b335eb8b0b321601f0548e324aa.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/3e1167ea.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" onerror="onerror=null;src='https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">23.IO流</div></div></a></div><div class="next-post pull-right"><a href="/post/5883a4af.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" onerror="onerror=null;src='https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">26.反射</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/post/ca0fcd03.html" title="0.Java概述"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-30</div><div class="title">0.Java概述</div></div></a></div><div><a href="/post/fbc82303.html" title="1.Java基本语法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-30</div><div class="title">1.Java基本语法</div></div></a></div><div><a href="/post/76fa8c0d.html" title="2.面向对象"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-30</div><div class="title">2.面向对象</div></div></a></div><div><a href="/post/8f9052f9.html" title="22.File类和递归"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-30</div><div class="title">22.File类和递归</div></div></a></div><div><a href="/post/3e1167ea.html" title="23.IO流"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-30</div><div class="title">23.IO流</div></div></a></div><div><a href="/post/5883a4af.html" title="26.反射"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-30</div><div class="title">26.反射</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://i.postimg.cc/wjTxDpBF/image.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">分享科技与生活</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">星仔极客</h1><div class="author-info__desc">珍惜当下 不负此生</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://juejin.cn/user/745920887002011/posts" target="_blank" title="稀土掘金"><i class="anzhiyufont anzhiyu-icon-link"></i></a><a class="social-icon faa-parent animated-hover" href="https://www.bilibili.com/" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://img.picgo.net/2024/08/19/7769745c3a8abda4b76a2c8767c011c4ccc3bcc6d25362ee.webp) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://img.picgo.net/2024/08/19/7229edbc2326d9f1a077d9f251d15dfc93e3d4fe574b7ca8.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">知识点一：Thread线程基础</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">知识点二：并行和并发</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">知识点三：线程和进程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">知识点四：Java程序中实现线程的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E4%B9%8B%E7%BB%A7%E6%89%BFthread%E7%B1%BB-center"><span class="toc-number">4.1.</span> <span class="toc-text">1、线程创建方式之继承Thread类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-2-%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E4%B9%8B%E5%AE%9E%E7%8E%B0runnable%E6%8E%A5%E5%8F%A3-center"><span class="toc-number">4.2.</span> <span class="toc-text">2、线程创建方式之实现Runnable接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-3-thread%E7%B1%BB%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%92%8Crunnable%E6%8E%A5%E5%8F%A3%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B-center"><span class="toc-number">4.3.</span> <span class="toc-text">3、Thread类创建线程和Runnable接口创建线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-4-start%E6%96%B9%E6%B3%95%E5%92%8Crun%E6%96%B9%E6%B3%95-center"><span class="toc-number">4.4.</span> <span class="toc-text">4、start方法和run方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-5-%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E6%88%96lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BE%BF%E6%8D%B7%E7%9A%84%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1%E5%B9%B6%E6%89%A7%E8%A1%8C-%E4%BA%86%E8%A7%A3-center"><span class="toc-number">4.5.</span> <span class="toc-text">5、使用匿名内部类或Lambda表达式便捷的创建线程对象并执行（了解）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">知识点五：线程常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81getstate-center"><span class="toc-number">5.1.</span> <span class="toc-text">1、线程状态getState</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-2-%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7setpriority-center"><span class="toc-number">5.2.</span> <span class="toc-text">2、线程优先级setPriority</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-3-%E6%9B%B4%E6%94%B9%E5%92%8C%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8D%E5%AD%97-center"><span class="toc-number">5.3.</span> <span class="toc-text">3、更改和获取线程的名字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-4-%E7%BA%BF%E7%A8%8B%E4%BC%91%E7%9C%A0sleep-%E4%BD%BF%E7%94%A8%E5%87%A0%E7%8E%87%E6%9E%81%E9%AB%98-center"><span class="toc-number">5.4.</span> <span class="toc-text">4、线程休眠sleep【使用几率极高】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-5-%E7%BA%BF%E7%A8%8B%E7%A4%BC%E8%AE%A9yield-%E4%BA%86%E8%A7%A3-center"><span class="toc-number">5.5.</span> <span class="toc-text">5、线程礼让yield（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-6-%E7%BA%BF%E7%A8%8B%E5%90%88%E5%B9%B6join-center"><span class="toc-number">5.6.</span> <span class="toc-text">6、线程合并join</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-7-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD-%E6%A0%87%E8%AE%B0-center"><span class="toc-number">5.7.</span> <span class="toc-text">7、线程中断(标记)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">知识点六：火车售票问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-getinstance-center"><span class="toc-number">6.1.</span> <span class="toc-text">GetInstance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90-%E4%BF%9D%E8%AF%81%E8%B5%84%E6%BA%90%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-center"><span class="toc-number">6.2.</span> <span class="toc-text">1、如何解决多线程并发访问临界资源，保证资源安全问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-2-synchronized%E5%85%B3%E9%94%AE%E5%AD%97-center"><span class="toc-number">6.3.</span> <span class="toc-text">2、synchronized关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-3-%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95-%E5%AF%B9%E8%B1%A1%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95-%E6%88%90%E5%91%98%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95-center"><span class="toc-number">6.4.</span> <span class="toc-text">3、同步方法&#x2F;对象同步方法&#x2F;成员同步方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-4-%E7%B1%BB%E9%94%81-%E7%B1%BB%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97-%E7%B1%BB%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95-%E9%9D%99%E6%80%81%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95-center"><span class="toc-number">6.5.</span> <span class="toc-text">4、类锁&#x2F;类同步代码块&#x2F;类同步方法&#x2F;静态同步方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">知识点七：线程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-%E5%AE%8C%E6%88%90%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8Bv1%E7%89%88%E6%9C%AC-center"><span class="toc-number">7.1.</span> <span class="toc-text">1、完成生产者和消费者通信模型v1版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-2-%E5%AE%8C%E6%88%90%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8Bv2%E7%89%88%E6%9C%AC-center"><span class="toc-number">7.2.</span> <span class="toc-text">2、完成生产者和消费者通信模型v2版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-3-%E5%88%86%E6%9E%90%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-center"><span class="toc-number">7.3.</span> <span class="toc-text">3、分析执行流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">知识点八：多对多通信模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-%E8%B4%9F%E6%95%B0%E9%97%AE%E9%A2%98-center"><span class="toc-number">8.1.</span> <span class="toc-text">1、负数问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-2-%E6%AD%BB%E7%AD%89%E5%BE%85%E9%97%AE%E9%A2%98-center"><span class="toc-number">8.2.</span> <span class="toc-text">2、死等待问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-3-%E6%89%A9%E5%B1%95%EF%BC%9Alock%E6%8E%A5%E5%8F%A3-%E6%98%BE%E7%A4%BA%E9%94%81-center"><span class="toc-number">8.3.</span> <span class="toc-text">3、扩展：Lock接口【显示锁】</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">知识点九：线程声明周期</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">知识点十：拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E9%87%8D%E7%82%B9-center"><span class="toc-number">10.1.</span> <span class="toc-text">1、线程池【重点】</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A6%82%E5%BF%B5"><span class="toc-number">10.1.1.</span> <span class="toc-text">（1）线程池概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">10.1.2.</span> <span class="toc-text">（2）线程池实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B1%BB"><span class="toc-number">10.1.3.</span> <span class="toc-text">（3）线程池中常见的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-callable%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.1.4.</span> <span class="toc-text">（4）Callable接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-future%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.1.5.</span> <span class="toc-text">（5）Future接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">10.1.6.</span> <span class="toc-text">（6）读写锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">10.1.7.</span> <span class="toc-text">（7）重入锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">10.1.8.</span> <span class="toc-text">（8）公平锁</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/a2c247c4.html" title="项目"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/11/13/c12889d56cf9e0078ed87b335eb8b0b321601f0548e324aa.png" onerror="this.onerror=null;this.src='https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png'" alt="项目"/></a><div class="content"><a class="title" href="/post/a2c247c4.html" title="项目">项目</a><time datetime="2024-11-25T02:22:50.000Z" title="发表于 2024-11-25 10:22:50">2024-11-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/d98607ab.html" title="0.ArkTS基础语法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/11/13/c12889d56cf9e0078ed87b335eb8b0b321601f0548e324aa.png" onerror="this.onerror=null;this.src='https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png'" alt="0.ArkTS基础语法"/></a><div class="content"><a class="title" href="/post/d98607ab.html" title="0.ArkTS基础语法">0.ArkTS基础语法</a><time datetime="2024-11-24T02:22:50.000Z" title="发表于 2024-11-24 10:22:50">2024-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/de777d6b.html" title="1.界面开发"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/11/13/c12889d56cf9e0078ed87b335eb8b0b321601f0548e324aa.png" onerror="this.onerror=null;this.src='https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png'" alt="1.界面开发"/></a><div class="content"><a class="title" href="/post/de777d6b.html" title="1.界面开发">1.界面开发</a><time datetime="2024-11-23T02:23:35.000Z" title="发表于 2024-11-23 10:23:35">2024-11-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/36f99b3f.html" title="2.交互开发"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/11/13/c12889d56cf9e0078ed87b335eb8b0b321601f0548e324aa.png" onerror="this.onerror=null;this.src='https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png'" alt="2.交互开发"/></a><div class="content"><a class="title" href="/post/36f99b3f.html" title="2.交互开发">2.交互开发</a><time datetime="2024-11-22T08:44:16.000Z" title="发表于 2024-11-22 16:44:16">2024-11-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/9d10e9f6.html" title="4.Linux应用编程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://i.postimg.cc/MKRR79pj/7777777.jpg" onerror="this.onerror=null;this.src='https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png'" alt="4.Linux应用编程"/></a><div class="content"><a class="title" href="/post/9d10e9f6.html" title="4.Linux应用编程">4.Linux应用编程</a><time datetime="2024-11-20T12:47:12.000Z" title="发表于 2024-11-20 20:47:12">2024-11-20</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="星仔极客" target="_blank">星仔极客</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">80</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">11</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://juejin.cn/user/745920887002011/posts" title="稀土掘金"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="/img/favicon.ico" alt="稀土掘金"/><span class="back-menu-item-text">稀土掘金</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://www.bilibili.com/" title="哔哩哔哩"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="/img/favicon.ico" alt="哔哩哔哩"/><span class="back-menu-item-text">哔哩哔哩</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">资源下载</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://www.sscha.com/" title="商查查"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="商查查"/><span class="back-menu-item-text">商查查</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 小伙伴</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://link3.cc/xinzai_x"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 个人资源</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="http://ainm.cc/c/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐网</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 常用文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://68565200.xyz/post/1f293ccb"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 资源搜索</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/32%E5%8D%95%E7%89%87%E6%9C%BA/" style="font-size: 0.88rem;">32单片机<sup>12</sup></a><a href="/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/" style="font-size: 0.88rem;">51单片机<sup>8</sup></a><a href="/tags/CubeIDE%E4%B8%8ECubeMX%E8%BD%AF%E4%BB%B6%E8%AE%BE%E7%BD%AE/" style="font-size: 0.88rem;">CubeIDE与CubeMX软件设置<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">C语言<sup>13</sup></a><a href="/tags/Java%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">Java语言<sup>12</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>5</sup></a><a href="/tags/MySQL/" style="font-size: 0.88rem;">MySQL<sup>3</sup></a><a href="/tags/RT-Thread/" style="font-size: 0.88rem;">RT-Thread<sup>6</sup></a><a href="/tags/Win11%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/" style="font-size: 0.88rem;">Win11相关设置<sup>1</sup></a><a href="/tags/springboot%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/" style="font-size: 0.88rem;">springboot相关配置<sup>1</sup></a><a href="/tags/ubuntu%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/" style="font-size: 0.88rem;">ubuntu相关设置<sup>1</sup></a><a href="/tags/%E4%BA%91%E5%9B%BE%E5%BA%8A/" style="font-size: 0.88rem;">云图床<sup>1</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2CDN%E8%A7%A3%E6%9E%90/" style="font-size: 0.88rem;">博客CDN解析<sup>1</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/" style="font-size: 0.88rem;">博客搭建相关<sup>1</sup></a><a href="/tags/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">图片压缩在线工具<sup>1</sup></a><a href="/tags/%E5%B0%8F%E7%8B%BC%E6%AF%AB%E8%BE%93%E5%85%A5%E6%B3%95/" style="font-size: 0.88rem;">小狼毫输入法<sup>1</sup></a><a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 0.88rem;">插件<sup>1</sup></a><a href="/tags/%E8%90%A5%E4%B8%9A%E6%89%A7%E7%85%A7/" style="font-size: 0.88rem;">营业执照<sup>1</sup></a><a href="/tags/%E8%B5%84%E6%BA%90%E6%90%9C%E7%B4%A2/" style="font-size: 0.88rem;">资源搜索<sup>1</sup></a><a href="/tags/%E9%B8%BF%E8%92%99NEXT%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/" style="font-size: 0.88rem;">鸿蒙NEXT应用开发<sup>4</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 星仔极客 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script async src="https://www.iconfont.cn/collections/detail?cid=44481"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>