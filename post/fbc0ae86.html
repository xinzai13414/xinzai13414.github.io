<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>24.多线程 | 星仔极客</title><noscript>开启JavaScript才能访问本站哦~</noscript><link rel="icon" href="https://img.picgo.net/2024/09/24/811513a1eaacadb85ae79568d39c3337b8b87d11b124d4ab.png"><!-- index.css--><link rel="stylesheet" href="/css/index.css?v=2.1.15"><!-- inject head--><link rel="canonical" href="https://xinzaigeek.68565200.xyz/post/fbc0ae86.html"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css"><!-- aplayer--><!-- swiper--><!-- fancybox ui--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.36/fancybox/fancybox.min.css"><!-- katex--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css"><!-- Open Graph--><meta name="description" content="知识点一：Thread线程基础 有一个场景：在一个程序中即可以玩游戏又可以播放音乐？ 以现在编程手段而言 —》 提供编程结构【顺序、分支、循环】 代码是要遵守顺序执行，代码需要遵守从上至下逐行执行，利用分支和循环修改循环执行一些操作，选择性执行某代码或者是让某些代码重复执行，无论如何操作代码依旧要顺"><!-- pwa--><meta name="apple-mobile-web-app-capable" content="星仔极客"><meta name="theme-color" content="var(--efu-main)"><meta name="apple-mobile-web-app-status-bar-style" content="var(--efu-main)"><link rel="bookmark" href="https://img.picgo.net/2024/09/24/811513a1eaacadb85ae79568d39c3337b8b87d11b124d4ab.png"><link rel="apple-touch-icon" href="https://img.picgo.net/2024/09/24/811513a1eaacadb85ae79568d39c3337b8b87d11b124d4ab.png" sizes="180x180"><script>console.log(' %c Solitude %c ' + '2.1.15' + ' %c https://github.com/everfu/hexo-theme-solitude',
    'background:#35495e ; padding: 1px; border-radius: 3px 0 0 3px;  color: #fff',
    'background:#ff9a9a ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff',
    'background:unset ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff')
</script><script>(()=>{
        const saveToLocal = {
            set: function setWithExpiry(key, value, ttl) {
                if (ttl === 0)
                    return
                const now = new Date()
                const expiryDay = ttl * 86400000
                const item = {
                    value: value,
                    expiry: now.getTime() + expiryDay
                }
                localStorage.setItem(key, JSON.stringify(item))
            },
            get: function getWithExpiry(key) {
                const itemStr = localStorage.getItem(key)

                if (!itemStr) {
                    return undefined
                }
                const item = JSON.parse(itemStr)
                const now = new Date()

                if (now.getTime() > item.expiry) {
                    localStorage.removeItem(key)
                    return undefined
                }
                return item.value
            }
        };
        window.utils = {
            saveToLocal: saveToLocal,
            getCSS: (url, id = false) => new Promise((resolve, reject) => {
              const link = document.createElement('link')
              link.rel = 'stylesheet'
              link.href = url
              if (id) link.id = id
              link.onerror = reject
              link.onload = link.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                link.onload = link.onreadystatechange = null
                resolve()
              }
              document.head.appendChild(link)
            }),
            getScript: (url, attr = {}) => new Promise((resolve, reject) => {
              const script = document.createElement('script')
              script.src = url
              script.async = true
              script.onerror = reject
              script.onload = script.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                script.onload = script.onreadystatechange = null
                resolve()
              }

              Object.keys(attr).forEach(key => {
                script.setAttribute(key, attr[key])
              })

              document.head.appendChild(script)
            }),
            addGlobalFn: (key, fn, name = false, parent = window) => {
                const globalFn = parent.globalFn || {}
                const keyObj = globalFn[key] || {}

                if (name && keyObj[name]) return

                name = name || Object.keys(keyObj).length
                keyObj[name] = fn
                globalFn[key] = keyObj
                parent.globalFn = globalFn
            },
            addEventListenerPjax: (ele, event, fn, option = false) => {
              ele.addEventListener(event, fn, option)
              utils.addGlobalFn('pjax', () => {
                  ele.removeEventListener(event, fn, option)
              })
          },
        }
    })()</script><!-- theme--><script>initTheme = () => {
    let isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const cachedMode = utils.saveToLocal.get('theme');
    if (cachedMode === undefined) {
        const nowMode =
            isDarkMode ? 'dark' : 'light'
        document.documentElement.setAttribute('data-theme', nowMode);
    } else {
        document.documentElement.setAttribute('data-theme', cachedMode);
    }
    typeof rm === 'object' && rm.mode(cachedMode === 'dark' && isDarkMode)
}
initTheme()</script><!-- global head--><script>const GLOBAL_CONFIG = {
    root: '/',
    algolia: {"appId":"V1R8T877I8","apiKey":"5d3e42b03150eed38d97122513aa8714","indexName":"Blog","hits":{"per_page":10}},
    localsearch: undefined,
    runtime: '2023-04-20 00:00:00',
    lazyload: {
        enable: true,
        error: '/img/error_load.avif'
    },
    copyright: {"limit":50,"author":"作者: 星仔极客","link":"链接: ","source":"来源: 星仔极客","info":"著作权归作者所有。 商业转载请联系作者获得授权，非商业转载请注明出处。"},
    highlight: {"limit":500,"expand":true,"copy":true,"syntax":"highlight.js"},
    randomlink: false,
    lang: {"theme":{"dark":"已切换至深色模式","light":"已切换至浅色模式"},"copy":{"success":"复制成功","error":"复制失败"},"backtop":"返回顶部","time":{"day":"天前","hour":"小时前","just":"刚刚","min":"分钟前","month":"个月前"},"day":" 天","f12":"开发者模式已打开，请遵循GPL协议。","totalk":"无需删除空行，直接输入评论即可","search":{"empty":"找不到你查询的内容：${query}","hit":"找到 ${hits} 条结果，用时 ${time} 毫秒","placeholder":"输入关键词快速查找","count":"共 <b>${count}</b> 条结果。","loading":"搜索中..."},"barrage":{"title":"热评"}},
    aside: {
        sayhello: {
            morning: "✨ 早上好，新的一天开始了",
            noon: "中午饭时间",
            afternoon: "下午茶时间 ☕️",
            night: "不要熬夜哦",
            goodnight: "晚安，早点休息",
        },
        sayhello2: ["你可以的","相信你可以的","你一定可以的"],
        sayhello3: {
            prefix: '好久不见，',
            back: '欢迎再次回来，',
        },
    },
    covercolor: {
        enable: true
    },
    comment: {"avatar":"https://gravatar.com/avatar","commentBarrage":true},
    lightbox: 'fancybox',
    post_ai: false,
    right_menu: {"mode":{"dark":"深色模式","light":"浅色模式"},"img_error":"此图片无法复制与下载","barrage":{"open":"显示热评","close":"关闭热评"},"ctrlOriginalMenu":"按住Ctrl+右键可打开浏览器右键菜单"},
    translate: false,
    lure: false,
    expire: false,
};</script><!-- page-config head--><script id="config-diff">var PAGE_CONFIG = {
    is_post: true,
    is_page: false,
    is_home: false,
    page: '',
    toc: true,
    comment: true,
    ai_text: false,
    color: false,
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="星仔极客" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body id="body"><!-- universe--><!-- background img--><div id="global_bg"></div><!-- loading--><!-- console--><!-- sidebar--><div id="sidebar" style="zoom: 1;"><div id="menu-mask" style="display: none;"></div><div id="sidebar-menus"><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">80</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div></div></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><span class="darkmode_switchbutton menu-child" onclick="sco.switchDarkMode()"><i class="solitude fa-solid fa-circle-half-stroke"></i><span>显示模式</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  fas fa-folder-closed"></i><span>全部文章</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  fas fa-clone"></i><span>分类列表</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  fas fa-tags"></i><span>标签列表</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/links/"><i class="solitude  fas fa-user-group"></i><span>友情链接</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://link3.cc/xinzai_x"><i class="solitude  fas fa-tools"></i><span>工具站</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="http://ainm.cc/c/music/"><i class="solitude  fas fa-headphones"></i><span>音乐网</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>常用文章</span></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://68565200.xyz/post/79959306.html"><i class="solitude  fas fa-images"></i><span>图片工具</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="solitude  fas fa-user"></i><span>关于本站</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-widget card-tags card-archives card-webinfo card-allinfo"><div class="card-tag-cloud"><a href="/tags/Java%E8%AF%AD%E8%A8%80/">Java语言<sup>12</sup></a><a href="/tags/MySQL/">MySQL<sup>3</sup></a><a href="/tags/%E4%BA%91%E5%9B%BE%E5%BA%8A/">云图床<sup>1</sup></a><a href="/tags/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/">图片压缩在线工具<sup>1</sup></a><a href="/tags/%E6%8F%92%E4%BB%B6/">插件<sup>1</sup></a><a href="/tags/%E8%B5%84%E6%BA%90%E6%90%9C%E7%B4%A2/">资源搜索<sup>1</sup></a><a href="/tags/CubeIDE%E4%B8%8ECubeMX%E8%BD%AF%E4%BB%B6%E8%AE%BE%E7%BD%AE/">CubeIDE与CubeMX软件设置<sup>1</sup></a><a href="/tags/springboot%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/">springboot相关配置<sup>1</sup></a><a href="/tags/Win11%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/">Win11相关设置<sup>1</sup></a><a href="/tags/ubuntu%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/">ubuntu相关设置<sup>1</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2CDN%E8%A7%A3%E6%9E%90/">博客CDN解析<sup>1</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/">博客搭建相关<sup>1</sup></a><a href="/tags/%E5%B0%8F%E7%8B%BC%E6%AF%AB%E8%BE%93%E5%85%A5%E6%B3%95/">小狼毫输入法<sup>1</sup></a><a href="/tags/%E8%90%A5%E4%B8%9A%E6%89%A7%E7%85%A7/">营业执照<sup>1</sup></a><a href="/tags/%E9%B8%BF%E8%92%99next%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/">鸿蒙next应用开发<sup>4</sup></a><a href="/tags/32%E5%8D%95%E7%89%87%E6%9C%BA/">32单片机<sup>12</sup></a><a href="/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/">51单片机<sup>8</sup></a><a href="/tags/Linux/">Linux<sup>5</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/">C语言<sup>13</sup></a><a href="/tags/RT-Thread/">RT-Thread<sup>6</sup></a></div></div></div></div><!-- keyboard--><!-- righhtside--><div class="needEndHide" id="rightside"><div class="rs_hide"><button class="mode" type="button" title="显示模式切换" onclick="sco.switchDarkMode()"><i class="fas fa-circle-half-stroke"></i></button></div><div class="rs_show"><button class="config" type="button" title="扩展" onclick="document.querySelector(&quot;.rs_hide&quot;).classList.toggle(&quot;show&quot;)"><i class="fas fa-gear fa-spin"></i></button><button class="mobile toc" type="button" title="目录" onclick="document.querySelector('#card-toc').classList.toggle('open')"><i class="fas fa-list"></i></button><button class="comment" type="button" title="评论" onclick="sco.scrollTo('post-comment')"><i class="fas fa-comment"></i></button><button class="barrage pc" type="button" title="弹" onclick="sco.switchCommentBarrage()"><span>弹</span></button><button class="top" type="button" title="返回顶部" onclick="sco.toTop()"><i class="fas fa-arrow-up"></i><span id="percent">0</span></button></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav class="show" id="nav"><div id="nav-group"><div id="blog_name"><a id="site-name" href="/" title="返回博客主页"><i class="solitude fa-solid fa-home"></i></a></div><div id="page-name-mask"><div id="page-name"><a id="page-name-text" onclick="sco.toTop()">24.多线程</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  fas fa-folder-closed"></i><span>全部文章</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  fas fa-clone"></i><span>分类列表</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  fas fa-tags"></i><span>标签列表</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/links/"><i class="solitude  fas fa-user-group"></i><span>友情链接</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://link3.cc/xinzai_x"><i class="solitude  fas fa-tools"></i><span>工具站</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="http://ainm.cc/c/music/"><i class="solitude  fas fa-headphones"></i><span>音乐网</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>常用文章</span></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://68565200.xyz/post/79959306.html"><i class="solitude  fas fa-images"></i><span>图片工具</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="solitude  fas fa-user"></i><span>关于本站</span></a></li></ul></div></div></div><div id="nav-left"></div><div id="nav-right"><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索"><i class="solitude fa-solid fa-magnifying-glass"></i></a></div><div id="toggle-menu"><a class="site-page"><i class="solitude fa-solid fa-bars"></i></a></div></div></div></nav><div class="coverdiv" id="coverdiv"><img class="nolazyload" id="post-cover" src="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" alt="24.多线程"></div><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original" title="该文章为原创文章，注意版权协议">原创</a><span class="post-meta-categories"><a class="post-meta-categories" href="/categories/Java%E8%AF%AD%E8%A8%80/">Java语言</a></span><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E8%AF%AD%E8%A8%80/"><span class="tags-name tags-punctuation"><i class="solitude fa-solid fa-hashtag"></i>Java语言</span></a></div></div></div></div><h1 class="post-title">24.多线程</h1><div id="post-meta"><div class="meta-secondline"><span class="post-meta-date" title="发布于 2023-12-30 13:11:26"><i class="post-meta-icon solitude fas fa-calendar-days"></i><time datetime="2023-12-30T05:11:26.000Z">2023-12-30T05:11:26.000Z</time></span><span class="post-meta-date" title="最后更新于 2024-10-11 09:27:40"><i class="post-meta-icon solitude fa-solid fa-arrows-rotate"></i><time datetime="2024-10-11T01:27:40.393Z">2024-10-11T01:27:40.393Z</time></span><span class="post-meta-position" title="作者IP归属地为揭阳"><i class="post-meta-icon solitude fas fa-location-dot"></i><span>揭阳</span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content article-container"><h1><center>知识点一：Thread线程基础</center></h1>
<p>有一个场景：在一个程序中即可以玩游戏又可以播放音乐？</p>
<p>以现在编程手段而言 —》 提供编程结构【顺序、分支、循环】</p>
<p>代码是要遵守顺序执行，代码需要遵守从上至下逐行执行，利用分支和循环修改循环执行一些操作，选择性执行某代码或者是让某些代码重复执行，无论如何操作代码依旧要顺序执行，没有办法让两段代交替执行</p>
<img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012202919.WebP" alt="线程流程" style="zoom: 50%;">
<p>此时Java为了解决这样的问题，提供一个操作，这个操作就叫做<strong>线程</strong>，可以在代码中使用多线程形式来完成这个操作</p>
<p>PS:现在电脑基本上都是多核CPU，所以每个人电脑上运行线程程序结果可能都不一样，这是一个非常正常现象，多线程运行时是一个不可预知状态，程序猿可以通过代码干预线程运行，以达到我们运行效果</p>
<h1><center>知识点二：并行和并发</center></h1>
<p>这两个概念在宏观的角度而言他们是一样(相似)的，但是在微观的角度而言他们是有区别</p>
<img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012203194.WebP" alt="并行和并发" style="zoom:50%;">
<p><strong>并行就是同时执行，并发就是在交替执行</strong></p>
<p>    在操作系统中，安装了很多程序，并发指的是在一段时间内宏观上多个程序同时执行，这个在单个CPU系统中，每一个时刻只有一个程序执行，即微观上这些程序是分时交替的执行，只不过给人感觉是在同时运行，因为分时交替运行时间非常短暂</p>
<p>    现在而言都是多核CPU，则这些并发执行程序可以分配到不同的处理器上（CPU），实现多个任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序就可以同时执行了，你的电脑CPU核心越多你电脑的性能就相对更加强悍</p>
<p>PS:单核处理的计算机肯定是不能并行处理多个任务，只能是多个任务在单个CPU上并发需要运行，同理线程也是一样的从宏观的角度而言线程并行运行从微观角度看就是串行运行，即线程是一个一个去执行的，当系统只有一个CPU是，线程会以某种顺序执行多个线程，这个情况称之线程调度【线程提供CPU时间争抢】</p>
<h1><center>知识点三：线程和进程</center></h1>
<p><strong>进程</strong></p>
<p>    进程是程序的一次执行过程，是系统运行程序的基本单元，系统运行一个程序即在运行一个进程【从创建、运行、消亡的一个过程】，每一个进程都有自己一个独立的空间【内存空间】，一个应用程序(进程)可以同时运行多个线程</p>
<p>特点：</p>
<ol>
<li>进程是一个独立程序单元并且拥有自己独立空间</li>
<li>一个进程中可以同时运行多个线程</li>
</ol>
<img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012204035.WebP" alt="进程" style="zoom:50%;">
<p>进程是可以完成多个任务交替执行的，可以开发一个音乐软件（QQ音乐、网易云音乐、酷狗音乐），也可以开发一个打游戏软件（L0L、吃鸡战场、Dota2），只要运行这两个进程程序就可以完成一边听音乐，一边打游戏，这样做开发成本高，进行是独立的进程与进程之间是无法进行“<strong>通信</strong>”的</p>
<p><strong>线程</strong></p>
<p>    线程是进程中一个内部执行单元，负责当前进程中的程序执行，一个进程中至少有一个线程，一个进程可以有多个线程，这些线程在进程中被称之为“多线程”，进程就可以利用这些多线程，去完成不同操作</p>
<p>特点:</p>
<ol>
<li>线程是在进程的内部执行，并且可以存在多个，彼此之间共享进程的内存区域</li>
<li>线程与线程之间彼此独立，但是可以进行“通信”</li>
</ol>
<p>可以利用这个轻量级的开发完成一个进程内部程序交替执行效果（线程并发执行）</p>
<img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012205517.WebP" alt="线程" style="zoom:50%;">
<p>总结进程与线程的区别：</p>
<p>    进程： 有独立的内存空间，进程中数据存放的空间是独立的并且至少有一个线程</p>
<p>    线程：堆空间是共享的，栈空间是独立的，线程消耗的资源要比进程小，并且可以多个线程存在同一个进程中</p>
<p>PS:需要知道了解的知识点：</p>
<ol>
<li>因为一个程序中有多个线程并发运行，那么从微观的角度而言是有先后顺序的，那么线程执行的顺序是取决于CPU的调度【线程争抢CPU时间片】，程序猿只能进行干涉，在不加干涉前提下线程执行就会出现很多随机性</li>
<li>Java程序进程中最少包含两个线程，一个是主线程就是main()方法【它在执行方法是或者执行程序时它的优先级永远最高】，另外一个垃圾回收机制线程(GC)【守护线程】，每当Java执行一个类的时候，实际上都会启动一个JVM，每一个JVM实际上就是在操作系统中启动了一个线程，Java本身就被垃圾回收机制所守护，所Java运行时至少启动了两个线程</li>
<li>由于创建一个线程开销远比创建一个进程开销要小很多，那么我们在开发多任务运行时，通常会优先考虑创建多线程，而不是多进程</li>
<li>所有的线程轮流使用CPU，每一个线程都会得到CPU分配的时间片，这个分配“尽量”平均分配CPU资源，但是这个效果不一定能达到，所以同优先级的线程对CPU时间的争抢是存在随机性的，可以对线程进行优先级设置来概念获取CPU时间片的几率，优先级越高几率越大，优先级越低几率越小</li>
</ol>
<h1><center>知识点四：Java程序中实现线程的方式</center></h1>
<p>在Java中主要创建线程方式有四种：</p>
<ol>
<li>继承Thread类，此时子类就是线程类</li>
<li>实现Runnable接口，此时实现类不是线程类，使用Thread类才可成为线程</li>
</ol>
<p><strong>无论是上述两种方式中那种方式都需必须重写run方法实现线程逻辑</strong></p>
<ol start="3">
<li>实现Callable接口， 此实现方方式并不是线程类，主要针对的是线程池提供</li>
<li>线程池可以帮组我们创建线程并进行管理操作</li>
</ol>
<p>如果实现线程需要继承Thread或实现Runnable接口，但是无论是那种都需要实现一个必要核心方法</p>
<p><strong>这个run方法是提供线程实现的核心逻辑，需要线程什么样需求代码，就将将代码写入到这个线程中</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">void</th>
<th style="text-align:center">run() 使用实现接口 Runnable 的对象创建一个线程时，启动该线程将导致在独立执行的线程中调用对象的 run方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><strong>PS：通过观察可以发现这个run方法是没有参数和返回值类型，所以这个run不能通过方法接收参数和返回数据值</strong></td>
</tr>
</tbody>
</table>
<h2 id="center-1-线程创建方式之继承thread类-center"><center>1、线程创建方式之继承Thread类</center></h2>
<p>步骤：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 定义一个普通类继承与`java.lang.Thread`类</span><br><span class="line"><span class="number">2.</span> 在子类中重新给父类Thread中run方法并提供线程实现逻辑</span><br><span class="line"><span class="number">3.</span> 在测试类中main方法中，通过线程子类或Thread这个父类创建线程对象并执行线程启动完成调用run方法中逻辑执行</span><br></pre></td></tr></table></figure>
<p>PS：因为Thread本身就是线程类，所以继承Thread类子类也是线程类，具备父类中Thread所提供的所有操作者线程方法</p>
<p>需求：使用继承Thread类方法是完成边打游戏和边听音乐</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了演示效果方便观察写在同一个文件中</span></span><br><span class="line"><span class="comment">//此时GameThread继承与Thread类所以GameThread就是线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//必须重写Thread父类中的run方法，提供这个线程需要的执行逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span> ; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;打游戏：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//此时MusicThread继承与Thread类所以GameThread就是线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MusicThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//必须重写Thread父类中的run方法，提供这个线程需要的执行逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span> ; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;听音乐：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//提供一个测试类完成线程创建与调用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//main方法本身一个线程，主线线程优先级最高</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如何创建线程对象</span></span><br><span class="line">        <span class="comment">//下面两种创建线程方式并没有指定线程优先级，所以都是默认优先级athread和bthread的优先级相同</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1. 使用多态的效果【Thread是子线程类父类，所以可以使用Thread方式创建】</span></span><br><span class="line"><span class="comment">                Thread 线程对象的名字 = new 子线程类();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GameThread</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            2. 直接使用继承线程子类创建对象</span></span><br><span class="line"><span class="comment">                子线程类 线程对象的名字 = new 子线程类();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">MusicThread</span> <span class="variable">bthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicThread</span>();</span><br><span class="line">        <span class="comment">//启动线程执行 ---》调用 Thread类中提供 start方法 ，而不是调用run方法</span></span><br><span class="line">        athread.start();</span><br><span class="line">        bthread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-2-线程创建方式之实现runnable接口-center"><center>2、线程创建方式之实现Runnable接口</center></h2>
<p>PS：<strong>实现Runnable接口的类并不是线程类，只是实现Runnable接口并提供run方法的重写，需要配合使用Thread类创建线程对象，此时线程才可以操作</strong>。因为Runnable接口中提供run方法的实现【实现Runnable接口的类】，传入到Thread类中时，就会覆盖Thread类中run方法，所以Thread提供创建线程对象就会执行重写Runnable接口中run方法，就会得到线程的效果</p>
<p>步骤:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 定义一个普通类实现Runnable接口</span><br><span class="line"><span class="number">2.</span> 实现Runnable接口的类必须重写run方法提供线程需要执行的逻辑</span><br><span class="line"><span class="number">3.</span> 在测试类中main方法中，使用Thread创建线程对象完成线程操作</span><br></pre></td></tr></table></figure>
<p>需求：使用继承Thread类方法是完成边打游戏和边听音乐</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Runnable;</span><br><span class="line"><span class="comment">//为了演示效果方便观察写在同一个文件中</span></span><br><span class="line"><span class="comment">//此类就是实现Runnable接口并提供run方法实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameRunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">1</span>; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;打游戏：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MusicRunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">1</span>; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;听音乐：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建Runnable接口实现类作为Thread线程对象操作</span></span><br><span class="line">        <span class="comment">//需要将Runnable接口的对象传递到Thread这个类中</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1. 先创建Runnable接口实现类的对象，然后再传递到Thread类中进行线程对象创建</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">GameRunnableImpl</span> <span class="variable">gri</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GameRunnableImpl</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(gri);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            2.使用匿名对象的方式进行Thread构造方法Runnable参数传递</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MusicRunnableImpl</span>());</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-3-thread类创建线程和runnable接口创建线程-center"><center>3、Thread类创建线程和Runnable接口创建线程</center></h2>
<p>    两种方式皆可，因为都要实现run方法，但是从类的扩展角度而言，建议使用实现Runnable接口方式来完成作，因为Java中类是单一继承，所以如果继承Thread类就无法在继承其他类，所以就会影响类的扩展，但是如果实现接口方式完成，不仅可以继承一个类还可以实现多个接口所以就比较推荐实现Runnable接口</p>
<p>继承效果：</p>
<p>    class A extends Thread{} //没有办法让A在继承</p>
<p>    class B extends XXXX implements Runnable{} // 不仅可以作为线程类操作而且还可以进行继承其他类</p>
<h2 id="center-4-start方法和run方法-center"><center>4、start方法和run方法</center></h2>
<p>PS：<strong>创建完毕线程对象之后，线程执行需要调用的是start方法而不是run方法</strong></p>
<p>start方法： 用start方法来启动线程，真正的实现了线程运行，通过Thread类中给提供start来启动一个线程，此时线程会进入到“<strong>准备就绪</strong>”状态，但是真正运行，一旦线程获取到CPU时间片，此时线程才会真正的执行，执行调用提供run方法完成线程逻辑</p>
<p>run方法：run方法只是一个普通方法，只是在run方法中实现线程执行逻辑，如果外界直接调用run方法，线程是没有启动，只不过是在main方法调用了run方法执行，执行出run方法提供操作，和线程一点关系都没有</p>
<h2 id="center-5-使用匿名内部类或lambda表达式便捷的创建线程对象并执行-了解-center"><center>5、使用匿名内部类或Lambda表达式便捷的创建线程对象并执行（了解）</center></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousAndLambdaThread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这种方式，线程是现创建现使用，只会使用一次即可</span></span><br><span class="line">        <span class="comment">//1.针对Thread类提供匿名内部类创建【只支持匿名内部类】</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">50</span>;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;听音乐：&quot;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();     <span class="comment">// 在最外侧的大括号中调用start方法</span></span><br><span class="line">        <span class="comment">//2.针对Runnable接口提供匿名内部类和Lambda表达式实现</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">50</span>;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;打游戏：&quot;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start(); <span class="comment">// 在最外侧的大括号中调用start方法</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">50</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;吃饭：&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start(); <span class="comment">// 在最外侧的大括号中调用start方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点五：线程常用方法</center></h1>
<h2 id="center-1-线程状态getstate-center"><center>1、线程状态getState</center></h2>
<p>这个方法可以返回线程运行状态</p>
<p>PS：API有一个静态属性 State【API中给返回类型时错误的，它不是静态类，他是一个枚举】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetStateDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用run方法进行求和操作【GetStateDemo 是 Thread子类</span></span><br><span class="line">        所以会得到所有方法】</span><br><span class="line">        System.out.println(<span class="string">&quot;进入run方法是当前线程状态：&quot;</span> + <span class="built_in">this</span>.getState());</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;=<span class="number">100</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;sum = &quot;</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetStateDemo</span>();</span><br><span class="line">        <span class="comment">//在启动线程之前</span></span><br><span class="line">        System.out.println(<span class="string">&quot;start方法之前线程状态：&quot;</span>+thread.getState());</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;start方法之后线程状态：&quot;</span>+thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以表示线程状态说明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 出生、新生</span></span><br><span class="line"><span class="comment">* 至今尚未启动的线程就是这种状态</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">NEW,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 准备就绪和执行</span></span><br><span class="line"><span class="comment">*PS：Java中提供Thread类并没有提供准备就绪的状态描述，所以RUNNABLE就有两个概念</span></span><br><span class="line"><span class="comment">* 调用start方法时是 ---&gt; 准备就绪</span></span><br><span class="line"><span class="comment">* 执行run方法时是 ---&gt; 执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">RUNNABLE,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 阻塞或睡眠 ---》 sleep方法</span></span><br><span class="line"><span class="comment">* 当线程出现【阻塞状态】，当前线程就会出现让出CPU时间片的操作等待后续执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">BLOCKED,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 等待 ---》 wait</span></span><br><span class="line"><span class="comment">* 等待是无限期等待只有进行唤醒之后等待效果才会消失【等待不是阻塞状态】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">WAITING,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 时间等待</span></span><br><span class="line"><span class="comment">* 在设置等待状态时设置一个时间，只要在时间范围内都是等待状</span></span><br><span class="line"><span class="comment">态，如果到了并且在等待时期并没有进行唤 </span></span><br><span class="line"><span class="comment">* 醒从操作，等待线程会自动唤醒</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">TIMED_WAITING,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 消亡，死亡</span></span><br><span class="line"><span class="comment">* 线程都执行完毕不会在执行就出现这个状态【线程结束】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">TERMINATED;</span><br></pre></td></tr></table></figure>
<h2 id="center-2-线程优先级setpriority-center"><center>2、线程优先级setPriority</center></h2>
<p>理论上线程优先级越高，获取CPU时间片的几率越大，反之获取几率越小</p>
<p>PS：但是优先级只是相当于给CPU一个暗示【先由我开始】，但是CPU是否会决定将时间片给当前线程，是CPU决定</p>
<p>所有在没有修改优先级之前的线程默认优先级都是相同，在Java中使用1~10之间数字表示线程优先级，数值越大优先级越高，所有在没有</p>
<p>修改优先级之前默认优先级是【5】API中提供三个静态常量方便对优先级的定义</p>
<table>
<thead>
<tr>
<th style="text-align:center">static int</th>
<th style="text-align:center">MAX_PRIORITY 线程可以具有的最高优先级【等级10】</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">static int</td>
<td style="text-align:center">MIN_PRIORITY 线程可以具有的最低优先级【等级1】</td>
</tr>
<tr>
<td style="text-align:center">static int</td>
<td style="text-align:center">NORM_PRIORITY 分配给线程的默认优先级【等级5】</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetPriorityDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span> ;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//getName()获取线程名字</span></span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;：i的数值：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//利用线程创建两个线程对象使用默认优先级</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SetPriorityDemo</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">bthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SetPriorityDemo</span>();</span><br><span class="line">        <span class="comment">//可能会出现Thread-0先执行 或 Thread-1先执行</span></span><br><span class="line">        <span class="comment">// athread.start(); // Thread-0</span></span><br><span class="line">        <span class="comment">// bthread.start(); // Thread-1</span></span><br><span class="line">        <span class="comment">//修改优先级</span></span><br><span class="line">        <span class="comment">// 【只要优先级的差别较大就可以的得到先执行和后执行效果】</span></span><br><span class="line">        <span class="comment">// 【只要优先级等级差别不是很大(比较接近)，执行效果就不是很明显了】</span></span><br><span class="line">        athread.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        bthread.setPriority(<span class="number">6</span>);</span><br><span class="line">        athread.start();     <span class="comment">// Thread-0</span></span><br><span class="line">        bthread.start();     <span class="comment">// Thread-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-3-更改和获取线程的名字-center"><center>3、更改和获取线程的名字</center></h2>
<p>线程是有默认名字组成方式 —》 使用到一个关键字“Thread” + “-” +“数字”，数字的从0开始，随着线程创建而逐渐增多，随着线程的减少而逐渐减少 —》 默认名字 【Thread-数字】</p>
<p>在编写线程程序时可以通过<strong>getName方法获取线程名字</strong>，但是如果创建线程过多使用默认名字看到效果就不是很明显</p>
<p>Java中提供线程名字修改方式有三种：</p>
<ol>
<li>在创建出线程对象之后调用setName(“线程新的名字&quot;)</li>
<li>使用类实现Runnable接口并使用Thread类创建线程对象，调用两个参数版本构造方法进行名字设置</li>
</ol>
<p>    Thread(Runnable接口实现类的对象，“线程名字”);</p>
<ol start="3">
<li>使用类继承与Thread类，子类中提供一个仿照父类生成构造方法，这个方法参数是String name，子类只	需要实现这个构造方法即可，在创建线程对象时只需要调用有参构造方法就可以指定线程名字</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetNameDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//方式一</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AThread</span>();</span><br><span class="line">        athread.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        System.out.println(athread.getName());</span><br><span class="line">        <span class="comment">//方式二</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">bthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">BThread</span>(),<span class="string">&quot;线程B&quot;</span>);</span><br><span class="line">        System.out.println(bthread.getName());</span><br><span class="line">        <span class="comment">//方式三</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">cthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CThread</span>(<span class="string">&quot;线程C&quot;</span>);    <span class="comment">//多态</span></span><br><span class="line">        System.out.println(cthread.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//实现Runnable接口不是线程类，所以不能在实现Runnable接口类中调用Thread类中方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;线程的名字：&quot;+getName());</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 如何在实现Runnable接口的类中获取当前线程</span></span><br><span class="line"><span class="comment">        * Thread类中提供一个静态方法currentThread() 可以获取当前线程对象</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;通过静态访获取到线程对象：&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//子类只要仿照生成一个带有String类型参数方法即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CThread</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-4-线程休眠sleep-使用几率极高-center"><center>4、线程休眠sleep【使用几率极高】</center></h2>
<p>sleep这个方法是静态方法，它可以让线程进入到【阻塞状态】即让线程进行到休眠时间，<strong>进入休眠之后线程会让出CPU时间片，给其他的线程进行争抢，当休眠时间到了之后恢复之后线程会继续和其线程进行CPU时间片的争抢</strong></p>
<p>sleep方法的参数是毫秒值 —》 1000毫秒 等于 1秒</p>
<p>线程如果触发sleep方法会有两种方式可以醒来：</p>
<ol>
<li>自然醒来【睡眠时间到了，自动醒来】</li>
<li>中断醒来【会通过Thread类中添加中断标记，强行让sleep醒来】</li>
</ol>
<p>所以sleep方法在调用时候会有一个编译时异常【InterruptedException(中断异常)】</p>
<p><strong>特别注意：如果sleep方法被调用在【同步锁、对象锁、同步监听器、同步代码块】中，sleep方法休眠之后是不会让出当前系统时间片【虽然会睡眠时间片也会释放，但是外界线程是无法获取】</strong></p>
<p>需求：通过sleep方法来实现以下交替执行效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">100</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">5</span> == <span class="number">0</span>)    <span class="comment">//只要i值可以对5整除</span></span><br><span class="line">            &#123; </span><br><span class="line">                System.out.println(<span class="string">&quot;当前线程:&quot;</span>+getName()+<span class="string">&quot;~~~~~~~~~&quot;</span>+i);</span><br><span class="line">                <span class="comment">//在run方法中调用sleep方法是不可以throws异常，只能try-catch抓取</span></span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SleepDemo</span>();</span><br><span class="line">        athread.setName(<span class="string">&quot;子线程&quot;</span>);</span><br><span class="line">        athread.start();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Java程序会默认提供两个线程一个是GC 和 一个是main方法【主线程作为线程操作】</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//在主线程中提供和SleepDemo类中一样的操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i&lt;=<span class="number">100</span> ;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">5</span> ==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前线程：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;~~~~~~~~~&quot;</span>+i);</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sleep方法确实可以让线程进入到休眠状态，并且释放出CPU时间片，但是时间无法正确把控就会造成无法使用sleep方法进行代码的交替执行</p>
<h2 id="center-5-线程礼让yield-了解-center"><center>5、线程礼让yield（了解）</center></h2>
<p>礼让线程的作用就是在调用yield方法的线程中，让出CPU时间片【相当于通知CPU不急着执行】，让出之后CPU会不会回收CPU时间片取决于CPU，礼让原则是：线程优先级越高礼让效果就是会明显一些</p>
<p>yield和sleep方法是有一定区别的，sleep是立即让出CPU时间片，在睡眠时间内是不会争抢CPU时间片，yield方法执行之后，礼让线程会进入“准备就绪”，礼让线程可能会再次持有CPU时间片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YieldDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程的名字：&quot;</span>+getName()+<span class="string">&quot;~~~~~~~~&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.<span class="keyword">yield</span>(); <span class="comment">//让线程礼让</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建两个线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YieldDemo</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">bthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YieldDemo</span>();</span><br><span class="line">        athread.setName(<span class="string">&quot;a线程&quot;</span>);</span><br><span class="line">        bthread.setName(<span class="string">&quot;b线程&quot;</span>);</span><br><span class="line">        athread.start();</span><br><span class="line">        bthread.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        bthread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-6-线程合并join-center"><center>6、线程合并join</center></h2>
<p>合并线程是一个效果非常明显操作，合并线程是一个线程正处于运行阶段，此时这个线程达到某个条件时，可以让其他线程合并到这个执行线程中，只要使用join合并，合并线程<strong>必然</strong>会得到CPU时间片，被合并的线程需要等待合并线程执行完毕之后才会继续运行</p>
<p>需求：妹子在看葫芦娃【50级】，当看到【10级】汉子要看喜洋洋</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Meizi</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Meizi</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;妹子正在看精钢葫芦娃大战蛇精：&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//启动另外一个线程进行合并操作</span></span><br><span class="line">                <span class="type">Hanzi</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hanzi</span>();</span><br><span class="line">                <span class="comment">//合并之前必要前提：要合并线程必须进入准备就绪状态，即调用start方法</span></span><br><span class="line">                thread.start();</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    thread.join();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hanzi</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;汉子正在看喜羊羊与灰太狼：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程合并必然是让出CPU时间片，CPU时间片会join的线程，线程必须是启动状态【调用start】</p>
<h2 id="center-7-线程中断-标记-center"><center>7、线程中断(标记)</center></h2>
<p>在Thread这个类中提供让线程停止方法 stop方法，但是这个方法被Java进行过时处理，所以就不建议在线程中进行使用了，所以Java就提供一个替代 stop方法的方法 —》interrupt方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptThreadDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">20</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;线程中执行i值是:&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//停止线程 --&gt;过时的stop方法</span></span><br><span class="line">                <span class="comment">// stop();</span></span><br><span class="line">                <span class="comment">//中断线程</span></span><br><span class="line">                interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InterruptThreadDemo</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这个线程中断标记方法向线程中添加【中断标记】，只有被含有中断异常方法检测到这个标记就会终止方法的执行效果【sleep明显 和join不明显】，<strong>直接在线程调用这个方法是无用的</strong>，只是添加标记不会停止线程，配合API中所提供的一个方法来使用【<strong>interrupted</strong>】，作用检查线程中是否存在中断标记，如果存在着返回true，不存在则返回false</p>
<p><strong>正确使用方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptThreadDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">20</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;线程中执行i值是:&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//使用替代stop方法中断线程时，当遇到某个条件要终止线程时，检查中断标记</span></span><br><span class="line">                <span class="keyword">if</span>(Thread.interrupted())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//停止线程</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">InterruptThreadDemo</span> <span class="variable">interruptThreadDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterruptThreadDemo</span>();</span><br><span class="line">        interruptThreadDemo.start();</span><br><span class="line">        <span class="comment">//向线程中添加中断标记</span></span><br><span class="line">        interruptThreadDemo.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>强行终止睡眠</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.ThreadMethod;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptThreadDemo2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入线程&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;没有被中断正常睡眠苏醒&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;中断睡眠苏醒&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">InterruptThreadDemo2</span> <span class="variable">interruptThreadDemo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterruptThreadDemo2</span>();</span><br><span class="line">        interruptThreadDemo2.start();</span><br><span class="line">        <span class="comment">//为了效果让主线程休眠2秒之后在触发中断标记</span></span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        interruptThreadDemo2.interrupt();  <span class="comment">//如果检查到中断标记就会强行终止睡眠</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点六：火车售票问题</center></h1>
<p>需求：火车站买票，一共有且仅有【100】张票，4个窗口同时贩卖临界资源就是这个票，多个线程访问保证票有且仅有100张，开4个线程同时买100张票</p>
<p>    其实这个卖票案例就是多线程下同时操作一个资源(临界资源),如何保证线程操作资源安全不出现以下情况</p>
<p>    买票不会出现重票 --&gt; 线程1 卖出第99张票 线程2 卖出99张票</p>
<p>    错误票 —&gt; 线程1 卖出第75张票. 线程2 卖出76张票 —&gt; 这个是对</p>
<p>    但是 线程2 卖出49张票</p>
<p>    负数票 —&gt; 某个线程买完最后一张票的时候 剩余线程就不能在卖票0 -1 -2…票</p>
<p>    1秒卖一张 —&gt; 有且仅有100张 —&gt;不要卖出400张票数</p>
<p><strong>问题1：如何将票固定在100张，而不是每个线程都卖出100张票</strong></p>
<p>    如何做到所有的线程都共享这一个资源？</p>
<ol>
<li>将票作为成员变量，作为成员变量之后，需要保证这个提供票的类在外界创建对象必须是唯一的，如果不唯一的，就会出现你创建票的对象每个对象都会唯一，一个成员变量，4个对象就是4个成员变量，此时相当于400张票【单例设计模式】</li>
</ol>
<p>PS：单例设计模式的原则：保证外界无论如何获取对象都是唯一的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1基础版本</span></span><br><span class="line"><span class="keyword">package</span> com.qfedu.Thread.SellTicket1;</span><br><span class="line"><span class="comment">//v1版本</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    不要让类继承与Thread，继承Thread必然要提供四个线程对象</span></span><br><span class="line"><span class="comment">    这样就会出现无法控制票100张</span></span><br><span class="line"><span class="comment">    建议实现Runnable，以Runnable实现类方式创建线程处理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供成成员变量存储票的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑</span></span><br><span class="line">            <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)    <span class="comment">//证明还票可以出售</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//买票</span></span><br><span class="line">                System.out.println(<span class="string">&quot;当前售票员[&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;]第&quot;</span>+<span class="string">&quot;[&quot;</span>+(tickets--)+<span class="string">&quot;]票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果提供的是成员变量【保证存储成员变量的这个类所得到对象是必须唯一】</span></span><br><span class="line">        <span class="comment">//出现400张票问题[在构建线程对象时，提供四个Runnable接口实现类对象创建]</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            Thread thread1 = new Thread(new SellTicket1(),&quot;刘德华&quot;);</span></span><br><span class="line"><span class="comment">            Thread thread2 = new Thread(new SellTicket1(),&quot;张学友&quot;);</span></span><br><span class="line"><span class="comment">            Thread thread3 = new Thread(new SellTicket1(),&quot;郭富城&quot;);</span></span><br><span class="line"><span class="comment">            Thread thread4 = new Thread(new SellTicket1(),&quot;吴奇隆&quot;);</span></span><br><span class="line"><span class="comment">            thread1.start();</span></span><br><span class="line"><span class="comment">            thread2.start();</span></span><br><span class="line"><span class="comment">            thread3.start();</span></span><br><span class="line"><span class="comment">            thread4.start();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//在外界只创建一个Runnable接口实现类对象，保证对象是唯一的</span></span><br><span class="line">        <span class="type">SellTicket1</span> <span class="variable">sellTicket1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket1</span>(); <span class="comment">//只会维护一份的票对象【100】张</span></span><br><span class="line">        <span class="comment">//利用这个对象初始化创建4个线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket1,<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket1,<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket1,<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket1,<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-getinstance-center"><center>GetInstance</center></h2>
<p>在主函数开始时调用，返回一个实例化对象，此对象是static的，在内存中保留着它的引用，即内存中有一块区域专门用来存放静态方法和变量，可以直接使用，调用多次返回同一个对象</p>
<p>GetInstance与new区别</p>
<p>    如Object object = new Object()，这时候，就必须要知道有第二个Object的存在，而第二个Object也常常是在当前的应用程序域中的，可以被直接调用的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.Demo03.test;</span><br><span class="line"><span class="comment">//提供了成员变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SellTicket2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供成员变量，变量是存储票信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    单设计模式的原则--》保证在外界获取对象时都是同一个对象【地址也是相同的】</span></span><br><span class="line"><span class="comment">    1.私有化构造方法</span></span><br><span class="line"><span class="comment">    2.提供一个私有化静态变量并对静态变量进行赋值【类型是本类类型提供对象创建】</span></span><br><span class="line"><span class="comment">    3.提供一个静态共有方法可以获取本类对象的唯一途径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SellTicket2</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">//使用本类类型创建对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SellTicket2</span> <span class="variable">sellTicket2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket2</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SellTicket2 <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> sellTicket2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑</span></span><br><span class="line">            <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)    <span class="comment">//证明还票可以出售</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//买票</span></span><br><span class="line">                System.out.println(<span class="string">&quot;当前售票员[&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;]第&quot;</span>+<span class="string">&quot;[&quot;</span>+(tickets--)+<span class="string">&quot;]票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提供了静态变量，这个类的创建对象方式就无所谓</span></span><br><span class="line">        <span class="type">SellTicket2</span> <span class="variable">sellTicket2</span> <span class="operator">=</span> SellTicket2.getInstance();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>定义一个变量保证所有对象共享，无论外界如何创建线程对象【实现Runnable还是继承Thread类】，这里都可以保证所有兑现共享这个变量，可以提供一个static修饰变量即静态变量</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.SellTicket1;</span><br><span class="line"><span class="comment">//v1.1版本 ---&gt; 提供了静态变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供静态成员变量存储票的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑</span></span><br><span class="line">            <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)    <span class="comment">//证明还票可以出售</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//买票</span></span><br><span class="line">                System.out.println(<span class="string">&quot;当前售票员[&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;]第&quot;</span>+<span class="string">&quot;[&quot;</span>+(tickets--)+<span class="string">&quot;]票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提供了静态变量，这个类的创建对象方式就无所谓</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket2</span>(),<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket2</span>(),<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket2</span>(),<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket2</span>(),<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题2：在买票的时候会出现、重票、错票、排序顺序的混乱的问题</p>
<p>    这个问题产生就是多线程并发争抢&quot;临界资源&quot;出现里临界资源不安全问题</p>
<h2 id="center-1-如何解决多线程并发访问临界资源-保证资源安全问题-center"><center>1、如何解决多线程并发访问临界资源，保证资源安全问题</center></h2>
<p>此时Java为了保证多线程并发访问临界资源线程安全问题，提供了一个处理机制，可以在处理临界资源代码中添加（同步锁/对象锁/同步代码块/同步监听器），这里四个名称都是指的是同一个操作，可以添加“锁机制”，保证在同一个时刻的只有一个线程操作临界资源，保证临界资源安全</p>
<h2 id="center-2-synchronized关键字-center"><center>2、synchronized关键字</center></h2>
<p>synchronized翻译意思：同步</p>
<p>使用synchronized关键字进行同步操作，使用synchronized组成同步操作叫做【同步锁/对象锁/同步代码块】</p>
<p>语法 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(资源锁对象)</span><br><span class="line">&#123;</span><br><span class="line">    提供操作临界资源的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行原理： 利用了同一时间内【只能有一个线程对象持有当前资源锁对象】，只要线程不释放这个所资源对象，外界线程是无法执行线程逻辑资源代码，在同步代码块中执行线程进行休眠是不会释放CPU时间片到外界给其他线程，因为sleep方法是不会释放锁资源</p>
<p>需要注意还需要保证【<strong>资源锁对象必须是唯一的</strong>】，不唯一锁对象数无法进行同步操作</p>
<p>如果保证资源锁对象是唯一的？</p>
<p>个人建议：十分不推荐使用 this 作为锁资源对象，this可能锁不了，this代表的是当前对象，那么就意味着这个提供临界支援类必须是创建唯一的对象才可以，这样才可以保证this是唯一的</p>
<p>替代方案一：</p>
<p>    在静态资源处理线程类中提供一个全局静态常量“锁资源”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">synchronized</span>(obj)</span><br><span class="line">&#123;</span><br><span class="line">    提供操作临界资源的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>替代方案二【推荐】</p>
<p>    天生对象就是唯一的，Java中这个对象无论你如何操作，就可以保证他是唯一的地址都是同一个，String字符串类，直接使用字符串对象即可----&gt;【使用 “” (双引号)创建】</p>
<p>提供字符串空串处理 —&gt; 即 提供字符串空串对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    提供操作临界资源的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用同步代码块修改买票的案例的</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.SynchronizedSellTicket1;</span><br><span class="line"><span class="comment">//v2版本 ---&gt; 提供了静态变量 和 同步代码块执行买票操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供静态成员变量存储票的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) <span class="comment">//同步代码块</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) <span class="comment">//证明还票可以出售</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">//买票</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;当前售票员[&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;]第&quot;</span></span><br><span class="line">                                                    + <span class="string">&quot;[&quot;</span> + (tickets--) + <span class="string">&quot;]票&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提供了静态变量，这个类的创建对象方式就无所谓</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket</span>(),<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket</span>(),<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket</span>(),<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket</span>(),<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-3-同步方法-对象同步方法-成员同步方法-center"><center>3、同步方法/对象同步方法/成员同步方法</center></h2>
<p>使用synchronized关键字进行成员方法的修饰，这个方法就会成为<strong>同步方法</strong>将操作资源代码写入到这个方法中就可以进行同步操作了</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">访问权限修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    方法体；</span><br><span class="line">    <span class="keyword">return</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>特别注意：使用是同步方法，所以这个方法使用锁资源对象是【this】，提供同步方法的这个类所创建对象必须是唯一的才可以锁住资源</strong></p>
<p>PS：到目前位置 方法定义中其他修饰符就已经全部介绍完毕</p>
<p>    类中方法可以使用：【static、final、abstract、synchronized】</p>
<p>    接口中方法可以使用：【abstract、static、default】</p>
<p><strong>修饰同步方法是该买票案例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.SynchronizedSellTicket1;</span><br><span class="line"><span class="comment">//v2.1版本 ---&gt; 提供了静态变量 和 同步方法进行买票</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供静态成员变量存储票的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑 ---》调用同步方法即可</span></span><br><span class="line">            seller();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同步方法 --&gt; 这个锁资源对象是this</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">seller</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供就是线程处理临界资源操作</span></span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) <span class="comment">//证明还票可以出售</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//买票</span></span><br><span class="line">            System.out.println(<span class="string">&quot;当前售票员[&quot;</span> +</span><br><span class="line">            Thread.currentThread().getName() + <span class="string">&quot;]第&quot;</span></span><br><span class="line">            + <span class="string">&quot;[&quot;</span> + (tickets--) + <span class="string">&quot;]票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提供了静态变量，这个类的创建对象方式就无所谓</span></span><br><span class="line">        <span class="comment">//同步方法提供类如果是线程类，需要保证线程类对象是唯一的</span></span><br><span class="line">        <span class="type">SellTicket2</span> <span class="variable">sellTicket2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket2</span>();   <span class="comment">//这是保证线程类对象唯一</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-4-类锁-类同步代码块-类同步方法-静态同步方法-center"><center>4、类锁/类同步代码块/类同步方法/静态同步方法</center></h2>
<p>如果使用是同步代码块的语法，就是将资源锁对象，从当前对象替换成类对象，通过类的方式获取对象【通反射获取】，静态同步方法就是使用static和synchronized同时修饰方法</p>
<p><strong>类锁/类同步代码块</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(类名.class)    <span class="comment">// 类锁对象</span></span><br><span class="line">&#123;</span><br><span class="line">    操作临界资源代码即可</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>类同步方法/静态同步方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">访问权限修饰符 <span class="keyword">static</span> <span class="keyword">synchronized</span> 返回值类型 方法名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    方法代码</span><br><span class="line">    <span class="keyword">return</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v2.2版本 ---&gt; 提供了静态变量 和 静态同步操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket3</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供静态成员变量存储票的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑 ---》调用同步方法即可</span></span><br><span class="line">            <span class="comment">//seller();</span></span><br><span class="line">            <span class="keyword">synchronized</span> (String.class)    <span class="comment">// 类锁</span></span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) <span class="comment">//证明还票可以出售</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">//买票</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;当前售票员[&quot;</span> +</span><br><span class="line">                    Thread.currentThread().getName() + <span class="string">&quot;]第&quot;</span></span><br><span class="line">                    + <span class="string">&quot;[&quot;</span> + (tickets--) + <span class="string">&quot;]票&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态同步方法 --&gt; 这个锁资源就是当前类的对象【是唯一的】，通过类获取即 类.class</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">seller</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供就是线程处理临界资源操操作</span></span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) <span class="comment">//证明还票可以出售</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//休眠1秒再买票</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//卖票</span></span><br><span class="line">            System.out.println(<span class="string">&quot;当前售票员[&quot;</span> +Thread.currentThread().getName() + <span class="string">&quot;]第&quot;</span> </span><br><span class="line">                                                        + <span class="string">&quot;[&quot;</span> + (tickets--) + <span class="string">&quot;]票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提供了静态变量，这个类的创建对象方式就无所谓</span></span><br><span class="line">        <span class="comment">//同步方法提供类如果是线程类，需要保证线程类对象是唯一的</span></span><br><span class="line">        <span class="type">SellTicket3</span> <span class="variable">sellTicket2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket3</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized总结：</p>
<ol>
<li>在开发中常用肯定是对象锁【同步代码块】但是这个代码块的范围不要太大，不然的话会影响执行效率</li>
</ol>
<p>    PS: 在什么位置对资源操作就在什么位置添加 同步代码块</p>
<ol start="2">
<li>使用synchronized关键字之后线程就会变成安全，间接就将并行线程修改为串行线程，使用锁机制将线程变	成 【一个一个站排执行效果】</li>
</ol>
<h1><center>知识点七：线程通信</center></h1>
<p>到现目前位置线程与线程之间依旧是彼此独立，就算使用同步代码块，也是让线程执行有一定顺序，但是还是没有进行通信操作，如果需要遇到某个线程执行完毕之后需要通知另外一个线程继续执行，此时就需要使用到线程通信，可以在一个进程中开发多个线程，每个线程之间可以进行通信操作，从而协调性的完成某个进程中需要执行逻辑</p>
<p><strong>线程通信有一个标准的通信模型【生产者与消费者模式】</strong></p>
<img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012227153.WebP" alt="线程通信" style="zoom:50%;">
<h2 id="center-1-完成生产者和消费者通信模型v1版本-center"><center>1、完成生产者和消费者通信模型v1版本</center></h2>
<p>Bank(银行类) —》 提供数据维护与使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基础的第一个版本 ---》 提供临界资源并提供操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;    <span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一单例设计模式的实现：</span></span><br><span class="line"><span class="comment">        1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        money = m+money;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span>+m+<span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        money = money-m;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取了&quot;</span>+m+<span class="string">&quot;余额是：&quot;</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生产者【是一个线程提供数据存储操作】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供银行属性</span></span><br><span class="line">    <span class="keyword">private</span> Bank bank;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Bank bank)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.bank = bank;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供线程存储钱的操作 存储十次 每次1000元</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            bank.pushMoney(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者【是一个线程提供数据获取操作】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供银行属性</span></span><br><span class="line">    <span class="keyword">private</span> Bank bank;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Bank bank)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.bank = bank;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供线程存获取的操作 获取十次 每次1000元</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            bank.popMoney(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提供一个测试类Test进行测试操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.waitAndnotfiny;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过单例获取银行对象</span></span><br><span class="line">        <span class="type">Bank</span> <span class="variable">bank1</span> <span class="operator">=</span> Bank.getInstance();</span><br><span class="line">        <span class="comment">//2.创建线程对象并启动操作</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(bank1),<span class="string">&quot;花花&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(bank1),<span class="string">&quot;菲菲&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题1：现在执行速度太快了，看不到交替执行效果，让线程休眠1秒操作</p>
<p>问题2：虽然让线程休眠之后，出现了一个执行错乱的问题，因为多线程并发访问临界资源money，出现线程挣抢的问题，所以出现临界资源部不安全问题，添加同步代码块</p>
<p>Bank银行类需要修改为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.waitAndnotfiny;</span><br><span class="line"><span class="comment">//基础的第一个版本 ---》 提供临界资源并提供操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;<span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一</span></span><br><span class="line"><span class="comment">        单例设计模式的实现：</span></span><br><span class="line"><span class="comment">        1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = m + money;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = money - m;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-2-完成生产者和消费者通信模型v2版本-center"><center>2、完成生产者和消费者通信模型v2版本</center></h2>
<p>使用了同步代码块+sleep方法，虽然让程序执行有序了也保证线程中操作临界资源过程也安全了，但是还是无法保证线程可以做到交替执行的效果【<strong>即生产者生产完数据之后通知消费者可以进行消费，消费者消费完数据之后通知生产者可以生产</strong>】，所以如何完成这个通信操作呢？</p>
<p>此时就需要使用Java中Object类中提供三个方法了</p>
<table>
<thead>
<tr>
<th style="text-align:center">线程通信方法</th>
<th style="text-align:center">方法说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">wait()</td>
<td style="text-align:center">执行该方法的线程对象会释放【同步锁资源】，JVM会把当前线程放到等待池中，等待其他线程唤醒操作</td>
</tr>
<tr>
<td style="text-align:center">notify()</td>
<td style="text-align:center">执行该方法的线程对象会在等待池【随机唤醒】一个等待的线程，把线程转移到锁池中等待，再次获取资源</td>
</tr>
<tr>
<td style="text-align:center">notifyAll()</td>
<td style="text-align:center">执行该方法的线程对象会在等地池中【唤醒所有的线程】，把线程转移到锁池中等待，再次获取资源</td>
</tr>
</tbody>
</table>
<p>    就可以利用这三个方法进行线程通信操作了，<strong>特别注意调用通信方法必须是锁资源对象，否则会出现异常提示信息【在哪里调用等待方法就在位置被唤醒】</strong></p>
<p>线程通信执行流程：</p>
<p>    假设<strong>A线程</strong>和<strong>B线程</strong>共同操作一个<strong>X锁对象</strong>，A、B线程可以通过X锁对象调用wait和notify方法进行如下线程通信操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当A线程执行到X锁对象时，A线程持有X锁对象，B线程是没有执行机会的，B线程在X对象的等待锁池中</span><br><span class="line">A线程在同步代码块种执行到X.wait方法时，A线程会释放X对象所资源，A线程会进入到X对象的等待锁池中</span><br><span class="line">B线程就会在等待锁池中得到A线程释放的X资源锁对象，B线程就开始执行操作</span><br><span class="line">B线程在同步代码块中执行到X.notify方法时，JVM把A线程从X对象等待池中，移动到等待X对象锁资源中得到锁资源</span><br><span class="line">B线程执行完毕之后释放锁资源，A线程就有机会获取到锁，继续执行同步方法</span><br></pre></td></tr></table></figure>
<p>修改Bank类提供线程通信操作者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.waitAndnotfiny.V2;</span><br><span class="line"><span class="comment">//通信的版本 ---》 提供临界资源并提供操作[添加线程通信和同步代码块+sleep方法]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;    <span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一</span></span><br><span class="line"><span class="comment">        单例设计模式的实现：</span></span><br><span class="line"><span class="comment">            1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">            2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">            3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在外界创建生产者与消费者线程对象中都是可以获取到CPU资源</span></span><br><span class="line"><span class="comment">        但是问题在于，如果消费者先获取到资源，但是没有数据不能消费</span></span><br><span class="line"><span class="comment">        所以就提供一个变量来存储状态的，通过对这个状态的判断决定执行哪个线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//添加线程通信操作</span></span><br><span class="line">                <span class="keyword">if</span>(isEmpty)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果条件为true值，就证明现在有数据，无需生产</span></span><br><span class="line">                    <span class="comment">//生产这个就进入到等待状态</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//因为if没有执行就证明，没有数据可以生产</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = m + money;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//生产数据完毕之后需要修改状态信息</span></span><br><span class="line">                isEmpty = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//执行唤醒操作</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notify();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 增加线程通信操作</span></span><br><span class="line">                <span class="comment">//isEmpty状态值 false代表没有数据 true代表有属性</span></span><br><span class="line">                <span class="keyword">if</span>(!isEmpty)    <span class="comment">//没有数据的时候不能执行消费，等待生产</span></span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        没有数据isEmpty值是false，取非操作 !false --》 true if就执行等待</span></span><br><span class="line"><span class="comment">                        有数据isEmpty值是true ，取非操作 !true --》false if就不执行等待，进行消费</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//if分支语句不执行就证明有数据，进行消费操作</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = money - m;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//修改状态数据</span></span><br><span class="line">                isEmpty = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//进行唤醒操作</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notify();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-3-分析执行流程-center"><center>3、分析执行流程</center></h2>
<ol>
<li>现有的两个线程生产者【花花】和消费者【菲菲】默认初始isEmpty状态都是false</li>
<li>消费者【菲菲】先获取到CPU时间片，持有所资源，判断if分支条件为!false,消费者【菲菲】就会释放锁资源并且进入到等待池中</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待池</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    生产者【花花】</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>等待池中生产者【花花】就会或得到执行CPU时间片，并且获取到锁资源，判断if分支条件false，证明没有数据，生产数据并且唤醒等待池中【菲菲】修改isEmpty值true，生产者线程就执行完毕了</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待池</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    消费者【菲菲】</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>此时生产者【花花】和消费者【菲菲】就会再次同时争抢CPU时间片和锁资源对象，假如生产者【花花】再次获取哦到CPU时间片和锁资源对象，执行线程逻辑，判断if分支条件为true，此时花花就会释放资源进入到等待池中</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待池</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    生产者【花花】</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>消费者【菲菲】必然获取到CPU时间片，执行操作逻辑判断条件!true 得到是false，就执行消费，并且修改状态为false，唤醒等待池中生产者，这样就完成交替执行效果</li>
</ol>
<p><strong>PS：以上这些操作就是典型的一对一生产者与消费者模型</strong></p>
<h1><center>知识点八：多对多通信模型</center></h1>
<p>提供线程对象创建操作， 这里从原有一对一的模式，变成多对多的模式，原来的一个生产者对应一个消费者，修改为了多个生产者对应多个消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过单例获取银行对象</span></span><br><span class="line">        <span class="type">Bank</span> <span class="variable">bank1</span> <span class="operator">=</span> Bank.getInstance();</span><br><span class="line">        <span class="comment">//2.创建线程对象并启动操作</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(bank1),<span class="string">&quot;花花1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(bank1),<span class="string">&quot;菲菲2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(bank1),<span class="string">&quot;花花3&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(bank1),<span class="string">&quot;菲菲4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当将线程对象增多之后，执行多线程同时操作就出现两个问题“<strong>负数问题和死等待问题</strong>”</p>
<h2 id="center-1-负数问题-center"><center>1、负数问题</center></h2>
<p>现有线程【花花1（存)、菲菲2（取）、花花3（存）、菲菲4（取）】，模拟一个执行流程</p>
<ol>
<li>菲菲2先抢到线程，不能取，所以进入到等待队列中，释放CPU时间片和释放锁资源</li>
<li>菲菲4抢到线程资源，不能取，所以进入到等待列中，释放CPU时间片和释放锁资源</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列 菲菲2、菲菲4</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>花花1抢到线程，存储了数据，修改标记为true值，并唤醒等待队列中的线程的线程对象，现在使用唤醒机制notify方法【随机唤醒一个等待队列汇总线程对象】，假设唤醒了菲菲4</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 菲菲2</span></span><br><span class="line"><span class="comment">//外部争抢CPU操作的时间片 花花1、花花3、菲菲4</span></span><br><span class="line"><span class="comment">//临界资源中存储数据是 ---》 1000</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>菲菲4抢到了线程，在哪里等待就在哪里被唤醒，而且if分支语句特点，只会执行一次判断即if分支条件判断完成之后【不添加循环前提】，只会执行一次判断，菲菲4正好是在if分支语句中进行等待操作，醒来之后机会继续向后执行【它是不会在判断if分支语句】，菲菲4进行正常消费，修改标记为false，需要执行notify，唤醒等待队列菲菲2【菲菲2这个线程是通过wait进入到等待状态，它已经执行了if判断】</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 空</span></span><br><span class="line"><span class="comment">// 外部增强CPU操作者时间片 花花1、菲菲2【从等待状态恢复而来】、花花3、菲菲4</span></span><br><span class="line"><span class="comment">// 临界资源中存储的数据是 ----》 0 【因为菲菲4消费了】</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>菲菲2抢到了执行权，会在if分支语句继续执行操作，此时虽然标记已经修改为false，正常而言不应该消费的，但是if分支语句已经被执行过，所以不会进行判断继续执行，进行消费，修改标记，执行唤醒</li>
</ol>
<p>但是现在的数据是 0 在执行消费出现数据就是 -1000</p>
<p><strong>为了保证线程通信可以正常执行，建议在开发的时候，不要书写if作为状态判断操作，建议使用while循环语句替代if分支，while循环语句只有条件为false，才不执行，否者就继续执行，这样就可以让等待位置线程在次被唤醒之后可以再次判断状态操作，以防出现错误数据</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.waitAndnotfiny.V3;</span><br><span class="line"><span class="comment">//通信的版本【多对多】 ---》 提供临界资源并提供操作[添加线程通信和同步代码块+sleep方法]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;<span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一</span></span><br><span class="line"><span class="comment">        单例设计模式的实现：</span></span><br><span class="line"><span class="comment">        1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在外界创建生产者与消费者线程对象中都是可以获取到CPU资源</span></span><br><span class="line"><span class="comment">        但是问题在于，如果消费者先获取到资源，但是没有数据不能消费</span></span><br><span class="line"><span class="comment">        所以就提供一个变量来存储状态的，通过对这个状态的判断决定执行哪个线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//添加线程通信操作</span></span><br><span class="line">                <span class="comment">//只需要将if修改为while即可</span></span><br><span class="line">                <span class="keyword">while</span>(isEmpty)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果条件为true值，就证明现在有数据，无需生产</span></span><br><span class="line">                    <span class="comment">//生产这个就进入到等待状态</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//因为if没有执行就证明，没有数据可以生产</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = m + money;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//生产数据完毕之后需要修改状态信息</span></span><br><span class="line">                isEmpty = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//执行唤醒操作</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notify();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 增加线程通信操作</span></span><br><span class="line">                <span class="comment">//isEmpty状态值 false代表没有数据 true代表有属性</span></span><br><span class="line">                <span class="comment">//只需要将if修改为while即可</span></span><br><span class="line">                <span class="keyword">while</span>(!isEmpty)    <span class="comment">//没有数据的时候不能执行消费，等待生产</span></span><br><span class="line">                &#123; </span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        没有数据isEmpty值是false，取非操作 !false --》 true if就执行等待</span></span><br><span class="line"><span class="comment">                        有数据isEmpty值是true ，取非操作 !true --》false if就不执行等待，进行消费</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//if分支语句不执行就证明有数据，进行消费操作</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = money - m;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//修改状态数据</span></span><br><span class="line">                isEmpty = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//进行唤醒操作</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notify();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-2-死等待问题-center"><center>2、死等待问题</center></h2>
<p>所有线程都进入到等待池中无人唤醒</p>
<p><strong>PS：这个效果是需要特殊情况下才会出现【它属于一个极端情况】</strong></p>
<p><strong>这个原因的产生就是使用notfiy随机唤醒机制</strong></p>
<p>现有线程【花花1（存)、菲菲2（取）、花花3（存）、菲菲4（取）】模拟一个执行流程</p>
<ol>
<li>菲菲2先抢到线程，不能取，所以进入到等待池中，释放锁和CPU时间片</li>
<li>菲菲4抢到线程，不能取，所以进入到等待池中，释放锁和CPU时间片</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 菲菲2、菲菲4</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>花花1抢到线程，存储数据，修改标记为true并进行唤醒操作【随机唤醒】</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 菲菲2</span></span><br><span class="line"><span class="comment">//争抢CPU资源 花花1、花花3、菲菲4</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>花花1在次获取线程，不能存储，所以要进入到等待队列中，释放锁和CPU时间片</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 菲菲2、花花1 //争抢CPU资源 花花3、菲菲4</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>花花3抢到线程，不能存储，所以要进入到等待队列中，释放锁和CPU时间片</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 菲菲2、花花1、花花3 //争抢CPU资源 菲菲4</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li>菲菲4抢到线程，取钱消费，修改标记为false，并进入唤醒操作【随机唤醒】 --》 菲菲2唤醒</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列汇总 花花1、花花3 //争抢CPU资源 菲菲4、菲菲2 ，现在状态时false</span></span><br></pre></td></tr></table></figure>
<ol start="7">
<li>生产者都在等待队列中，外部都是消费这个，现在状态时false</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 花花1、花花3、菲菲4、菲菲2</span></span><br></pre></td></tr></table></figure>
<p>所有线程都进入到等待队列中，无人唤醒就出现死的等待问题</p>
<p>    之所以会出现死等待原因就因为使用了notify的操作，它是随机唤醒，等待池中两个消费，外界两个生产【生产完毕，状态修改，无法唤醒】，或等待池中两个生产，外界两个消费【消费完毕，状态修改，无法唤醒】，<strong>建议使用notifyAll 替换 notfiy</strong>，进行全部唤醒，然后再进行条件判断执行操作，决定好是否存储与消费</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通信的版本 ---》 提供临界资源并提供操作[添加线程通信和同步代码块+sleep方法]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;<span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一</span></span><br><span class="line"><span class="comment">        单例设计模式的实现：</span></span><br><span class="line"><span class="comment">        1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在外界创建生产者与消费者线程对象中都是可以获取到CPU资源</span></span><br><span class="line"><span class="comment">        但是问题在于，如果消费者先获取到资源，但是没有数据不能消费</span></span><br><span class="line"><span class="comment">        所以就提供一个变量来存储状态的，通过对这个状态的判断决定执行哪个线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//添加线程通信操作</span></span><br><span class="line">                <span class="keyword">while</span>(isEmpty)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果条件为true值，就证明现在有数据，无需生产</span></span><br><span class="line">                    <span class="comment">//生产这个就进入到等待状态</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//因为if没有执行就证明，没有数据可以生产</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = m + money;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//生产数据完毕之后需要修改状态信息</span></span><br><span class="line">                isEmpty = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//执行唤醒操作进行全部唤醒操作</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notifyAll();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 增加线程通信操作</span></span><br><span class="line">                <span class="comment">//isEmpty状态值 false代表没有数据 true代表有属性</span></span><br><span class="line">                <span class="keyword">while</span>(!isEmpty)    <span class="comment">//没有数据的时候不能执行消费，等待生产</span></span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    没有数据isEmpty值是false，取非操作 !false --》 true if就执行等待</span></span><br><span class="line"><span class="comment">                    有数据isEmpty值是true ，取非操作 !true --》false if就不执行等待，进行消费</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//if分支语句不执行就证明有数据，进行消费操作</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = money - m;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//修改状态数据</span></span><br><span class="line">                isEmpty = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//进行唤醒操作修改为全部唤醒</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notifyAll();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：如果在日后的开发中出现线程通信操作，建议判断状态标签的位置使用while关键字而不是if，进行唤醒操作建议使用notfiyAll而不是notify</strong></p>
<h2 id="center-3-扩展：lock接口-显示锁-center"><center>3、扩展：Lock接口【显示锁】</center></h2>
<p>Lock接口是Java5中新加入与Synchronized比较操作，它属于显示定义，结构更加灵活，提供了一个更加便捷的操作，相对比synchronized更加简洁易用</p>
<p>PS：这个锁资源Lock虽然语法更加简洁易用，但是它不能定义锁对象，Lock使用锁对象是【this】，<strong>使用Lock时就需要保证this的唯一性了</strong></p>
<p><strong>Lock锁如何操作？</strong></p>
<p>    Lock是一个接口所以需要使用到他实现类进行锁的操作</p>
<p><strong>ReentrantLock</strong>提供两常用操作</p>
<table>
<thead>
<tr>
<th style="text-align:center">Lock锁方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">lock()</td>
<td style="text-align:center">添加锁(对象上锁)</td>
</tr>
<tr>
<td style="text-align:center">unlock()</td>
<td style="text-align:center">释放锁(对象所释放)</td>
</tr>
</tbody>
</table>
<p>    以为Lock是一个显示锁对象，所有不能调用Object类中提供wait、notify、notifyAll方法进行线程通信，所以系统就提供了<strong>一个和Lock锁一起使用线程通信接口Condititon</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">通信方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">await()</td>
<td style="text-align:center">线程等待释放锁资源和CPU时间片</td>
</tr>
<tr>
<td style="text-align:center">signal()</td>
<td style="text-align:center">唤醒等待池中某一个线程对象【随机唤醒】</td>
</tr>
<tr>
<td style="text-align:center">signalAll()</td>
<td style="text-align:center">唤醒等待池中所有线程对象</td>
</tr>
</tbody>
</table>
<p>使用Lock锁替代Synchronized同步代码块进行数据操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="comment">//通信的版本【多对多】 ---》 提供临界资源并提供操作[添加线程Lock锁+sleep方法+线程通信]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankLock</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;<span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一</span></span><br><span class="line"><span class="comment">        单例设计模式的实现：</span></span><br><span class="line"><span class="comment">        1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BankLock</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">BankLock</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BankLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BankLock <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供锁资源对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//提供线程通信资源对象【它是接口不能new，使用lock对象调用newCondition创建】</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在外界创建生产者与消费者线程对象中都是可以获取到CPU资源</span></span><br><span class="line"><span class="comment">        但是问题在于，如果消费者先获取到资源，但是没有数据不能消费</span></span><br><span class="line"><span class="comment">        所以就提供一个变量来存储状态的，通过对这个状态的判断决定执行哪个线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//synchronized (&quot;&quot;) //替换成lock锁资源对象</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//添加线程通信操作</span></span><br><span class="line">                <span class="comment">//只需要将if修改为while即可</span></span><br><span class="line">                <span class="keyword">while</span>(isEmpty)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果条件为true值，就证明现在有数据，无需生产</span></span><br><span class="line">                    <span class="comment">//生产这个就进入到等待状态</span></span><br><span class="line">                    <span class="comment">// &quot;&quot;.wait();</span></span><br><span class="line">                    condition.await();    <span class="comment">//使用通信资源创建对象</span></span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//因为if没有执行就证明，没有数据可以生产</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = m + money;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//生产数据完毕之后需要修改状态信息</span></span><br><span class="line">                isEmpty = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//执行唤醒操作</span></span><br><span class="line">                <span class="comment">//&quot;&quot;.notifyAll();</span></span><br><span class="line">                condition.signalAll();    <span class="comment">//使用通信资源创建对象</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> </span><br><span class="line">            &#123;</span><br><span class="line">                lock.unlock(); <span class="comment">//锁资源释放</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//synchronized (&quot;&quot;) </span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 增加线程通信操作</span></span><br><span class="line">                    <span class="comment">//isEmpty状态值 false代表没有数据 true代表有属性</span></span><br><span class="line">                    <span class="comment">//只需要将if修改为while即可</span></span><br><span class="line">                    <span class="keyword">while</span>(!isEmpty)    <span class="comment">//没有数据的时候不能执行消费，等待生产</span></span><br><span class="line">                    &#123; </span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                            没有数据isEmpty值是false，取非操作 !false --》 true if就执行等待</span></span><br><span class="line"><span class="comment">                            有数据isEmpty值是true ，取非操作 !true --》false if就不执行等待，进行消费</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        <span class="comment">//&quot;&quot;.wait();</span></span><br><span class="line">                        condition.await();</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">//if分支语句不执行就证明有数据，进行消费操作</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    money = money - m;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                    <span class="comment">//修改状态数据</span></span><br><span class="line">                    isEmpty = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">//进行唤醒操作</span></span><br><span class="line">                    <span class="comment">// &quot;&quot;.notifyAll();</span></span><br><span class="line">                    condition.signalAll();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点九：线程声明周期</center></h1>
<img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012240972.WebP" alt="声明周期" style="zoom:50%;">
<p>线程声明周期分为两条线:</p>
<ol>
<li>基础线程声明周期： 新建 —》 准备就绪 —》 运行状态 —》 死亡状态</li>
<li>对线程添加了一些操作造成线程阻塞现象的产生【sleep、join、wait、synchronized等等】</li>
</ol>
<p>新建 —》 准备就绪 —》 运行状态 —》【 阻塞状态 —》 准备就绪 —》 运行状态】 —》 死亡状态</p>
<p>PS：在阻塞状态没有消失之前</p>
<p>准备就绪 —》 运行状态 —》阻塞状态 —》 准备就绪 —》 运行状态 … 【会一直重复执行】</p>
<p>1、新建状态(new):使用new创建一个线程对象,仅仅在堆中分配内存空间,在调用start方法之前.</p>
<p>    新建状态下,线程压根就没有启动,仅仅只是存在一个线程对象而已.</p>
<p>    Thread t = new Thread();//此时t就属于新建状态</p>
<p>    当新建状态下的线程对象调用了start方法,此时从新建状态进入可运行状态</p>
<p>    线程对象的start方法只能调用一次,否则报错:IllegalThreadStateException</p>
<p>2、可运行状态(runnable):分成两种状态，ready和running。分别表示就绪状态和运行状态</p>
<p>    就绪状态:线程对象调用start方法之后,等待JVM的调度(此时该线程并没有运行).</p>
<p>    运行状态:线程对象获得JVM调度,如果存在多个CPU,那么允许多个线程并行运行</p>
<p>3、阻塞状态(blocked):正在运行的线程因为某些原因放弃CPU,暂时停止运行,就会进入阻塞状态.</p>
<p>    此时JVM不会给线程分配CPU,直到线程重新进入就绪状态,才有机会转到运行状态.</p>
<p>    阻塞状态只能先进入就绪状态,不能直接进入运行状态</p>
<p>    阻塞状态的两种情况:</p>
<p>    （1）当A线程处于运行过程时,试图获取同步锁时,却被B线程获取.此时JVM把当前A线程存到对象的锁池中,A线程进入阻塞状态.</p>
<p>    （2）当线程处于运行过程时,发出了IO请求时,此时进入阻塞状态</p>
<p>4、等待状态(waiting)(等待状态只能被其他线程唤醒):此时使用的无参数的wait方法,</p>
<p>    （1）当线程处于运行过程时,调用了wait()方法,此时JVM把当前线程存在对象等待池中</p>
<p>5、计时等待状态(timed waiting)(使用了带参数的wait方法或者sleep方法)</p>
<p>    (1)当线程处于运行过程时,调用了wait(long time)方法,此时JVM把当前线程存在对象等待池中.</p>
<p>    (2)当前线程执行了sleep(long time)方法.</p>
<p>6、终止状态(terminated):通常称为死亡状态，表示线程终止.</p>
<p>    (1)正常执行完run方法而退出(正常死亡).</p>
<p>    (2)遇到异常而退出(出现异常之后,程序就会中断)(意外死亡)</p>
<p>线程一旦终止,就不能再重启启动,否则报错(IllegalThreadStateException).</p>
<p>在Thread类中过时的方法(因为存在线程安全问题,所以弃用了【真心好用，绝对不能用】)</p>
<p>    void suspend() :暂停当前线程</p>
<p>    void resume() :恢复当前线程</p>
<p>    void stop() :结束当前线程</p>
<h1><center>知识点十：拓展</center></h1>
<h2 id="center-1-线程池-重点-center"><center>1、线程池【重点】</center></h2>
<h3 id="1-线程池概念">（1）线程池概念</h3>
<p>如果有非常的多的任务需要多线程来完成，且每个线程执行时间不会太长，这样频繁的创建和销毁线程。</p>
<p>频繁创建和销毁线程会比较耗性能。有了线程池就不要创建更多的线程来完成任务，因为线程可以重用</p>
<p>线程池用维护者一个队列，队列中保存着处于等待（空闲）状态的线程。不用每次都创建新的线程</p>
<h3 id="2-线程池实现原理">（2）线程池实现原理</h3>
<img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012242641.WebP" alt="实现原理" style="zoom:50%;">
<h3 id="3-线程池中常见的类">（3）线程池中常见的类</h3>
<p>常用的线程池接口和类(所在包java.util.concurrent)</p>
<p>Executor：线程池的顶级接口。</p>
<p>ExecutorService：线程池接口，可过submit(Runnable task) 提交任务代码</p>
<p>Executors工厂类：通过此类可以获得一个线程池</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">newFixedThreadPool(int nThreads)</td>
<td style="text-align:center">获取固定数量的线程池。参数：指定线程池中线程的数量</td>
</tr>
<tr>
<td style="text-align:center">newCachedThreadPool()</td>
<td style="text-align:center">获得动态数量的线程池，如不够则创建新的，无上限</td>
</tr>
</tbody>
</table>
<p><strong>创建方法一：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建一个线程池对象   创建了一个固定数量3个的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);   <span class="comment">//返回ExecutorService对象</span></span><br><span class="line">        <span class="comment">//2.通过线程池对象调用sumit方法来提交线程任务</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable1</span>());   <span class="comment">//传入实现runnable接口的类</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable2</span>());</span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable3</span>());</span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable4</span>());</span><br><span class="line">        <span class="comment">//3.结束线程池</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable3</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable4</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">30</span>; i &lt; <span class="number">40</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建方式二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建一个线程池对象   创建一个带缓存的连接池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//2.通过线程池对象，提交线程任务，并启动线程执行任务</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-callable接口">（4）Callable接口</h3>
<p>JDK5加入，与Runnable接口类似，实现之后代表一个线程任务。</p>
<p>Callable具有泛型返回值、可以声明异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt; V &gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不使用返回值和Runnable的作用一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建一个线程对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//2.通过线程池对象提交线程任务，并启动线程执行任务</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.关闭线程对象</span></span><br><span class="line">        es.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>   <span class="comment">//Callable接口的泛型表示call方法返回值的类型</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread1;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建一个线程对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//2.通过线程池对象提交线程任务，并启动线程执行任务</span></span><br><span class="line">        Future&lt;String&gt; future = es.submit(<span class="keyword">new</span> <span class="title class_">MyCallable2</span>());   <span class="comment">//保存线程的返回结果</span></span><br><span class="line">        System.out.println(future.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.关闭线程对象</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable2</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是call方法返回值&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo03</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//需求：线程A 计算1~50 线程B 51~100  最终得到结果</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;Integer&gt; f1 = es.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">51</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Future&lt;Integer&gt; f2 = es.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">51</span>; i &lt; <span class="number">101</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;结果为:&quot;</span> + (f1.get() + f2.get()));</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-future接口">（5）Future接口</h3>
<p>Future接口表示将要执行完任务的结果。</p>
<p>get()以阻塞形式等待Future中的异步处理结果（call()的返回值）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCallable2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Runnable接口和Callable接口的区别？</span></span><br><span class="line"><span class="comment">    * 1、这两个接口都可以当做线程任务提交并执行</span></span><br><span class="line"><span class="comment">    * 2、Callable接口执行完线程任务之后有返回值，而Runnable接口没有返回值</span></span><br><span class="line"><span class="comment">    * 3、Callable接口中的call方法已经抛出了异常，而Runnable接口不能抛出编译异常</span></span><br><span class="line"><span class="comment">    * Future接口：</span></span><br><span class="line"><span class="comment">    * 用于接口Callable线程任务的返回值。</span></span><br><span class="line"><span class="comment">    * get()方法当线程任务执行完成之后才能获取返回值，这个方法是一个阻塞式的方法</span></span><br><span class="line"><span class="comment">    *随堂案例：</span></span><br><span class="line"><span class="comment">    * 使用两个线程，并发计算1-100的和， 一个线程计算1~50,另一个线程计算51~100， 最终汇总结果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,</span><br><span class="line">ExecutionException </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1、创建线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//2、通过线程池提交线程并执行任务</span></span><br><span class="line">        Future&lt;String&gt; future = es.submit(<span class="keyword">new</span> <span class="title class_">MyCallable1</span>());</span><br><span class="line">        <span class="comment">//获取线程任务的返回值</span></span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;哈哈哈哈哈哈&quot;</span>);</span><br><span class="line">        <span class="comment">//3、关闭线程池</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable1</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+i);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是Callable线程任务的返回值&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-读写锁">（6）读写锁</h3>
<p>ReentrantReadWriteLock：</p>
<p>    一种支持一写多读的同步锁，读写分离，可分别分配读锁、写锁。</p>
<p>    支持多次分配读锁，使多个读操作可以并发执行。</p>
<p>互斥规则：</p>
<p>    写-写：互斥，阻塞</p>
<p>    读-写：互斥，读阻塞写、写阻塞读。</p>
<p>    读-读：不互斥、不阻塞。</p>
<p>    在读操作远远高于写操作的环境中，可在保障线程安全的情况下，提高运行效率</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriterLockDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//记录开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//1.创建线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//2.提交8个读操作任务，提交2个写操作任务</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="type">ReadThread</span> <span class="variable">readThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReadThread</span>(user);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            es.submit(readThread);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="type">WriteThread</span> <span class="variable">writeThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WriteThread</span>(user);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            es.submit(writeThread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.结束线程池</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">        <span class="comment">//es.isTerminated();    获取当前线程池的状态，如果线程池钟的任务执行结束，那么返回true，否则返回false</span></span><br><span class="line">        <span class="comment">//System.out.println(es.isTerminated());</span></span><br><span class="line">        <span class="comment">//我们希望以下的代码在线程任务执行结束之后再执行.利用代码空转来判断</span></span><br><span class="line">        <span class="keyword">while</span> (!es.isTerminated())</span><br><span class="line">        &#123;&#125;</span><br><span class="line">        <span class="comment">//记录结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时&quot;</span> + (end-start) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写线程</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">WriteThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    User user;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WriteThread</span><span class="params">(User user)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        user.setName(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    User user;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReadThread</span><span class="params">(User user)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        user.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//读写锁</span></span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">rrwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">//读锁</span></span><br><span class="line">    ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> rrwl.readLock();</span><br><span class="line">    <span class="comment">//写锁</span></span><br><span class="line">    ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> rrwl.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读操作</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读和写都需要花一秒，而读和读是不影响的，读和写的互斥的，写和写是互斥的</span></span><br><span class="line"><span class="comment">//class User</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    private String name;</span></span><br><span class="line"><span class="comment">//    Lock lock = new ReentrantLock();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    //写操作</span></span><br><span class="line"><span class="comment">//    public void setName(String name)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        lock.lock();</span></span><br><span class="line"><span class="comment">//        try</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            Thread.sleep(1000);</span></span><br><span class="line"><span class="comment">//            this.name = name;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        catch (InterruptedException e)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        finally</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            lock.unlock();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    //读操作</span></span><br><span class="line"><span class="comment">//    public String getName()</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        lock.lock();</span></span><br><span class="line"><span class="comment">//        try</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            Thread.sleep(1000);</span></span><br><span class="line"><span class="comment">//            return name;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        catch (InterruptedException e)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        finally</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            lock.unlock();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return null;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="7-重入锁">（7）重入锁</h3>
<p>重入锁:在同步锁中可以继续加入同步锁(锁对象是同一个)</p>
<p>    synchronized和Lock锁都可以实现锁的重入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReentrantLock</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 重入锁:在同步锁中可以继续加入同步锁(锁对象是同一个)</span></span><br><span class="line"><span class="comment">    * synchronized和Lock锁都可以实现锁的重入</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        a();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//当前锁对象为this</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        b();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//当前锁对象为this</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        c();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-公平锁">（8）公平锁</h3>
<p>公平锁和非公平锁</p>
<p>    非公平锁：优先使用上一个线程接着执行下面的线程任务</p>
<p>        synchronized是非公平锁的实现，无法实现公平锁</p>
<p>        lock锁默认是非公平锁，如果想要实现公平锁，那么需要在构造方法设置为true</p>
<p>    公平锁：让每个线程都公平去执行线程任务</p>
<p>        lock锁可以实现公平锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Lock锁实现公平锁 参数为true表示是公平锁，默认是false表示非公平锁</span></span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author_group"><a class="post-copyright__author_img" target="_blank" rel="noopener" href="https://68565200.xyz/about/"><img class="post-copyright__author_img_front" src= "/img/loading.avif" data-lazy-src="https://i.postimg.cc/wjTxDpBF/image.jpg/banner"></a><div class="post-copyright__author_name">星仔极客</div><div class="post-copyright__author_desc">珍惜当下 不负此生</div></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div id="quit-box" onclick="RemoveRewardMask()"></div></div></div><div class="social-share"><a class="social-share-ico icon-qq" target="_blank" rel="noopener" href="https://connect.qq.com/widget/shareqq/index.html?url=https%3A%2F%2Fxinzaigeek.68565200.xyz%2Fpost%2Ffbc0ae86.html&amp;title=24.%E5%A4%9A%E7%BA%BF%E7%A8%8B&amp;desc=undefined&amp;summary=undefined&amp;site=24.%E5%A4%9A%E7%BA%BF%E7%A8%8B&amp;pics=https%3A%2F%2Fimg.picgo.net%2F2024%2F09%2F23%2F7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" title="分享到QQ"><i class="solitude fab fa-qq"></i></a><div class="social-share-ico icon-link" onclick="utils.copy(&quot;https://xinzaigeek.68565200.xyz/post/fbc0ae86.html&quot;)" title="复制文章链接"><i class="solitude fas fa-link"></i></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本文是原创文章，采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>协议，完整转载请注明来自<a href="/">星仔极客</a></span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E8%AF%AD%E8%A8%80/"><span class="tags-punctuation"><i class="solitude fa-solid fa-hashtag"></i>Java语言<span class="tagsPageCount">12</span></span></a></div></div></div><nav class="needEndHide pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/5883a4af.html"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">26.反射</div></div></a></div><div class="next-post pull-right"><a href="/post/3e1167ea.html"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">23.IO流</div></div></a></div></nav>
        <div class="relatedPosts">
            <div class="headline">
                <i class="solitude fa-solid fa-star"></i>
                <span>喜欢这篇的人也看了</span>
                <div class="relatedPosts-link">
                    <a onclick="event.preventDefault(); toRandomPost();" href="javascript:void(0);" rel="external nofollow" data-pjax-state="">随便逛逛</a>
                </div>
            </div>
            <div class="relatedPosts-list">
            <div>
                <a href="/post/f1dbdc9f.html" title="25.网络编程">
                    <img class="cover" src= "/img/loading.avif" data-lazy-src="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" alt="cover">
                    <div class="content is-center">
                        <div class="title">25.网络编程</div>
                    </div>
                </a>
            </div>
            <div>
                <a href="/post/5883a4af.html" title="26.反射">
                    <img class="cover" src= "/img/loading.avif" data-lazy-src="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" alt="cover">
                    <div class="content is-center">
                        <div class="title">26.反射</div>
                    </div>
                </a>
            </div>
            </div>
        </div><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="solitude fa-solid fa-comment"></i><span> 评论</span><span class="count"> (<span class="waline-comment-count"><i class="solitude fa-solid fa-spinner fa-spin"></i></span>)</span></div></div><div class="comment-wrap"><div id="waline-wrap"></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><div class="author-info__top-group"><div class="author-info__sayhi" id="author-info__sayhi" onclick="sco.changeSayHelloText()">sayhello.morning</div></div></div><div class="avatar-img-group"><img class="avatar-img" alt="头像" src= "/img/loading.avif" data-lazy-src="https://i.postimg.cc/wjTxDpBF/image.jpg/banner"></div><div class="author-info__description_group"><div class="author-info__description"></div><div class="author-info__description2"></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about/"><div class="author-info__name">星仔极客</div><div class="author-info__desc">珍惜当下 不负此生</div></a><div class="card-info-social-icons is-center"><a class="social-icon" target="_blank" rel="noopener" href="https://juejin.cn/user/745920887002011" title="稀土掘金"><i class="solitude  fas fa-blog"></i></a><a class="social-icon" target="_blank" rel="noopener" href="https://space.bilibili.com/488963146?spm_id_from=333.1007.0.0" title="Bilibili"><i class="solitude  fab fa-bilibili"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="solitude fa-solid fa-bars"></i><span>文章目录</span></div><div class="toc-content" id="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点一：Thread线程基础</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点二：并行和并发</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点三：线程和进程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点四：Java程序中实现线程的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E4%B9%8B%E7%BB%A7%E6%89%BFthread%E7%B1%BB-center"><span class="toc-text">1、线程创建方式之继承Thread类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-2-%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E4%B9%8B%E5%AE%9E%E7%8E%B0runnable%E6%8E%A5%E5%8F%A3-center"><span class="toc-text">2、线程创建方式之实现Runnable接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-3-thread%E7%B1%BB%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%92%8Crunnable%E6%8E%A5%E5%8F%A3%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B-center"><span class="toc-text">3、Thread类创建线程和Runnable接口创建线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-4-start%E6%96%B9%E6%B3%95%E5%92%8Crun%E6%96%B9%E6%B3%95-center"><span class="toc-text">4、start方法和run方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-5-%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E6%88%96lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BE%BF%E6%8D%B7%E7%9A%84%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1%E5%B9%B6%E6%89%A7%E8%A1%8C-%E4%BA%86%E8%A7%A3-center"><span class="toc-text">5、使用匿名内部类或Lambda表达式便捷的创建线程对象并执行（了解）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点五：线程常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81getstate-center"><span class="toc-text">1、线程状态getState</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-2-%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7setpriority-center"><span class="toc-text">2、线程优先级setPriority</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-3-%E6%9B%B4%E6%94%B9%E5%92%8C%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8D%E5%AD%97-center"><span class="toc-text">3、更改和获取线程的名字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-4-%E7%BA%BF%E7%A8%8B%E4%BC%91%E7%9C%A0sleep-%E4%BD%BF%E7%94%A8%E5%87%A0%E7%8E%87%E6%9E%81%E9%AB%98-center"><span class="toc-text">4、线程休眠sleep【使用几率极高】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-5-%E7%BA%BF%E7%A8%8B%E7%A4%BC%E8%AE%A9yield-%E4%BA%86%E8%A7%A3-center"><span class="toc-text">5、线程礼让yield（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-6-%E7%BA%BF%E7%A8%8B%E5%90%88%E5%B9%B6join-center"><span class="toc-text">6、线程合并join</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-7-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD-%E6%A0%87%E8%AE%B0-center"><span class="toc-text">7、线程中断(标记)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点六：火车售票问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-getinstance-center"><span class="toc-text">GetInstance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90-%E4%BF%9D%E8%AF%81%E8%B5%84%E6%BA%90%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-center"><span class="toc-text">1、如何解决多线程并发访问临界资源，保证资源安全问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-2-synchronized%E5%85%B3%E9%94%AE%E5%AD%97-center"><span class="toc-text">2、synchronized关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-3-%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95-%E5%AF%B9%E8%B1%A1%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95-%E6%88%90%E5%91%98%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95-center"><span class="toc-text">3、同步方法&#x2F;对象同步方法&#x2F;成员同步方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-4-%E7%B1%BB%E9%94%81-%E7%B1%BB%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97-%E7%B1%BB%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95-%E9%9D%99%E6%80%81%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95-center"><span class="toc-text">4、类锁&#x2F;类同步代码块&#x2F;类同步方法&#x2F;静态同步方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点七：线程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-%E5%AE%8C%E6%88%90%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8Bv1%E7%89%88%E6%9C%AC-center"><span class="toc-text">1、完成生产者和消费者通信模型v1版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-2-%E5%AE%8C%E6%88%90%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8Bv2%E7%89%88%E6%9C%AC-center"><span class="toc-text">2、完成生产者和消费者通信模型v2版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-3-%E5%88%86%E6%9E%90%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-center"><span class="toc-text">3、分析执行流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点八：多对多通信模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-%E8%B4%9F%E6%95%B0%E9%97%AE%E9%A2%98-center"><span class="toc-text">1、负数问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-2-%E6%AD%BB%E7%AD%89%E5%BE%85%E9%97%AE%E9%A2%98-center"><span class="toc-text">2、死等待问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-3-%E6%89%A9%E5%B1%95%EF%BC%9Alock%E6%8E%A5%E5%8F%A3-%E6%98%BE%E7%A4%BA%E9%94%81-center"><span class="toc-text">3、扩展：Lock接口【显示锁】</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点九：线程声明周期</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点十：拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E9%87%8D%E7%82%B9-center"><span class="toc-text">1、线程池【重点】</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A6%82%E5%BF%B5"><span class="toc-text">（1）线程池概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">（2）线程池实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B1%BB"><span class="toc-text">（3）线程池中常见的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-callable%E6%8E%A5%E5%8F%A3"><span class="toc-text">（4）Callable接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-future%E6%8E%A5%E5%8F%A3"><span class="toc-text">（5）Future接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-text">（6）读写锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-text">（7）重入锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-text">（8）公平锁</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="solitude fa-solid fa-map"></i><span>最近发布</span></div><div class="aside-list"><a class="aside-list-item" href="/post/a2c247c4.html" title="项目"><div class="thumbnail"><img alt="项目" src= "/img/loading.avif" data-lazy-src="https://img.picgo.net/2024/11/13/c12889d56cf9e0078ed87b335eb8b0b321601f0548e324aa.png"></div><div class="content"><span class="title" href="/post/a2c247c4.html" title="项目">项目</span><span class="article-recent_post_categories" href="/post/a2c247c4.html">鸿蒙next应用开发</span></div></a><a class="aside-list-item" href="/post/d98607ab.html" title="0.ArkTS基础语法"><div class="thumbnail"><img alt="0.ArkTS基础语法" src= "/img/loading.avif" data-lazy-src="https://img.picgo.net/2024/11/13/c12889d56cf9e0078ed87b335eb8b0b321601f0548e324aa.png"></div><div class="content"><span class="title" href="/post/d98607ab.html" title="0.ArkTS基础语法">0.ArkTS基础语法</span><span class="article-recent_post_categories" href="/post/d98607ab.html">鸿蒙next应用开发</span></div></a><a class="aside-list-item" href="/post/de777d6b.html" title="1.界面开发"><div class="thumbnail"><img alt="1.界面开发" src= "/img/loading.avif" data-lazy-src="https://img.picgo.net/2024/11/13/c12889d56cf9e0078ed87b335eb8b0b321601f0548e324aa.png"></div><div class="content"><span class="title" href="/post/de777d6b.html" title="1.界面开发">1.界面开发</span><span class="article-recent_post_categories" href="/post/de777d6b.html">鸿蒙next应用开发</span></div></a><a class="aside-list-item" href="/post/36f99b3f.html" title="2.交互开发"><div class="thumbnail"><img alt="2.交互开发" src= "/img/loading.avif" data-lazy-src="https://img.picgo.net/2024/11/13/c12889d56cf9e0078ed87b335eb8b0b321601f0548e324aa.png"></div><div class="content"><span class="title" href="/post/36f99b3f.html" title="2.交互开发">2.交互开发</span><span class="article-recent_post_categories" href="/post/36f99b3f.html">鸿蒙next应用开发</span></div></a><a class="aside-list-item" href="/post/9d10e9f6.html" title="4.Linux应用编程"><div class="thumbnail"><img alt="4.Linux应用编程" src= "/img/loading.avif" data-lazy-src="https://i.postimg.cc/MKRR79pj/7777777.jpg"></div><div class="content"><span class="title" href="/post/9d10e9f6.html" title="4.Linux应用编程">4.Linux应用编程</span><span class="article-recent_post_categories" href="/post/9d10e9f6.html">Linux</span></div></a></div></div></div></div></main><footer id="footer"><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div class="copyright">© 2023 - 2025 By&nbsp;<a class="footer-bar-link" href="/"><img class="author-avatar" src= "/img/loading.avif" data-lazy-src="https://img.picgo.net/2024/09/24/811513a1eaacadb85ae79568d39c3337b8b87d11b124d4ab.png">星仔极客</a></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/everfu/hexo-theme-solitude" alt="Theme">Theme</a></div></div></div><div class="comment-barrage needEndHide"></div></footer></div><!-- right_menu--><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="solitude fa-solid fa-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="solitude fa-solid fa-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="solitude fa-solid fa-arrows-rotate"></i></div><div class="rightMenu-item" id="menu-top"><i class="solitude fa-solid fa-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="solitude fa-solid fa-clone"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="solitude fa-solid fa-clipboard"></i><span>粘贴文本</span></div><div class="rightMenu-item" id="menu-commenttext"><i class="solitude fa-solid fa-comment-medical"></i><span>引用到评论</span></div><div class="rightMenu-item" id="menu-newwindow"><i class="solitude fa-regular fa-window-maximize"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="solitude fa-solid fa-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="solitude fa-solid fa-clone"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="solitude fa-solid fa-cloud-arrow-down"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-search"><i class="solitude fa-solid fa-magnifying-glass"></i><span>站内搜索</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><div class="rightMenu-item" id="menu-darkmode" onclick="sco.switchDarkMode()"><i class="solitude fa-solid fa-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></div></div></div><div id="rightmenu-mask"></div><!-- inject body--><div><script src="/js/utils.js?v=2.1.15"></script><script src="/js/main.js?v=2.1.15"></script><script src="/js/third_party/waterfall.min.js?v=2.1.15"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/19.1.3/lazyload.iife.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.36/fancybox/fancybox.umd.min.js"></script><script>const coverColorConfig = {
  api: 'https://api.qjqq.cn/api/Imgcolor?img=',
  time: 43200000
}</script><script src="/js/covercolor/api.js?v=2.1.15"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.75.6/instantsearch.production.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/5.18.0/algoliasearch.umd.min.js"></script><script src="/js/right_menu.js?v=2.1.15"></script><div class="js-pjax"><script>(() => {
    let walineInitFunction = window.walineFn || null

    function initWaline(initFn) {
        const walineOptions = {
            el: '#waline-wrap',
            serverURL: 'https://waline.68565200.xyz',
            pageview: true,
            dark: 'html[data-theme="dark"]',
            path: window.location.pathname,
            comment: true,
            ...{"lang":"zh-CN","dark":"auto","requiredMeta":["nick","mail"],"wordLimit":500,"pageSize":10,"commentCount":true}
        }
        const walineInstance = initFn(walineOptions)
        utils.addGlobalFn('pjax', () => walineInstance.destroy(), 'destroyWaline')
        GLOBAL_CONFIG.lightbox && utils.lightbox(document.querySelectorAll('#comment .wl-content img:not(.wl-emoji)'))
        sco.owoBig({
            body: '.wl-emoji-popup',
            item: '.wl-tab-wrapper button'
        })
    }

    async function loadWaline() {
        if (walineInitFunction) initWaline(walineInitFunction)
        else {
            await utils.getCSS('https://cdnjs.cloudflare.com/ajax/libs/waline/3.4.2/waline.min.css')
            const {init} = await import('https://cdnjs.cloudflare.com/ajax/libs/waline/3.4.2/waline.min.js')
            walineInitFunction = init || Waline.init
            initWaline(walineInitFunction)
            window.walineFn = walineInitFunction
        }
        true && barrageWaline()
    }

    if (true || true) {
        if (true) utils.loadComment(document.getElementById('waline-wrap'), loadWaline)
        else loadWaline()
    } else window.loadTwoComment = loadWaline
})()
</script><script>async function barrageWaline() {
    const url = new URL('https://waline.68565200.xyz/api/comment')
    const params = {path: window.location.pathname, sortBy: 'insertedAt_asc'}
    Object.entries(params).forEach(([key, value]) => url.searchParams.append(key, value))
    await fetch(url).then(async res => {
        if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`)
        const data = await res.json();
        const regex = /<img [^>]*class="wl-emoji"[^>]*>/;
        const init = () => {
            initializeCommentBarrage(data.data.data
                .map(item => ({
                    nick: item.nick,
                    mailId: item.avatar,
                    content: item.comment.replace(regex, ''),
                    id: item.objectId
                })))
        }
        if (typeof initializeCommentBarrage === "undefined") await utils.getScript('/js/third_party/barrage.min.js?v=2.1.15').then(init)
        else init()
    }).catch(error => console.error("An error occurred while fetching comments: ", error))
}</script></div></div><!-- pjax--><script>const pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: ["title","#body-wrap","#site-config","meta[name=\"description\"]",".js-pjax","meta[property^=\"og:\"]","#config-diff",".rs_show",".rs_hide"],
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
})

document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
})

document.addEventListener('pjax:complete', () => {
    window.refreshFn()

    document.querySelectorAll('script[data-pjax]').forEach(item => {
        const newScript = document.createElement('script')
        const content = item.text || item.textContent || item.innerHTML || ""
        Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
        newScript.appendChild(document.createTextNode(content))
        item.parentNode.replaceChild(newScript, item)
    })

    GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

})

document.addEventListener('pjax:error', (e) => {
    if (e.request.status === 404) {
        pjax.loadUrl('/404.html')
    }
})</script><!-- google adsense--><!-- search--><div id="algolia-search"><div class="search-dialog"><div class="algolia-navbar"><div class="search-dialog__title" id="algolia-search-title">搜索</div><div class="algolia-tips"><i class="solitude fab fa-algolia"></i><span class="algolia-tips-text">Algolia</span></div><span class="search-close-button"><i class="solitude fa-solid fa-xmark"></i></span></div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><div id="search-results"><div id="algolia-hits"></div></div><div id="algolia-tips"><div id="algolia-pagination"></div><div id="algolia-stats"></div></div></div><div id="search-mask"></div></div><script src="/js/search/algolia.js?v=2.1.15"></script><!-- Tianli-Talk--><!-- music--></body></html>
        <script>
            const posts = ["post/a2c247c4.html","post/d98607ab.html","post/de777d6b.html","post/36f99b3f.html","post/9d10e9f6.html","post/55a07e0f.html","post/f705831.html","post/68ec1b16.html","post/c24675b4.html","post/4e3021ff.html","post/dd99ee0d.html","post/69f8b9de.html","post/ff4327d1.html","post/fd908b52.html","post/288a7e13.html","post/bcf1b676.html","post/de55e8eb.html","post/e5f15f94.html","post/49f85af0.html","post/e9f3074a.html","post/a1db912f.html","post/54659a9b.html","post/8a87b27f.html","post/96c26968.html","post/520176db.html","post/99cd7d8.html","post/adb202b7.html","post/eb0bc4a3.html","post/2c4c3bc3.html","post/f71d0ad2.html","post/6928cd3f.html","post/bfd038f5.html","post/f5fba2c3.html","post/e8bc8f26.html","post/f0812160.html","post/52772f76.html","post/acb77072.html","post/bd740709.html","post/c4236caa.html","post/63d3dd68.html","post/32e9e993.html","post/c6b2a2fd.html","post/74750b31.html","post/81b224e1.html","post/2e5216dd.html","post/f736596e.html","post/f5fba2c3.html","post/8212ff63.html","post/93c966f3.html","post/def84ee6.html","post/1f293ccb.html","post/79959306.html","post/5f6e69ef.html","post/2ec6e870.html","post/f1dbdc9f.html","post/5883a4af.html","post/fbc0ae86.html","post/3e1167ea.html","post/8f9052f9.html","post/a24af109.html","post/9e25cba9.html","post/a920af81.html","post/fe7ab1f0.html","post/76fa8c0d.html","post/fbc82303.html","post/ca0fcd03.html","post/6ac19130.html","post/6f76074c.html","post/cb87841d.html","post/6271a51c.html","post/7422213c.html","post/3b48d11a.html","post/df718222.html","post/804ae251.html","post/b70ae4e7.html","post/3ec1fd44.html","post/bec635c1.html","post/5bdb5548.html","post/9b06d854.html","post/e2246be5.html"];
            function toRandomPost() {
                const randomPost = posts[Math.floor(Math.random() * posts.length)];
                pjax.loadUrl(GLOBAL_CONFIG.root + randomPost);
            }
        </script>