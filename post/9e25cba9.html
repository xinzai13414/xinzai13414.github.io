<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>5.集合 | 星仔极客</title><meta name="keywords" content="Java语言"><meta name="author" content="星仔极客"><meta name="copyright" content="星仔极客"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="5.集合"><meta name="application-name" content="5.集合"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="5.集合"><meta property="og:url" content="https://xinzaigeek.68565200.xyz/post/9e25cba9.html"><meta property="og:site_name" content="星仔极客"><meta property="og:description" content="知识点一：集合框架 1、概念     如果处理一套通用逻辑就提供一个自定义封装处理数组的类，那么开发中可能会需要提供N这样类，问题在于需要自行完成操作，Java也发现这个问题，所有为了让程序猿可以更加的便捷的对数据进行操作，无需向数组一样提供【增删改查】的自定义实现，Java提供一个集合框架，便于程"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp"><meta property="article:author" content="星仔极客"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp"><meta name="description" content="知识点一：集合框架 1、概念     如果处理一套通用逻辑就提供一个自定义封装处理数组的类，那么开发中可能会需要提供N这样类，问题在于需要自行完成操作，Java也发现这个问题，所有为了让程序猿可以更加的便捷的对数据进行操作，无需向数组一样提供【增删改查】的自定义实现，Java提供一个集合框架，便于程"><link rel="shortcut icon" href="https://img.picgo.net/2024/09/24/811513a1eaacadb85ae79568d39c3337b8b87d11b124d4ab.png"><link rel="canonical" href="https://xinzaigeek.68565200.xyz/post/9e25cba9.html"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: undefined,
  diytitle: undefined,
  LA51: {"enable":true,"ck":"3HZ1UVjhMEV6g7Lg","LingQueMonitorID":"3HZ1UVjhMEV6g7Lg"},
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: undefined,
  friends_vue_info: undefined,
  navMusic: false,
  mainTone: {"mode":"api","api":"https://api.qjqq.cn/api/Imgcolor?img=","cover_change":true},
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 星仔极客","link":"链接: ","source":"来源: 星仔极客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '星仔极客',
  title: '5.集合',
  postAI: '',
  pageFillDescription: '知识点一：集合框架, 1、概念, 2、集合架构, 3、List集合, 知识点二：List集合之ArrayList集合, 1、分析ArrayList的效率, 2、语法, 3、常用方法, 知识点三：List集合三种遍历方式, 普通for循环, 增强for循环【foreach循环】, foreach方法遍历, 知识点四：ArrayList底层实现原理, 知识点五：迭代器, 1、迭代器原理, 2、获取迭代器对象, 3、迭代器的三个方法, 4、强化迭代器, 5、迭代器注意事项, 知识点六：List集合之LinkedList集合, 1、说明, 2、分析LinkedList的执行效率, 3、常用方法, 4、LinkedList实现原理, 知识点七：List集合总结, 知识点八：泛型基本使用, 1、作用, 语法, 2、定义, 3、泛型的使用之集合, 4、泛型的使用之泛型类, 5、泛型使用之泛型方法, 6、泛型使用之接口泛型, 7、泛型的限定, 8、特点, 知识点九：Set集合的介绍, 知识点十：Set集合实现类HashSet, 1、Hash表, 2、HashSet基本使用, (1）语法, (2)HashSet集合的排重操作, (3)底层原理, 知识点十一：LinkedHashSet类, 知识点十二：Set集合实现类TreeSet, 知识点十三：Comparable接口【自然排序接口】, 知识点十四：Comparator接口【自定义排序接口】, 总结Comparable和Comparator接口, 知识点十五：Set集合总结, 知识点十六：Collection集合, 知识点十七：Collections工具类, 知识点十七：Map集合, 1、Map集合介绍, 2、Map集合主要实现类HashMap, 3、HashMap常用方法(Java8之前), 4、HashMap常用方法(Java8之后), 5、Map集合之TreeMap集合, 6、Collections工具类, 7、Collection集合和Map集合的总结, 8、HashMap应用, 9、HashMap底层实现原理, 10、put的过程原码, 11、resize过程原码, 12、get的过程原码, 知识点十八：常见的集合面试面试题知识点一集合框架概念如果处理一套通用逻辑就提供一个自定义封装处理数组的类那么开发中可能会需要提供这样类问题在于需要自行完成操作也发现这个问题所有为了让程序猿可以更加的便捷的对数据进行操作无需向数组一样提供增删改查的自定义实现提供一个集合框架便于程序猿对数据进行存储与管理操作什么是集合框架中的集合框架其实就是对数据结构的封装这个封装中提供了一些常用方法可方便操作数据无需程序猿自定定义操作只需要调用封装方法就可以完成对存在集合中数据增删改查集合其实就是对数据结构一种封装所以之前公司就把集合放置到一个统一包中进行管理包什么是数据结构数据结构其实就是计算机组织和存储数据形式数据结构是指相互之间存在一种或多种特定关系的数据集合通常情况下精心选择数据结构可以带来更加高效运行和存储效率数据结构往往高效的原因在于检索算法和索引计数常见数据结构数组栈链表单向和双向哈希表队列单向和双向堆树图的集合框架其实就是对数据结构实现我们需要掌握就是如何操作这个数据结构即操作集合中方法高效存储与处理数据根据不同数据结构操作数据性能是不同有地查询块有的插入快有地允许重复有的不允许重复等等在开发中只要选择合理数据结构即集合对数据存储与操作即可推荐后期可以看一本书大话数据结构兄弟大话设计模式集合架构习惯性说中集合有三大框架和如果详细说明的话应该个框架个实现个框架和个实现这个集合下两个主要实现和所以称为三大集合和集合和数组最大区别在于集合中只能存储引用类型即对象集合是一个变长容量根据集合存储元素个数动态进行删减扩容和减容数组是一个定长容器创建大小数固定无论存储多少数据长度都是唯一常见三大集合框架列表集合中存储对象是按照索引位置进行存储允许存储重复数据集集合中存储对象不是按照特定方式进行存储不允许出现重复数据映射集合中每一个存储元素都是以一种键值对方式进行存储的以一种和的形式存储的这个对象是不允许重复唯一性是允许重复无论什么时候都要先创建对象集合知识点二集合之集合分析的效率因为使用是数组实现所以可以得到如下以下特点保存操作把一个数据保存到中最快的操作只要操作一次即可最慢的操作可能操作次平均执行效率次扩容问题删除操作删除中某个数据最快的只要操作一次即可最慢的操作可能操作次平均执行效率次减容问题修改操作操作一次即可查询操作根据索引一次即可如果遍历查询使用检索算法做优化效率高度如果遍历从到为顺序查找效率是低因为使用是数组的形式进行存储数据操作所以基于这样数据结构做查询和修改效率是高但是做增加和删除效率是低动态扩容和减容语法泛型变量名常用方法向指定下标位置添加一个元素下标范围有多少个元素变量名指定下标数添加的元素移除指定下标位置的元素下标范围变量名指定下标数修改指定下标位置的元素下标范围变量名指定下标数修改元素内容获取指定下标位置上的元素下标范围变量名指定下标数返回值为对应的数据类型提供集合对象进行数据的存储操作集合提供一个无参构造方法可以创建一个空的集合对象空指定的是集合没有存储任何数据但是集合引用是在的在使用无参构造方法创建对象一个元素都不存储依旧会在堆中开辟一个大小为的数据空间并且数组的默认存储数据类型时在中开发人员发现如果在使用集合之前如果使用无参构造方法创建集合对象会出现一个大小的堆中数组空间这样会造成一定量的空间浪费所以在中提供一个全新优化使用无参构造方法创建对象时并不会创建一个大小为数组在堆中进行存储而是创建创建一个空的数组进行空间的开辟当通过集合对象调用集合集合中提供方法时此时才会真正的初始化数组空间集合使用其他的集合对象中存储数据作为新的集合中存储数据进行初始化即将参数中集合对象数据存储到新建集合中自定义集合的底层数组初始化容量使用较少常用向集合对象中添加元素存储数据集合只能存储引用类型即对象集合中只能存储引用类型明显调用时存储的是类型数据可以存储的因为向集合中存储基本数据类型时完成自动转换操作将基本数据类型转换为对应包装类集合在没有使用泛型之前是可以存储任何引用类型对象因为方法参数类型时集合重写所以可以直接打印集合对象查看集合内容向集合中指定位置添加元素数据第一个参数是下标位置第二个参数是存储的元素向集合中添加参数集合中数据到集合中进行存储参数是一个集合所以只要是或集合实现类都是传递到这个参数中将集合里面的数据存储到集合中有一个重载在指定位置中添加添加参数集合数据下标集合对象特别注意和的区别这个方法是向集合中添加引用类型对象即向集合集合添加地址这个方法是向集合中添加参数中集合数据相当于将中引用存储到这个集合中存储是对象即地址相当于将中存储数据存储到这个集合中存储的是数据内容清空集合中存储的数据但是集合引用不会消失消失的是集合数据没有清空之前中的数据是清空之后中的数据是判断集合否为空即判断集合是都没有存储任何数据空不空判断集合中是否存在指定元素判断集合中是否存储在这个对象存在不存在判断集合中是否存在参数集合中数据这方法不是独有的而是接口提供通过集合中存储元素下标获取集合中元素下标不要越界范围集合存储元素个数查询集合中是否存在指定元素并返回下标只会返回第一次遇到元素的下标找到了就是下标找不到就是负数查找的数据查询集合中是否存在指定元素并返回下标从后向前寻找集合是提供真正删除操作进行减容操作根据数据删除集合中存在数据根据下标删除集合中数据集合接口提供方法根据参数集合提供数据在当前集合进行删除操作集合接口提供方法根据参数集合提供数据保留当前集合中存储的数据剩余的数据进行删除在中提供一个新的处理集合删除方法这个方法参数支持表达式和匿名内部类方式处理匿名内部类需要在这个方法方法执行删除规则结果就会进行删除操作参数中会获取到集合每一个元素的值表达式中提供一个全新的方法支持表达式和匿名内部类根据指定规则进行元素的替换操作指定当前替换规则的方法方法参数中会获取到所有集合中数据需要在方法内部提供替换规则返回的是替换之后需要存在集合中数据修改替换集合中指定位置的数据第一个参数是下标第二个参数修改数据获取集合中存储元素个数集合长度将集合转换为数组数组中也提供一个方法将数组转换为集合不太推荐截取指定范围内容集合数据得到一个新的集合包括前不包括后包括开始位置不包括结束位置参数都是下标知识点三集合三种遍历方式普通循环因为的底层实现是数组所以支持数组中提供下标进行对进行操作语法格式集合对象循环变量值就是集合下标变量定义下标初始值它获取集合长度使用方法通过集合提供方法或方法对集合数据进行取值与赋值操作特点因为这里操作的是下标所以可以利用下标对集合数据进行增删改查操作增强循环循环因为的底层实现是数组所以支持数组中提供下标进行对进行操作语法格式集合中存储元素的类型变量名集合名通过操作局部变量就可以操作集合中数据了之前在学习数组的时候说过数组遍历方式有两种一种普通循环一种是增强循环增强循环只能使用在数组或集合中在数组使用增强循环它的实现原码是将数组值赋值给局部变量所以对与增强循环中局部变量修改是不会影响到数组增强循环适合简单数据运算分支判断和打印数组中数据特点集合中增强循环和数组中增强循环同样效果支持数组进行简单数据运算分支判断和打印集合中数据但是不支持对集合中数据进行修改操作也不允许在增强循环中调用集合删除方法进行数据删除如果一旦删除就会出现一个并发迭代修改异常李四尼古拉斯集合遍历方式使用迭代器提供一个集合对象提供一个普通循环操作获取存储的数据通过下标对集合中数据进行修改通过下标进行数据删除操作支持全套删除增强循环中就会存储这个集合中所有数据打印集合数据判断集合中数据做什么操作操作代码数据类型是可以做计算需要注意方法无法使用因为第一个参数是下标不能使用集合中删除方法即在增强循环中是不允许调用删除方法的提供增强循环的原码增强循环之所以不可以删除原因就是在于增强循环即底层实现就是一个迭代器迭代器中是不允许使用集合中删除方法进行数据删除的如果删除就出现这个异常方法遍历是中提供一个新增的方法主要是以一个方法形态可以遍历打印集合中数据因为这个方式中提供所以这个方法支持表达式和匿名内部类实现这个方法主要就是用于打印其他方式较少提供一个集合对象方法内部可以指定打印效果匿名内部类的形式这个方法中就是咱们打印集合中数据的形式类型参数可以获取到集合每一个数据提供一些判断打印效果根据具体需求来这个方法没有返回值所以打印效果是不会影响实际存储数据的表达式实现提供中方法引用操作知识点四底层实现原理构造方法初始化一个长度为的数组底层的元素是数组方法的原理当第一次添加元素的时候初始化一个长度为的数组当添加元素超过数组的长度的时候会对数组进行扩容扩容到倍将当前的元素添加到数组指定的下标位置上数组数据结构的特点增删慢查询快知识点五迭代器中专门针对集合提供了一种遍历方式这种遍历方式是根据接口来决定只要是的集合接口在子接口基本上都会具备这个接口这个接口中主要提供一个方法返回按适当顺序在列表的元素上进行迭代的迭代器这个方法会返回一个按照集合顺序并存储集合数据的一个迭代器对象迭代器原理迭代是重复反馈过程的活动其目的通常是为了逼近所需目标或结果每一次对过程的重复称为一次迭代而每一次迭代得到的结果会作为下一次迭代的初始值获取迭代器对象变量名的变量名迭代器的三个方法判断迭代器是否有下一个元素变量名返回值类型获取当前游标对应元素并将游标向后移动一位变量名返回迭代的下一个元素移除当前迭代器上对应的元素变量名说明可以利用中提供三个核心方法操作迭代器影响集合中数据迭代器中在没有使用泛型之前方法的返回值类型都是统一所以将方法中返回看做是即可迭代器提供自身方法所以在迭代器中删除数据时要调用迭代器提供而不是集合基础迭代器需要使用集合对象调用方法获取迭代器对象利用迭代器对象调用进行操作判断迭代器中是否还存在下一个元素通过方法获取迭代器中数据迭代器使用问题删除数据删除掉这个值使用迭代器中提供删除删除迭代器中存储数据的同时会删除集合中对应数据千万不要调用集合中提供删除方法就会出现并发迭代修改异常强化迭代器强化迭代器只有集合具备专门为集合提供一个增强迭代器因为原始迭代器中只有三个方法不利于对集合数据的操作增强迭代器就新增多个方法进行迭代器操作是集合在迭代器接口之上提供一个更多方法操作的迭代器在原始迭代器基础上增加新增数据修改数据从后向前遍历获取数据的操作还可以获取下标将指定的元素插入列表可选操作以正向遍历列表时如果列表迭代器有多个元素则返回换句话说如果返回一个元素而不是抛出异常则返回如果以逆向遍历列表列表迭代器有多个元素则返回将指定的元素插入列表可选操作返回列表中的下一个元素返回对的后续调用所返回元素的索引返回列表中的前一个元素返回对的后续调用所返回元素的索引从列表中移除由或返回的最后一个元素可选操作用指定元素替换或返回的最后一个元素可选操作在没有使用泛型之前方法所有使用的部分都看做是类型即可基础迭代器需要使用集合对象调用方法获取迭代器对象如果你想调用逆向遍历操作时需要现将光标向后移动才可以光标最先开始是在第一个元素位置上此时对迭代器进行逆向遍历从后向前同样是遵守一个原则不要再迭代器中使用后集合删除方法删除数据要使用迭代器提供方法进行删除迭代器注意事项迭代器迭代完成之后迭代器的位置在最后一位所以迭代器只能迭代一次迭代器在迭代的时候不要调用多次方法可能会出错在迭代器迭代的时候不能向集合中添加或者删除元素马冬梅迭代器不能使用多次如果要多次使用那么要多次获取在同一次迭代中不能多次使用方法第一种第二种不能这么多次使用迭代器在迭代的过程中不能调用或者方法知识点六集合之集合说明集合也是集合接口中主要实现类这个的主要实现结构有链表除了链表结构之外还使用栈队列数组是允许存重复数据化并且可以快速插入数据中实现的数据结构栈又称堆栈它是运算受限的线性表其限制是仅允许在表的一端进行插入和删除操作不允许在其他任何位置进行添加查找删除等操作简单的说采用该结构的集合对元素的存取有如下的特点先进后出即存进去的元素要在后它后面的元素依次取出后才能取出该元素例如子弹压进弹夹先压进去的子弹在下面后压进去的子弹在上面当开枪时先弹出上面的子弹然后才能弹出下面的子弹栈的入口出口的都是栈的顶端位置这里两个名词需要注意压栈就是存元素即把元素存储到栈的顶端位置栈中已有元素依次向栈底方向移动一个位置弹栈就是取元素即把栈的顶端位置元素取出栈中已有元素依次向栈顶方向移动一个位置队列队列和栈有一些类似也是一种受到限制的线性表其限制是仅允许在表的一表进行插入另外一段进行取出和删除这样队列叫做单向队列队列是存在一个特点先进先出队列除了单向队列之外还提供一种非受限制线性表这表就是双端队列依旧遵守先进先出原则双端队列链表链表属于一个线性表线性表中包含了存储链接位置和数据的位置利用链接位置进行相连接使数据之间呈现一种链接状态链表可以理解为老鹰抓小鸡链表和队列差不多链表也分为单向和双向链表类似于现实生活中的火车通过链接方式就可以获取得到链表中数据单向链表和双向链表是有本质上区别的单向链表包含两个区域存储链接位置和数据存储位置通过存储链接位置让每一个单独链接节点进行相连形成一个单向链表即单向链表只能向一个方法进行遍历操作双向链表包含是三个区域个存储链接位置和个数据存储位置利用双向链表中两个存储链接的位置进行前后节点的链接此时链表就形成了一个双向通道即可以从头到尾也可以从到头允许直接在头尾两端进行操作分析的执行效率主要实现方式是双向链表所以使用效果保存数据只要执行一次即可中也提供和删除操作只要执行一次即可中也提供和就选中间节点查询操作和修改操作平均值结论增删执行效率是高的但是查询和修改执行效率是低的常用方法常用的方法与一致自己独有一些向首尾添加移除等方法可以模拟对列堆栈等数据结构因为实现了集合接口所以具备所有集合操作方法中方法操作完全参考即可集合独有方法创建对象创建一个空的集合对象使用参数中集合对象中存储数据初始化集合对象独有向集合开头的位置添加元素向集合结尾的位置添加元素获取集合第一个元素的数据但是不删除集合数据获取集合中第一个数据和最后一个数据但是不删除集合数据允许使用下标形式进行数据获取添加元素到集合的末尾添加到第一个位置和最后一个位置获取集合集合第一个元素但是不删除集合数据有元素就返回没有就是获取最后一个元素的值有元素就返回没有就是系列也是也可以获取集合中第一个和最后一个元素的删除数据在获取数据的同时删除集合中数据弹出集合中第一个数据向集合中添加数据删除集合中第一个或最后一个元素值集合特点就是允许存储重复数据下面两个方法的作用就是遍历集合的方法从前之后的方法从后向前遇到第一个相同数据删除有一个独有的迭代器允许逆向的遍历迭代器中数据值但是它的操作方式和是一样它的方式只有三个和不同点在于它的光标最先开始是放置在迭代器最后一个元素的位置你是向前判断实现原理知识点七集合总结集合是集合子集合即集合是继承与集合因为集合是接口所以无法直接操作就提供了两个可以便捷操作集合实现类和集合的特点允许存储重复数据并给存储数据是有顺序在官方文档中可以查看到有序的也称为序列此接口的用户可以对列表中每个元素的插入位置进行精确地控制用户可以根据元素的整数索引在列表中的位置访问元素并搜索列表中的元素所有已知实现类和所有超级接口和因为也继承了所以集合中是支持的迭代器接口中提供常用方法已经在集合中完全进行演示所以使用集合时只要参考提供方法演示就可以操作集合和实现类是实现接口所以相当于是他们的父类所以集合接口支持多态集合接口允许这样这样创建对象或者这样直接使用较少多用于在方法中如果需要设置集合参数优先会将作为参数类型而不是实现类因为这样做可以接收或上面这种方式是不使用泛型所以默认数据类型时操作时就一定注意转换问题对象的向下转型中所有集合都是有泛型语法所以可以使用泛型方式进行创建对象数据类型泛型语法形式集合的数据类型数据类型集合对象名字集合数据类型集合都是使用关键字创建所以它是引用类型现在学习和都是线程不安全的集合在多线程操作前提下是不能使用这两个集合进行数据存储操作这两个集合只适合在单线程下使用集合接口还有一个实现类在的时候就已经存在这个类其实是集合类前身在时候开始强调了集合框架概念所以提供集合框架在下面提供和的实现也是数组所以被归类到了接口的实现类中现在开发已经不在使用这个类主要使用这个类和之间相似点和区别在于什么相似点都是集合接口的实现类都使用数组作为集合数据结构进行实现不同点这个集合是线程安全的但是效率低提供较早并且使用率低这个集合是线程不安全但是效率高提供较晚并且使用率高就算是线程安全的但实际开发中也不会使用还是使用从开始提供和线程安全处理模式集合中是存在一个工具类这个类叫做这个工具类提供了如果将线程不安全集合转换为线程安装集合的方法集合对象可以将一个线程不安全集合转换为线程安全除了这种处理方式之外现在主要处理方式可以使用在中提供的一个新包并发工具包这个包中提供大量的线程安全处理时可以使用的集合栈集合和队列集合是集合的实现类而集合接口有专门实现类来实现主要体现在于知识点八泛型基本使用作用什么是泛型泛型是一个特殊类型泛型是统称指代任何引用数据类型泛型本身代表通用类型含义在定义泛型时如果没有对泛型进行数据类型赋值之前泛型本身是不具备任何含义只有赋值为具体数据类型时泛型才会真正意义为什么要使用这个泛型泛型解决了集合中存储数据类型的问题在学习集合之前是没有使用泛型所以集合中默认类型就是我们面临的问题就是取出数据时需要进行向下转型操作才可以对集合存储的数据进行计算求和因为不使用泛型默认类型时类型所以和这个集合中就可以存储任何数据类型只要是子类如果你在不清楚集合中存储在什么样数据类型数据时如果进行转换操作代码就无形中增加开发成本所以在这种情况下集合建议使用泛型来约束集合中存储数据一旦集合使用泛型就要可以约束集合只能存储泛型中提供的数据类型对应数据从而减少转换操作此时这个集合中只能存储类型数据使用泛型作为约束如何定义泛型集合语法集合数据类型存储数据的数据类型集合对象名集合数据类型此时就可以使用存储数据的数据类型约束集合中存储的数据了集合泛型你就可以理解为就是创建数组是数组中存储元素数据类型相当于集合数据类型存储数据的数据类型只能引用数据类型泛型解决通用性问题编程原则不要重复你自己不要写重复性代码需求求点中和的值为了类型可以获得不同参数类型数据需要提供大量相同逻辑类此时就触发原则现有解决方案就是将数据类型替换成类型但是我们需要面临数据类型转换和传递非计算类型问题有没有什么方式可以动态决定类中和属性类型操作根据外界传递类型来进行和的限制操作可以使用泛型定义泛型中会出现一个占位符的概念这个占位符本身是没有任何意义就是一个占位对泛型进行赋值时占位符才会有具体的意义泛型的概念是开始引入到中它可以通过对泛型赋值进行对数据赋值约束通过泛型动态决定数据类型时什么语法占位符这种语法在中叫做菱形语法这样语法与占位符组合就是成为泛型这个语法可以使用在类方法和接口上占位符一般是一个大写字母不建议使用其他形式进行占位符定义习惯书写占位符是类型泛型占位符可以在一个语法存在多个需要使用分隔使用占位符的多少就相当于你定义多个泛型泛型语法只能存在在编译时期一旦程序运行泛型就会自动消失称之为泛型擦除定义的泛型在编译字节码文件中即文件看不到泛型的使用之集合集合的数据类型泛型赋值数据类型集合对象名字集合的数据类型声明的就是带有泛型集合泛型可以作为集合类型一部分可以出现在方法参数位置和返回值类型的位置一旦集合使用泛型之后集合只允许使用泛型定义数据类型非泛型定义数据类型时无法存储到集合中集合使用泛型之后确定了集合中存储数据的数据类型在集合中的数据就无需向下转型操作泛型的使用之泛型类当前类在没有使用任何其他修饰符之前或没有使用泛型语法之前都是一个普通类利用泛型语法占位符可以将当前类变成泛型类语法类名占位符这个类就是泛型类此时这个泛型是定义在类上所以在类中成员变量和成员方法都可以使用这个泛型作为数据类型使用使用泛型是这个现在是没有意义只是一个占位符号此时这个是没意义为了保证语法不错误占位使用泛型只有被赋值之后数据类型必须是引用数据类型才会有意义在类上定义泛型如何确定泛型数据类型只要在创建类的对象时对泛型进行赋值泛型就有具体的数据类型类名泛型赋值数据类型对象名字类名这样创建对象创建泛型的同时不对泛型进行赋值操作此时没有对泛型进行赋值所以泛型类型默认使用泛型在动态决定数据类型时什么的时候不存在继承关系不要这样写这个语法是错误对泛型进行赋值什么数据类型时就决定这个数类型所不允许赋值为其他类泛型使用之泛型方法泛型方法的定义主要是为了摆脱使用泛型类上或泛型接口上的泛型约束问题就相当于方法向使用自己定义泛型作为类型操作就可以定义为泛型方法泛型类和泛型接口上定义泛型不能在静态方法上使用所以只能定义泛型方法对方法进行泛型使用修饰使用泛型是这个现在是没有意义只是一个占位符号提供一个成员方法泛型类上定义泛型就可以在方法中使用泛型类上定义泛型是不能在静态方法上使用给方法添加泛型泛型静态方法访问权限修饰符占位符返回值类型方法名参数列表此时这个占位符可以使用在返回值类型上和参数列表定义中方法上泛型主要是为了返回值类型和参数类型而提供的在内部就不在使用泛型成员方法访问权限修饰符占位符返回值类型方法名参数列表此时这个占位符可以使用在返回值类型上和参数列表定义中此时不仅可以使用泛型方法上定义泛型也可以使用类上或接口上定义泛型方法上泛型主要是为了返回值类型和参数类型而提供的在内部就不在使用定义泛型方法泛型不能单独使用在方法返回值类型位置需要配合使用参数列表定义静态方法可以这样操作成员的不可以如何给方法定义泛型进行赋值操作赋值数据类型在调用方法对泛型定义参数列表赋值时可以决定方法的泛型是什么定义泛型方法时一定要将泛型定义在参数列表中以确定数据类型是什么泛型使用之接口泛型接口泛型和泛型类差不多在接口上定义泛型这个泛型可以在接口内部使用接口名占位符泛型接口在接口上定义泛型可以在接口内部使用支持抽象方法自定义泛型在使用类实现接口时可以对泛型接口的泛型进行赋值决定泛型类型是什么在接口中定义方法使用泛型位置都会变成数据类型使用泛型类实现泛型接口使用泛型类中泛型作为接口中新泛型在创建泛型类对象时可以决定泛型类型这种操作其实就是集合中使用集合创建对象的方式直接使用匿名内部类的形似进行泛型接口上泛型的赋值泛型的限定泛型限定其实就是定义泛型可以赋值哪些数据类型只有满足限定要求的数据类型才可以进行定义赋值操作泛型通配符代表未知可以作为通配符使用但是不能作为参数类型单独使用通配符多用于在泛型限定上是一个通配符这里是无法确定数据类型无法单独使用类这是使用途径此时就代表着可以接收关键字后的相同类型或子类类这是使用途径此时就代表着可以接收关键字后的相同类型或父类提供个集合对象调用泛型的上限操作即参数类型使用的是进行限制泛型限定必须是类型或子类而是类型即子类是类型即类型所以可以进行传递而和分别是和既不是类型也不是子类所以无法传递到方法中调用泛型下限操作即参数类型使用的是进行限制泛型限定必须是类型或父类而和分别是和既不是类型也不是父类所以无法传递到方法中和分别是和满足了必须是类型或父类所以传递到方法中泛型的上限此时的泛型中通配符必须是的类型或子类泛型的下限此时的泛型中通配符必须是的类型或父类特点泛型集合在存储元素的时候支持多态不推荐使用泛型定义的时候不存在多态泛型擦除在之后右边的中不需要定义泛型类型集合的泛型不能是基本数据类型要使用它们的包装类类泛型参数化类型之后泛型作用因为在没有使用泛型之前向集合中存储实际上是类型的数据所以获取的时候也是类型如果想要使用这个对象需要发生向下转型那么在整个集合存储元素的时候不停的发生向上和向下转型可能会发生异常泛型的好处类型转换的操作提前到了编译器泛型特点泛型集合在存储元素的时候支持多态不推荐使用泛型定义的时候不存在多态泛型擦除在之后右边的中不需要定义泛型类型集合的泛型不能是基本数据类型要使用它们的包装类尼古拉斯遍历集合迭代器没有向下转型时时类泛型集合在存储元素的时候支持多态不能用基本数据类型类类类中的方法玩类知识点九集合的介绍知识点十集合实现类集合是集合主要实现类也是日常开发使用最常用集合实现类集合继承了集合的特点向集合中存储数据时是不允许出现重复数据如果有存储重复数据集合会进行自动排重操作集合的主要实现数据结构表存储数据顺序是无序通过观察文档发现集合的所有方法都是集合接口提供本身没有任何特殊方法特点无序插入顺序无下标不可重复表什么是表一般被翻译为散列也可以直接音译为哈希它是基于快速存取的角度而设计的一种存储结构而且是一个典型空间换时间的做法利用表的原理进行数据存储操作表其实就是数组链表的组合形式在表数组起到作用提供存储位置在表链表起到作用提供数据存储结构上图中是典型表的结构表也别称之为散列表表是根据键值对而直接进行访问的数据结构也就是说通过把值映射到表中一个位置来记录访问位置以加快查找数据这个操作就是确定数据在表中存储的位置这个操作也被称之为散列函数通过散列函数计算出存储位置会后会将存储数据以链表形似挂载在存储位置中这种方式成为桶如果存储个元素但是存储个元素时申请个空间这个这个值就称之为负载加载因子通过这个因子对表进行扩容操作因为表是基于快速存取的操作所以表会尽量的平均将数据分配到表中进行存储但是在存储过程中就会触发在同一个存储空间中出现重复数据问题此时就会启动自动排重操作原则就是比较只要比较结果为就不在这个空间存储相同数据假如向上面表中存储这个数据如果进行存储计算第一步通过散列函数计算需要存储的位置散列函数是要存储数据计算的值即中值其实就是存储表中数组长度上图中数组长度为所以散列函数计算效果余数利用这个值去数组中提供存储位置对别查找存表的扩容机制表示一个自动扩容机制当达到加载因子参数要求时表就会进行自动扩容中使用表默认大小给加载因子当个存储位置发生了位置都存储了数据即也就说个下标位置中都存储数据表就会发生自动扩容扩容机制就以的幂次进行扩容是扩容之后即表每次扩容之后都是原有容量一倍就会从原有扩容到在介绍时说过中存储数据不能保证存储位置永久不变只要表发生一次扩容那么表中存储的数据就要重新计算存储位置原始数据存储在大小为的表中计算位置余数一旦扩容大小从变成此时原始数据可就要重新计算存储位置在表计算位置余数总结表数据存储和查找是非常优秀但是一旦扩容就会降低表的性能基本使用语法泛型变量名是实现集合接口查看时可以发现中并没有任何特殊方法所以知己使用接口提供方法就完成集合操作集合中操作方法方式和集合中介绍方式是一样的只不过带有排重的效果可以完全参考集合中使用在中进行使用创建集合对象表面上代码操作是在创建一个集合但是实际底层操作过程中是在创建集合向集合存储的数据其实就是在想中的位置存储数据为什么要这样会做表存储数据值是以进行数据存储操作集合中可以提供形式存储只有集合提供一个空的集合对象默认容量加载因子是集合的实现类也就相当于是集合子类利用集合接口使用多态形式创建集合对象可以利用参数集合对象中存储数据初始化集合对象指定集合初始化容量大小使用默认加载因子遵守大小原则是次幂来定义的但是不要小于的次幂类型强转指定集合初始化容量大小和加载因子第二参数加载因子是类型常用向集合中添加数据是可以对存储在集合数据提供排重操作的将参数集合对象中数据存储到当前中集合对象清空集合中数据判断集合是否为空指没有任何数据而不是当前地址为判断集合中是否存在指定元素返回证明存在返回证明不存在集合对象判断集合对象中个存储数据是否存在在集合对象中因为不存在下标的概念所以是不支持普通循环的支持循环方式有增强循环不要调用集合删除方法方法普通迭代器集合只支持普通迭代器不支持增强迭代器即删除数据就调用迭代器中删除集合中数据参数是要删除的数据删除参数结合提供提供数据所在集合对象中数据集合对象保留参数集合对象中数据在集合中然后删除剩余集合中数据集合对象获取集合中存储元素的个数转换成数组集合的排重操作需求创建一个对象提供属性名字和年龄按照标准提供提供重写在提供类型在类中创建两个对象赋值为张三存储在集合中然后打印集合中数据查看是否排重如果没有排重如何处理张三张三利用中存储机制表可以存储重复数据进行排重操作底层实现是什么使用表实现的表示如何进行数据存储的使用表提供散列函数散列函数是什么这是散列函数得到结果什么得到结果什么计算存储数据所在内存中地址值是表中容量的大小默认是利用散列函数求得存储在表中位置以进行数据的存储表的排重机制是通过散列函数计算出数据存储的位置进行数据存储如果出现同一个数据计算出位置相同此时也会向存储位置进行插入存储但是要进行比较如果比较结果为就整存储位置中没有与之相同数据以链表存储如果比较结果为证明这个存储位置有与之相同数据此时就会放弃新添加的数据存从而不会进行存储数据操作那么些就是即表排重机制张三张三对象的值对象的值利用中存储机制表可以存储重复数据进行排重操作为什么存储自定类的对象到集合没有进行排重就是因为自动以类并没对对象提供同一个的实现并且在类中也没有一共方法的实现所以我们根本没有提供排重操作的原则所以向中存储自定义类的对象是无法排重如果需要向集合存储自定义类的对象并提供排重机制那么自定义类必须提供和方法的重写从写的目的在于在中认为两个对象相等是通过方决定决定原则在于类中提供属性完全或部分相等认为两个对象相等既然两个对象已经相等了那么他们的地址也要相等但是语言是无法直接操作真实内存地址的但是我们可以获取到真实内存地址映射值所以将比较相等对象的修改为相等就间接的满足真实内存地址相等当向集合存储数据时候集合底层实现是表而表有需要通过计算存数据位置只有在表存储位置相同才可能出现相同数据这样一来就需要提供相同对象地址是相同的通过这个方法将对象计算到同一个存储位置在通过方法计算相等操作触发表排重机制综上所述对这类提供和的重写操作编译器提供两个版本的和的重写这两个版本都是可以只能二选一不能共存这个版本默认版本生成和方法是最后选项中有一个这里不建议勾选这个选中给提供属性因为引用类型还是进行非判断如果你勾选在那么系统就默认认为引用类型时为值就会使用这个引用类型方法如果此时你引用类型属性被赋值必出空指针异常勾选之后选项之后提供实现没有勾选选项之后提供实现比较了地址这个地址是真实地址如果真实地址都相等必然是同一个对象如果输入对象引用地址那么必然对象不同一个方法的作用是用过字节码文件文件进行对象获取只要是同一个类创建对象他们字节码文件都是同一个唯一两个对象字节码文件都不一样必然不是同一个对象多态向下转型操作如果当前对象属性与传入对象的属性不一致返回如果相等就不做任何操作提供引用类型非判断只要当前对象的属性值不为就通过调用类方法与传入对象进行比较相等为不相等为如果对象的属性为就判断传入对象的属性是否为如果也为结果就是否则就是获取引用类值作为新的值计算使用这个值乘以引用类型值然后加上值类型属性值得到最终最大的限度保证不出现重复这个版本使用中提供工具类变化现在使用值类型比较融入到返回值比较结果中调用了工具类中方法进行引用类型比较原码实现地址相等就是同一个对象或者判断参数不为然后用调用进行比较工具类中提供方法这个方法可以计算新的值底层原理底层实现原理是没有特殊方法它的方法与中学的方法是一致的集合的遍历方式迭代器遍历的底层实现原理底层实现原理是知识点十一类特点有序无下标不可重复与父类的方法一致去重的原理也与父类一致特点有序插入顺序不重复无下标底层实现去重原理与一致知识点十二集合实现类是集合接口实现类之一它是一个特殊集合这个集合不仅可以排重而且可以对存储到集合中的数据提供升序排序在以往开发中可以利用这个特性对需要排序数据进行操作从开始集合专门提供方法方法集合也可以调用集合提供方法进行对数据排序操作但是不能排重所以学习的目的为类接触可以排序接口在文档中有说明基于的实现使用元素的自然顺序对元素进行排序或者根据创建时提供的自定义排序进行排序具体取决于使用的构造方法集合系列主要实现都是依赖于集合底层实现是底层实现是在之前底层实现的结构二叉树表从开始之后将底层实现的结构红黑树表中的使用可以完全参考集合即可其余文档中提供方法自行查看提供一个基础的使用向中存储系统提供数据类型存储数据中提供两个进行存储自动排重和排序操作默认是升序向中存储自定义类的对象根据学生年龄进行排序操作提供集合对象用于存储类的对象张三李四王五赵六田七问题使用存储系统提供数据类型时可以对数据进行排重与排序操作但是向中添加自定义类对象时并没有进行排重排序操作出现了一个异常问题原因所在当用的无参构造方法时创建集合对象该根据其元素的自然顺序进行排序插入该的所有元素都必须实现接口刚刚插入到集合中类的对象并没有实现接口所以出现知识点十三接口自然排序接口官方文档说明此接口强行对实现它的每个类的对象进行整体排序这种排序被称为类的自然排序类的方法被称为它的自然比较方法间接的说明接口是一个自然排序接口对与实现接口类会提供排序操作这个排序操作需要完成这个方法当前调用集合的无参构造方法时就要求向中存储的数据必须实现实现接口就需要实现接口中给提供方法比较此对象与指定对象的顺序这个方法使用接口上泛型作为方法参数泛型所以在实现的时候需要指定接口中泛型是什么类型这样可以避免不必要向下转型泛型如何赋值提供谁进行比较这个类型就是谁提供方法对数据进行比较时遵守的原则比较此对象与指定对象的顺序如果该对象小于等于或大于指定对象则分别返回负整数零或正整数这个方法的返回值类型时类型这个方法返回值是一个数字这个方法不建议理解为比较方法理解为交换方法即通过这个方法的得到返回值决定如何进行数据交换存储之前有接触过一些排序的操作例如冒泡选择这些手写排序但是这些排序中都会有一个必要的操作提供比较操作进行数据交换通过修改比较操作中大于号或小于号可以决定排序顺序那么接口中得到的类型数值就是决定数据如何排序需要对方法进行深入的理解万能公式这方法会返回三个值正整数负整数和一般来说自定义类中提供比较属性基本上都是系统类型就可以通过两个数据之间记性差值计算从而得到正整数负整数和类为例需要比较是年龄年龄的属性是类型用两个类型进行相减得到结果就是正整数负整数和正好满足了方法需求谁减谁可以得到什么结果如果不是基本数据类型时引用类型减也不能计算不用担心引用类型问题基本上能用来比较的引用类型都实现了所以比较引用类型调用这个引用类型中对应方法就可以需要区分当前对象和传入对象调用方法的就是当前对象使用表示对方法参数赋值的就是传入对象使用表示由此就可以得到一个万能公式当前对象传入对象得到排序结果就是升序正整数传入对象当前对象得到排序结果就是降序负整数切记的排重机制并不是和而是实现排序接口中或方法的返回值只要返回值为就会认为是同一个对象进行排重操作当前使用万能公式做计算时如果遇到得到时出现排重效果建议在得到时在提供一个排序条件操作或者使用中方法排序使用这个公式进行排序时会面临到问题问题此时排序数据类型时自定义类我们是不能使用也不可能对自定义对象排序时排序时自定义对象的属性将当前公式变形为当前对象属性传入对象属性得到排序结果就是升序正整数传入对象属性当前对象属性得到排序结果就是降序负整数问题此时排序数据类型时系统类型当前对象传入对象得到排序结果就是升序正整数传入对象当前对象得到排序结果就是降序负整数问题如果遇到是引用类型无法使用减号进行计算时当前对象传入对象得到排序结果就是升序正整数传入对象当前对象得到排序结果就是降序负整数修改类进行年龄属性排序操作比较的是类中属性值升序排序比较的是类中属性值降序排序防止出现比较结果为的时候怎么办在提供一个比较数据即可知识点十四接口自定义排序接口除了集合中可以使用接口进行自然排序之外还有一个更加灵活方便的接口在系统文档中说明强行对某个对象进行整体排序的比较函数可以将传递给方法如或从而允许在排序顺序上实现精确控制还可以使用来控制某些数据结构如有序或有序映射的顺序或者为那些没有自然顺序的对象提供排序综上所述接口不仅可以对提供排序操作而且可以针对系统提供方法进行自定义排序操作接口中的核心比较方法比较用来排序的两个参数这个方法和接口中方法是一个道理也是返回正整数负整数和代表对象大于小于和等于刚刚在中提供万能公式可以直接使用在这里是需要注意的是接口中方法有两个参数两个参数谁是当前对象谁是传入对象方法中第一个参数即就是当前对象即方法中第二个参数即就是传入对象即由此就可以得到一个万能公式当前对象传入对象得到排序结果就是升序正整数传入对象当前对象得到排序结果就是降序负整数切记的排重机制并不是和而是实现排序接口中或方法的返回值只要返回值为就会认为是同一个对象进行排重操作当前使用功能公式做计算时如果遇到得到时出现排重效果建议在得到时在提供一个排序条件操作或者算着中方法排序使用这个公式进行排序时会面临到问题问题此时排序数据类型时自定义类我们是不能使用也不可能对自定义对象排序时排序时自定义对象的属性将当前公式变形为当前对象属性传入对象属性得到排序结果就是升序正整数传入对象属性当前对象属性得到排序结果就是降序负整数问题此时排序数据类型时系统类型当前对象传入对象得到排序结果就是升序正整数传入对象当前对象得到排序结果就是降序负整数问题如果遇到是引用类型无法使用减号进行计算时当前对象传入对象得到排序结果就是升序正整数传入对象当前对象得到排序结果就是降序负整数复制类创建来进行接口操作接口对应的是中有参构造方法所以要使用进行排序就需要使用当前这个有参构造方法传入实现接口的实现类对象方可进行排序操作提供两种实现接口的方式第一种提供一个比较原则类实现接口实现方法定义排序提供一个类实现接口调用中具备接口方法参数赋值就是实现接口的对象张三李四王五赵六田七第二种方式就是使用匿名内部类或者表达式实现调用中具备接口方法参数赋值就是实现接口的对象匿名内部类版本张三李四王五赵六田七表达式张三李四王五赵六田七总结和接口现在而言不仅只有能排序集合也可以排序集合也可以排序合理规划使用排序即可这个接口值专门针对集合进行排序而设计一个接口它的局限性在于它只适合自定义类存储在进行使用其他位置提供方法是不使用作为参数属于自定义排序接口使用比较广泛除了在中可以使用之外集合中提供和中提供其他方法基本上都是使用参数类型所以这两个接口建议优先掌握接口使用广泛其次知识点十五集合总结集合是一个接口继承与接口和接口集合本身具备排重功能和存储无序集合集合主要的实现类有和所以集合接口是支持多态创建对象集合中提供可操作集合都是线程不安全所以面临多线程处理数据的时候集合的对象将一个集合对象变成线程安全集合除了这种方式之外可以使用开始提供包下提供线程集合完全类来进行操作它是集合主要实现类也是实际开发中使用比较广泛的一个类这个类的主要实现是表底层实现是创建一个对象作为的具体实现并且向存储数据时其实是向中值的位置进行数据存储构造方法添加数据的默认容量是加载因子是扩容大小是原有一倍在之前底层主要实现是表数组链表形式从开始对底层存储进行优化提供存储和查询效果将原有表进行优化数组链表或红黑树向表中如果存储数据某个存储位置中链表长度大达到的时候存储了个数据就将链表修改为红黑树从而提高查询效率存储自定义类对象时如果需要进行排重操作需要提供和重写是子类本身不具备任何特殊方法所有都是来源于接口唯一特点就是提供一个链表来记录存储顺序开发中是几乎与不用它操作可有完全仿照是集合中一个排序排重的集合这个集合使用红黑树表当使用的无参构造方法创建对象时向集合存数据这个存储的数据必须实现接口也可使用的有参构造方法方法参数是类型实现接口进行存储数据的自定义排序不是只有才可以排序和集合都可以进行排序操作但是这个俩个集合都会使用到知识点十六集合集合接口是和集合接口父接口集合接口继承接口所以和集合接口都是支持迭代器操作因为和集合接口都是集合子接口所以和集合接口的实现了可以作为集合接口的实现类使用所以支持多态创建集合接口创建对象因为是集合接口所以里面的方法都已经讲解完毕在实际开发中集合接口中最常用类是集合接口中最常用类是知识点十七工具类将集合中的元素反转将集合中的元素随机打乱将集合中的元素排序必须要实现接口大娃二娃妖怪蛇妖蛇妖按照字典顺序将集合元素进行翻转将集合中的元素进行随机打乱数组工具类集合工具类知识点十七集合集合介绍集合是两大集合之一和之间是并存关系不是的子类一般会和和这两个集合并称三大集合和因为和并没有什么关系所以集合和接口也没有任何关系所以集合是不提供迭代器操作集合在提供一种存储数据方式这种方式称之为映射键值对通过映射这种关系将将两个数据进行相连形成数据存储形式就是键值对和值不要过分纠结只要提供存储数据数据类型就可以决定值存储什么值存储什么他们在底层存储形式是以一种键值对相连的情侣映射的说明在数学中假设两个非空集合如果存在一个法则使用集合中每一个元素按照法则在集合中有一个唯一对应则成为到集合映射关系在做映射关系时提供值要求是唯一的集合中相当于存储而是唯一的所以可以想象存储的集合其实就是集合提供值是可以不唯一的集合相当于存储而是不唯一的所以可以想象存储的集合其实就是集合提供一个链接法则链接原则让集合可以和集合中进行一个链接形成一个键值对提供存储方式就是这个方法中存储大量实体存储就是相当与键值对存储了集合主要实现类与接口之间关系的主要实现接就是也是接口的最主要实现类在官方文档中说明基于哈希表的接口的实现此实现提供所有可选的映射操作并允许使用值和键除了非同步和允许使用之外类与大致相同此类不保证映射的顺序特别是它不保证该顺序恒久不变说明的主要实现使用表但是在之前使用的是原始表的形式即数组链表形式存储数据但是从开始集合提供表实现从数组链表转换为数组链表或红黑树当前向中某个桶节点即存储位置添加的数据达到个时就会将链表结构转换红黑树这个数字在链表中的查询效果是可以控制因为链表的查询方式是线性查询从前之后所以最快效率是最慢效率平均值随着值不断变大这个查询效率会逐渐降低所以在节点时将链表转换为红黑树就是为提高查询效率而是用红黑树是平衡树而且树的查询效率是倍效率集合是线程不安全集合在多线程前提现可以使用之前做法现在开发不在使用如何解决线程不安全问题得到一个线程安全集合或者使用线程安全集合集合是存储键值对形式集合所以创建对象时需要提供和的泛型的数据类型毕竟底层是表所以在中初始容量加载因子扩容方式是原有容量倍并且会重新计算所有存储在中数据存储位置即从新计算的存储位置在之前和之后有很大的变化将之前看做是基础将提供看做增强操作即可常用方法之前提供的对象创建方式创建一个空集合对象默认初始容量加载因子常用创建一个提供初始容量大小的集合对象加载因子创建一个提供初始容量大小和加载因子的对象提供的容量是的倍数加载因子不易过小将参数集合对象中存储数据赋值给当前集合对象进行存储偶尔提供常用向集合对象中添加数据第一个参数是存储的值第二个参数参数存储是值已经重写方法所以直接打印集合对象查看结果在使用方法向集合对象中添加键值对向集合添加键值对时值必须是唯一的又使用那么系统并没有提示任何语法错误信息和异常信息是否会出现运行时异常呢不会出现异常方法的第二个作用修改指定对应值当使用方法提供一个已经在集合对象中存在时将操作认为是覆盖原有已经存在集合中集合对象将参数集合对象中存储的数据赋值给集合将集合中存储数据清空对象的引用是保留判断集合中是否有存储数据存储数据返回没有存储返回判断集合中是否存在指定值存储返回不存在返回判断集合中是否存在指定值存储返回不存在返回获取存储在集合值时存在会得到对应不存在会得到值参数值建议添加非判断将存储在集合中键值对删除条件是一个值获取集合中存储元素的个数集合遍历方式比较麻烦没有迭代器不支持普通循环遍历不支持增强获取集合中所有的值存储在一个集合中通过这种方式获取到所有获取集合中所有的值存储在一个集合中通过这种方式获取到所有值提供了一种遍历方式方法返回值是一个集合集合存在一个泛型类型集合中存储的数据类型相当类型中存储数据是类型和类型通过这个方法返回一个集合这个集合存储这个的类型类型的内部存储的是兼职对提供集合之增强循环遍历就得到了存储在集合中键值对即的值是的值是在中时提供一个方法可以便捷遍历集合中和集合中值集合汇总这个方法被出触发时可以获取集合中每一对这个可以进行操作但是只是打印的结果不会影响最终集合中的结果常用方法之后提供基础之后提供的对象创建方式创建一个空集合对象默认初始容量加载因子常用新中方法向集合中添加数据如果已经存在则不添加否则添加数据建议向集合存储数据使用提供了一个全系列对集合中和进行存储的方法方法集合中指定在集合进行操作执行原理无论是否存在都会执行参数中提供表达式如果值存在后面提供表达式就会取出所对应并在表达式中进行操作然后修改原有和值如果值不存在后面提供表达式就会将进行存到集合操作第一个参数就是值第二个参数就是提供操作对应表达式判断集合是否存在提供对应操作执行原理如果存在后面提供表达式就不会执行并返回对应值如果不存储后面提供表达式就会执行操作者并将表达式中处理之后值与一起存储到集合中表达式是你如何处理这个操作你自己决定但是一定要返回这个即添加第一个参数就是值第二个参数就是提供操作对应表达式判断集合是否存在提供对应操作执行原理如果存在就执行后表达式并修改集合所对应值如果不存在就不会执行后面表达式不会像集合中做任何操作但是方法会返回一个第一个参数就是值第二个参数就是提供操作对应表达式相当于你调用在调用得到之后进行操作在调用这个存储回去这个方法作用是通过值获取对应这个方法根方法最大区别在于这个方法提供一个默认值如果不存在则返回对应默认值存在则返回值方法在则返回不在则返回值第一个参数是值第二个参数是默认值合并方法含义对存在在集合中键值对进行更新操作更新值第一个参数是集合存在值第二个参数这个参数的作用是向表达式中提供方法参数中第二个参数赋值即第三个参数需要对存在在集合所对应所提供更新数据操作提供一个中第一个参数即是获取出提供所对应的值第二个参数即或获取方法中第二个参数值提供这两个参数计算更新所对应值删除方法根据提供和值进行删除如果存在在中删除成功返回如果不存在删除失败返回中提供一个操作官方文档意思在于使用这个方法替代方法修改操作根据值替换存储对应值如果存在则替换不存在则不替换多参数版本提供完整键值对进行替换操作如果和匹配成功存在则替换不存在则替换第一个参数是值第二个参数是对应原理的值第三个参数是新替换值只要满足表达式提供替换条件就会将值进行替换提供替换操作者条件提供替换操作需要将替换的值提提供返回打印方法有一个子类这个集合操作方式和是一样只不过就是存储结构有所变化多了一个链表存储已经不在使用了所以这个执行查看和操作一样的集合之集合集合是集合实现类之一集合提供排序操作集合排序操作和道理相同的需要提供和接口根据使用中构造方法决定说那个那个接口来实现排序操作在官方的文档中的介绍基于红黑树的实现该映射根据其键的自然顺序进行排序或者根据创建映射时提供的进行排序具体取决于使用的构造方法集合的排序点在于存储的键值将要排序数据存储到中就可以进行排序操作当调用无参构造方法创建对象时使用进行的比较操作使用键的自然顺序构造一个新的空的树映射当调用有参构造方法创建对象时使用进行的比较操作构造一个新的空的树映射该映射根据给定比较器进行排序集合排序的时候也是会对值进行排重操作这个排重操作依据是提供和接口中方法实现时如果结果为就会进行排重操作工具类工具类类似于工具类工具类是为了给集合提供便捷操作工具类虽然集合已经提供很多方法了但是工具类也提供一些操作方法弥补开发时所需要自行定义方法工具类提供方法大部分都是给集合使用极少部分是给集合使用一次性向集合对象中添加多个数据推荐向集合中存这些数据不用上面这样麻烦操作了直接使用方法就可以了这个方法的第一个参数是集合对象第二个参数就是要存储值使用分隔即可提供集合排序操作针对是集合默认是升序排序操作要去排序数据要么实现要么实现可以使用工具类中提供静态方法进行降序排序仅针对集合中存储系统引用类型有效指针对系统类型自定义排序操作从开始集合接口提供方法所以可以直接调用集合的方法进行排序操作将和集合转换为线程安全的集合提供二分查找要排序数据找到下标找不到负数交换集合存储元素的位置位置参数是下标第一个元素和最后一个元素互换打乱集合对象中存储数据的顺序将有序存储数据打乱存储向集合中填充同一个数据集合和集合的总结是集合框架中根接口也是和集合的父接口集合接口也继承接口所有系的集合都支持迭代器进行遍历操作在集合接口中常用的就是和接口和接口中常用的实现类集合允许存储重复数据并且使用数组实现和不允许存储重复数据并且使用表实现集合本身没是不在范围内容它是一个独立的集合提供一种键值对即的形式进行数据存储操作在存储数据时要求值必须是唯一的值可以不唯一在集合接口中主要使用实现类是集合使用集合使用集合使用应用可以使用表示一个实体类可以使用表示一个实体类集合在一个用户对象一个用户对象多个用户对象以前现在在实战开发中如果这个类使用不多那么这个时候就没有必要创建一个类可以使用来代替一个用户对象多个用户对象底层实现原理的过程原码流程表示存放节点的数据表示当前节点表示长度表示节点在数组中的下标判断数组如果为空或者数组长度为那么就对数组进行扩容数组默认初始大小为将数组的长度与值进行与运算计算的结果一定是数组长度得到元素应该存放的下标如果当前下标位置为空那么直接将节点存放在当前位置如果当前位置不为空分为三种情况情况要添加的元素与当前位置上的元素相同一致则直接替换情况如果要添加的元素是红黑树节点那么将其添加到红黑树上情况如果要添加的元素是链表则需要遍历将当前元素的下一个节点赋给如果为空则创建新的元素节点放在当前位置的下一个元素上并退出循环如果链表的元素个数大于个且当数组中的元素个数大于则将其转换成红黑树要添加的元素与当前位置上的元素相同一致则直接退出循环如果返回的不为将的值赋给返回以前的值当添加的元素已经存在返回的是以前的值如果数组的元素个数大于阈值则进行扩容过程原码扩容流程表示原来数组如果是第二次扩容长度为的那个表示原数组的容量长度表示数组原来的阈值新数组的容量新数组的阈值新数组的容量扩大一半新阈值扩大老阈值的一半创建一个长度为的数组指向新数组将原数组中的元素拷贝到新数组中如果当前位置元素不为空情况当前位置上的下一个元素为空则直接将这个元素拷贝到新数组中情况当前位置上的元素红黑树类型则需要进行切割情况当前位置上的元素链表类型则需要进行分散拷贝的过程原码当前与要找到的和都相等直接返回当前这个元素如果当前不为空有两种情况当前位置是一个红黑树根据从红黑树上找到对应的元素当前位置是一个链表循环进行比较直到找到向的和的元素并返回如果数组的为空数组的长度为当前下标位置上的值为这三种情况都返回知识点十八常见的集合面试面试题简述的区别简述的去重原理底层实现的区别底层实现原理扩容机制的数组容量为什么是的次方数的负载因子为什么是添加元素的过程谈谈了解的数据结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-04 10:13:16',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="星仔极客" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">星仔极客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 小伙伴</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://link3.cc/xinzai_x"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 个人资源</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="http://ainm.cc/c/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐网</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 常用文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://68565200.xyz/post/1f293ccb"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 资源搜索</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/32%E5%8D%95%E7%89%87%E6%9C%BA/" style="font-size: 1.05rem;">32单片机<sup>12</sup></a><a href="/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/" style="font-size: 1.05rem;">51单片机<sup>8</sup></a><a href="/tags/CubeIDE%E4%B8%8ECubeMX%E8%BD%AF%E4%BB%B6%E8%AE%BE%E7%BD%AE/" style="font-size: 1.05rem;">CubeIDE与CubeMX软件设置<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">C语言<sup>13</sup></a><a href="/tags/Java%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">Java语言<sup>12</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>5</sup></a><a href="/tags/MySQL/" style="font-size: 1.05rem;">MySQL<sup>3</sup></a><a href="/tags/RT-Thread/" style="font-size: 1.05rem;">RT-Thread<sup>6</sup></a><a href="/tags/Win11%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/" style="font-size: 1.05rem;">Win11相关设置<sup>1</sup></a><a href="/tags/springboot%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/" style="font-size: 1.05rem;">springboot相关配置<sup>1</sup></a><a href="/tags/ubuntu%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/" style="font-size: 1.05rem;">ubuntu相关设置<sup>1</sup></a><a href="/tags/%E4%BA%91%E5%9B%BE%E5%BA%8A/" style="font-size: 1.05rem;">云图床<sup>1</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2CDN%E8%A7%A3%E6%9E%90/" style="font-size: 1.05rem;">博客CDN解析<sup>1</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/" style="font-size: 1.05rem;">博客搭建相关<sup>1</sup></a><a href="/tags/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">图片压缩在线工具<sup>1</sup></a><a href="/tags/%E5%B0%8F%E7%8B%BC%E6%AF%AB%E8%BE%93%E5%85%A5%E6%B3%95/" style="font-size: 1.05rem;">小狼毫输入法<sup>1</sup></a><a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 1.05rem;">插件<sup>1</sup></a><a href="/tags/%E8%90%A5%E4%B8%9A%E6%89%A7%E7%85%A7/" style="font-size: 1.05rem;">营业执照<sup>1</sup></a><a href="/tags/%E8%B5%84%E6%BA%90%E6%90%9C%E7%B4%A2/" style="font-size: 1.05rem;">资源搜索<sup>1</sup></a><a href="/tags/%E9%B8%BF%E8%92%99NEXT%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/" style="font-size: 1.05rem;">鸿蒙NEXT应用开发<sup>4</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">16</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">10</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">21</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E8%AF%AD%E8%A8%80/" itemprop="url">Java语言</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Java%E8%AF%AD%E8%A8%80/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Java语言</span></a></span></div></div><h1 class="post-title" itemprop="name headline">5.集合</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-12-30T05:09:59.000Z" title="发表于 2023-12-30 13:09:59">2023-12-30</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-11-04T02:13:16.196Z" title="更新于 2024-11-04 10:13:16">2024-11-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为揭阳"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>揭阳</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://xinzaigeek.68565200.xyz/post/9e25cba9.html"><header><a class="post-meta-categories" href="/categories/Java%E8%AF%AD%E8%A8%80/" itemprop="url">Java语言</a><a href="/tags/Java%E8%AF%AD%E8%A8%80/" tabindex="-1" itemprop="url">Java语言</a><h1 id="CrawlerTitle" itemprop="name headline">5.集合</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">星仔极客</span><time itemprop="dateCreated datePublished" datetime="2023-12-30T05:09:59.000Z" title="发表于 2023-12-30 13:09:59">2023-12-30</time><time itemprop="dateCreated datePublished" datetime="2024-11-04T02:13:16.196Z" title="更新于 2024-11-04 10:13:16">2024-11-04</time></header><h1><center>知识点一：集合框架</center></h1>
<h2 id="center-1-概念-center"><center>1、概念</center></h2>
<p>    如果处理一套通用逻辑就提供一个自定义封装处理数组的类，那么开发中可能会需要提供N这样类，问题在于需要自行完成操作，Java也发现这个问题，所有为了让程序猿可以更加的便捷的对数据进行操作，无需向数组一样提供【增删改查】的自定义实现，Java提供一个集合框架，便于程序猿对数据进行存储与管理操作</p>
<p>什么是集合框架？</p>
<p>    Java中的集合框架其实就是对【数据结构】的封装，这个封装中提供了一些常用方法，可方便操作数据，无需程序猿自定定义操作，只需要调用封装方法就可以完成对存在集合中数据【增删改查】集合其实就是对数据结构一种封装，所以之前sun公司就把集合放置到一个统一包中进行管理【java.util】包</p>
<p>什么是数据结构？</p>
<p>    数据结构其实就是计算机，组织和存储数据形式</p>
<p>    数据结构是指相互之间存在一种或多种特定关系的数据集合</p>
<p>    通常情况下，精心选择数据结构可以带来更加高效运行和存储效率，数据结构往往高效的原因在于【检索算法】和【索引计数】</p>
<p>    常见数据结构：【数组、栈、链表(单向和双向)、哈希表、队列(单向和双向)、堆、树、图】</p>
<p>    Java的集合框架其实就是对【数据结构实现】，我们需要掌握就是如何操作这个数据结构（即操作集合中方法），高效存储与处理数据</p>
<p>PS：根据不同数据结构，操作数据性能是不同（有地查询块、有的插入快、有地允许重复、有的不允许重复等等），在开发中只要选择合理数据结构即集合对数据存储与操作即可</p>
<p>推荐： 后期可以看一本书【大话数据结构】 —》兄弟 ----》【大话设计模式】</p>
<h2 id="center-2-集合架构-center"><center>2、集合架构</center></h2>
<p>PS：习惯性说Java中集合有三大框架【List、Set和Map】</p>
<p>如果详细说明的话应该2个框架3个实现：</p>
<p>    2个框架： Collection 和 Map</p>
<p>    3个实现 ：Collection这个集合下两个主要实现 List 和 set 所以称为三大集合List、set 和Map</p>
<p>集合和数组最大区别在于：</p>
<ol>
<li>集合中只能存储引用类型即对象</li>
<li>集合是一个变长容量，根据集合存储元素个数动态进行删减【扩容和减容】</li>
<li>数组是一个定长容器，创建大小数固定，无论存储多少数据长度都是唯一</li>
</ol>
<p>常见三大集合框架：</p>
<ol>
<li>List【列表】：集合中存储对象是按照索引位置进行存储，允许存储重复数据</li>
<li>Set【集】: 集合中存储对象不是按照特定方式进行存储，不允许出现重复数据</li>
<li>Map【映射】：集合中每一个存储元素都是以一种【键值对keyvalue】方式进行存储的，以一种key和value的形式存储的，key这个对象是不允许重复【唯一性】，value是允许重复</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271930400.WebP" alt="列表、集合、映射图" style="zoom: 33%;">
<p>无论什么时候都要先创建Collection对象</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271930293.WebP" alt="集合"></p>
<h2 id="center-3-list集合-center"><center>3、List集合</center></h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271930586.WebP" alt="List集合"></p>
<h1><center>知识点二：List集合之ArrayList集合</center></h1>
<h2 id="center-1-分析arraylist的效率-center"><center>1、分析ArrayList的效率</center></h2>
<p>因为ArrayList使用是数组实现所以可以得到如下以下特点：</p>
<ol>
<li>保存操作：</li>
</ol>
<p>    把一个数据保存到ArrayList中，最快的操作只要操作一次即可，最慢的操作可能操作N次</p>
<p>    平均执行效率(N+1)/2次 —》扩容问题</p>
<ol start="2">
<li>删除操作:</li>
</ol>
<p>删除ArrayList中某个数据，最快的只要操作一次即可， 最慢的操作可能操作N次</p>
<p>平均执行效率(N+1)/2次 —》减容问题</p>
<ol start="3">
<li>
<p>修改操作: 操作一次即可</p>
</li>
<li>
<p>查询操作：根据索引一次即可。如果遍历查询使用【检索算法】做优化效率高度，如果遍历从到为【顺序查找】效率是低</p>
</li>
</ol>
<p>因为ArrayList使用是数组的形式进行存储数据操作，所以基于这样数据结构做查询和修改效率是高，但是做增加和删除效率是低【动态扩容和减容】</p>
<h2 id="center-2-语法-center"><center>2、语法</center></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;泛型&gt; 变量名 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h2 id="center-3-常用方法-center"><center>3、常用方法</center></h2>
<p>1）向指定下标位置添加一个元素,下标范围：0~list.size	list.size：有多少个元素</p>
<p>    变量名.add(指定下标数,添加的元素);</p>
<p>2）移除指定下标位置的元素,下标范围：0~list.size-1</p>
<p>    变量名.remove(指定下标数);</p>
<p>3）修改指定下标位置的元素,下标范围：0~list.size-1</p>
<p>    变量名.set(指定下标数,修改元素内容);</p>
<p>4）获取指定下标位置上的元素，下标范围：0~list.size-1</p>
<p>    变量名.get(指定下标数)</p>
<p>    返回值为对应的数据类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.UnaryOperator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListAPIDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供ArrayList集合对象进行数据的存储操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1.ArrayList集合提供一个无参构造方法可以创建一个空的集合对象</span></span><br><span class="line"><span class="comment">            --&gt;空指定的是集合没有存储任何数据，但是集合引用是在的</span></span><br><span class="line"><span class="comment">            在Java7，使用new ArrayList无参构造方法创建对象，一个元素都不存储</span></span><br><span class="line"><span class="comment">            依旧会在堆中开辟一个大小为10的数据空间，并且数组的默认存储数据类型时Object</span></span><br><span class="line"><span class="comment">            在Java8中，Java开发人员发现，如果在使用ArrayList集合之前，如果使用无参构造方法</span></span><br><span class="line"><span class="comment">            创建ArrayList集合对象会出现一个10大小的堆中数组空间，这样会造成一定量的空间浪费</span></span><br><span class="line"><span class="comment">            所以在Java8中提供一个全新优化，使用 new ArrayList无参构造方法创建ArrayList对象时</span></span><br><span class="line"><span class="comment">            并不会创建一个大小为10数组在堆中进行存储，而是创建创建一个空的数组进行空间的开辟</span></span><br><span class="line"><span class="comment">            private static final Object[]</span></span><br><span class="line"><span class="comment">            DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span></span><br><span class="line"><span class="comment">            当通过集合对象调用集合集合中提供add方法时，此时才会真正的初始化数组空间</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//2.ArrayList集合使用其他的Collection集合对象中存储数据</span></span><br><span class="line">        作为新的集合中存储数据进行初始化</span><br><span class="line">        <span class="comment">//即将参数中Collection集合对象数据存储到新建ArrayList集合中</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(list);</span><br><span class="line">        <span class="comment">//3.自定义ArrayList集合的底层数组初始化容量 --》【使用较少】</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//常用API</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.向集合对象中添加元素【存储数据】 ---》 集合只能存储引用</span></span><br><span class="line">        类型即对象</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            集合中只能存储引用类型 --&gt; 明显调用add时存储的是1,2,3,4,5 int类型数据</span></span><br><span class="line"><span class="comment">            可以存储的，因为向集合中存储基本数据类型时，完成自动转换操作 --》将基本数据类型 转换为对应 包装类</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        list.add(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        <span class="comment">//集合在没有使用泛型之前是可以存储任何引用类型对象,因为方法参数类型时Object</span></span><br><span class="line">        <span class="comment">//ArrayList集合重写toString，所以可以直接打印集合对象查看集合内容</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.向集合中指定位置添加元素数据【第一个参数是下标位置，第二个参数是存储的元素】</span></span><br><span class="line">        list.add(<span class="number">2</span>,<span class="number">100</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.向集合中添加参数集合中数据到集合中进行存储</span></span><br><span class="line">        <span class="comment">//PS：参数是一个Collection集合，所以只要是List或Set集合实现类都是传递到这个参数中</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list1_1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list1_1.add(<span class="number">1</span>);</span><br><span class="line">        list1_1.add(<span class="number">2</span>);</span><br><span class="line">        list.addAll(list1_1);    <span class="comment">//将list1_1集合里面的数据存储到list集合中</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//addAll有一个重载在指定位置中添加添加参数集合数据 addAll(下标, Collection集合对象);</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            特别注意： add 和 addAll的区别</span></span><br><span class="line"><span class="comment">            add这个方法是向集合中添加引用类型对象，即向集合集合添加地址</span></span><br><span class="line"><span class="comment">            addAll这个方法是向集合中添加参数中集合数据</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList1.add(<span class="number">1</span>);</span><br><span class="line">        arrayList1.add(<span class="number">2</span>);</span><br><span class="line">        System.out.println(arrayList1);</span><br><span class="line">        arrayList2.add(<span class="number">3</span>);</span><br><span class="line">        arrayList2.add(<span class="number">4</span>);</span><br><span class="line">        arrayList1.add(arrayList2);    <span class="comment">//相当于将arrayList2中引用存储到arrayList1这个集合中，存储是对象即地址</span></span><br><span class="line">        System.out.println(arrayList1);</span><br><span class="line">        arrayList1.addAll(arrayList2);    <span class="comment">//相当于将arrayList2中存储数据存储到arrayList1这个集合中，存储的是数据内容</span></span><br><span class="line">        System.out.println(arrayList1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.清空集合中存储的数据，但是集合引用不会消失，消失的是集合数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;没有清空之前arrayList1中的数据是：&quot;</span>+arrayList1);</span><br><span class="line">        arrayList1.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;清空之后arrayList1中的数据是：&quot;</span>+arrayList1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.判断集合否为空，即判断集合是都没有存储任何数据 [true空/false不空]</span></span><br><span class="line">        System.out.println(arrayList1.isEmpty());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6.判断集合中是否存在指定元素【判断集合中是否存储在这个对象】 --&gt; true存在 false不存在</span></span><br><span class="line">        System.out.println(list.contains(<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7.判断集合中是否存在参数集合中数据 ---》这方法不是</span></span><br><span class="line">        ArrayList独有的而是List接口提供</span><br><span class="line">        System.out.println(list.containsAll(list1_1));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//8.通过集合中存储元素下标获取集合中元素 ---》【下标不要越界范围（0~集合存储元素个数-1）】</span></span><br><span class="line">        System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//9.查询集合中是否存在指定元素并返回下标【只会返回第一次遇到元素的下标】</span></span><br><span class="line">        <span class="comment">// 找到了就是下标 找不到就是负数</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//list.lastIndexOf(查找的数据) --》查询集合中是否存在指定元素并返回下标【从后向前寻找】</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10.集合是提供真正删除操作 ---&gt; 进行减容操作</span></span><br><span class="line">        <span class="comment">//10.1 根据数据删除集合中存在数据</span></span><br><span class="line">        list.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10.2 根据下标删除集合中数据</span></span><br><span class="line">        list.remove(<span class="number">6</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10.3 List集合接口提供方法 removeAll</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list1_2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list1_2.add(<span class="number">2</span>);</span><br><span class="line">        list1_2.add(<span class="number">100</span>);</span><br><span class="line">        list1_2.add(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//根据参数集合提供数据在当前集合进行删除操作</span></span><br><span class="line">        list.removeAll(list1_2);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10.4 List集合接口提供方法 retainAll</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list1_3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list1_3.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//根据参数集合提供数据保留当前集合中存储的数据，剩余的数据进行删除</span></span><br><span class="line">        list.retainAll(list1_3);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10.5 在java8中ArrayList提供一个新的处理集合删除方法removeIf</span></span><br><span class="line">        <span class="comment">//这个方法参数支持 Lambda表达式 和 匿名内部类方式处理</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list1_4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list1_4.add(<span class="number">1</span>);</span><br><span class="line">        list1_4.add(<span class="number">2</span>);</span><br><span class="line">        list1_4.add(<span class="number">3</span>);</span><br><span class="line">        list1_4.add(<span class="number">5</span>);</span><br><span class="line">        list1_4.add(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        list1_4.removeIf(<span class="keyword">new</span> <span class="title class_">Predicate</span>()&#123;</span><br><span class="line">        <span class="comment">//需要在这个方法方法执行删除规则 结果true就会进行删除操作</span></span><br><span class="line">        <span class="comment">//参数Object 中o会获取到集合每一个元素的值</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Object o)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Integer)o)%<span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//lambda表达式</span></span><br><span class="line">        list1_4.removeIf(o-&gt; ((Integer)o)%<span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">        System.out.println(list1_4);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//11.Java8中提供一个全新的方法【支持lambda表达式和匿名内部类】</span></span><br><span class="line">        <span class="comment">//根据指定规则进行元素的替换操作</span></span><br><span class="line">        list1_4.replaceAll(<span class="keyword">new</span> <span class="title class_">UnaryOperator</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//指定当前替换规则的方法，方法参数Object中o会获取到所有集合中数据</span></span><br><span class="line">            <span class="comment">//需要在方法内部提供替换规则，返回的是替换之后需要存在集合中数据</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">apply</span><span class="params">(Object o)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> o.equals(<span class="number">3</span>) ? <span class="number">30</span> : o;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        list1_4.replaceAll(o-&gt;o.equals(<span class="number">3</span>) ? <span class="number">30</span> : o);</span><br><span class="line">        System.out.println(list1_4);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//12. 修改【替换】集合中指定位置的数据 ---》第一个参数是下标，第二个参数修改数据</span></span><br><span class="line">        list1_4.set(<span class="number">0</span>,<span class="number">10000</span>);</span><br><span class="line">        System.out.println(list1_4);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//13.获取集合中存储元素个数【集合长度】</span></span><br><span class="line">        System.out.println(list1_4.size());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//14.将集合转换为数组</span></span><br><span class="line">        Object[] objects = list1_4.toArray();</span><br><span class="line">        <span class="comment">//PS：数组中也提供一个方法【Arrays】，将数组转换为List集合</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">objects1</span> <span class="operator">=</span> Arrays.asList(objects);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//15.【不太推荐】 截取指定范围内容集合数据得到一个新的集合</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList1_5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList1_5.add(<span class="number">1</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">2</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">3</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">4</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">5</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">6</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">7</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">//包括前不包括后 包括开始位置，不包括结束位置，参数都是下标</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> arrayList1_5.subList(<span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点三：List集合三种遍历方式</center></h1>
<h2 id="center-普通for循环-center"><center>普通for循环</center></h2>
<p>PS：因为ArrayList的底层实现是数组，所以支持数组中提供下标进行</p>
<p>对ArrayList进行操作</p>
<p>语法格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; 集合对象.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">    循环变量i值就是ArrayList集合下标变量，<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> 定义下标初始值</span><br><span class="line">    ArrayList它获取集合长度使用 size() 方法</span><br><span class="line">    通过ArrayList集合提供get方法或set方法对集合数据进行</span><br><span class="line">取值与赋值操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特点：因为这里操作的是下标，所以可以利用下标对集合数据进行【增删改查】操作</p>
<h2 id="center-增强for循环-foreach循环-center"><center>增强for循环【foreach循环】</center></h2>
<p>PS：因为ArrayList的底层实现是数组，所以支持数组中提供下标进行对ArrayList进行操作</p>
<p>语法格式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(集合中存储元素的类型 变量名 : 集合名)</span><br><span class="line">&#123;</span><br><span class="line">    通过操作局部变量就可以操作集合中数据了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：之前在学习数组的时候说过，数组遍历方式有两种一种普通for循环，一种是增强for循环，增强for循环只能使用在数组或集合中，在数组使用增强for循环它的实现原码是将数组值赋值给局部变量，所以对与增强for循环中局部变量修改是不会影响到数组，增强for循环适合简单数据运算、分支判断和打印数组中数据</p>
<p>特点：集合中增强for循环和数组中增强for循环同样效果，支持数组进行简单数据运算、分支判断和打印集合中数据，【但是不支持对集合中数据进行修改操作，也不允许在增强for循环中调用集合删除方法进行数据删除】，如果一旦删除就会出现一个【并发迭代修改异常 --》ConcurrentModificationException】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionForeach</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);    </span><br><span class="line">        list.add(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;cxk&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;尼古拉斯&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//List集合遍历方式1：使用迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.提供一个ArrayList集合对象</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line">        arrayList.add(<span class="number">2</span>);</span><br><span class="line">        arrayList.add(<span class="number">3</span>);</span><br><span class="line">        arrayList.add(<span class="number">4</span>);</span><br><span class="line">        arrayList.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//提供一个普通for循环操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;arrayList.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获取存储的数据</span></span><br><span class="line">            System.out.println(arrayList.get(i));</span><br><span class="line">            <span class="comment">// 通过下标对集合中数据进行修改</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">2</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                arrayList.set(i, <span class="number">100</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//通过下标进行数据删除操作 ---》 支持全套删除</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arrayList.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//增强for循环</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(Object obj : arrayList)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//obj中就会存储这个集合中所有数据</span></span><br><span class="line">            System.out.println(obj);<span class="comment">//打印集合数据</span></span><br><span class="line">            <span class="comment">//判断集合中数据做什么操作</span></span><br><span class="line">            <span class="keyword">if</span>(obj.equals(<span class="number">3</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//操作代码</span></span><br><span class="line">                System.out.println(obj);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//数据类型是可以做计算</span></span><br><span class="line">            sum += ((Integer)obj);</span><br><span class="line">            <span class="comment">//需要注意set方法无法使用，因为set第一个参数是下标</span></span><br><span class="line">            <span class="comment">//不能使用集合中删除方法，即在增强for循环中是不允许调用</span></span><br><span class="line">            删除方法的</span><br><span class="line">            <span class="keyword">if</span>(obj.equals(<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                arrayList.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>提供增强for循环的原码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> arrayList.iterator();</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!iterator.hasNext())</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">    <span class="keyword">if</span> (obj.equals(Integer.valueOf(<span class="number">3</span>)))</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">    sum += ((Integer)obj).intValue();</span><br><span class="line">    <span class="keyword">if</span> (obj.equals(Integer.valueOf(<span class="number">1</span>)))</span><br><span class="line">    arrayList.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>));</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"><span class="string">&quot;增强for循环之所以不可以删除,原因就是在于增强for循环即foreach底层实现就是一个迭代器，</span></span><br><span class="line"><span class="string">迭代器中是不允许使用集合中删除方法进行数据删除的，如果删除ConcurrentModificationException就出现这个异常&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="center-foreach方法遍历-center"><center>foreach方法遍历</center></h2>
<p>foreach是Java8中提供一个新增的方法，主要是以一个方法形态可以遍历打印集合中数据，因为这个方式Java8中提供，所以这个方法支持lambda表达式和匿名内部类实现</p>
<p>PS: 这个方法主要就是用于打印，其他方式较少</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8ForArrayList</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供一个ArrayList集合对象</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line">        arrayList.add(<span class="number">2</span>);</span><br><span class="line">        arrayList.add(<span class="number">3</span>);</span><br><span class="line">        arrayList.add(<span class="number">4</span>);</span><br><span class="line">        arrayList.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//方法内部可以指定打印效果</span></span><br><span class="line">        <span class="comment">//匿名内部类的形式</span></span><br><span class="line">        arrayList.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这个方法中就是咱们打印集合中数据的形式</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Object o)</span> &#123;<span class="comment">//Object类型o参数</span></span><br><span class="line">            可以获取到集合每一个数据</span><br><span class="line">            System.out.println(o);</span><br><span class="line">            <span class="comment">//提供一些判断打印效果，根据具体需求来，这个方法没</span></span><br><span class="line">            有返回值，所以打印效果是不会影响实际存储数据的</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//Lambda表达式实现</span></span><br><span class="line">        arrayList.forEach(o -&gt; System.out.println(o));</span><br><span class="line">        <span class="comment">//提供Lambda中方法引用操作</span></span><br><span class="line">        arrayList.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点四：ArrayList底层实现原理</center></h1>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271931515.WebP" alt="ArrayList底层实现原理" style="zoom: 50%;">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListDemo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1、构造方法初始化一个长度为0的Object数组</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * ArrayList底层的元素是数组</span></span><br><span class="line"><span class="comment">         * add方法的原理</span></span><br><span class="line"><span class="comment">         * 1、当第一次添加元素的时候，初始化一个长度为10的数组</span></span><br><span class="line"><span class="comment">         *  当添加元素超过数组的长度的时候，会对数组进行扩容，扩容到1.5倍</span></span><br><span class="line"><span class="comment">         * 2、将当前的元素添加到数组指定的下标位置上</span></span><br><span class="line"><span class="comment">         *    elementData[size++] = e;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *数组数据结构的特点：增删慢，查询快</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点五：迭代器</center></h1>
<p>Java中专门针对Collection集合提供了一种遍历方式，这种遍历方式是根据Iterable接口来决定，只要是Collection的集合接口在子接口基本上都会具备Iterable这个接口，这个接口中主要提供一个方法</p>
<table>
<thead>
<tr>
<th>Iterator</th>
<th>iterator() 返回按适当顺序在列表的元素上进行迭代的迭代器</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>这个方法会返回一个按照集合顺序并存储集合数据的一个迭代器对象</td>
</tr>
</tbody>
</table>
<h2 id="center-1-迭代器原理-center"><center>1、迭代器原理</center></h2>
<p>迭代是重复反馈过程的活动,其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”,而每一次迭代得到的结果会作为下一次迭代的初始值</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291911167.WebP" alt="原理" style="zoom: 50%;">
<h2 id="center-2-获取迭代器对象-center"><center>2、获取迭代器对象</center></h2>
<p>Iterator 变量名 = Collection的变量名.iterator();</p>
<h2 id="center-3-迭代器的三个方法-center"><center>3、迭代器的三个方法</center></h2>
<p>（1）判断迭代器是否有下一个元素</p>
<p>    变量名.hasNext();</p>
<p>    返回值boolean类型</p>
<p>（2）获取当前游标对应元素并将游标向后移动一位</p>
<p>    变量名.next()</p>
<p>    返回迭代的下一个元素</p>
<p>（3）移除当前迭代器上对应的元素</p>
<p>    变量名.remove();</p>
<p>    说明：可以利用Iterator中提供三个核心方法操作迭代器影响集合中数据</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292037504.WebP" alt="迭代器方法" style="zoom:50%;">
<p>PS： 迭代器中在没有使用泛型之前，next方法的返回值类型都是统一Object，所以将方法中返回E看做是Object即可，迭代器提供自身remove方法，所以在迭代器中删除数据时要调用迭代器提供remove，而不是集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorArrayList</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//基础迭代器</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line">        arrayList.add(<span class="number">2</span>);</span><br><span class="line">        arrayList.add(<span class="number">3</span>);</span><br><span class="line">        arrayList.add(<span class="number">4</span>);</span><br><span class="line">        arrayList.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//需要使用ArrayList集合对象调用iterator方法获取迭代器对象</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> arrayList.iterator();</span><br><span class="line">        <span class="comment">//利用迭代器对象调用hasNext进行操作判断迭代器中是否还存在下一个元素</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        while(iterator.hasNext())</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            //通过next方法获取迭代器中数据</span></span><br><span class="line"><span class="comment">            System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//迭代器使用问题--》删除数据</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> ((Integer) iterator.next());</span><br><span class="line">            <span class="keyword">if</span> (integer.equals(<span class="number">2</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//删除掉2这个值</span></span><br><span class="line">                <span class="comment">//iterator.remove();//使用迭代器中提供删除[删除迭代器中存储数据的同时会删除集合中对应数据]</span></span><br><span class="line">                <span class="comment">//千万不要调用集合中提供删除方法</span></span><br><span class="line">                <span class="comment">//ConcurrentModificationException --&gt; 就会出现并发迭代修改异常</span></span><br><span class="line">                </span><br><span class="line">                arrayList.remove(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-4-强化迭代器-center"><center>4、强化迭代器</center></h2>
<p>强化迭代器只有List集合具备，专门为List集合提供一个增强迭代器，因为原始迭代器中只有三个方法，不利于对集合数据的操作，增强迭代器就新增多个方法进行迭代器操作</p>
<p>ListIterator是List集合在Iterator迭代器接口之上提供一个更多方法操作的迭代器，ListIterator在原始迭代器基础上增加，新增数据，修改数据，从后向前遍历【获取数据】的操作，还可以获取下标</p>
<table>
<thead>
<tr>
<th>void</th>
<th>add(E e) 将指定的元素插入列表（可选操作）</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>hasNext() 以正向遍历列表时，如果列表迭代器有多个元素，则返回 true （换句话说，如果 next 返回一个元素而不是抛出异常，则返回 true ）</td>
</tr>
<tr>
<td>boolean</td>
<td>hasPrevious() 如果以逆向遍历列表，列表迭代器有多个元素，则返回 true</td>
</tr>
<tr>
<td>void</td>
<td>add(E e) 将指定的元素插入列表（可选操作）</td>
</tr>
<tr>
<td>E</td>
<td>next() 返回列表中的下一个元素</td>
</tr>
<tr>
<td>int</td>
<td>nextIndex() 返回对 next 的后续调用所返回元素的索引</td>
</tr>
<tr>
<td>E</td>
<td>previous() 返回列表中的前一个元素</td>
</tr>
<tr>
<td>int</td>
<td>previousIndex() 返回对 previous 的后续调用所返回元素的索引</td>
</tr>
<tr>
<td>void</td>
<td>remove() 从列表中移除由 next 或 previous 返回的最后一个元素（可选操作）</td>
</tr>
<tr>
<td>void</td>
<td>set(E e) 用指定元素替换 next 或 previous 返回的最后一个元素（可选操作）</td>
</tr>
</tbody>
</table>
<p>PS：在没有使用泛型之前，方法所有使用E的部分都看做是Object类型即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListIteratorArrayList</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//基础迭代器</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line">        arrayList.add(<span class="number">2</span>);</span><br><span class="line">        arrayList.add(<span class="number">3</span>);</span><br><span class="line">        arrayList.add(<span class="number">4</span>);</span><br><span class="line">        arrayList.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//需要使用ArrayList集合对象调用listiterator方法获取迭代器对象</span></span><br><span class="line">        <span class="type">ListIterator</span> <span class="variable">iterator</span> <span class="operator">=</span> arrayList.listIterator();</span><br><span class="line">        <span class="comment">//如果你想调用逆向遍历操作时，需要现将光标向后移动才可以，光标最先开始是在第一个元素位置上</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时对迭代器进行逆向遍历【从后向前】</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasPrevious())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(iterator.previous());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&quot;listIterator同样是遵守一个原则，不要再迭代器中使用后集合删除方法删除数据，要使用迭代器提供方法进行删除&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="center-5-迭代器注意事项-center"><center>5、迭代器注意事项</center></h2>
<p>（1）迭代器迭代完成之后，迭代器的位置在最后一位。 所以迭代器只能迭代一次</p>
<p>（2）迭代器在迭代的时候，不要调用多次next方法，可能会出错 NoSuchElementException</p>
<p>（3）在迭代器迭代的时候，不能向集合中添加或者删除元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionDemo03</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="string">&quot;jeck&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;马冬梅&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;Lisi&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、迭代器不能使用多次，如果要多次使用那么要多次获取</span></span><br><span class="line"><span class="comment">//        Iterator it = coll.iterator();</span></span><br><span class="line"><span class="comment">//        while (it.hasNext())</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(it.next());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        while (it.hasNext())</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(it.next());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、在同一次迭代中，不能多次使用next方法</span></span><br><span class="line"><span class="comment">//        Iterator it = coll.iterator();</span></span><br><span class="line"><span class="comment">//        while (it.hasNext())</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            //第一种</span></span><br><span class="line"><span class="comment">//            Object obj = it.next();</span></span><br><span class="line"><span class="comment">//            System.out.println(obj);</span></span><br><span class="line"><span class="comment">//            //第二种</span></span><br><span class="line"><span class="comment">//            System.out.println(it.next());</span></span><br><span class="line"><span class="comment">//            //不能这么多次使用</span></span><br><span class="line"><span class="comment">//            Object obj = it.next();</span></span><br><span class="line"><span class="comment">//            System.out.println(it.next());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、迭代器在迭代的过程中不能调用add或者remove方法</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            coll.add(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点六：List集合之LinkedList集合</center></h1>
<h2 id="center-1-说明-center"><center>1、说明</center></h2>
<p>LinkedList集合也是List集合接口中主要实现类，这个LinkedList的主要实现结构有【链表】，除了链表结构之外LinkeList还使用栈、 队	列、数组，LinkedList是允许存重复数据化并且可以快速插入数据</p>
<p><strong>LinkedList中实现的数据结构</strong></p>
<p><strong>栈</strong>：stack,又称堆栈，它是运算受限的线性表，其限制是仅允许在表的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</p>
<p>简单的说：采用该结构的集合，对元素的存取有如下的特点</p>
<p><strong>先进后出</strong>（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹</p>
<p><strong>栈的入口、出口的都是栈的顶端位置</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291919875.WebP" alt="栈的位置" style="zoom:67%;">
<p>这里两个名词需要注意：</p>
<p>    <strong>压栈</strong>：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置</p>
<p>    <strong>弹栈</strong>：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置</p>
<p><strong>队列</strong>：队列和栈有一些类似，也是一种受到限制的线性表，其限制是仅允许在表的一表进行插入，另外一段进行取出和删除，这样队列叫做单向队列【Queue】</p>
<p>队列是存在一个特点：先进先出</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291920090.WebP" alt="队列" style="zoom: 33%;">
<p>队列：除了单向队列之外，还提供一种非受限制线性表，这表就是双端队列，依旧遵守先进先出原则，<strong>双端队列</strong>【Deque】</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291921569.WebP" alt="双端队列" style="zoom:33%;">
<p>链表：链表属于一个线性表，线性表中包含了存储链接位置和数据的位置，利用链接位置进行相连接，使数据之间呈现一种链接状态，链表可以理解为：老鹰抓小鸡</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291921058.WebP" alt="链表" style="zoom:50%;">
<p>链表和队列差不多，链表也分为单向和双向链表，类似于现实生活中的【火车】通过链接方式就可以获取得到链表中数据</p>
<p>单向链表和双向链表是有本质上区别的，单向链表包含两个区域【存储链接位置和数据存储位置】，通过【存储链接位置】让每一个单独链接节点进行相连，形成一个单向链表，即单向链表只能向一个方法进行遍历操作，双向链表包含是三个区域【2个存储链接位置和1个数据存储位置】 ，利用双向链表中两个存储链接的位置进行前后节点的链接，此时链表就形成了一个双向通道，即可以从头到尾，也可以从到头，允许直接在头尾两端进行操作</p>
<h2 id="center-2-分析linkedlist的执行效率-center"><center>2、分析LinkedList的执行效率</center></h2>
<p>主要实现方式是【双向链表】，所以使用LinkedList效果</p>
<ol>
<li>
<p>保存数据 ：只要执行一次即可【API中也提供 addFirst 和addLast】</p>
</li>
<li>
<p>删除操作： 只要执行一次即可【API中也提供 removeFirst 和removeLast】，就选中间节点(1+N)/2</p>
</li>
<li>
<p>查询操作和修改操作：平均值(N+1)/2</p>
</li>
</ol>
<p>结论：LinkedList增删执行效率是高的，但是查询和修改执行效率是低的</p>
<h2 id="center-3-常用方法-center"><center>3、常用方法</center></h2>
<p>常用的方法与ArrayList一致。自己独有一些向首尾添加移除等方法(可以模拟对列、堆栈等数据结构)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListAPIDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//因为LinkedList实现了List集合接口，所以具备所有List集合</span></span><br><span class="line">        操作方法</span><br><span class="line">        <span class="comment">//LinkedList中List方法操作完全参考ArrayList即可</span></span><br><span class="line">        <span class="comment">//LinkedList集合独有方法</span></span><br><span class="line">        <span class="comment">//1.创建LinkedList对象</span></span><br><span class="line">        <span class="comment">//1.1 创建一个空的LinkedList集合对象</span></span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="comment">//1.2使用参数中Collection集合对象中存储数据初始化LinkedList集合对象</span></span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">linkedList1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>(linkedList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//独有API        </span></span><br><span class="line">        <span class="comment">//1.向集合开头的位置添加元素</span></span><br><span class="line">        linkedList.addFirst(<span class="number">1</span>);</span><br><span class="line">        System.out.println(linkedList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.向集合结尾的位置添加元素</span></span><br><span class="line">        linkedList.addLast(<span class="number">2</span>);</span><br><span class="line">        System.out.println(linkedList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.获取集合第一个元素的数据【但是不删除集合数据】</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">element</span> <span class="operator">=</span> linkedList.element();</span><br><span class="line">        System.out.println(element);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.获取集合中第一个数据和最后一个数据【但是不删除集合数据】</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">first</span> <span class="operator">=</span> linkedList.getFirst();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">last</span> <span class="operator">=</span> linkedList.getLast();</span><br><span class="line">        <span class="comment">//PS： LinkedList允许使用下标形式进行数据获取</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> linkedList.get(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.添加元素到集合的末尾</span></span><br><span class="line">        linkedList.offer(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//添加到第一个位置offerFirst和最后一个位置offerLast</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6.获取集合集合第一个元素但是【不删除集合数据】，有元素就返回，没有就是null</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">peek</span> <span class="operator">=</span> linkedList.peek();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> linkedList.peekFirst();</span><br><span class="line">        <span class="comment">//获取最后一个元素的值，有元素就返回，没有就是null</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> linkedList.peekLast();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7.poll系列也是也可以获取集合中第一个和最后一个元素的【删除数据】</span></span><br><span class="line">        <span class="comment">//在获取数据的同时删除集合中数据</span></span><br><span class="line">        <span class="comment">// Object poll = linkedList.poll();</span></span><br><span class="line">        <span class="comment">// Object o3 = linkedList.pollFirst();</span></span><br><span class="line">        <span class="comment">// Object o4 = linkedList.pollLast();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//8. 弹出集合中第一个数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">pop</span> <span class="operator">=</span> linkedList.pop();</span><br><span class="line">        <span class="comment">//向集合中添加数据</span></span><br><span class="line">        linkedList.push(<span class="number">4</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//9.删除集合中第一个或最后一个元素值</span></span><br><span class="line">        linkedList.removeFirst();</span><br><span class="line">        linkedList.removeLast();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10.List集合特点就是允许存储重复数据，下面两个方法的作用就是遍历集合</span></span><br><span class="line">        <span class="comment">//First的方法从前之后 Last的方法从后向前</span></span><br><span class="line">        <span class="comment">//遇到第一个相同数据删除</span></span><br><span class="line">        linkedList.removeFirstOccurrence(<span class="number">1</span>);</span><br><span class="line">        linkedList.removeLastOccurrence(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//LinkedList有一个独有的迭代器，允许逆向的遍历迭代器中数据值</span></span><br><span class="line">        <span class="comment">//但是它的操作方式和iterator是一样</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> linkedList.descendingIterator();</span><br><span class="line">        <span class="comment">//它的方式只有三个 hasNext next 和 remove</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//不同点在于：它的光标最先开始是放置在迭代器最后一个元素的位置，你hasNext是向前判断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-4-linkedlist实现原理-center"><center>4、LinkedList实现原理</center></h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291923333.WebP" alt="实现原理" style="zoom:50%;">
<h1><center>知识点七：List集合总结</center></h1>
<p>List集合是Collection集合子集合即List集合是继承与Collection集合，因为List集合是接口所以无法直接操作，Java就提供了两个可以便捷操作List集合实现类ArrayList和LinkedList</p>
<p>List集合的特点：允许存储重复数据并给存储数据是有顺序</p>
<p>在官方API文档中可以查看到：public interface List extends Collection</p>
<p>有序的 collection（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素</p>
<p><strong>所有已知实现类</strong>： ArrayList 和 LinkedList</p>
<p><strong>所有超级接口</strong>： Collection 和 Iterable</p>
<p>因为也继承了Iterable所以List集合中是支持的迭代器【Iterator】</p>
<p>List接口中提供常用方法已经在ArrayList集合中完全进行演示，所以使用List集合时只要参考ArrayList提供方法演示就可以操作集合</p>
<p>ArrayList和LinkedList实现类是实现List接口，所以List相当于是他们的父类，所以List集合接口支持多态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List集合接口允许这样这样创建对象</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">或者</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line"><span class="string">&quot;这样直接使用较少，多用于在方法中如果需要设置List集合参数，优先会</span></span><br><span class="line"><span class="string">将List作为参数类型，而不是实现类&quot;</span></span><br><span class="line"><span class="string">&quot;因为这样做可以接收ArrayList或LinkedList&quot;</span></span><br><span class="line"><span class="string">&quot;上面这种方式是不使用泛型，所以默认数据类型时Object，操作时就一定</span></span><br><span class="line"><span class="string">注意转换问题【对象的向下转型】&quot;</span></span><br><span class="line"><span class="string">&quot;Java中所有集合都是有泛型语法，所以可以使用泛型方式进行创建对象&quot;</span></span><br><span class="line">    List&lt;数据类型&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="string">&quot;泛型语法形式：&quot;</span></span><br><span class="line">    集合的数据类型&lt;数据类型&gt; 集合对象名字 = <span class="keyword">new</span> 集合数据类型&lt;&gt;();</span><br><span class="line"><span class="string">&quot;集合都是使用new关键字创建，所以它是引用类型&quot;</span></span><br><span class="line"><span class="string">&quot;现在学习ArrayList和LinkedList都是线程不安全的集合，在多线程操</span></span><br><span class="line"><span class="string">作前提下是不能使用这两个集合进行数据存储操作，这两个集合只适合在单线程下使用&quot;</span></span><br></pre></td></tr></table></figure>
<p>List集合接口还有一个<strong>实现类Vector</strong></p>
<p>Vector在JDK1.0的时候就已经存在，这个类其实是ArrayList集合类“前身”，在JDK1.2时候Java开始强调了集合框架概念，所以提供Collection集合框架，在Collection下面提供List和Set，Vector的实现也是数组，所以被归类到了List接口的实现类中，现在开发已经不在使用Vector这个类，主要使用ArrayList这个类</p>
<p>Vector和ArrayList之间相似点和区别在于什么？</p>
<p>相似点：都是List集合接口的实现类，都使用数组作为集合数据结构进行实现</p>
<p>不同点：Vector这个集合是线程安全的，但是效率低，提供较早并且使用率低</p>
<p>    ArrayList这个集合是线程不安全，但是效率高，提供较晚并且使用率高</p>
<p>PS：就算Vector是线程安全的，但实际开发中也不会使用Vector，还是使用ArrayList</p>
<p>从Java5开始提供ArrayList和LinkeList线程安全处理模式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;集合中是存在一个工具类，这个类叫做Collections，这个工具类提供</span></span><br><span class="line"><span class="string">了如果将线程不安全集合转换为线程安装集合的方法&quot;</span></span><br><span class="line">Collections.synchronizedList(List集合对象); ---》可以将</span><br><span class="line">一个线程不安全集合转换为线程安全</span><br><span class="line"><span class="string">&quot;除了这种处理方式之外,现在主要处理方式可以使用Java在JDK1.5中提</span></span><br><span class="line"><span class="string">供的一个新包java.util.concurrent 并发工具包，</span></span><br><span class="line"><span class="string">这个包中提供大量的线程安全处理时可以使用的集合&quot;</span></span><br></pre></td></tr></table></figure>
<p>Stack(栈集合)和Queue、Deque(队列集合)</p>
<p>Stack是List集合的实现类，而Queue、Deque集合接口：有专门实现类来实现主要体现在于LinkedList</p>
<h1><center>知识点八：泛型基本使用</center></h1>
<h2 id="center-1-作用-center"><center>1、作用</center></h2>
<p>什么是泛型？</p>
<p>    泛型是一个特殊类型，泛型是统称指代任何引用数据类型，泛型本身代表【通用类型含义】，在定义泛型时如果没有对泛型进行数据类型赋值之前，泛型本身是不具备任何含义，只有赋值为具体数据类型时，泛型才会真正意义</p>
<p>为什么要使用这个泛型?</p>
<p>    泛型解决了集合中存储数据类型的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CenericityList</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在学习集合之前，是没有使用泛型，所以集合中默认类型就是Object</span></span><br><span class="line"><span class="comment">            我们面临的问题就是取出数据时，需要进行向下转型操作才可以</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//对集合存储的数据进行计算求和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span><span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(Object obj : list)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += ((Integer) obj);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//因为不使用泛型默认类型时Object类型所以和这个集合中就可以存储任何数据类型只要是Object子类</span></span><br><span class="line">        list.add(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line">        list.add(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//如果你在不清楚集合中存储在什么样数据类型数据时，如果进行转换操作？代码就无形中增加开发成本</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            所以在这种情况下，集合建议使用泛型，来约束集合中存储数据</span></span><br><span class="line"><span class="comment">            一旦集合使用泛型就要可以约束集合只能 存储泛型中提供的数据类型对应数据，从而减少转换操作</span></span><br><span class="line"><span class="comment">            此时list1这个集合中只能存储Integer类型数据，使用泛型作为约束</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list1.add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//list1.add(&quot;1&quot;);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer i : list1)</span><br><span class="line">        &#123;</span><br><span class="line">            sum1+=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS： 如何定义泛型集合？</p>
<h3 id="语法">语法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">集合数据类型&lt;存储数据的数据类型&gt; 集合对象名 = <span class="keyword">new</span> 集合数据类型&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>此时就可以使用【存储数据的数据类型】约束集合中存储的数据了</p>
<p>PS：集合泛型你就可以理解为 就是创建数组是</p>
<p>数组中存储元素数据类型[] —》相当于 集合数据类型&lt;存储数据的数据类型&gt;	只能引用数据类型</p>
<p>泛型解决通用性问题</p>
<p>编程原则：DRY【不要重复你自己（不要写重复性代码）】</p>
<p>需求： 求点中x和y的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer x;</span><br><span class="line">    <span class="keyword">private</span> Integer y;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Double x;</span><br><span class="line">    <span class="keyword">private</span> Double y;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Long x;</span><br><span class="line">    <span class="keyword">private</span> Long y;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String x;</span><br><span class="line">    <span class="keyword">private</span> String y;</span><br><span class="line">&#125; </span><br><span class="line">为了Point类型可以获得不同参数类型数据，需要提供大量相同逻辑类，此时就触发DRY原则，</span><br><span class="line">现有解决方案就是将数据类型替换成Object类型，但</span><br><span class="line">是我们需要面临数据类型转换和传递非计算类型问题，有没有什么方式可以</span><br><span class="line">动态决定类中x和y属性类型操作，根据外界传递类型来进行x和y的限制操作 ---》 可以使用<span class="string">&quot;泛型&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="keyword">private</span> T y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-2-定义-center"><center>2、定义</center></h2>
<p>PS：泛型中会出现一个【占位符】的概念，这个占位符本身是没有任何意义，就是一个占位，对泛型进行赋值时，占位符才会有具体的意义</p>
<p>泛型的概念是Java5开始引入到Java中，它可以通过对泛型赋值进行对数据赋值约束，通过泛型动态决定数据类型时什么</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;占位符&gt;</span><br><span class="line">PS：这种语法在Java中叫做<span class="string">&quot;菱形语法&quot;</span>，这样语法与占位符组合就是成</span><br><span class="line">为<span class="string">&quot;泛型&quot;</span></span><br><span class="line">这个语法可以使用在 <span class="string">&quot;类、方法和接口&quot;</span>上</span><br><span class="line">占位符<span class="string">&quot;一般是一个大写字母[A~Z]&quot;</span>,不建议使用其他形式进行占位符定义</span><br><span class="line">习惯书写占位符是 <span class="string">&quot;T&quot;</span> --&gt; <span class="string">&quot;Type(类型)&quot;</span> ---&gt; &lt;T&gt; 泛型T</span><br><span class="line">占位符可以在一个语法存在多个需要使用<span class="string">&quot;,&quot;</span>分隔，使用占位符的多少就相</span><br><span class="line">当于你定义多个泛型</span><br><span class="line">泛型语法:只能存在在编译时期，一旦程序运行泛型就会自动消失<span class="string">&quot;称之为泛型擦除&quot;</span></span><br><span class="line">        定义的泛型在编译字节码文件中即[.class文件]看不到</span><br></pre></td></tr></table></figure>
<h2 id="center-3-泛型的使用之集合-center"><center>3、泛型的使用之集合</center></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CenericityList</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 集合的数据类型&lt;泛型赋值数据类型&gt; 集合对象名字 = new 集合的数据类型&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// 声明的就是带有泛型集合，泛型可以作为集合类型一部分，可以出现在方法参数位置和返回值类型的位置</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list1.add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//一旦集合使用泛型之后，集合只允许使用泛型定义数据类型，非泛型定义数据类型时无法存储到集合中</span></span><br><span class="line">        <span class="comment">//list1.add(&quot;1&quot;);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//集合使用泛型之后，确定了集合中存储数据的数据类型，在集合中的数据就无需向下转型操作</span></span><br><span class="line">        <span class="keyword">for</span>(Integer i : list1)</span><br><span class="line">        &#123;</span><br><span class="line">            sum1+=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showList</span><span class="params">(ArrayList&lt;Integer&gt; list)</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title function_">showList</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-4-泛型的使用之泛型类-center"><center>4、泛型的使用之泛型类</center></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    当前类在没有使用任何其他修饰符之前【final 或 abstract】,没有使用泛</span></span><br><span class="line"><span class="comment">型语法之前 都是一个普通类</span></span><br><span class="line"><span class="comment">    public class CenericityClass </span></span><br><span class="line"><span class="comment">    &#123;&#125;</span></span><br><span class="line"><span class="comment">    利用泛型语法 &lt;占位符&gt; 可以将当前类变成泛型类</span></span><br><span class="line"><span class="comment">    语法：</span></span><br><span class="line"><span class="comment">        public class 类名&lt;占位符&gt;    //这个类就是泛型类</span></span><br><span class="line"><span class="comment">        &#123; </span></span><br><span class="line"><span class="comment">            此时这个泛型是定义在类上，所以在类中成员变量和成员方法都可以使用</span></span><br><span class="line"><span class="comment">            这个泛型</span></span><br><span class="line"><span class="comment">作为数据类型使用</span></span><br><span class="line"><span class="comment">        &#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CenericityClass</span>&lt;T&gt; <span class="comment">// 使用泛型是 T 这个T现在是没有意义 只是一个占位符号</span></span><br><span class="line">&#123;     </span><br><span class="line">    <span class="comment">//此时这个T是没意义，为了保证语法不错误，占位使用</span></span><br><span class="line">    <span class="comment">//泛型T只有被赋值之后【数据类型（必须是引用数据类型）】 T才会有意义</span></span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="keyword">public</span> T y;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CenericityClass</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CenericityClass</span><span class="params">(T x, T y)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//在类上定义泛型，如何确定泛型数据类型，只要在创建类的对象时对泛型进行赋值，泛型就有具体的数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 类名&lt;泛型赋值数据类型&gt; 对象名字 = new 类名&lt;&gt;();</span></span><br><span class="line">        CenericityClass&lt;Integer&gt; cc = <span class="keyword">new</span></span><br><span class="line">        <span class="title class_">CenericityClass</span>&lt;&gt;();</span><br><span class="line">        cc.y = <span class="number">1</span>;</span><br><span class="line">        cc.show(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//这样创建对象,创建泛型的同时不对泛型进行赋值操作</span></span><br><span class="line">        <span class="comment">//此时没有对泛型进行赋值，所以泛型类型默认使用Object</span></span><br><span class="line">        <span class="type">CenericityClass</span> <span class="variable">cc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CenericityClass</span>();</span><br><span class="line">        cc1.y = <span class="number">1</span>;</span><br><span class="line">        cc1.y = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        cc1.show(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">PS：泛型在动态决定数据类型时什么的时候，不存在继承关系&quot;</span></span><br><span class="line"><span class="string">&quot;不要这样写，这个语法是错误，对泛型进行赋值什么数据类型时，就决定这个数类型，所不允许赋值为其他类&quot;</span></span><br><span class="line">CenericityClass&lt;Object&gt; cc = <span class="keyword">new</span></span><br><span class="line"><span class="title class_">CenericityClass</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>
<h2 id="center-5-泛型使用之泛型方法-center"><center>5、泛型使用之泛型方法</center></h2>
<p>泛型方法的定义主要是为了摆脱使用泛型类上或泛型接口上的泛型约束问题，就相当于方法向使用自己定义泛型作为类型操作，就可以定义为泛型方法</p>
<p>泛型类和泛型接口上定义泛型，不能在静态方法上使用，所以只能定义泛型方法对方法进行泛型使用修饰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericityMethod</span>&lt;T&gt; <span class="comment">// 使用泛型是 T 这个T现在是没有意义 只是一个占位符号</span></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个成员方法 泛型类上定义泛型就可以在方法中使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//泛型类上定义泛型是不能在静态方法上使用</span></span><br><span class="line">    <span class="comment">//public static void showInfos(T t)&#123; &#125;</span></span><br><span class="line">    <span class="comment">//给方法添加泛型</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        泛型静态方法：</span></span><br><span class="line"><span class="comment">            访问权限修饰符 static&lt;占位符&gt; 返回值类型 方法名(参数列表)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                此时这个占位符可以使用在返回值类型上 和 参数列表定义中</span></span><br><span class="line"><span class="comment">            &#125; </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;E&gt; <span class="keyword">void</span> <span class="title function_">showInfos</span><span class="params">(E e)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//E a;// 方法上泛型主要是为了 返回值类型和参数类型而提供的，在内部就不在使用</span></span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        泛型成员方法：</span></span><br><span class="line"><span class="comment">            访问权限修饰符&lt;占位符&gt; 返回值类型 方法名(参数列表)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                此时这个占位符可以使用在返回值类型上 和 参数列表定义中</span></span><br><span class="line"><span class="comment">            &#125; </span></span><br><span class="line"><span class="comment">        此时不仅可以使用泛型方法上定义泛型，也可以使用类上或接口上定义泛型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span>&lt;F&gt; <span class="keyword">void</span> <span class="title function_">showInfoss</span><span class="params">(F f,T t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//F a;// 方法上泛型主要是为了 返回值类型和参数类型而提供的，在内部就不在使用</span></span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//定义泛型方法泛型，不能单独使用在方法返回值类型位置，需要配合使用参数列表定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;O&gt; O <span class="title function_">showInfosss</span><span class="params">(O o)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//静态方法可以这样操作，成员的不可以</span></span><br><span class="line">        <span class="comment">//return o;</span></span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如何给方法定义泛型进行赋值操作---》赋值数据类型</span></span><br><span class="line">        <span class="comment">//在调用方法对泛型定义参数列表赋值时，可以决定方法的泛型是什么，定义泛型方法时</span></span><br><span class="line">        <span class="comment">//一定要将泛型定义在参数列表中，以确定数据类型是什么</span></span><br><span class="line">        GenericityMethod.showInfos(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="type">GenericityMethod</span> <span class="variable">genericityMethod</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">        <span class="title class_">GenericityMethod</span>();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> GenericityMethod.showInfosss(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-6-泛型使用之接口泛型-center"><center>6、泛型使用之接口泛型</center></h2>
<p>接口泛型和泛型类差不多，在接口上定义泛型，这个泛型可以在接口内部使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    public interface 接口名&lt;占位符&gt;</span></span><br><span class="line"><span class="comment">    &#123;&#125;泛型接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenericityInterface</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在接口上定义泛型可以在接口内部使用</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(T t)</span>;</span><br><span class="line">    <span class="comment">//支持抽象方法自定义泛型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span>&lt;E&gt; <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(E e)</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//1. 在使用类实现接口时可以对泛型接口的泛型进行赋值，决定泛型类型是什么 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">GenericityInterface</span>&lt;Integer&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在接口中定义方法使用泛型位置都会变成数据类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Integer integer)</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(E e)</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 使用泛型类实现泛型接口，使用泛型类中泛型作为接口中新泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo2</span>&lt;P&gt; <span class="keyword">implements</span> <span class="title class_">GenericityInterface</span>&lt;P&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在创建泛型类对象时可以决定泛型类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(P p)</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(E e)</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        GenericityInterface&lt;Double&gt; gi = <span class="keyword">new</span> <span class="title class_">Demo2</span>&lt;&gt;();</span><br><span class="line">        gi.run(<span class="number">1.0</span>);</span><br><span class="line">        Demo2&lt;String&gt; demo2 = <span class="keyword">new</span> <span class="title class_">Demo2</span>&lt;&gt;();</span><br><span class="line">        demo2.run(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">//这种操作其实就是List集合中使用List集合创建对象的方式</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Long&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//3.直接使用匿名内部类的形似进行泛型接口上泛型的赋值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">GenericityInterface</span>&lt;Integer&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Integer integer)</span> </span><br><span class="line">            &#123;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(E e)</span> </span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-7-泛型的限定-center"><center>7、泛型的限定</center></h2>
<p>泛型限定其实就是定义泛型可以赋值哪些数据类型，只有满足限定要求的数据类型才可以进行定义赋值操作</p>
<p><strong>泛型通配符【?】</strong></p>
<p>?代表未知，可以作为通配符使用，但是不能作为参数类型单独使用，通配符多用于在泛型限定上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericityDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ? 是一个通配符</span></span><br><span class="line">        List&lt;?&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>); <span class="comment">// 这里是无法确定数据类型，无法单独使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>&lt; ? extends 类&gt; 这是使用途径 此时 ？ 就代表着可以接收extends关键字后的相同类型或子类</strong></p>
<p><strong>&lt; ? super 类&gt; 这是使用途径 此时 ？ 就代表着可以接收super关键字后的相同类型或父类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericityDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供4个List集合对象</span></span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Number&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Object&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//调用泛型的上限操作，即参数类型使用的是List&lt;? extends Number&gt;进行限制</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            泛型限定必须是 Number类型或Number子类</span></span><br><span class="line"><span class="comment">            而list1是Integer类型即Number子类 list3是Number类型即</span></span><br><span class="line"><span class="comment">Number类型所以可以进行传递</span></span><br><span class="line"><span class="comment">            而list2和list4分别是String和Object，既不是Number类型也</span></span><br><span class="line"><span class="comment">不是Number子类，所以无法传递到方法中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        doWork1(list1);</span><br><span class="line">        <span class="comment">//doWork1(list2);</span></span><br><span class="line">        doWork1(list3);</span><br><span class="line">        <span class="comment">//doWork1(list4);</span></span><br><span class="line">        <span class="comment">//调用泛型下限操作，即参数类型使用的是List&lt;? super Number&gt;进行限制</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            泛型限定必须是Number类型或Number父类</span></span><br><span class="line"><span class="comment">            而list1和list2分别是Integer和String，既不是Number类型也不是Number父类，所以无法传递到方法中</span></span><br><span class="line"><span class="comment">            list3和list4 分别是Number和Object 满足了必须是Number类型或Number父类，所以传递到方法中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//doWork2(list1);</span></span><br><span class="line">        <span class="comment">//doWork2(list2);</span></span><br><span class="line">        doWork2(list3);</span><br><span class="line">        doWork2(list4);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//泛型的上限，此时的泛型中?(通配符) 必须是Number的类型或Number子类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doWork1</span><span class="params">(List&lt;? extends Number&gt; list)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//泛型的下限，此时的泛型中?(通配符) 必须是Number的类型或Number父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doWork2</span><span class="params">(List&lt;? <span class="built_in">super</span> Number&gt; list)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-8-特点-center"><center>8、特点</center></h2>
<p>（1）泛型集合在存储元素的时候，支持多态(不推荐使用)</p>
<p>（2）泛型定义的时候，不存在多态</p>
<p>    Collection coll1 = new ArrayList(); err</p>
<p>（3）泛型擦除</p>
<p>    在JDK1.7之后，右边的&lt;&gt;中不需要定义泛型类型</p>
<p>    集合的泛型不能是基本数据类型，要使用它们的包装类</p>
<p>CollectionDemo01类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionDemo01</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型：参数化类型     JKD1.5之后</span></span><br><span class="line"><span class="comment">     * 泛型作用：因为在没有使用泛型之前，向集合中存储实际上是Object类型的数据，所以获取的时候也是Object类型</span></span><br><span class="line"><span class="comment">     *         如果想要使用这个对象，需要发生向下转型，那么在整个集合存储元素的时候，不停的发生向上和向下转型,可能会发生异常</span></span><br><span class="line"><span class="comment">     * 泛型的好处：类型转换的操作提前到了编译器</span></span><br><span class="line"><span class="comment">     *泛型特点：</span></span><br><span class="line"><span class="comment">     *      泛型集合在存储元素的时候，支持多态(不推荐使用)</span></span><br><span class="line"><span class="comment">     *      泛型定义的时候，不存在多态</span></span><br><span class="line"><span class="comment">     *         Collection&lt;Person&gt; coll1 = new ArrayList&lt;Student&gt;(); err</span></span><br><span class="line"><span class="comment">     *      泛型擦除</span></span><br><span class="line"><span class="comment">     *          在JDK1.7之后，右边的&lt;&gt;中不需要定义泛型类型</span></span><br><span class="line"><span class="comment">     *      集合的泛型不能是基本数据类型，要使用它们的包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        Collection coll = new ArrayList();</span></span><br><span class="line"><span class="comment">//        coll.add(new Student(&quot;jack&quot;,28));</span></span><br><span class="line"><span class="comment">//        coll.add(new Student(&quot;尼古拉斯&quot;,23));</span></span><br><span class="line"><span class="comment">//        coll.add(new Teacher(&quot;rose&quot;,32));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //遍历集合  迭代器</span></span><br><span class="line"><span class="comment">//        Iterator it = coll.iterator();</span></span><br><span class="line"><span class="comment">//        while (it.hasNext())</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            //没有向下转型时时Object类</span></span><br><span class="line"><span class="comment">//            //System.out.println(it.next().play());</span></span><br><span class="line"><span class="comment">//            Object obj = it.next();</span></span><br><span class="line"><span class="comment">//            Student stu = (Student) obj;</span></span><br><span class="line"><span class="comment">//            stu.play();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        Collection&lt;Student&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;niu&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        Iterator&lt;Student&gt; it = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> it.next();</span><br><span class="line">            student.play();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//泛型集合在存储元素的时候，支持多态</span></span><br><span class="line">        Collection&lt;Person&gt; coll1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        coll1.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        coll1.add(<span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;sdf&quot;</span>,<span class="number">34</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不能用基本数据类型</span></span><br><span class="line">        <span class="comment">//Collection&lt;int&gt; coll2 = new ArrayList&lt;&gt;();</span></span><br><span class="line">        Collection&lt;Integer&gt; coll3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Person类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Student类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Student类中的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student玩。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Teacher类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Teacher&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点九：Set集合的介绍</center></h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291933362.WebP" alt="set集合"></p>
<h1><center>知识点十：Set集合实现类HashSet</center></h1>
<p>HashSet集合是Set集合主要实现类，也是日常开发使用最常用Set集合实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span> <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>
<p>HashSet集合继承了Set集合的特点，向hashSet集合中存储数据时，是不允许出现重复数据，如果有存储重复数据HashSet集合会进行自动排重操作，<strong>HashSet集合的主要实现数据结构“Hash表”</strong>,存储数据顺序是无序，<strong>通过观察API文档发现HashSet集合的所有方法都是Set集合接口提供，本身没有任何特殊方法</strong></p>
<p>特点:</p>
<ul>
<li>无序 （插入顺序）</li>
<li>无下标</li>
<li>不可重复</li>
</ul>
<h2 id="center-1-hash表-center"><center>1、Hash表</center></h2>
<p><strong>什么是hash表？</strong></p>
<p>    Hash 一般被翻译为“散列”，也可以直接音译为“哈希”，它是基于【快速存取的角度而设计的一种存储结构】，而且是一个典型【空间换时间】的做法，利用Hash表的原理进行数据存储操作</p>
<p>    Hash表其实就是【“数组+链表”】的组合形式，在Hash表数组起到作用提供存储位置，在Hash表链表起到作用提供数据存储结构</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291936873.WebP" alt="Hash表" style="zoom:50%;">
<p>上图中是典型Hash表的结构，Hash表也别称之为【散列表(Hashtable)】，Hash表是根据键值对（Key-value）而直接进行访问的数据结构，也就是说【通过把key值映射到表中一个位置来记录访问位置】，以加快查找数据（这个操作就是确定数据在Hash表中存储的位置），这个操作也被称之为【散列函数】，通过散列函数计算出存储位置会后，会将存储数据以链表形似挂载在存储位置中，这种方式成为【桶】如果存储70个元素，但是存储70个元素时申请100个空间，70/100 = 0.7 ，这个0.7这个值就称之为“负载（加载）因子”，通过这个因子对hash表进行扩容操作</p>
<p>因为Hash表是基于【快速存取】的操作，所以Hash表会尽量的平均将数据分配到Hash表中进行存储，但是在存储过程中就会触发，在同一个存储空间中出现重复数据问题，此时Hash就会启动自动排重操作，原则就是equals比较，只要equals比较结果为true，就不在这个空间存储相同数据</p>
<p>假如：向上面Hash表中存储12这个数据如果进行存储计算</p>
<p>第一步：通过散列函数计算12需要存储的位置 --》hash(key)%len【散列函数】</p>
<p>hash(key) —》 key 是要存储数据 hash(key) —》<strong>计算key的hash值即Java中hashcode值</strong></p>
<p>len —》其实就是存储Hash表中数组长度，上图中数组长度为16所以散列函数计算效果</p>
<p>hash(12) % 16 —》 12%16 ----》 余数12 ，利用12这个值去数组中提供存储位置对别查找存</p>
<p><strong>Hash表的扩容机制？</strong></p>
<p>    Hash表示一个自动扩容机制，<strong>当达到【加载因子】参数要求时，Hash表就会进行自动扩容</strong></p>
<p>    Java中使用<strong>Hash表默认大小给16，加载因子0.75</strong>当16个存储位置发生了75%位置都存储了数据即16*0.75 = 12，也就说12个下标位置中都存储数据，Hash表就会发生自动扩容，扩容机制就以2的幂次进行扩容【16是2^4】扩容之后2^5即hash表每次扩容之后都是原有容量一倍，就会从原有16扩容到32</p>
<p>    在介绍HashSet时说过HashSet中存储数据不能保证存储位置永久不变，只要Hash表发生一次扩容，那么Hash表中存储的数据就要重新计算存储位置</p>
<p>原始数据28 存储在大小为16的hash表中 计算位置 28%16 --》 余数12</p>
<p>一旦扩容大小从16变成32 此时原始数据28可就要重新计算存储位置</p>
<p>在hash表 计算位置 28%32 —》 余数 28</p>
<p><strong>总结：Hash表数据存储和查找是非常优秀，但是一旦扩容就会降低Hash表的性能</strong></p>
<h2 id="center-2-hashset基本使用-center"><center>2、HashSet基本使用</center></h2>
<h3 id="1-语法">(1）语法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;泛型&gt; 变量名 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>HashSet是实现Set集合接口，查看API时可以发现HashSet中并没有任何特殊方法，所以知己使用Set接口提供方法就完成HashSet集合操作【<strong>HashSet集合中操作方法方式和ArrayList集合中介绍方式是一样的，只不过HashSet带有排重的效果，可以完全参考ArrayList集合中API使用在HashSet中进行使用</strong>】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetAPI</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建HashSet集合对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            表面上代码操作是在创建一个HashSet集合，但是实际底层操作过程中是在创建HashMap集合</span></span><br><span class="line"><span class="comment">            向HashSet集合存储的数据其实就是在想HashMap中key的位置存储</span></span><br><span class="line"><span class="comment">数据，为什么要这样会做</span></span><br><span class="line"><span class="comment">            Hash表存储数据值是以【key-value】进行数据存储操作 --》</span></span><br><span class="line"><span class="comment">Java集合中可以提供Key-value形式存储只有Map集合</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//1.提供一个空的HashSet集合对象【默认容量16,加载因子0.75】</span></span><br><span class="line">        HashSet&lt;Integer&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//PS：HashSet是Set集合的实现类，也就相当于是Set集合&quot;子类&quot;</span></span><br><span class="line">        <span class="comment">//利用Set集合接口使用多态形式创建Set集合对象</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.可以利用参数Collection集合对象中存储数据初始化HashSet集合对象</span></span><br><span class="line">        HashSet&lt;Integer&gt; hashSet1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;</span><br><span class="line">(hashSet);</span><br><span class="line">        <span class="comment">//3.指定HashSet集合初始化容量大小【使用默认加载因子0.75】</span></span><br><span class="line">        <span class="comment">//遵守大小原则是2次幂来定义的，但是不要小于16</span></span><br><span class="line">        HashSet&lt;Double&gt; hashSet2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;</span><br><span class="line">(((<span class="type">int</span>)Math.pow(<span class="number">2</span>,<span class="number">5</span>)));    <span class="comment">//2的5次幂(double类型)强转int</span></span><br><span class="line">        <span class="comment">//4.指定HashSet集合初始化容量大小和加载因子 第二参数加载因子是float类型</span></span><br><span class="line">        HashSet&lt;Character&gt; hashSet3 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt; (((<span class="type">int</span>)Math.pow(<span class="number">2</span>,<span class="number">5</span>)),<span class="number">0.85f</span>);</span><br><span class="line">        <span class="comment">//常用API</span></span><br><span class="line">        <span class="comment">//向集合中添加数据</span></span><br><span class="line">        hashSet.add(<span class="number">1</span>);</span><br><span class="line">        hashSet.add(<span class="number">20</span>);</span><br><span class="line">        hashSet.add(<span class="number">4</span>);</span><br><span class="line">        hashSet.add(<span class="number">9</span>);</span><br><span class="line">        hashSet.add(<span class="number">7</span>);</span><br><span class="line">        hashSet.add(<span class="number">17</span>);</span><br><span class="line">        <span class="comment">//hashSet是可以对存储在集合数据提供排重操作的</span></span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将参数集合对象中数据存储到当前HashSet中</span></span><br><span class="line">        <span class="comment">//addAll(Collection集合对象); </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//清空HashSet集合中数据</span></span><br><span class="line">        <span class="comment">//hashSet.clear();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断HashSet集合是否为空【指没有任何数据，而不是当前hashset地址为null】</span></span><br><span class="line">        <span class="comment">//isEmpty();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断HashSet集合中是否存在指定元素</span></span><br><span class="line">        <span class="keyword">if</span>(hashSet.contains(<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;返回true证明存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;返回false证明不存在&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//containsAll(Collection集合对象) 判断Collection集合对象中个存储数据是否存在在Hashset集合对象中</span></span><br><span class="line">        <span class="comment">//因为HashSet不存在下标的概念所以HashSet是不支持普通for循环的</span></span><br><span class="line">        <span class="comment">//HashSet支持循环方式有</span></span><br><span class="line">        <span class="comment">// 增强for循环</span></span><br><span class="line">        <span class="keyword">for</span>(Integer integer : hashSet)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(integer);</span><br><span class="line">            <span class="comment">//不要调用集合删除方法</span></span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// foreach方法</span></span><br><span class="line">        hashSet.forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//普通迭代器(HashSet集合只支持普通迭代器，不支持增强迭代器即listIterator)</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = hashSet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">            <span class="comment">//删除数据就调用 迭代器中remove</span></span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除集合中数据 参数是要删除的数据</span></span><br><span class="line">        hashSet.remove(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//删除参数结合提供提供数据所在HashSet集合对象中数据</span></span><br><span class="line">        <span class="comment">//removeAll(Collection集合对象);</span></span><br><span class="line">        <span class="comment">//保留参数集合对象中数据在HashSet集合中然后删除剩余HashSet集合中数据</span></span><br><span class="line">        <span class="comment">//retainAll(Collection集合对象);</span></span><br><span class="line">        hashSet.removeIf(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Integer&gt;() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Integer integer)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> integer%<span class="number">2</span> ==<span class="number">0</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        hashSet.removeIf(integer -&gt; integer%<span class="number">2</span> ==<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取集合中存储元素的个数</span></span><br><span class="line">        System.out.println(hashSet.size());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//转换成数组</span></span><br><span class="line">        Object[] objects = hashSet.toArray();</span><br><span class="line">        Integer[] integers = hashSet.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[hashSet.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-hashset集合的排重操作">(2)HashSet集合的排重操作</h3>
<p>需求:创建一个Person对象，提供属性名字和年龄【按照标准JavaBean提供，提供toString重写】在提供PersonTest类型在类中创建两个Person对象，赋值为张三，18，存储在HashSet集合中，然后打印集合中数据，查看是否排重？如果没有排重如何处理？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        HashSet&lt;Person&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        <span class="comment">//利用HashSet中存储机制【Hash表】可以存储重复数据进行排重操作</span></span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line">        HashSet&lt;Integer&gt; hashSet1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet1.add(<span class="number">1</span>);</span><br><span class="line">        hashSet1.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(hashSet1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashSet底层实现是什么？—》</p>
<p>使用Hash表实现的，Hash表示如何进行数据存储的？ —》</p>
<p>使用Hash表提供散列函数，散列函数是什么？ —》</p>
<p>这是散列函数 hash(key)%len， hash(key)得到结果什么？len得到结果什么？ —》</p>
<p><strong>hash(key)计算存储数据所在内存中hashcoded地址值</strong></p>
<p>len是Hash表中容量的大小，默认是16 —》</p>
<p>利用散列函数【 hash(key)%len】 求得存储在Hash表中位置以进行数据的存储</p>
<p>Hash表的排重机制是：通过散列函数计算出数据存储的位置进行数据存储，如果出现同一个数据计算出位置相同，此时也会向存储位置进行插入存储，但是要进行equals比较，如果equals 比较结果为false就整存储位置中，没有与之相同数据，以链表存储，如果equals比较结果为true，证明这个存储位置有与之相同数据，此时就会放弃新添加的数据存，从而不会进行存储数据操作，那么些就是HashSet即Hash表排重机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        HashSet&lt;Person&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        hashSet.add(p1);</span><br><span class="line">        hashSet.add(p2);</span><br><span class="line">        System.out.println(<span class="string">&quot;p1对象的hashcode值：&quot;</span>+ p1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;p2对象的hashcode值:&quot;</span>+ p2.hashCode());</span><br><span class="line">        <span class="comment">//利用HashSet中存储机制【Hash表】可以存储重复数据进行排重操作</span></span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line">        HashSet&lt;Integer&gt; hashSet1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet1.add(<span class="number">1</span>);</span><br><span class="line">        hashSet1.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(hashSet1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么存储自定类的对象到HashSet集合没有进行排重？</p>
<p>就是因为自动以类并没对对象提供同一个hashcode的实现并且在Person类中也没有一共equals方法的实现，所以我们根本没有提供排重操作的原则，所以向HashSet中存储自定义类的对象是无法排重</p>
<p><strong>如果需要向HashSet集合存储自定义类的对象并提供排重机制，那么自定义类必须提供equals和hashcode方法的重写</strong></p>
<p>从写hashcode的目的在于：</p>
<ol>
<li>在Java中认为两个对象相等是通过equals方决定，决定原则在于类中提供属性完全或部分相等，认为两个对象相等，既然两个对象已经相等了，那么他们的地址也要相等，但是Java语言是无法直接操作真实内存地址的，但是我们可以获取到真实内存地址映射hashcode值，所以将equals比较相等对象的hashcode修改为相等就间接的满足【真实内存地址相等】</li>
<li>当向HashSet集合存储数据时候，HashSet集合底层实现是Hash表，而Hash表有需要通过hashcode计算存数据位置，只有在hash表存储位置相同才可能出现相同数据，这样一来就需要提供相同对象hashcode地址是相同的，通过这个方法将对象计算到同一个存储位置，在通过equals方法计算相等操作触发Hash表排重机制</li>
</ol>
<p>综上所述：对Person这类提供equals和hashcode的重写操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Objects;</span><br><span class="line">public class Person </span><br><span class="line">&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public Person() </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    public Person(String name, int age) </span><br><span class="line">    &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    public String getName() </span><br><span class="line">    &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125; </span><br><span class="line">    public void setName(String name) </span><br><span class="line">    &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    public int getAge() </span><br><span class="line">    &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125; </span><br><span class="line">    public void setAge(int age) </span><br><span class="line">    &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() </span><br><span class="line">    &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">        &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">        &quot;, age=&quot; + age +</span><br><span class="line">        &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">        IDEA编译器提供两个版本的equals和hashcode的重写</span><br><span class="line">        这两个版本都是可以，只能二选一不能共存</span><br><span class="line">    */    </span><br><span class="line">    </span><br><span class="line">    //这个版本IDEA默认版本</span><br><span class="line">    /*</span><br><span class="line">        生成equals和hashcode方法是最后选项中有一个non-null</span><br><span class="line">        这里不建议勾选这个选中给提供属性，因为引用类型还是进行非null判断</span><br><span class="line">        如果你勾选在那么系统就默认认为引用类型时为null值</span><br><span class="line">        就会使用这个引用类型方法，如果此时你引用类型属性被赋值null，必</span><br><span class="line">出空指针异常</span><br><span class="line">    */</span><br><span class="line">    //勾选之后 non-null选项之后提供 equals实现</span><br><span class="line">    /* </span><br><span class="line">        @Override</span><br><span class="line">        public boolean equals(Object o) </span><br><span class="line">        &#123;</span><br><span class="line">            if (this == o) return true;</span><br><span class="line">            if (o == null || getClass() != o.getClass())</span><br><span class="line">            return false;</span><br><span class="line">            Person person = (Person) o;</span><br><span class="line">            if (age != person.age) return false;</span><br><span class="line">            return name.equals(person.name);</span><br><span class="line">        &#125;</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    //没有勾选 non-null选项之后提供 equals实现</span><br><span class="line">    /* </span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) </span><br><span class="line">    &#123;</span><br><span class="line">        //比较了地址，这个地址是真实地址，如果真实地址都相等 必然是同一个对象</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        */</span><br><span class="line">        /*</span><br><span class="line">            如果输入对象引用地址null那么 必然对象不同一个</span><br><span class="line">getClass方法的作用是用过字节码文件[.class]文件进行对象获</span><br><span class="line">取</span><br><span class="line">            只要是同一个类创建对象，他们字节码文件都是同一个【唯一】</span><br><span class="line">            两个对象字节码文件都不一样必然不是同一个对象</span><br><span class="line">        */</span><br><span class="line">        /*</span><br><span class="line">            if (o == null || getClass() != o.getClass())</span><br><span class="line">            return false;</span><br><span class="line">            //多态向下转型操作</span><br><span class="line">            Person person = (Person) o;</span><br><span class="line">        */        </span><br><span class="line">        //如果当前对象age属性与传入对象的age属性不一致 返回false，</span><br><span class="line">如果相等就不做任何操作</span><br><span class="line">        /*</span><br><span class="line">        if (age != person.age) return false;</span><br><span class="line">        */</span><br><span class="line">        /*</span><br><span class="line">        提供引用类型非null判断</span><br><span class="line">		只要当前对象的name属性值不为null 就通过name调用String类</span><br><span class="line">		equals方法</span><br><span class="line">        与传入对象name进行比较 相等为true，不相等为false</span><br><span class="line">        如果对象的name属性为null 就判断传入对象的name属性是否为null</span><br><span class="line">        如果也为null 结果就是true 否则就是false</span><br><span class="line">        */</span><br><span class="line">        /*</span><br><span class="line">        return name != null ? name.equals(person.name) :</span><br><span class="line">        person.name == null;</span><br><span class="line">    &#125; </span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() </span><br><span class="line">    &#123;</span><br><span class="line">        //获取引用类hashcode值作为新的hashcode值计算</span><br><span class="line">        int result = name != null ? name.hashCode() : 0;</span><br><span class="line">        //使用31这个值 乘以 引用类型hashcode值 然后加上 值类型属性值 得到最终hashcode</span><br><span class="line">        //最大的限度保证hashcode不出现重复</span><br><span class="line">        result = 31 * result + age;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    //这个版本IDEA使用Java7中提供Objects工具类</span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) </span><br><span class="line">    &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (o == null || getClass() != o.getClass())</span><br><span class="line">        return false;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        /*</span><br><span class="line">            变化现在使用:值类型比较融入到返回值比较结果中</span><br><span class="line">            调用了Objects工具类中equals方法进行 引用类型比较 --》原码实现</span><br><span class="line">            public static boolean equals(Object a, Object b)</span><br><span class="line">            &#123;</span><br><span class="line">            地址相等就是同一个对象或者判断 a 参数不为null 然后用a调用equals进行比较</span><br><span class="line">            return (a == b) || (a != null &amp;&amp; a.equals(b));</span><br><span class="line">            &#125; </span><br><span class="line">        */</span><br><span class="line">        return age == person.age &amp;&amp;</span><br><span class="line"> Objects.equals(name, person.name);</span><br><span class="line">    &#125; </span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() </span><br><span class="line">    &#123;</span><br><span class="line">        /*</span><br><span class="line">        Objects工具类中提供 hash方法 这个方法可以计算新的hashcode值</span><br><span class="line">        */</span><br><span class="line">        return Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-底层原理">(3)底层原理</h3>
<p>HashSet底层实现原理是HashMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet.add(<span class="number">3</span>);</span><br><span class="line">        hashSet.add(<span class="number">2</span>);</span><br><span class="line">        hashSet.add(<span class="number">1</span>);</span><br><span class="line">        hashSet.add(<span class="number">4</span>);</span><br><span class="line">        hashSet.add(<span class="number">4</span>);</span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//HashSet没有特殊方法，它的方法与Collection中学的方法是一致的</span></span><br><span class="line">        <span class="comment">//Set集合的遍历方式(迭代器)</span></span><br><span class="line">        Iterator&lt;Integer&gt; it = hashSet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//foreach遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Integer integer :</span><br><span class="line">                hashSet)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(integer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//HashSet的底层实现原理：HashSet底层实现原理是HashMap</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十一：LinkedHashSet类</center></h1>
<p>特点：</p>
<ul>
<li>有序</li>
<li>无下标</li>
<li>不可重复</li>
</ul>
<p>与父类的方法(HashSet)一致,去重的原理，也与父类一致</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSetDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 特点：</span></span><br><span class="line"><span class="comment">     *     1、有序（插入顺序）</span></span><br><span class="line"><span class="comment">     *     2、不重复</span></span><br><span class="line"><span class="comment">     *     3、无下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        LinkedHashSet&lt;String&gt; linkedHashSet = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        System.out.println(linkedHashSet);</span><br><span class="line">        <span class="comment">//1、底层实现 (LinkedHashMap)</span></span><br><span class="line">        <span class="comment">//2、去重原理 (与hashSet一致)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十二：Set集合实现类TreeSet</center></h1>
<p>TreeSet是Set集合接口实现类之一，它是一个特殊集合【这个集合不仅可以排重而且可以对存储到集合中的数据提供升序排序】，在以往开发中可以利用TreeSet这个特性对需要排序数据进行操作</p>
<p>PS：从Java8开始List集合专门提供方法sort方法，List集合也可以调用集合提供Sort方法进行对数据排序操作，但是不能排重，所以学习TreeSet的目的为类接触可以排序接口</p>
<p>在API文档中有说明：基于 TreeMap 的 NavigableSet 实现。使用元素的 自然顺序Comparable 对元素进行排序，或者根据创建 set 时提供的 自定义排序Comparator 进行排序，具体取决于使用的构造方法</p>
<p>Set集合系列主要实现都是依赖于Map集合，HashSet底层实现是HashMap，TreeSet底层实现是TreeMap，在Java8之前TreeSet底层实现的结构【二叉树+Hash表】，从Java8开始之后将底层实现的结构【红黑树+Hash表】</p>
<p>TreeSet中的使用API可以完全参考Set集合即可，其余API文档中提供方法自行查看</p>
<p>提供一个基础的TreeSet使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//向TreeSet中存储系统提供数据类型</span></span><br><span class="line">        TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        set.add(<span class="number">100</span>);</span><br><span class="line">        set.add(<span class="number">20</span>);</span><br><span class="line">        set.add(<span class="number">17</span>);</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        set.add(<span class="number">6</span>);</span><br><span class="line">        set.add(<span class="number">88</span>);</span><br><span class="line">        set.add(<span class="number">66</span>);</span><br><span class="line">        set.add(<span class="number">33</span>);</span><br><span class="line">        set.add(<span class="number">77</span>);</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//存储数据中提供两个1进行存储 ---》 自动排重和排序操作【默认是升序】</span></span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向TreeSet中存储自定义类的对象Student，根据学生年龄进行排序操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> height, <span class="type">int</span></span></span><br><span class="line"><span class="params"> weight)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">int</span> height)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">int</span> weight)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">        <span class="string">&quot;, height=&quot;</span> + height +</span><br><span class="line">        <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供TreeSet集合对象用于存储Student类的对象</span></span><br><span class="line">        TreeSet&lt;Student&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">178</span>,<span class="number">100</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>,<span class="number">181</span>,<span class="number">200</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">16</span>,<span class="number">200</span>,<span class="number">10</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;赵六&quot;</span>,<span class="number">19</span>,<span class="number">145</span>,<span class="number">150</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;田七&quot;</span>,<span class="number">21</span>,<span class="number">190</span>,<span class="number">160</span>));</span><br><span class="line">        System.out.println(treeSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题：使用TreeSet存储系统提供数据类型时，可以对数据进行排重与排序操作，但是向TreeSet中添加自定义类对象时，并没有进行排重排序操作，出现了一个异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException:com.qfedu.TreeSet.</span><br><span class="line">    Student cannot be cast tojava.lang.Comparable</span><br></pre></td></tr></table></figure>
<p>问题原因所在：当用TreeSet的无参构造方法时创建Set集合对象，【该 set 根据其元素的自然顺序进行排序。插入该 set 的所有元素都必须实现 Comparable 接口】，刚刚插入到TreeSet集合中Student类的对象并没有实现Comparable接口，所以出现ClassCastException</p>
<h1><center>知识点十三：Comparable接口【自然排序接口】</center></h1>
<p>官方文档说明:此接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 compareTo 方法被称为它的自然比较方法,【间接的说明Comparable接口是一个自然排序接口，对与实现接口类会提供排序操作，这个排序操作需要完成compareTo这个方法】</p>
<p>当前调用TreeSet集合的无参构造方法时，就要求向TreeSet中存储的数据必须实现Comparbale</p>
<p>实现Comparbale接口就需要实现接口中给提供方法</p>
<table>
<thead>
<tr>
<th>int</th>
<th>compareTo(T o) 比较此对象与指定对象的顺序</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>compareTo这个方法使用接口上泛型作为方法参数泛型，所以在实现Comparable的时候需要指定接口中泛型是什么类型，这样可以避免不必要向下转型，泛型T如何赋值，Comparbale提供谁进行比较这个类型就是谁Comparable提供compareTo方法对数据进行比较时遵守的原则 比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。compareTo这个方法的返回值类型时int类型，这个方法返回值是一个数字</td>
</tr>
</tbody>
</table>
<p>PS：compareTo这个方法不建议理解为比较方法，理解为交换方法即通过这个方法的得到返回值决定如何进行数据交换【存储】</p>
<p>之前有接触过一些排序的操作，例如冒泡、选择这些手写排序，但是这些排序中都会有一个必要的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提供比较操作，进行数据交换</span></span><br><span class="line"><span class="keyword">if</span>(arr[i] &gt; arr[i+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[i+<span class="number">1</span>];</span><br><span class="line">    arr[i+<span class="number">1</span>] = tmp;</span><br><span class="line">&#125; </span><br><span class="line">-------------------------------------</span><br><span class="line"><span class="keyword">if</span>(arr[i] &lt; arr[i+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[i+<span class="number">1</span>];</span><br><span class="line">    arr[i+<span class="number">1</span>] = tmp;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//通过修改比较操作中 大于号 或 小于号 可以决定 排序顺序</span></span><br><span class="line"><span class="comment">//那么Comparable接口中compareTo得到的int类型数值就是决定数据如何排序</span></span><br></pre></td></tr></table></figure>
<p>需要对CompareTo方法进行深入的理解【万能公式】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;CompareTo这方法会返回三个值 正整数、 负整数 和 0&quot;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    一般来说自定义类中提供比较属性基本上都是系统类型，就可以通过两个数</span></span><br><span class="line"><span class="comment">据之间记性“差值计算”从而得到 正整数、 负整数 和 0</span></span><br><span class="line"><span class="comment">    Student类为例 需要比较是年龄 --》年龄的属性是 int类型</span></span><br><span class="line"><span class="comment">    用两个int类型进行相减 得到结果就是 正整数、 负整数 和 0 正好满</span></span><br><span class="line"><span class="comment">足了CompareTo方法需求</span></span><br><span class="line"><span class="comment">    谁减谁可以得到什么结果，如果不是基本数据类型时引用类型减也不能计</span></span><br><span class="line"><span class="comment">算？</span></span><br><span class="line"><span class="comment">    不用担心引用类型问题，基本上能用来比较的引用类型都实现了</span></span><br><span class="line"><span class="comment">Comparable，</span></span><br><span class="line"><span class="comment">    所以比较引用类型调用这个引用类型中对应CompareTo方</span></span><br><span class="line"><span class="comment">法就可以</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="string">&quot;需要区分当前对象和传入对象&quot;</span></span><br><span class="line"><span class="string">&quot;调用CompareTo方法的就是当前对象使用【this表示】&quot;</span></span><br><span class="line"><span class="string">&quot;对CmpareTo方法参数赋值的就是传入对象使用【other表示】&quot;</span></span><br><span class="line"><span class="string">&quot;由此就可以得到一个万能公式：</span></span><br><span class="line"><span class="string">&quot;</span>当前对象 - 传入对象 【得到排序结果就是升序】<span class="string">&quot; ---》 正整数</span></span><br><span class="line"><span class="string">&quot;</span>传入对象 - 当前对象 【得到排序结果就是降序】<span class="string">&quot; ---》 负整数</span></span><br><span class="line"><span class="string">&quot;</span>切记：TreeSet的排重机制并不是equals和HashCode，而是实现排序</span><br><span class="line">接口中CompareTo或Compare方法的返回值，只要返回值为<span class="number">0</span>，TreeSet</span><br><span class="line">就会认为是同一个对象，进行排重操作<span class="string">&quot;</span></span><br><span class="line"><span class="string">//当前使用万能公式做计算时，如果遇到得到0时，出现排重效果，建议在得到0时在提供一个排序条件操作，或者使用List中sort方法排序</span></span><br><span class="line"><span class="string">使用这个公式进行排序时会面临到问题：</span></span><br><span class="line"><span class="string">问题1：此时排序数据类型时自定义类Student</span></span><br><span class="line"><span class="string">我们是不能使用 Student - Student 也不可能</span></span><br><span class="line"><span class="string">Student.CompareTo(Student)</span></span><br><span class="line"><span class="string">对自定义对象排序时，排序时*自定义对象的属性*，将当前公式变形为</span></span><br><span class="line"><span class="string">&quot;</span>当前对象.属性 - 传入对象.属性 【得到排序结果就是升序】<span class="string">&quot; ---》正整数</span></span><br><span class="line"><span class="string">&quot;</span>传入对象.属性 - 当前对象.属性 【得到排序结果就是降序】<span class="string">&quot; ---》负整数</span></span><br><span class="line"><span class="string">问题2：此时排序数据类型时系统类型Integer</span></span><br><span class="line"><span class="string">&quot;</span>当前对象 - 传入对象 【得到排序结果就是升序】<span class="string">&quot; ---》 正整数</span></span><br><span class="line"><span class="string">&quot;</span>传入对象 - 当前对象 【得到排序结果就是降序】<span class="string">&quot; ---》 负整数</span></span><br><span class="line"><span class="string">问题3: 如果遇到是引用类型无法使用减号进行计算时</span></span><br><span class="line"><span class="string">&quot;</span>当前对象.compareTo(传入对象) 【得到排序结果就是升序】<span class="string">&quot; ---》正整数</span></span><br><span class="line"><span class="string">&quot;</span>传入对象.compareTo(当前对象) 【得到排序结果就是降序】<span class="string">&quot; ---》负整数</span></span><br></pre></td></tr></table></figure>
<p>修改Student类进行年龄属性排序操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> height, <span class="type">int</span> weight)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125; </span><br><span class="line">    p</span><br><span class="line">ublic <span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">int</span> height)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125; </span><br><span class="line">    p</span><br><span class="line">ublic <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">int</span> weight)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">        <span class="string">&quot;, height=&quot;</span> + height +</span><br><span class="line">        <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student other)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//比较的是student类中age属性值 [升序排序]</span></span><br><span class="line">        <span class="comment">//return this.age - other.age;</span></span><br><span class="line">        <span class="comment">//比较的是student类中age属性值 [降序排序]</span></span><br><span class="line">        <span class="comment">//return other.age - this.age;</span></span><br><span class="line">        <span class="comment">//防止出现比较结果为0的时候怎么办？ ---&gt; 在提供一个比较数据即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age - other.age == <span class="number">0</span> ? <span class="built_in">this</span>.height - other.height : <span class="built_in">this</span>.age - other.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十四：Comparator接口【自定义排序接口】</center></h1>
<p>除了TreeSet集合中可以使用Comparable接口进行自然排序之外，还有一个更加灵活方便的接口Comparator，在系统API文档中说明：强行对某个对象 collection 进行整体排序 的比较函数。可以将Comparator 传递给 sort 方法（如 Collections.sort 或Arrays.sort ），从而允许在排序顺序上实现精确控制。还可以使用Comparator 来控制某些数据结构（如 有序 set 或 有序映射）的顺序，或者为那些没有 自然顺序的对象 collection 提供排序</p>
<p><strong>综上所述：Comparator接口不仅可以对TreeSet提供排序操作，而且可以针对Java系统API提供sort方法进行自定义排序操作</strong></p>
<p>Comparator接口中的核心比较方法</p>
<table>
<thead>
<tr>
<th>int</th>
<th>compare(T o1, T o2) 比较用来排序的两个参数</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>compare这个方法和Comparable接口中compareTo方法是一个道理也是返回 正整数、负整数和0 代表对象 大于 小于和等于</td>
</tr>
</tbody>
</table>
<p>刚刚在Comparable中提供万能公式可以直接使用在Comparator</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">这里是需要注意的是：</span></span><br><span class="line"><span class="string">&quot;</span>Comparator接口中compare方法有两个参数,两个参数谁是当前对象，谁是传入对象<span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span>compare方法中第一个参数 即 o1 就是当前对象即<span class="built_in">this</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span>compare方法中第二个参数 即 o2 就是传入对象即other<span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span>由此就可以得到一个万能公式：</span><br><span class="line"><span class="string">&quot;当前对象 - 传入对象 【得到排序结果就是升序】&quot;</span> ---》 正整数</span><br><span class="line"><span class="string">&quot;传入对象 - 当前对象 【得到排序结果就是降序】&quot;</span> ---》 负整数</span><br><span class="line"><span class="string">&quot;切记：TreeSet的排重机制并不是equals和HashCode，而是实现排序</span></span><br><span class="line"><span class="string">接口中CompareTo或Compare方法的返回值，</span></span><br><span class="line"><span class="string">只要返回值为0，TreeSet就会认为是同一个对象，进行排重操作&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当前使用功能公式做计算时，如果遇到得到0时，出现排重效果，建议在</span></span><br><span class="line">得到<span class="number">0</span>时在提供一个排序条件操作，或者算着List中sort方法排序</span><br><span class="line">使用这个公式进行排序时会面临到问题：</span><br><span class="line">问题<span class="number">1</span>：此时排序数据类型时自定义类Student</span><br><span class="line">我们是不能使用 Student - Student 也不可能</span><br><span class="line"> Student.CompareTo(Student)</span><br><span class="line">对自定义对象排序时，排序时自定义对象的属性，将当前公式变形为</span><br><span class="line"><span class="string">&quot;当前对象.属性 - 传入对象.属性 【得到排序结果就是升序】&quot;</span> ---》正整数</span><br><span class="line"><span class="string">&quot;传入对象.属性 - 当前对象.属性 【得到排序结果就是降序】&quot;</span> ---》负整数</span><br><span class="line">问题<span class="number">2</span>：此时排序数据类型时系统类型Integer</span><br><span class="line"><span class="string">&quot;当前对象 - 传入对象 【得到排序结果就是升序】&quot;</span> ---》 正整数</span><br><span class="line"><span class="string">&quot;传入对象 - 当前对象 【得到排序结果就是降序】&quot;</span> ---》 负整数</span><br><span class="line">问题<span class="number">3</span>: 如果遇到是引用类型无法使用减号进行计算时</span><br><span class="line"><span class="string">&quot;当前对象.compareTo(传入对象) 【得到排序结果就是升序】&quot;</span> ---》正整数</span><br><span class="line"><span class="string">&quot;传入对象.compareTo(当前对象) 【得到排序结果就是降序】&quot;</span> ---》负整数</span><br></pre></td></tr></table></figure>
<p><strong>复制Student类创建Student2来进行Comparator接口操作</strong></p>
<p>Comparator接口对应的是TreeSet中有参构造方法，所以要使用Comparator进行排序就需要使用当前这个有参构造方法【传入实现Comparator接口的实现类对象】方可进行排序操作</p>
<p><strong>提供两种实现Comparator接口的方式</strong>:</p>
<p>    第一种:提供一个比较原则类实现Comparator接口，实现compare方法定义排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student2</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student2</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> height, <span class="type">int</span> weight)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">int</span> height)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125; </span><br><span class="line">    p</span><br><span class="line">ublic <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">int</span> weight)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">        <span class="string">&quot;, height=&quot;</span> + height +</span><br><span class="line">        <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="comment">//提供一个类实现Comparator接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortGZ</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student2&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student2 o1, Student2 o2)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.getAge()-o1.getAge();</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用TreeSet中具备Comparator接口方法,参数赋值就是实现Comparator接口的对象</span></span><br><span class="line">        TreeSet&lt;Student2&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">SortGZ</span>());</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">178</span>,<span class="number">100</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>,<span class="number">181</span>,<span class="number">200</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">16</span>,<span class="number">200</span>,<span class="number">10</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;赵六&quot;</span>,<span class="number">19</span>,<span class="number">145</span>,<span class="number">150</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;田七&quot;</span>,<span class="number">21</span>,<span class="number">190</span>,<span class="number">160</span>));</span><br><span class="line">        treeSet.forEach(System.out::println);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>    第二种方式：就是使用匿名内部类或者lambda表达式实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest3</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用TreeSet中具备Comparator接口方法,参数赋值就是实现</span></span><br><span class="line">        Comparator接口的对象</span><br><span class="line">        <span class="comment">//匿名内部类版本</span></span><br><span class="line">        TreeSet&lt;Student2&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span></span><br><span class="line">        <span class="title class_">Comparator</span>&lt;Student2&gt;() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student2 o1, Student2 o2)</span> </span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">178</span>,<span class="number">100</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>,<span class="number">181</span>,<span class="number">200</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">16</span>,<span class="number">200</span>,<span class="number">10</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;赵六&quot;</span>,<span class="number">19</span>,<span class="number">145</span>,<span class="number">150</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;田七&quot;</span>,<span class="number">21</span>,<span class="number">190</span>,<span class="number">160</span>));</span><br><span class="line">        treeSet.forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Lambda表达式</span></span><br><span class="line">        TreeSet&lt;Student2&gt; treeSet2 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((o1,o2) -&gt; o2.getAge()-o1.getAge());</span><br><span class="line">        treeSet2.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">178</span>,<span class="number">100</span>));</span><br><span class="line">        treeSet2.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>,<span class="number">181</span>,<span class="number">200</span>));</span><br><span class="line">        treeSet2.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">16</span>,<span class="number">200</span>,<span class="number">10</span>));</span><br><span class="line">        treeSet2.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;赵六&quot;</span>,<span class="number">19</span>,<span class="number">145</span>,<span class="number">150</span>));</span><br><span class="line">        treeSet2.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;田七&quot;</span>,<span class="number">21</span>,<span class="number">190</span>,<span class="number">160</span>));</span><br><span class="line">        treeSet2.forEach(System.out::println);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结comparable和comparator接口">总结Comparable和Comparator接口</h2>
<p>    现在Java而言不仅只有TreeSet能排序，List集合也可以排序，Map集合也可以排序，合理规划使用排序即可，Comparable这个接口值专门针对TreeSet集合进行排序而设计一个接口，它的局限性在于它只适合自定义类存储在TreeSet进行使用，其他位置提供Sort方法是不使用Comparable作为参数，Comparator属于自定义排序接口，使用比较广泛，除了在TreeSet中可以使用之外，List集合中提供Sort和JavaAPI中提供其他Sort方法基本上都是使用Comparator参数类型，所以这两个接口建议优先掌握Comparator接口【使用广泛】，其次Comparable</p>
<h1><center>知识点十五：Set集合总结</center></h1>
<p>Set集合是一个接口继承与Collection接口和Iterable接口,Set集合本身具备排重功能和存储无序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Set</span> &lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p>Set集合集合主要的实现类有HashSet、LinkedHashSet和TreeSet，所以Set集合接口是支持多态创建对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">Set&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">Set&lt;Integer&gt; set3 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>Set集合中提供可操作集合都是线程不安全，所以面临多线程处理数据的时候</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.synchronizedSet(Set集合的对象); --》将一个Set集合对象变成线程安全集合</span><br></pre></td></tr></table></figure>
<p>除了这种方式之外可以使用Java5开始提供java.util.concurrent包下提供线程集合完全类来进行操作</p>
<p><strong>HashSet它是Set集合主要实现类，也是实际开发中使用比较广泛的一个类</strong>，这个类的主要实现是Hash表，底层实现是创建一个HashMap对象作为HashSet的具体实现，并且向HashSet存储数据时，其实是向HashMap中key值的位置进行数据存储</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//添加数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashSet的默认容量是16，加载因子是0.75，扩容大小是原有一倍</p>
<p>在Java8之前HashSet底层主要实现是Hash表【数组+链表】形式，从Java8开始对底层存储进行优化，提供存储和查询效果将原有Hash表进行优化【数组+链表或红黑树】，向Hash表中如果存储数据，<strong>某个存储位置中链表长度大达到8的时候【存储了8个数据】，就将链表修改为红黑树，从而提高查询效率</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291950536.WebP" alt="红黑树" style="zoom:50%;">
<p>HashSet存储自定义类对象时，如果需要进行排重操作，需要提供equals和hashcode重写</p>
<p>LinkedHashSet是HashSet子类，本身不具备任何特殊方法，所有都是来源于Set接口，唯一特点就是提供一个链表来记录存储顺序，开发中是几乎与不用，它操作可有完全仿照HashSet</p>
<p>TreeSet 是Set集合中一个排序排重的集合，这个集合使用 红黑树+Hash表，当使用TreeSet的无参构造方法创建对象时，向TreeSet集合存数据，这个存储的数据必须实现Comparable接口，也可使用TreeSet的有参构造方法，方法参数是Comparator类型，实现Comparator接口进行存储数据的自定义排序</p>
<p>PS:不是只有TreeSet才可以排序，List和Map集合都可以进行排序操作，但是这个俩个集合都会使用到Comparator</p>
<h1><center>知识点十六：Collection集合</center></h1>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291950700.WebP" alt="Collection集合" style="zoom:50%;">
<p>Collection集合接口是List和Set集合接口父接口，Collection集合接口继承Iterable接口，所以List和Set集合接口都是支持迭代器操作，因为List和Set集合接口都是Collection集合子接口，所以List和Set集合接口的实现了可以作为Collection集合接口的实现类使用，所以支持多态创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Collection集合接口创建对象</span></span><br><span class="line">Collection &lt;Integer&gt; c1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collection &lt;Integer&gt; c2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">Collection &lt;Integer&gt; c3 = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">Collection &lt;Integer&gt; c4 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">Collection &lt;Integer&gt; c5 = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">Collection &lt;Integer&gt; c6 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>因为Collection是集合接口，所以里面的方法都已经讲解完毕</p>
<p>PS：在实际开发中List集合接口中最常用类是ArrayList，Set集合接口中最常用类是HashSet</p>
<h1><center>知识点十七：Collections工具类</center></h1>
<p>将集合中的元素反转</p>
<p>    Collections.reverse(List list)</p>
<p>将集合中的元素随机打乱</p>
<p>    Collections.shuffle(List list)</p>
<p>将集合中的元素排序 （必须要实现Comparable接口）</p>
<p>    Collections.sort(List list)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;大娃&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;二娃&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;妖怪&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;蛇妖&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;蛇妖&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//按照字典顺序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将集合元素进行翻转</span></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将集合中的元素进行随机打乱</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Arrays数组工具类 Collections集合工具类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十七：Map集合</center></h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291953280.WebP" alt="Map集合"></p>
<h2 id="center-1-map集合介绍-center"><center>1、Map集合介绍</center></h2>
<p>    Map集合是两大集合之一和Collection之间是并存关系，Map不是Collection的子类，Map一般会和List和Set这两个集合并称三大集合【List、Set和Map】，因为Map和Collection并没有什么关系，所以Map集合和Iterable接口也没有任何关系，所以Map集合是不提供迭代器操作</p>
<p>    Map集合在Java提供一种存储数据方式，这种方式称之为“映射”【keyvalue键值对】，通过映射这种关系将将两个数据进行相连形成数据存储形式就是key-value键值对</p>
<p>PS：key和value值不要过分纠结，只要提供Map存储数据数据类型就可以决定key值存储什么value值存储什么，他们在底层存储形式是以一种键值对相连的【情侣】</p>
<p>    映射的说明: 在数学中假设A，B两个非空集合，如果存在一个法则F，使用A集合中每一个元素按照法则F在B集合中有一个唯一对应，则成F为A到B集合映射关系</p>
<p>在做映射关系时：</p>
<p>    提供key值要求是唯一的 ，A集合中相当于存储Key而<strong>Key是唯一</strong>的，所以可以想象存储key的集合其实就是Set集合提供vlaue值是可以不唯一的，B集合相当于存储Value而<strong>value是不唯一的</strong>，所以可以想象存储value的集合其实就是List集合</p>
<p>提供一个链接法则【链接原则】 让A集合key可以和B集合中value进行一个链接形成一个键值对，Map提供存储方式就是这个方法Entry(key-value),Map中存储大量Entry实体存储就是相当与键值对存储了</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291954387.WebP" alt="介绍" style="zoom:50%;">
<h2 id="center-2-map集合主要实现类hashmap-center"><center>2、Map集合主要实现类HashMap</center></h2>
<p>HashMap与Map接口之间关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>
<p>    HashMap的主要实现接就是Map，HashMap也是Map接口的最主要实现类HashMap在官方文档中说明：基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外， HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变</p>
<p>    说明：HashMap的主要实现使用Hash表，但是在Java7之前使用的是原始Hash表的形式即【数组+链表】形式存储数据，但是从Java8开始HashMap集合提供Hash表实现从【数组+链表】转换为【数组+链表或红黑树】，当前向HashMap中某个“桶节点【即存储位置】”，添加的数据达到8个时，就会将链表结构转换红黑树，8这个数字在链表中的查询效果是可以控制，因为链表的查询方式是线性查询【从前之后】，所以最快效率是1，最慢效率N，平均值(1+N)/2,随着N值不断变大，这个查询效率会逐渐降低，所以在8节点时将链表转换为红黑树，就是为提高查询效率而是用，红黑树是平衡树，而且树的查询效率是【2倍效率】</p>
<p>HashMap集合是线程不安全集合，在多线程前提现可以使用</p>
<p>Hashtable【之前做法】，现在开发不在使用Hashtable，如何解决线程不安全问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>()); ---&gt; 得到一个线程安全集合或者</span><br><span class="line">                                                    使用线程安全Map集合---》ConcurrentHashMap集合</span><br></pre></td></tr></table></figure>
<p>HashMap是存储key-value键值对形式集合，所以创建HashMap对象时需要提供Key和Value的泛型的数据类型，HashMap毕竟底层是Hash表所以在Java中初始容量16,加载因子0.75，扩容方式是原有容量2倍，并且会重新计算所有存储在HashMap中数据存储位置即从新计算key的存储位置</p>
<p>HashMap在Java8之前和Java8之后API有很大的变化，将Java8之前API看做是基础API，将Java8提供API看做增强操作API即可</p>
<h2 id="center-3-hashmap常用方法-java8之前-center"><center>3、HashMap常用方法(Java8之前)</center></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiConsumer;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供HashMap的对象创建方式</span></span><br><span class="line">        <span class="comment">//1.1创建一个空HashMap集合对象【默认初始容量16，加载因子0.75】 ---&gt; 常用</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//1.2创建一个提供初始容量大小的HashMap集合对象【加载因子0.75】</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">32</span>);</span><br><span class="line">        <span class="comment">//1.3创建一个提供初始容量大小和加载因子的HashMap对象---》提供的容量是16的倍数，加载因子不易过小</span></span><br><span class="line">        HashMap&lt;Character,Double&gt; map3 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt; (<span class="number">32</span>,<span class="number">0.5f</span>);</span><br><span class="line">        <span class="comment">//1.4将参数Map集合对象中存储数据赋值给当前HashMap集合对象进行存储 ---&gt; 偶尔</span></span><br><span class="line">        HashMap&lt;String, Integer&gt; map4 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt; (map);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//提供常用API;</span></span><br><span class="line">        <span class="comment">//1.向HashMap集合对象中添加数据 [第一个参数是存储的key值，第二个参数参数存储是value值]</span></span><br><span class="line">        map.put(<span class="string">&quot;1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(map);<span class="comment">//HashMap已经重写toString方法所以直接打印集合对象查看结果</span></span><br><span class="line">        <span class="comment">//PS：在使用put方法向map集合对象中添加 &quot;1&quot;,2 键值对</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1.向Map集合添加Key-value键值对时 key值必须是唯一的，又使用key = &quot;1&quot; 那么系统并没有</span></span><br><span class="line"><span class="comment">                提示任何语法错误信息和异常信息，是否会出现运行时异常呢？ ---》不会出现异常</span></span><br><span class="line"><span class="comment">            2.put方法的第二个作用：修改指定key对应value值</span></span><br><span class="line"><span class="comment">                当使用put方法提供一个已经在map集合对象中存在key时，将put操作认为是覆盖原有已经存在map集合中key-value</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        map.put(<span class="string">&quot;1&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//putAll(Map集合对象) --&gt; 将参数Map集合对象中存储的数据赋值给Map集合</span></span><br><span class="line">        <span class="comment">// clear() ---&gt; 将Map集合中存储数据清空，map对象的引用是保留</span></span><br><span class="line">        <span class="comment">// isEmpty() ---&gt;判断Map集合中是否有存储数据 存储数据返回false 没有存储返回true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断Map集合中是否存在指定key值 --&gt; 存储返回true 不存在返回false</span></span><br><span class="line">        System.out.println(map.containsKey(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">        <span class="comment">//判断Map集合中是否存在指定value值 --&gt;存储返回true 不存在返回false</span></span><br><span class="line">        System.out.println(map.containsValue(<span class="number">2</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取存储在Map集合value值时 ---》key存在会得到对应value，key不存在会得到null值</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> map.get(<span class="string">&quot;2&quot;</span>);    <span class="comment">//参数：key值</span></span><br><span class="line">        <span class="keyword">if</span>(Objects.nonNull(integer)) <span class="comment">//建议添加非null判断</span></span><br><span class="line">        &#123; </span><br><span class="line">            integer.intValue();</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将存储在Map集合中key-value键值对删除，条件是一个key值</span></span><br><span class="line">        map.remove(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;获取Map集合中存储元素的个数：&quot;</span>+map.size());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Map集合遍历方式比较麻烦，没有迭代器，不支持普通for循环遍历，不支持增强for</span></span><br><span class="line">        <span class="comment">//获取map集合中所有key的值存储在一个Set集合中</span></span><br><span class="line">        Set&lt;String&gt; strings = map.keySet(); <span class="comment">//通过这种方式获取到所有key</span></span><br><span class="line">        <span class="comment">//获取map集合中所有value的值存储在一个Collection集合中</span></span><br><span class="line">        Collection&lt;Integer&gt; values = map.values(); <span class="comment">//通过这种方式获取到所有value值</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Map提供了一种遍历方式entrySet方法 --&gt;返回值是一个Set集合</span></span><br><span class="line"><span class="comment">            Set集合存在一个泛型类型 Map.Entry ---》Set集合中存储的数据类型</span></span><br><span class="line"><span class="comment">            Map.Entry&lt;String,Integer&gt; --&gt; 相当Map.Entry类型中存储数据是 String类型key 和 Integer类型value</span></span><br><span class="line"><span class="comment">            通过entrySet这个方法，返回一个Set集合这个集合存储这个Entry的类型，Entry类型的内部存储的是key-value兼职对</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; map5 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map5.put(<span class="string">&quot;key1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        map5.put(<span class="string">&quot;key2&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        map5.put(<span class="string">&quot;key3&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        map5.put(<span class="string">&quot;key4&quot;</span>,<span class="number">4</span>);</span><br><span class="line">        map5.put(<span class="string">&quot;key5&quot;</span>,<span class="number">5</span>);</span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map5.entrySet();</span><br><span class="line">        System.out.println(entries);</span><br><span class="line">        <span class="comment">//提供Set集合之增强for循环遍历</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : entries)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//entry就得到了存储在Set集合中key-value键值对 即 key1=1</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Key的值是：&quot;</span>+entry.getKey());</span><br><span class="line">            System.out.println(<span class="string">&quot;Value的值是：&quot;</span>+entry.getValue());</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//在Java8中时提供一个foreach方法可以便捷遍历集合中key和value</span></span><br><span class="line">        map5.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;String, Integer&gt;() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * </span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> s map集合中key值</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> integer map集合汇总value</span></span><br><span class="line"><span class="comment">            * 这个方法被出触发时可以获取map集合中每一对：keyvalue</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s, Integer integer)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//这个可以进行操作但是只是打印的结果，不会影响最终map集合中的结果</span></span><br><span class="line">                System.out.println(s);</span><br><span class="line">                System.out.println(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        map5.forEach((k,v)-&gt; System.out.println(k+<span class="string">&quot;=&quot;</span>+v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-4-hashmap常用方法-java8之后-center"><center>4、HashMap常用方法(Java8之后)</center></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 提供HashMap基础API【Java8之后】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapAPIDemo_2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供HashMap的对象创建方式</span></span><br><span class="line">        <span class="comment">//1.1创建一个空HashMap集合对象【默认初始容量16，加载因子0.75】 ---&gt; 常用</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//新Java8中方法</span></span><br><span class="line">        <span class="comment">//1向map集合中添加数据 ---&gt;如果key已经存在则不添加，否则添加数据 【建议向Map集合存储数据使用】</span></span><br><span class="line">        map.putIfAbsent(<span class="string">&quot;1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        map.putIfAbsent(<span class="string">&quot;2&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        map.putIfAbsent(<span class="string">&quot;3&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        map.putIfAbsent(<span class="string">&quot;1&quot;</span>,<span class="number">1000</span>);</span><br><span class="line">        map.putIfAbsent(<span class="string">&quot;1&quot;</span>,<span class="number">10000</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">//2.提供了一个全系列对map集合中k和v进行存储的方法 ---》computeXXX方法</span></span><br><span class="line">        <span class="comment">//2.1 map集合中指定key在map集合进行操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        执行原理:</span></span><br><span class="line"><span class="comment">            无论key是否存在都会执行参数中提供Lambda表达式</span></span><br><span class="line"><span class="comment">            1.如果key值存在，后面提供Lambda表达式就会取出key所对应value并在Lambda表达式中进行操作，然后修改原有k和v值</span></span><br><span class="line"><span class="comment">            2.如果key值不存在，后面提供Lambda表达式就会将key进行存到 map集合操作</span></span><br><span class="line"><span class="comment">                第一个参数就是key值，第二个参数就是提供操作key对应Lambda表达式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        map.compute(<span class="string">&quot;3&quot;</span>,(k,v) -&gt; v == <span class="literal">null</span> ? <span class="number">0</span> : v+<span class="number">1</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        map.compute(<span class="string">&quot;4&quot;</span>,(k,v) -&gt; v == <span class="literal">null</span> ? <span class="number">0</span> : v+<span class="number">1</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">//2.2 判断map集合key是否存在提供对应操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        执行原理：</span></span><br><span class="line"><span class="comment">            1.如果key存在，后面提供Lambda表达式就不会执行，并返回key对应value值</span></span><br><span class="line"><span class="comment">            2.如果key不存储，后面提供Lambda表达式就会执行操作者并将Lambda表达式中处理</span></span><br><span class="line"><span class="comment">            之后value值与key一起存储到map集合中</span></span><br><span class="line"><span class="comment">            PS：Lambda表达式是你如何处理这个value操作 ，你自己决定</span></span><br><span class="line"><span class="comment">            但是一定要返回这个value即添加return</span></span><br><span class="line"><span class="comment">            第一个参数就是key值，第二个参数就是提供操作key对应Lambda表达式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> map.computeIfAbsent(<span class="string">&quot;3&quot;</span>,key -&gt; <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">5</span>));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        map.computeIfAbsent(<span class="string">&quot;5&quot;</span>,key -&gt; <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">5</span>));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">//2.3 判断map集合key是否存在提供对应操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        执行原理：</span></span><br><span class="line"><span class="comment">            1.如果key存在，就执行后lambda表达式，并修改map集合key所对应value值</span></span><br><span class="line"><span class="comment">            2.如果key不存在，就不会执行后面lambda表达式，不会像Map集合中做任何操作，但是方法会返回一个null</span></span><br><span class="line"><span class="comment">            第一个参数就是key值，第二个参数就是提供操作key对应Lambda表达式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        map.computeIfPresent(<span class="string">&quot;3&quot;</span>,(k,v) -&gt; v+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            相当于 你调用map.containsKey() --》 在调用 map.get()--》得到value之后进行操作</span></span><br><span class="line"><span class="comment">            在调用 ---&gt;map.put 这个存储回去</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(map);</span><br><span class="line">        map.computeIfPresent(<span class="string">&quot;6&quot;</span>,(k,v) -&gt; v+<span class="number">1</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            getOrDefault这个方法作用是通过key值获取对应value，这个方法根get方法最大区别在于</span></span><br><span class="line"><span class="comment">            这个方法提供一个默认值，如果key不存在则返回对应默认值， 存在则返回value值</span></span><br><span class="line"><span class="comment">            get方法在则返回value不在则返回null值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//第一个参数是key值 第二个参数是默认值</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">orDefault</span> <span class="operator">=</span> map.getOrDefault(<span class="string">&quot;7&quot;</span>, Integer.MAX_VALUE);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//merge(合并) --》方法含义 对存在在map集合中kv键值对进行更新操作【更新value值】</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一个参数 是map集合存在key值</span></span><br><span class="line"><span class="comment">            第二个参数 这个参数的作用是向Lambda表达式中提供方法参数中</span></span><br><span class="line"><span class="comment">            第二个参数赋值 即 newVal</span></span><br><span class="line"><span class="comment">            第三个参数 需要对存在在集合key所对应value所提供更新数据操作 --》 提供一个lambda</span></span><br><span class="line"><span class="comment">            lambda中第一个参数即oldVal是获取出提供key所对应的value值</span></span><br><span class="line"><span class="comment">            第二个参数即newVal或获取方法中第二个参数值</span></span><br><span class="line"><span class="comment">            提供这两个参数计算更新key所对应value值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        map.merge(<span class="string">&quot;1&quot;</span>,<span class="number">2</span>,(oldVal,newVal)-&gt;oldVal+newVal);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除方法--》根据提供k和v值进行删除，如果存在在map中删除成功返回true，如果不存在删除失败返回false</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">remove</span> <span class="operator">=</span> map.remove(<span class="string">&quot;1&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(remove);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Java8中提供一个操作，官方文档意思在于使用这个方法替代put方法修改操作</span></span><br><span class="line">        <span class="comment">//根据key值替换存储对应value值，如果key存在则替换，不存在则不替换</span></span><br><span class="line">        map.replace(<span class="string">&quot;2&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">// 多参数版本 提供完整key-value键值对，进行替换操作 如果key和value匹配成功存在则替换，不存在则替换</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一个参数是 key值</span></span><br><span class="line"><span class="comment">            第二个参数是 key对应原理的value值</span></span><br><span class="line"><span class="comment">            第三个参数是 新替换value值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        map.replace(<span class="string">&quot;2&quot;</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//只要满足lambda表达式提供替换条件，就会将value值进行替换</span></span><br><span class="line">        map.replaceAll((key,value)-&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供替换操作者条件</span></span><br><span class="line">            <span class="keyword">if</span>(key.length() &gt;= <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//提供替换操作</span></span><br><span class="line">                value = <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//需要将替换的value值提提供return返回</span></span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">// forEach打印方法</span></span><br><span class="line">        map.forEach((k,v)-&gt; System.out.println(k+<span class="string">&quot;=&quot;</span>+v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashMap有一个子类LinkedHashMap这个集合 操作方式和HashMap是一样，只不过就是存储结构有所变化多了一个链表存储，Hashtable已经不在使用了，所以这个API执行查看和HashMap操作一样的</p>
<h2 id="center-5-map集合之treemap集合-center"><center>5、Map集合之TreeMap集合</center></h2>
<p>TreeMap集合是Map集合实现类之一，TreeMap集合提供排序操作，TreeMap集合排序操作和TreeSet道理相同的，需要提供Comparator和Comaprable接口，根据使用TreeMap中构造方法决定说那个那个接口来实现排序操作</p>
<p>在官方的API文档中的介绍：基于红黑树（Red-Black tree）的NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法</p>
<p>TreeMap集合的排序点在于存储的键值key，将要排序数据存储到key中就可以进行排序操作</p>
<p>当调用无参构造方法创建TreeMap对象时，使用Comparable进行的比较操作</p>
<p>TreeMap() 使用键的自然顺序构造一个新的、空的树映射</p>
<p>当调用有参构造方法创建TreeMap对象时，使用Comparator进行的比较操作</p>
<p>TreeMap(Comparator comparator) 构造一个新的、空的树映射，该映射根据给定比较器进行排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMapDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        TreeMap&lt;Integer,String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">10</span>,<span class="string">&quot;value10&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">8</span>,<span class="string">&quot;value8&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">15</span>,<span class="string">&quot;value15&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">7</span>,<span class="string">&quot;value7&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">1</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">9</span>,<span class="string">&quot;value9&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">20</span>,<span class="string">&quot;value20&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">13</span>,<span class="string">&quot;value13&quot;</span>);</span><br><span class="line">        System.out.println(treeMap);</span><br><span class="line">        </span><br><span class="line">        TreeMap&lt;Integer,String&gt; treeMap2 = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt; (<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> </span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">10</span>,<span class="string">&quot;value10&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">8</span>,<span class="string">&quot;value8&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">15</span>,<span class="string">&quot;value15&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">7</span>,<span class="string">&quot;value7&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">1</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">9</span>,<span class="string">&quot;value9&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">20</span>,<span class="string">&quot;value20&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">13</span>,<span class="string">&quot;value13&quot;</span>);</span><br><span class="line">        System.out.println(treeMap2);</span><br><span class="line">        </span><br><span class="line">        TreeMap&lt;Integer,String&gt; treeMap3= <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt; ((o1,o2)-&gt;o2 - o1);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">10</span>,<span class="string">&quot;value10&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">8</span>,<span class="string">&quot;value8&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">15</span>,<span class="string">&quot;value15&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">7</span>,<span class="string">&quot;value7&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">1</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">9</span>,<span class="string">&quot;value9&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">20</span>,<span class="string">&quot;value20&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">13</span>,<span class="string">&quot;value13&quot;</span>);</span><br><span class="line">        System.out.println(treeMap3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TreeMap集合排序的时候也是会对key值进行排重操作，这个排重操作依据是提供Comparable和Comparator接口中方法实现时，如果结果为0，就会进行排重操作</p>
<h2 id="center-6-collections工具类-center"><center>6、Collections工具类</center></h2>
<p>Collections工具类类似于Arrays工具类，Collections工具类是为了给Collection集合提供便捷操作工具类，虽然Collection集合已经提供很多方法了，但是Collections工具类也提供一些操作方法，弥补开发时所需要自行定义方法</p>
<p>Collections工具类提供方法大部分都是给Collection集合使用，极少部分是给Map集合使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsAPIDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.一次性向Collection集合对象中添加多个数据--》【推荐】</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//向集合中存这些数据：【 321,34,3,1,4,4231,4123,353,1】</span></span><br><span class="line">        list.add(<span class="number">321</span>);</span><br><span class="line">        list.add(<span class="number">34</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">4231</span>);</span><br><span class="line">        list.add(<span class="number">4123</span>);</span><br><span class="line">        list.add(<span class="number">353</span>);</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//不用上面这样麻烦操作了,直接使用addAll方法就可以了</span></span><br><span class="line">        <span class="comment">//这个方法的第一个参数是 Collection集合对象， 第二个参数就是要存储值使用【,】分隔即可</span></span><br><span class="line">        Collections.addAll(list,<span class="number">321</span>,<span class="number">34</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">4231</span>,<span class="number">4123</span>,<span class="number">353</span>,<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.提供Collection集合排序操作【针对是List集合】</span></span><br><span class="line">        Collections.sort(list); <span class="comment">//默认是升序排序操作【要去排序数据要么实现Comparable要么实现Comparator】</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//可以使用Collections工具类中提供静态方法进行降序排序【仅针对集合中存储系统引用类型有效】</span></span><br><span class="line">        Collections.sort(list,Collections.reverseOrder());</span><br><span class="line"></span><br><span class="line">        System.out.println(list); <span class="comment">//指针对系统类型</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//自定义排序操作</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> o1 - o2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Collections.sort(list,(o1,o2)-&gt;o2-o1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从Java8开始List集合接口提供sort方法，所以可以直接调用List集合的sort方法进行排序操作</span></span><br><span class="line">        list.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> o1-o2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        list.sort((o1,o2)-&gt;o2-o1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将List、set和Map集合转换为线程安全的集合</span></span><br><span class="line">        List&lt;Integer&gt; lists = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        Set&lt;String&gt; sets = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;());</span><br><span class="line">        Map&lt;String, Integer&gt; maps = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 提供二分查找【要排序数据】 找到 下标 找不到 负数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Collections.binarySearch(list, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//交换List集合存储元素的位置 位置参数是下标</span></span><br><span class="line">        Collections.swap(list,<span class="number">0</span>,list.size()-<span class="number">1</span>);<span class="comment">//第一个元素和最后一个元素互换</span></span><br><span class="line">        <span class="comment">//打乱List集合对象中存储数据的顺序【将有序存储数据打乱存储】</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        <span class="comment">//向List集合中填充同一个数据</span></span><br><span class="line">        Collections.fill(list,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-7-collection集合和map集合的总结-center"><center>7、Collection集合和Map集合的总结</center></h2>
<p>Collection是Java集合框架中根接口也是List和Set集合的父接口，Collection集合接口也继承Iterable接口所有Collection系的集合都支持迭代器进行遍历操作，在Collection集合接口中常用的就是List和Set接口，List和Set接口中常用的实现类集合<strong>ArrayList【允许存储重复数据并且使用数组实现】和HashSet【不允许存储重复数据并且使用Hash表实现】</strong></p>
<p>Map集合本身没是不在Collection范围内容，它是一个独立的集合，Map提供一种【键值对】即key-value的形式进行数据存储操作，在存储数据时要求key值必须是唯一的，value值可以不唯一，<strong>在Map集合接口中主要使用实现类是HashMap</strong></p>
<p><strong>PS：List集合使用ArrayList 、Set集合使用HashSet、Map集合使用HashMap</strong></p>
<h2 id="center-8-hashmap应用-center"><center>8、HashMap应用</center></h2>
<ul>
<li>可以使用Map 表示一个实体类</li>
<li>可以使用List&gt; 表示一个实体类集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapDemo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在java一个用户对象</span></span><br><span class="line"><span class="comment">     *      一个用户对象</span></span><br><span class="line"><span class="comment">     *      public class user</span></span><br><span class="line"><span class="comment">     *      &#123;</span></span><br><span class="line"><span class="comment">     *          private String username;</span></span><br><span class="line"><span class="comment">     *          private String password;</span></span><br><span class="line"><span class="comment">     *          private int age;</span></span><br><span class="line"><span class="comment">     *          private String phone;</span></span><br><span class="line"><span class="comment">     *          private String address;</span></span><br><span class="line"><span class="comment">     *          ......</span></span><br><span class="line"><span class="comment">     *      &#125;</span></span><br><span class="line"><span class="comment">     *      User user = new User(&quot;admin&quot;,&quot;123&quot;,30);</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      多个用户对象</span></span><br><span class="line"><span class="comment">     *      以前：User[]</span></span><br><span class="line"><span class="comment">     *      现在：List&lt;User&gt;</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     * 在实战开发中，如果这个类使用不多，那么这个时候就没有必要创建一个User类</span></span><br><span class="line"><span class="comment">     * 可以使用Map来代替</span></span><br><span class="line"><span class="comment">     *      一个用户对象</span></span><br><span class="line"><span class="comment">     *       HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">     *       map.put(&quot;username&quot;,&quot;admin&quot;);</span></span><br><span class="line"><span class="comment">     *       map.put(&quot;password&quot;,&quot;123&quot;);</span></span><br><span class="line"><span class="comment">     *       map.put(&quot;age&quot;,20);</span></span><br><span class="line"><span class="comment">     *       多个用户对象</span></span><br><span class="line"><span class="comment">     *       List&lt;Map&lt;String,Object&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-9-hashmap底层实现原理-center"><center>9、HashMap底层实现原理</center></h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292004683.WebP" alt="实现原理" style="zoom: 50%;">
<h2 id="center-10-put的过程原码-center"><center>10、put的过程原码</center></h2>
<p>put流程</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292004096.WebP" alt="put流程" style="zoom:50%;">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//tab表示存放Node节点的数据 p表示当前节点 n表示长度 i表示节点在数组中的下标</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">//判断数组如果为空或者数组长度为0，那么就对数组进行扩容，数组默认初始大小为16</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//将数组的长度-1与hash值进行与运算(计算的结果一定是0~数组长度-1)得到元素应该存放的下标</span></span><br><span class="line">    <span class="comment">//如果当前下标位置为空，那么直接将Node节点存放在当前位置</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//如果当前位置不为空(分为三种情况)</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//情况1：要添加的元素与当前位置上的元素相同(hash(hashCode)、key(equals)一致),则直接替换</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//情况2:如果要添加的元素是红黑树节点，那么将其添加到红黑树上</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//情况3:如果要添加的元素是链表，则需要遍历</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//将当前元素的下一个节点赋给e</span></span><br><span class="line">                <span class="comment">//如果e为空，则创建新的元素节点放在当前位置的下一个元素上，并退出循环</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//如果链表的元素个数大于8个(且当数组中的元素个数大于64)，则将其转换成红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)     <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//要添加的元素与当前位置上的元素相同(hash(hashCode)、key(equals)一致),则直接退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; </span><br><span class="line">          <span class="comment">//如果返回的e不为null</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="literal">null</span>)</span><br><span class="line">          &#123; </span><br><span class="line">              <span class="comment">// existing mapping for key</span></span><br><span class="line">              <span class="comment">//将e的值赋给oldValue</span></span><br><span class="line">              <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                  e.value = value;afterNodeAccess(e);</span><br><span class="line">                  <span class="comment">//返回以前的值(当添加的元素已经存在返回的是以前的值)</span></span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//如果数组的元素个数大于阈值则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-11-resize过程原码-center"><center>11、resize过程原码</center></h2>
<p>扩容流程</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292005741.WebP" alt="扩容时机" style="zoom:50%;">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//oldTab 表示原来数组(如果是第二次扩容：长度为16的那个)</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//oldCap 表示原数组的容量(长度)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//oldThr 表示数组原来的阈值 12</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="comment">//newCap 新数组的容量 newThr 新数组的阈值</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">        &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;<span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//新数组的容量扩大一半 newCap 32</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">        <span class="comment">//新阈值扩大老阈值的一半 newThr 24</span></span><br><span class="line">        newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)     <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?(<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//threshold 24</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">//创建一个长度为32的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    <span class="comment">//table指向新数组</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将原数组中的元素拷贝到新数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">//如果当前位置元素不为空</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//情况1：当前位置上的下一个元素为空，则直接将这个元素拷贝到新数组中</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//情况2：当前位置上的元素红黑树类型，则需要进行切割</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">//情况3：当前位置上的元素链表类型，则需要进行分散拷贝</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                             loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-12-get的过程原码-center"><center>12、get的过程原码</center></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e;</span><br><span class="line">    <span class="type">int</span> n;K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;(first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当前first与要找到的hash和key都相等直接返回当前这个first元素</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">            <span class="comment">//如果当前first不为空(有两种情况)</span></span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//当前位置是一个红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//根据hash、key从红黑树上找到对应的元素z</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="comment">//当前位置是一个链表</span></span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//循环进行比较直到找到向的hash和key的元素，并返回</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">     &#125; </span><br><span class="line">    <span class="comment">//如果数组的为空、数组的长度为0、当前下标位置上的值为null,这三种情况都返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十八：常见的集合面试面试题</center></h1>
<ul>
<li>1、简述：ArrayList、LinkedList、Vector的区别</li>
<li>2、简述：HashSet、TreeSet的去重原理</li>
<li>3、ArrayList、LinkedList底层实现</li>
<li>4、HashMap、HashTable的区别</li>
<li>5、HashMap底层实现原理</li>
<li>6、HashMap扩容机制</li>
<li>7、HashMap的数组容量为什么是2的次方数</li>
<li>8、HashMap的负载因子为什么是0.75</li>
<li>9、HashMap添加元素的过程</li>
<li>10、谈谈了解的数据结构</li>
</ul>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://i.postimg.cc/wjTxDpBF/image.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://i.postimg.cc/wjTxDpBF/image.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">星仔极客</div><div class="post-copyright__author_desc">珍惜当下 不负此生</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://xinzaigeek.68565200.xyz/post/9e25cba9.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://xinzaigeek.68565200.xyz/post/9e25cba9.html')">5.集合</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://xinzaigeek.68565200.xyz/post/9e25cba9.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=5.集合&amp;url=https://xinzaigeek.68565200.xyz/post/9e25cba9.html&amp;pic=https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xinzaigeek.68565200.xyz" target="_blank">星仔极客</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Java%E8%AF%AD%E8%A8%80/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Java语言<span class="tagsPageCount">12</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://img.picgo.net/2024/11/13/c12889d56cf9e0078ed87b335eb8b0b321601f0548e324aa.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/a920af81.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" onerror="onerror=null;src='https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">4.常用工具类</div></div></a></div><div class="next-post pull-right"><a href="/post/a24af109.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" onerror="onerror=null;src='https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">6.异常、File类和递归</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/post/ca0fcd03.html" title="0.Java概述"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-30</div><div class="title">0.Java概述</div></div></a></div><div><a href="/post/fbc82303.html" title="1.Java基本语法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-30</div><div class="title">1.Java基本语法</div></div></a></div><div><a href="/post/8f9052f9.html" title="22.File类和递归"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-30</div><div class="title">22.File类和递归</div></div></a></div><div><a href="/post/76fa8c0d.html" title="2.面向对象"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-30</div><div class="title">2.面向对象</div></div></a></div><div><a href="/post/3e1167ea.html" title="23.IO流"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-30</div><div class="title">23.IO流</div></div></a></div><div><a href="/post/fbc0ae86.html" title="24.多线程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-30</div><div class="title">24.多线程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://i.postimg.cc/wjTxDpBF/image.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">分享科技与生活</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">星仔极客</h1><div class="author-info__desc">珍惜当下 不负此生</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://juejin.cn/user/745920887002011/posts" target="_blank" title="稀土掘金"><i class="anzhiyufont anzhiyu-icon-link"></i></a><a class="social-icon faa-parent animated-hover" href="https://www.bilibili.com/" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://img.picgo.net/2024/08/19/7769745c3a8abda4b76a2c8767c011c4ccc3bcc6d25362ee.webp) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://img.picgo.net/2024/08/19/7229edbc2326d9f1a077d9f251d15dfc93e3d4fe574b7ca8.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">知识点一：集合框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-%E6%A6%82%E5%BF%B5-center"><span class="toc-number">1.1.</span> <span class="toc-text">1、概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-2-%E9%9B%86%E5%90%88%E6%9E%B6%E6%9E%84-center"><span class="toc-number">1.2.</span> <span class="toc-text">2、集合架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-3-list%E9%9B%86%E5%90%88-center"><span class="toc-number">1.3.</span> <span class="toc-text">3、List集合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">知识点二：List集合之ArrayList集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-%E5%88%86%E6%9E%90arraylist%E7%9A%84%E6%95%88%E7%8E%87-center"><span class="toc-number">2.1.</span> <span class="toc-text">1、分析ArrayList的效率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-2-%E8%AF%AD%E6%B3%95-center"><span class="toc-number">2.2.</span> <span class="toc-text">2、语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-center"><span class="toc-number">2.3.</span> <span class="toc-text">3、常用方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">知识点三：List集合三种遍历方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-%E6%99%AE%E9%80%9Afor%E5%BE%AA%E7%8E%AF-center"><span class="toc-number">3.1.</span> <span class="toc-text">普通for循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF-foreach%E5%BE%AA%E7%8E%AF-center"><span class="toc-number">3.2.</span> <span class="toc-text">增强for循环【foreach循环】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-foreach%E6%96%B9%E6%B3%95%E9%81%8D%E5%8E%86-center"><span class="toc-number">3.3.</span> <span class="toc-text">foreach方法遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">知识点四：ArrayList底层实现原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">知识点五：迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8E%9F%E7%90%86-center"><span class="toc-number">5.1.</span> <span class="toc-text">1、迭代器原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-2-%E8%8E%B7%E5%8F%96%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AF%B9%E8%B1%A1-center"><span class="toc-number">5.2.</span> <span class="toc-text">2、获取迭代器对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-3-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95-center"><span class="toc-number">5.3.</span> <span class="toc-text">3、迭代器的三个方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-4-%E5%BC%BA%E5%8C%96%E8%BF%AD%E4%BB%A3%E5%99%A8-center"><span class="toc-number">5.4.</span> <span class="toc-text">4、强化迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-5-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-center"><span class="toc-number">5.5.</span> <span class="toc-text">5、迭代器注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">知识点六：List集合之LinkedList集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-%E8%AF%B4%E6%98%8E-center"><span class="toc-number">6.1.</span> <span class="toc-text">1、说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-2-%E5%88%86%E6%9E%90linkedlist%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87-center"><span class="toc-number">6.2.</span> <span class="toc-text">2、分析LinkedList的执行效率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-center"><span class="toc-number">6.3.</span> <span class="toc-text">3、常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-4-linkedlist%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-center"><span class="toc-number">6.4.</span> <span class="toc-text">4、LinkedList实现原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">知识点七：List集合总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">知识点八：泛型基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-%E4%BD%9C%E7%94%A8-center"><span class="toc-number">8.1.</span> <span class="toc-text">1、作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">8.1.1.</span> <span class="toc-text">语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-2-%E5%AE%9A%E4%B9%89-center"><span class="toc-number">8.2.</span> <span class="toc-text">2、定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-3-%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%8B%E9%9B%86%E5%90%88-center"><span class="toc-number">8.3.</span> <span class="toc-text">3、泛型的使用之集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-4-%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%8B%E6%B3%9B%E5%9E%8B%E7%B1%BB-center"><span class="toc-number">8.4.</span> <span class="toc-text">4、泛型的使用之泛型类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-5-%E6%B3%9B%E5%9E%8B%E4%BD%BF%E7%94%A8%E4%B9%8B%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95-center"><span class="toc-number">8.5.</span> <span class="toc-text">5、泛型使用之泛型方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-6-%E6%B3%9B%E5%9E%8B%E4%BD%BF%E7%94%A8%E4%B9%8B%E6%8E%A5%E5%8F%A3%E6%B3%9B%E5%9E%8B-center"><span class="toc-number">8.6.</span> <span class="toc-text">6、泛型使用之接口泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-7-%E6%B3%9B%E5%9E%8B%E7%9A%84%E9%99%90%E5%AE%9A-center"><span class="toc-number">8.7.</span> <span class="toc-text">7、泛型的限定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-8-%E7%89%B9%E7%82%B9-center"><span class="toc-number">8.8.</span> <span class="toc-text">8、特点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">知识点九：Set集合的介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">知识点十：Set集合实现类HashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-hash%E8%A1%A8-center"><span class="toc-number">10.1.</span> <span class="toc-text">1、Hash表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-2-hashset%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-center"><span class="toc-number">10.2.</span> <span class="toc-text">2、HashSet基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AF%AD%E6%B3%95"><span class="toc-number">10.2.1.</span> <span class="toc-text">(1）语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-hashset%E9%9B%86%E5%90%88%E7%9A%84%E6%8E%92%E9%87%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">10.2.2.</span> <span class="toc-text">(2)HashSet集合的排重操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">10.2.3.</span> <span class="toc-text">(3)底层原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">知识点十一：LinkedHashSet类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">知识点十二：Set集合实现类TreeSet</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">知识点十三：Comparable接口【自然排序接口】</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">14.</span> <span class="toc-text">知识点十四：Comparator接口【自定义排序接口】</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93comparable%E5%92%8Ccomparator%E6%8E%A5%E5%8F%A3"><span class="toc-number">14.1.</span> <span class="toc-text">总结Comparable和Comparator接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">15.</span> <span class="toc-text">知识点十五：Set集合总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">16.</span> <span class="toc-text">知识点十六：Collection集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">17.</span> <span class="toc-text">知识点十七：Collections工具类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">18.</span> <span class="toc-text">知识点十七：Map集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-map%E9%9B%86%E5%90%88%E4%BB%8B%E7%BB%8D-center"><span class="toc-number">18.1.</span> <span class="toc-text">1、Map集合介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-2-map%E9%9B%86%E5%90%88%E4%B8%BB%E8%A6%81%E5%AE%9E%E7%8E%B0%E7%B1%BBhashmap-center"><span class="toc-number">18.2.</span> <span class="toc-text">2、Map集合主要实现类HashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-3-hashmap%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-java8%E4%B9%8B%E5%89%8D-center"><span class="toc-number">18.3.</span> <span class="toc-text">3、HashMap常用方法(Java8之前)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-4-hashmap%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-java8%E4%B9%8B%E5%90%8E-center"><span class="toc-number">18.4.</span> <span class="toc-text">4、HashMap常用方法(Java8之后)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-5-map%E9%9B%86%E5%90%88%E4%B9%8Btreemap%E9%9B%86%E5%90%88-center"><span class="toc-number">18.5.</span> <span class="toc-text">5、Map集合之TreeMap集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-6-collections%E5%B7%A5%E5%85%B7%E7%B1%BB-center"><span class="toc-number">18.6.</span> <span class="toc-text">6、Collections工具类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-7-collection%E9%9B%86%E5%90%88%E5%92%8Cmap%E9%9B%86%E5%90%88%E7%9A%84%E6%80%BB%E7%BB%93-center"><span class="toc-number">18.7.</span> <span class="toc-text">7、Collection集合和Map集合的总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-8-hashmap%E5%BA%94%E7%94%A8-center"><span class="toc-number">18.8.</span> <span class="toc-text">8、HashMap应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-9-hashmap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-center"><span class="toc-number">18.9.</span> <span class="toc-text">9、HashMap底层实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-10-put%E7%9A%84%E8%BF%87%E7%A8%8B%E5%8E%9F%E7%A0%81-center"><span class="toc-number">18.10.</span> <span class="toc-text">10、put的过程原码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-11-resize%E8%BF%87%E7%A8%8B%E5%8E%9F%E7%A0%81-center"><span class="toc-number">18.11.</span> <span class="toc-text">11、resize过程原码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-12-get%E7%9A%84%E8%BF%87%E7%A8%8B%E5%8E%9F%E7%A0%81-center"><span class="toc-number">18.12.</span> <span class="toc-text">12、get的过程原码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">19.</span> <span class="toc-text">知识点十八：常见的集合面试面试题</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/a2c247c4.html" title="项目"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/11/13/c12889d56cf9e0078ed87b335eb8b0b321601f0548e324aa.png" onerror="this.onerror=null;this.src='https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png'" alt="项目"/></a><div class="content"><a class="title" href="/post/a2c247c4.html" title="项目">项目</a><time datetime="2024-11-25T02:22:50.000Z" title="发表于 2024-11-25 10:22:50">2024-11-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/d98607ab.html" title="0.ArkTS基础语法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/11/13/c12889d56cf9e0078ed87b335eb8b0b321601f0548e324aa.png" onerror="this.onerror=null;this.src='https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png'" alt="0.ArkTS基础语法"/></a><div class="content"><a class="title" href="/post/d98607ab.html" title="0.ArkTS基础语法">0.ArkTS基础语法</a><time datetime="2024-11-24T02:22:50.000Z" title="发表于 2024-11-24 10:22:50">2024-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/de777d6b.html" title="1.界面开发"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/11/13/c12889d56cf9e0078ed87b335eb8b0b321601f0548e324aa.png" onerror="this.onerror=null;this.src='https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png'" alt="1.界面开发"/></a><div class="content"><a class="title" href="/post/de777d6b.html" title="1.界面开发">1.界面开发</a><time datetime="2024-11-23T02:23:35.000Z" title="发表于 2024-11-23 10:23:35">2024-11-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/36f99b3f.html" title="2.交互开发"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/11/13/c12889d56cf9e0078ed87b335eb8b0b321601f0548e324aa.png" onerror="this.onerror=null;this.src='https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png'" alt="2.交互开发"/></a><div class="content"><a class="title" href="/post/36f99b3f.html" title="2.交互开发">2.交互开发</a><time datetime="2024-11-22T08:44:16.000Z" title="发表于 2024-11-22 16:44:16">2024-11-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/9d10e9f6.html" title="4.Linux应用编程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://i.postimg.cc/MKRR79pj/7777777.jpg" onerror="this.onerror=null;this.src='https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png'" alt="4.Linux应用编程"/></a><div class="content"><a class="title" href="/post/9d10e9f6.html" title="4.Linux应用编程">4.Linux应用编程</a><time datetime="2024-11-20T12:47:12.000Z" title="发表于 2024-11-20 20:47:12">2024-11-20</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="星仔极客" target="_blank">星仔极客</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">80</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">11</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://juejin.cn/user/745920887002011/posts" title="稀土掘金"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="/img/favicon.ico" alt="稀土掘金"/><span class="back-menu-item-text">稀土掘金</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://www.bilibili.com/" title="哔哩哔哩"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="/img/favicon.ico" alt="哔哩哔哩"/><span class="back-menu-item-text">哔哩哔哩</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">资源下载</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://www.sscha.com/" title="商查查"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="商查查"/><span class="back-menu-item-text">商查查</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 小伙伴</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://link3.cc/xinzai_x"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 个人资源</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="http://ainm.cc/c/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐网</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 常用文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://68565200.xyz/post/1f293ccb"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 资源搜索</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/32%E5%8D%95%E7%89%87%E6%9C%BA/" style="font-size: 0.88rem;">32单片机<sup>12</sup></a><a href="/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/" style="font-size: 0.88rem;">51单片机<sup>8</sup></a><a href="/tags/CubeIDE%E4%B8%8ECubeMX%E8%BD%AF%E4%BB%B6%E8%AE%BE%E7%BD%AE/" style="font-size: 0.88rem;">CubeIDE与CubeMX软件设置<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">C语言<sup>13</sup></a><a href="/tags/Java%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">Java语言<sup>12</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>5</sup></a><a href="/tags/MySQL/" style="font-size: 0.88rem;">MySQL<sup>3</sup></a><a href="/tags/RT-Thread/" style="font-size: 0.88rem;">RT-Thread<sup>6</sup></a><a href="/tags/Win11%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/" style="font-size: 0.88rem;">Win11相关设置<sup>1</sup></a><a href="/tags/springboot%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/" style="font-size: 0.88rem;">springboot相关配置<sup>1</sup></a><a href="/tags/ubuntu%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/" style="font-size: 0.88rem;">ubuntu相关设置<sup>1</sup></a><a href="/tags/%E4%BA%91%E5%9B%BE%E5%BA%8A/" style="font-size: 0.88rem;">云图床<sup>1</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2CDN%E8%A7%A3%E6%9E%90/" style="font-size: 0.88rem;">博客CDN解析<sup>1</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/" style="font-size: 0.88rem;">博客搭建相关<sup>1</sup></a><a href="/tags/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">图片压缩在线工具<sup>1</sup></a><a href="/tags/%E5%B0%8F%E7%8B%BC%E6%AF%AB%E8%BE%93%E5%85%A5%E6%B3%95/" style="font-size: 0.88rem;">小狼毫输入法<sup>1</sup></a><a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 0.88rem;">插件<sup>1</sup></a><a href="/tags/%E8%90%A5%E4%B8%9A%E6%89%A7%E7%85%A7/" style="font-size: 0.88rem;">营业执照<sup>1</sup></a><a href="/tags/%E8%B5%84%E6%BA%90%E6%90%9C%E7%B4%A2/" style="font-size: 0.88rem;">资源搜索<sup>1</sup></a><a href="/tags/%E9%B8%BF%E8%92%99NEXT%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/" style="font-size: 0.88rem;">鸿蒙NEXT应用开发<sup>4</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 星仔极客 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script async src="https://www.iconfont.cn/collections/detail?cid=44481"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>