<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>5.集合 | 星仔极客</title><noscript>开启JavaScript才能访问本站哦~</noscript><link rel="icon" href="https://img.picgo.net/2024/09/24/811513a1eaacadb85ae79568d39c3337b8b87d11b124d4ab.png"><!-- index.css--><link rel="stylesheet" href="/css/index.css?v=2.1.15"><!-- inject head--><link rel="canonical" href="https://xinzaigeek.68565200.xyz/post/9e25cba9.html"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css"><!-- aplayer--><!-- swiper--><!-- fancybox ui--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.36/fancybox/fancybox.min.css"><!-- katex--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css"><!-- Open Graph--><meta name="description" content="知识点一：集合框架 1、概念 如果处理一套通用逻辑就提供一个自定义封装处理数组的类，那么开发中可能会需要提供N这样类，问题在于需要自行完成操作，Java也发现这个问题，所有为了让程序猿可以更加的便捷的对数据进行操作，无需向数组一样提供【增删改查】的自定义实现，Java提供一个集合框架，便于程"><!-- pwa--><meta name="apple-mobile-web-app-capable" content="星仔极客"><meta name="theme-color" content="var(--efu-main)"><meta name="apple-mobile-web-app-status-bar-style" content="var(--efu-main)"><link rel="bookmark" href="https://img.picgo.net/2024/09/24/811513a1eaacadb85ae79568d39c3337b8b87d11b124d4ab.png"><link rel="apple-touch-icon" href="https://img.picgo.net/2024/09/24/811513a1eaacadb85ae79568d39c3337b8b87d11b124d4ab.png" sizes="180x180"><script>console.log(' %c Solitude %c ' + '2.1.15' + ' %c https://github.com/everfu/hexo-theme-solitude',
    'background:#35495e ; padding: 1px; border-radius: 3px 0 0 3px;  color: #fff',
    'background:#ff9a9a ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff',
    'background:unset ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff')
</script><script>(()=>{
        const saveToLocal = {
            set: function setWithExpiry(key, value, ttl) {
                if (ttl === 0)
                    return
                const now = new Date()
                const expiryDay = ttl * 86400000
                const item = {
                    value: value,
                    expiry: now.getTime() + expiryDay
                }
                localStorage.setItem(key, JSON.stringify(item))
            },
            get: function getWithExpiry(key) {
                const itemStr = localStorage.getItem(key)

                if (!itemStr) {
                    return undefined
                }
                const item = JSON.parse(itemStr)
                const now = new Date()

                if (now.getTime() > item.expiry) {
                    localStorage.removeItem(key)
                    return undefined
                }
                return item.value
            }
        };
        window.utils = {
            saveToLocal: saveToLocal,
            getCSS: (url, id = false) => new Promise((resolve, reject) => {
              const link = document.createElement('link')
              link.rel = 'stylesheet'
              link.href = url
              if (id) link.id = id
              link.onerror = reject
              link.onload = link.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                link.onload = link.onreadystatechange = null
                resolve()
              }
              document.head.appendChild(link)
            }),
            getScript: (url, attr = {}) => new Promise((resolve, reject) => {
              const script = document.createElement('script')
              script.src = url
              script.async = true
              script.onerror = reject
              script.onload = script.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                script.onload = script.onreadystatechange = null
                resolve()
              }

              Object.keys(attr).forEach(key => {
                script.setAttribute(key, attr[key])
              })

              document.head.appendChild(script)
            }),
            addGlobalFn: (key, fn, name = false, parent = window) => {
                const globalFn = parent.globalFn || {}
                const keyObj = globalFn[key] || {}

                if (name && keyObj[name]) return

                name = name || Object.keys(keyObj).length
                keyObj[name] = fn
                globalFn[key] = keyObj
                parent.globalFn = globalFn
            },
            addEventListenerPjax: (ele, event, fn, option = false) => {
              ele.addEventListener(event, fn, option)
              utils.addGlobalFn('pjax', () => {
                  ele.removeEventListener(event, fn, option)
              })
          },
        }
    })()</script><!-- theme--><script>initTheme = () => {
    let isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const cachedMode = utils.saveToLocal.get('theme');
    if (cachedMode === undefined) {
        const nowMode =
            isDarkMode ? 'dark' : 'light'
        document.documentElement.setAttribute('data-theme', nowMode);
    } else {
        document.documentElement.setAttribute('data-theme', cachedMode);
    }
    typeof rm === 'object' && rm.mode(cachedMode === 'dark' && isDarkMode)
}
initTheme()</script><!-- global head--><script>const GLOBAL_CONFIG = {
    root: '/',
    algolia: {"appId":"V1R8T877I8","apiKey":"5d3e42b03150eed38d97122513aa8714","indexName":"Blog","hits":{"per_page":10}},
    localsearch: undefined,
    runtime: '2023-04-20 00:00:00',
    lazyload: {
        enable: true,
        error: '/img/error_load.avif'
    },
    copyright: {"limit":50,"author":"作者: 星仔极客","link":"链接: ","source":"来源: 星仔极客","info":"著作权归作者所有。 商业转载请联系作者获得授权，非商业转载请注明出处。"},
    highlight: {"limit":500,"expand":true,"copy":true,"syntax":"highlight.js"},
    randomlink: false,
    lang: {"theme":{"dark":"已切换至深色模式","light":"已切换至浅色模式"},"copy":{"success":"复制成功","error":"复制失败"},"backtop":"返回顶部","time":{"day":"天前","hour":"小时前","just":"刚刚","min":"分钟前","month":"个月前"},"day":" 天","f12":"开发者模式已打开，请遵循GPL协议。","totalk":"无需删除空行，直接输入评论即可","search":{"empty":"找不到你查询的内容：${query}","hit":"找到 ${hits} 条结果，用时 ${time} 毫秒","placeholder":"输入关键词快速查找","count":"共 <b>${count}</b> 条结果。","loading":"搜索中..."},"barrage":{"title":"热评"}},
    aside: {
        sayhello: {
            morning: "✨ 早上好，新的一天开始了",
            noon: "中午饭时间",
            afternoon: "下午茶时间 ☕️",
            night: "不要熬夜哦",
            goodnight: "晚安，早点休息",
        },
        sayhello2: ["你可以的","相信你可以的","你一定可以的"],
        sayhello3: {
            prefix: '好久不见，',
            back: '欢迎再次回来，',
        },
    },
    covercolor: {
        enable: true
    },
    comment: {"avatar":"https://gravatar.com/avatar","commentBarrage":true},
    lightbox: 'fancybox',
    post_ai: false,
    right_menu: {"mode":{"dark":"深色模式","light":"浅色模式"},"img_error":"此图片无法复制与下载","barrage":{"open":"显示热评","close":"关闭热评"},"ctrlOriginalMenu":"按住Ctrl+右键可打开浏览器右键菜单"},
    translate: false,
    lure: false,
    expire: false,
};</script><!-- page-config head--><script id="config-diff">var PAGE_CONFIG = {
    is_post: true,
    is_page: false,
    is_home: false,
    page: '',
    toc: true,
    comment: true,
    ai_text: false,
    color: false,
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="星仔极客" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body id="body"><!-- universe--><!-- background img--><div id="global_bg"></div><!-- loading--><!-- console--><!-- sidebar--><div id="sidebar" style="zoom: 1;"><div id="menu-mask" style="display: none;"></div><div id="sidebar-menus"><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">80</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div></div></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><span class="darkmode_switchbutton menu-child" onclick="sco.switchDarkMode()"><i class="solitude fa-solid fa-circle-half-stroke"></i><span>显示模式</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  fas fa-folder-closed"></i><span>全部文章</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  fas fa-clone"></i><span>分类列表</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  fas fa-tags"></i><span>标签列表</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/links/"><i class="solitude  fas fa-user-group"></i><span>友情链接</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://link3.cc/xinzai_x"><i class="solitude  fas fa-tools"></i><span>工具站</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="http://ainm.cc/c/music/"><i class="solitude  fas fa-headphones"></i><span>音乐网</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>常用文章</span></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://68565200.xyz/post/79959306.html"><i class="solitude  fas fa-images"></i><span>图片工具</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="solitude  fas fa-user"></i><span>关于本站</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-widget card-tags card-archives card-webinfo card-allinfo"><div class="card-tag-cloud"><a href="/tags/MySQL/">MySQL<sup>3</sup></a><a href="/tags/Java%E8%AF%AD%E8%A8%80/">Java语言<sup>12</sup></a><a href="/tags/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/">图片压缩在线工具<sup>1</sup></a><a href="/tags/%E4%BA%91%E5%9B%BE%E5%BA%8A/">云图床<sup>1</sup></a><a href="/tags/CubeIDE%E4%B8%8ECubeMX%E8%BD%AF%E4%BB%B6%E8%AE%BE%E7%BD%AE/">CubeIDE与CubeMX软件设置<sup>1</sup></a><a href="/tags/%E8%B5%84%E6%BA%90%E6%90%9C%E7%B4%A2/">资源搜索<sup>1</sup></a><a href="/tags/%E6%8F%92%E4%BB%B6/">插件<sup>1</sup></a><a href="/tags/springboot%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/">springboot相关配置<sup>1</sup></a><a href="/tags/ubuntu%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/">ubuntu相关设置<sup>1</sup></a><a href="/tags/Win11%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/">Win11相关设置<sup>1</sup></a><a href="/tags/%E5%B0%8F%E7%8B%BC%E6%AF%AB%E8%BE%93%E5%85%A5%E6%B3%95/">小狼毫输入法<sup>1</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2CDN%E8%A7%A3%E6%9E%90/">博客CDN解析<sup>1</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/">博客搭建相关<sup>1</sup></a><a href="/tags/%E8%90%A5%E4%B8%9A%E6%89%A7%E7%85%A7/">营业执照<sup>1</sup></a><a href="/tags/%E9%B8%BF%E8%92%99next%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/">鸿蒙next应用开发<sup>4</sup></a><a href="/tags/32%E5%8D%95%E7%89%87%E6%9C%BA/">32单片机<sup>12</sup></a><a href="/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/">51单片机<sup>8</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/">C语言<sup>13</sup></a><a href="/tags/RT-Thread/">RT-Thread<sup>6</sup></a><a href="/tags/Linux/">Linux<sup>5</sup></a></div></div></div></div><!-- keyboard--><!-- righhtside--><div class="needEndHide" id="rightside"><div class="rs_hide"><button class="mode" type="button" title="显示模式切换" onclick="sco.switchDarkMode()"><i class="fas fa-circle-half-stroke"></i></button></div><div class="rs_show"><button class="config" type="button" title="扩展" onclick="document.querySelector(&quot;.rs_hide&quot;).classList.toggle(&quot;show&quot;)"><i class="fas fa-gear fa-spin"></i></button><button class="mobile toc" type="button" title="目录" onclick="document.querySelector('#card-toc').classList.toggle('open')"><i class="fas fa-list"></i></button><button class="comment" type="button" title="评论" onclick="sco.scrollTo('post-comment')"><i class="fas fa-comment"></i></button><button class="barrage pc" type="button" title="弹" onclick="sco.switchCommentBarrage()"><span>弹</span></button><button class="top" type="button" title="返回顶部" onclick="sco.toTop()"><i class="fas fa-arrow-up"></i><span id="percent">0</span></button></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav class="show" id="nav"><div id="nav-group"><div id="blog_name"><a id="site-name" href="/" title="返回博客主页"><i class="solitude fa-solid fa-home"></i></a></div><div id="page-name-mask"><div id="page-name"><a id="page-name-text" onclick="sco.toTop()">5.集合</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  fas fa-folder-closed"></i><span>全部文章</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  fas fa-clone"></i><span>分类列表</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  fas fa-tags"></i><span>标签列表</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/links/"><i class="solitude  fas fa-user-group"></i><span>友情链接</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://link3.cc/xinzai_x"><i class="solitude  fas fa-tools"></i><span>工具站</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="http://ainm.cc/c/music/"><i class="solitude  fas fa-headphones"></i><span>音乐网</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>常用文章</span></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://68565200.xyz/post/79959306.html"><i class="solitude  fas fa-images"></i><span>图片工具</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="solitude  fas fa-user"></i><span>关于本站</span></a></li></ul></div></div></div><div id="nav-left"></div><div id="nav-right"><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索"><i class="solitude fa-solid fa-magnifying-glass"></i></a></div><div id="toggle-menu"><a class="site-page"><i class="solitude fa-solid fa-bars"></i></a></div></div></div></nav><div class="coverdiv" id="coverdiv"><img class="nolazyload" id="post-cover" src="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" alt="5.集合"></div><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original" title="该文章为原创文章，注意版权协议">原创</a><span class="post-meta-categories"><a class="post-meta-categories" href="/categories/Java%E8%AF%AD%E8%A8%80/">Java语言</a></span><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E8%AF%AD%E8%A8%80/"><span class="tags-name tags-punctuation"><i class="solitude fa-solid fa-hashtag"></i>Java语言</span></a></div></div></div></div><h1 class="post-title">5.集合</h1><div id="post-meta"><div class="meta-secondline"><span class="post-meta-date" title="发布于 2023-12-30 13:09:59"><i class="post-meta-icon solitude fas fa-calendar-days"></i><time datetime="2023-12-30T05:09:59.000Z">2023-12-30T05:09:59.000Z</time></span><span class="post-meta-date" title="最后更新于 2024-11-04 10:13:16"><i class="post-meta-icon solitude fa-solid fa-arrows-rotate"></i><time datetime="2024-11-04T02:13:16.196Z">2024-11-04T02:13:16.196Z</time></span><span class="post-meta-position" title="作者IP归属地为揭阳"><i class="post-meta-icon solitude fas fa-location-dot"></i><span>揭阳</span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content article-container"><h1><center>知识点一：集合框架</center></h1>
<h2 id="center-1-概念-center"><center>1、概念</center></h2>
<p>    如果处理一套通用逻辑就提供一个自定义封装处理数组的类，那么开发中可能会需要提供N这样类，问题在于需要自行完成操作，Java也发现这个问题，所有为了让程序猿可以更加的便捷的对数据进行操作，无需向数组一样提供【增删改查】的自定义实现，Java提供一个集合框架，便于程序猿对数据进行存储与管理操作</p>
<p>什么是集合框架？</p>
<p>    Java中的集合框架其实就是对【数据结构】的封装，这个封装中提供了一些常用方法，可方便操作数据，无需程序猿自定定义操作，只需要调用封装方法就可以完成对存在集合中数据【增删改查】集合其实就是对数据结构一种封装，所以之前sun公司就把集合放置到一个统一包中进行管理【java.util】包</p>
<p>什么是数据结构？</p>
<p>    数据结构其实就是计算机，组织和存储数据形式</p>
<p>    数据结构是指相互之间存在一种或多种特定关系的数据集合</p>
<p>    通常情况下，精心选择数据结构可以带来更加高效运行和存储效率，数据结构往往高效的原因在于【检索算法】和【索引计数】</p>
<p>    常见数据结构：【数组、栈、链表(单向和双向)、哈希表、队列(单向和双向)、堆、树、图】</p>
<p>    Java的集合框架其实就是对【数据结构实现】，我们需要掌握就是如何操作这个数据结构（即操作集合中方法），高效存储与处理数据</p>
<p>PS：根据不同数据结构，操作数据性能是不同（有地查询块、有的插入快、有地允许重复、有的不允许重复等等），在开发中只要选择合理数据结构即集合对数据存储与操作即可</p>
<p>推荐： 后期可以看一本书【大话数据结构】 —》兄弟 ----》【大话设计模式】</p>
<h2 id="center-2-集合架构-center"><center>2、集合架构</center></h2>
<p>PS：习惯性说Java中集合有三大框架【List、Set和Map】</p>
<p>如果详细说明的话应该2个框架3个实现：</p>
<p>    2个框架： Collection 和 Map</p>
<p>    3个实现 ：Collection这个集合下两个主要实现 List 和 set 所以称为三大集合List、set 和Map</p>
<p>集合和数组最大区别在于：</p>
<ol>
<li>集合中只能存储引用类型即对象</li>
<li>集合是一个变长容量，根据集合存储元素个数动态进行删减【扩容和减容】</li>
<li>数组是一个定长容器，创建大小数固定，无论存储多少数据长度都是唯一</li>
</ol>
<p>常见三大集合框架：</p>
<ol>
<li>List【列表】：集合中存储对象是按照索引位置进行存储，允许存储重复数据</li>
<li>Set【集】: 集合中存储对象不是按照特定方式进行存储，不允许出现重复数据</li>
<li>Map【映射】：集合中每一个存储元素都是以一种【键值对keyvalue】方式进行存储的，以一种key和value的形式存储的，key这个对象是不允许重复【唯一性】，value是允许重复</li>
</ol>
<img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271930400.WebP" alt="列表、集合、映射图" style="zoom: 33%;">
<p>无论什么时候都要先创建Collection对象</p>
<p><img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271930293.WebP" alt="集合"></p>
<h2 id="center-3-list集合-center"><center>3、List集合</center></h2>
<p><img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271930586.WebP" alt="List集合"></p>
<h1><center>知识点二：List集合之ArrayList集合</center></h1>
<h2 id="center-1-分析arraylist的效率-center"><center>1、分析ArrayList的效率</center></h2>
<p>因为ArrayList使用是数组实现所以可以得到如下以下特点：</p>
<ol>
<li>保存操作：</li>
</ol>
<p>    把一个数据保存到ArrayList中，最快的操作只要操作一次即可，最慢的操作可能操作N次</p>
<p>    平均执行效率(N+1)/2次 —》扩容问题</p>
<ol start="2">
<li>删除操作:</li>
</ol>
<p>删除ArrayList中某个数据，最快的只要操作一次即可， 最慢的操作可能操作N次</p>
<p>平均执行效率(N+1)/2次 —》减容问题</p>
<ol start="3">
<li>
<p>修改操作: 操作一次即可</p>
</li>
<li>
<p>查询操作：根据索引一次即可。如果遍历查询使用【检索算法】做优化效率高度，如果遍历从到为【顺序查找】效率是低</p>
</li>
</ol>
<p>因为ArrayList使用是数组的形式进行存储数据操作，所以基于这样数据结构做查询和修改效率是高，但是做增加和删除效率是低【动态扩容和减容】</p>
<h2 id="center-2-语法-center"><center>2、语法</center></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;泛型&gt; 变量名 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h2 id="center-3-常用方法-center"><center>3、常用方法</center></h2>
<p>1）向指定下标位置添加一个元素,下标范围：0~list.size	list.size：有多少个元素</p>
<p>    变量名.add(指定下标数,添加的元素);</p>
<p>2）移除指定下标位置的元素,下标范围：0~list.size-1</p>
<p>    变量名.remove(指定下标数);</p>
<p>3）修改指定下标位置的元素,下标范围：0~list.size-1</p>
<p>    变量名.set(指定下标数,修改元素内容);</p>
<p>4）获取指定下标位置上的元素，下标范围：0~list.size-1</p>
<p>    变量名.get(指定下标数)</p>
<p>    返回值为对应的数据类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.UnaryOperator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListAPIDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供ArrayList集合对象进行数据的存储操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1.ArrayList集合提供一个无参构造方法可以创建一个空的集合对象</span></span><br><span class="line"><span class="comment">            --&gt;空指定的是集合没有存储任何数据，但是集合引用是在的</span></span><br><span class="line"><span class="comment">            在Java7，使用new ArrayList无参构造方法创建对象，一个元素都不存储</span></span><br><span class="line"><span class="comment">            依旧会在堆中开辟一个大小为10的数据空间，并且数组的默认存储数据类型时Object</span></span><br><span class="line"><span class="comment">            在Java8中，Java开发人员发现，如果在使用ArrayList集合之前，如果使用无参构造方法</span></span><br><span class="line"><span class="comment">            创建ArrayList集合对象会出现一个10大小的堆中数组空间，这样会造成一定量的空间浪费</span></span><br><span class="line"><span class="comment">            所以在Java8中提供一个全新优化，使用 new ArrayList无参构造方法创建ArrayList对象时</span></span><br><span class="line"><span class="comment">            并不会创建一个大小为10数组在堆中进行存储，而是创建创建一个空的数组进行空间的开辟</span></span><br><span class="line"><span class="comment">            private static final Object[]</span></span><br><span class="line"><span class="comment">            DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span></span><br><span class="line"><span class="comment">            当通过集合对象调用集合集合中提供add方法时，此时才会真正的初始化数组空间</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//2.ArrayList集合使用其他的Collection集合对象中存储数据</span></span><br><span class="line">        作为新的集合中存储数据进行初始化</span><br><span class="line">        <span class="comment">//即将参数中Collection集合对象数据存储到新建ArrayList集合中</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(list);</span><br><span class="line">        <span class="comment">//3.自定义ArrayList集合的底层数组初始化容量 --》【使用较少】</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//常用API</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.向集合对象中添加元素【存储数据】 ---》 集合只能存储引用</span></span><br><span class="line">        类型即对象</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            集合中只能存储引用类型 --&gt; 明显调用add时存储的是1,2,3,4,5 int类型数据</span></span><br><span class="line"><span class="comment">            可以存储的，因为向集合中存储基本数据类型时，完成自动转换操作 --》将基本数据类型 转换为对应 包装类</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        list.add(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        <span class="comment">//集合在没有使用泛型之前是可以存储任何引用类型对象,因为方法参数类型时Object</span></span><br><span class="line">        <span class="comment">//ArrayList集合重写toString，所以可以直接打印集合对象查看集合内容</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.向集合中指定位置添加元素数据【第一个参数是下标位置，第二个参数是存储的元素】</span></span><br><span class="line">        list.add(<span class="number">2</span>,<span class="number">100</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.向集合中添加参数集合中数据到集合中进行存储</span></span><br><span class="line">        <span class="comment">//PS：参数是一个Collection集合，所以只要是List或Set集合实现类都是传递到这个参数中</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list1_1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list1_1.add(<span class="number">1</span>);</span><br><span class="line">        list1_1.add(<span class="number">2</span>);</span><br><span class="line">        list.addAll(list1_1);    <span class="comment">//将list1_1集合里面的数据存储到list集合中</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//addAll有一个重载在指定位置中添加添加参数集合数据 addAll(下标, Collection集合对象);</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            特别注意： add 和 addAll的区别</span></span><br><span class="line"><span class="comment">            add这个方法是向集合中添加引用类型对象，即向集合集合添加地址</span></span><br><span class="line"><span class="comment">            addAll这个方法是向集合中添加参数中集合数据</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList1.add(<span class="number">1</span>);</span><br><span class="line">        arrayList1.add(<span class="number">2</span>);</span><br><span class="line">        System.out.println(arrayList1);</span><br><span class="line">        arrayList2.add(<span class="number">3</span>);</span><br><span class="line">        arrayList2.add(<span class="number">4</span>);</span><br><span class="line">        arrayList1.add(arrayList2);    <span class="comment">//相当于将arrayList2中引用存储到arrayList1这个集合中，存储是对象即地址</span></span><br><span class="line">        System.out.println(arrayList1);</span><br><span class="line">        arrayList1.addAll(arrayList2);    <span class="comment">//相当于将arrayList2中存储数据存储到arrayList1这个集合中，存储的是数据内容</span></span><br><span class="line">        System.out.println(arrayList1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.清空集合中存储的数据，但是集合引用不会消失，消失的是集合数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;没有清空之前arrayList1中的数据是：&quot;</span>+arrayList1);</span><br><span class="line">        arrayList1.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;清空之后arrayList1中的数据是：&quot;</span>+arrayList1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.判断集合否为空，即判断集合是都没有存储任何数据 [true空/false不空]</span></span><br><span class="line">        System.out.println(arrayList1.isEmpty());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6.判断集合中是否存在指定元素【判断集合中是否存储在这个对象】 --&gt; true存在 false不存在</span></span><br><span class="line">        System.out.println(list.contains(<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7.判断集合中是否存在参数集合中数据 ---》这方法不是</span></span><br><span class="line">        ArrayList独有的而是List接口提供</span><br><span class="line">        System.out.println(list.containsAll(list1_1));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//8.通过集合中存储元素下标获取集合中元素 ---》【下标不要越界范围（0~集合存储元素个数-1）】</span></span><br><span class="line">        System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//9.查询集合中是否存在指定元素并返回下标【只会返回第一次遇到元素的下标】</span></span><br><span class="line">        <span class="comment">// 找到了就是下标 找不到就是负数</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//list.lastIndexOf(查找的数据) --》查询集合中是否存在指定元素并返回下标【从后向前寻找】</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10.集合是提供真正删除操作 ---&gt; 进行减容操作</span></span><br><span class="line">        <span class="comment">//10.1 根据数据删除集合中存在数据</span></span><br><span class="line">        list.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10.2 根据下标删除集合中数据</span></span><br><span class="line">        list.remove(<span class="number">6</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10.3 List集合接口提供方法 removeAll</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list1_2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list1_2.add(<span class="number">2</span>);</span><br><span class="line">        list1_2.add(<span class="number">100</span>);</span><br><span class="line">        list1_2.add(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//根据参数集合提供数据在当前集合进行删除操作</span></span><br><span class="line">        list.removeAll(list1_2);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10.4 List集合接口提供方法 retainAll</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list1_3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list1_3.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//根据参数集合提供数据保留当前集合中存储的数据，剩余的数据进行删除</span></span><br><span class="line">        list.retainAll(list1_3);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10.5 在java8中ArrayList提供一个新的处理集合删除方法removeIf</span></span><br><span class="line">        <span class="comment">//这个方法参数支持 Lambda表达式 和 匿名内部类方式处理</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list1_4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list1_4.add(<span class="number">1</span>);</span><br><span class="line">        list1_4.add(<span class="number">2</span>);</span><br><span class="line">        list1_4.add(<span class="number">3</span>);</span><br><span class="line">        list1_4.add(<span class="number">5</span>);</span><br><span class="line">        list1_4.add(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        list1_4.removeIf(<span class="keyword">new</span> <span class="title class_">Predicate</span>()&#123;</span><br><span class="line">        <span class="comment">//需要在这个方法方法执行删除规则 结果true就会进行删除操作</span></span><br><span class="line">        <span class="comment">//参数Object 中o会获取到集合每一个元素的值</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Object o)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Integer)o)%<span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//lambda表达式</span></span><br><span class="line">        list1_4.removeIf(o-&gt; ((Integer)o)%<span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">        System.out.println(list1_4);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//11.Java8中提供一个全新的方法【支持lambda表达式和匿名内部类】</span></span><br><span class="line">        <span class="comment">//根据指定规则进行元素的替换操作</span></span><br><span class="line">        list1_4.replaceAll(<span class="keyword">new</span> <span class="title class_">UnaryOperator</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//指定当前替换规则的方法，方法参数Object中o会获取到所有集合中数据</span></span><br><span class="line">            <span class="comment">//需要在方法内部提供替换规则，返回的是替换之后需要存在集合中数据</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">apply</span><span class="params">(Object o)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> o.equals(<span class="number">3</span>) ? <span class="number">30</span> : o;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        list1_4.replaceAll(o-&gt;o.equals(<span class="number">3</span>) ? <span class="number">30</span> : o);</span><br><span class="line">        System.out.println(list1_4);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//12. 修改【替换】集合中指定位置的数据 ---》第一个参数是下标，第二个参数修改数据</span></span><br><span class="line">        list1_4.set(<span class="number">0</span>,<span class="number">10000</span>);</span><br><span class="line">        System.out.println(list1_4);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//13.获取集合中存储元素个数【集合长度】</span></span><br><span class="line">        System.out.println(list1_4.size());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//14.将集合转换为数组</span></span><br><span class="line">        Object[] objects = list1_4.toArray();</span><br><span class="line">        <span class="comment">//PS：数组中也提供一个方法【Arrays】，将数组转换为List集合</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">objects1</span> <span class="operator">=</span> Arrays.asList(objects);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//15.【不太推荐】 截取指定范围内容集合数据得到一个新的集合</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList1_5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList1_5.add(<span class="number">1</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">2</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">3</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">4</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">5</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">6</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">7</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">//包括前不包括后 包括开始位置，不包括结束位置，参数都是下标</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> arrayList1_5.subList(<span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点三：List集合三种遍历方式</center></h1>
<h2 id="center-普通for循环-center"><center>普通for循环</center></h2>
<p>PS：因为ArrayList的底层实现是数组，所以支持数组中提供下标进行</p>
<p>对ArrayList进行操作</p>
<p>语法格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; 集合对象.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">    循环变量i值就是ArrayList集合下标变量，<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> 定义下标初始值</span><br><span class="line">    ArrayList它获取集合长度使用 size() 方法</span><br><span class="line">    通过ArrayList集合提供get方法或set方法对集合数据进行</span><br><span class="line">取值与赋值操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特点：因为这里操作的是下标，所以可以利用下标对集合数据进行【增删改查】操作</p>
<h2 id="center-增强for循环-foreach循环-center"><center>增强for循环【foreach循环】</center></h2>
<p>PS：因为ArrayList的底层实现是数组，所以支持数组中提供下标进行对ArrayList进行操作</p>
<p>语法格式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(集合中存储元素的类型 变量名 : 集合名)</span><br><span class="line">&#123;</span><br><span class="line">    通过操作局部变量就可以操作集合中数据了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：之前在学习数组的时候说过，数组遍历方式有两种一种普通for循环，一种是增强for循环，增强for循环只能使用在数组或集合中，在数组使用增强for循环它的实现原码是将数组值赋值给局部变量，所以对与增强for循环中局部变量修改是不会影响到数组，增强for循环适合简单数据运算、分支判断和打印数组中数据</p>
<p>特点：集合中增强for循环和数组中增强for循环同样效果，支持数组进行简单数据运算、分支判断和打印集合中数据，【但是不支持对集合中数据进行修改操作，也不允许在增强for循环中调用集合删除方法进行数据删除】，如果一旦删除就会出现一个【并发迭代修改异常 --》ConcurrentModificationException】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionForeach</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);    </span><br><span class="line">        list.add(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;cxk&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;尼古拉斯&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//List集合遍历方式1：使用迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.提供一个ArrayList集合对象</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line">        arrayList.add(<span class="number">2</span>);</span><br><span class="line">        arrayList.add(<span class="number">3</span>);</span><br><span class="line">        arrayList.add(<span class="number">4</span>);</span><br><span class="line">        arrayList.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//提供一个普通for循环操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;arrayList.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获取存储的数据</span></span><br><span class="line">            System.out.println(arrayList.get(i));</span><br><span class="line">            <span class="comment">// 通过下标对集合中数据进行修改</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">2</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                arrayList.set(i, <span class="number">100</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//通过下标进行数据删除操作 ---》 支持全套删除</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arrayList.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//增强for循环</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(Object obj : arrayList)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//obj中就会存储这个集合中所有数据</span></span><br><span class="line">            System.out.println(obj);<span class="comment">//打印集合数据</span></span><br><span class="line">            <span class="comment">//判断集合中数据做什么操作</span></span><br><span class="line">            <span class="keyword">if</span>(obj.equals(<span class="number">3</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//操作代码</span></span><br><span class="line">                System.out.println(obj);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//数据类型是可以做计算</span></span><br><span class="line">            sum += ((Integer)obj);</span><br><span class="line">            <span class="comment">//需要注意set方法无法使用，因为set第一个参数是下标</span></span><br><span class="line">            <span class="comment">//不能使用集合中删除方法，即在增强for循环中是不允许调用</span></span><br><span class="line">            删除方法的</span><br><span class="line">            <span class="keyword">if</span>(obj.equals(<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                arrayList.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>提供增强for循环的原码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> arrayList.iterator();</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!iterator.hasNext())</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">    <span class="keyword">if</span> (obj.equals(Integer.valueOf(<span class="number">3</span>)))</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">    sum += ((Integer)obj).intValue();</span><br><span class="line">    <span class="keyword">if</span> (obj.equals(Integer.valueOf(<span class="number">1</span>)))</span><br><span class="line">    arrayList.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>));</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"><span class="string">&quot;增强for循环之所以不可以删除,原因就是在于增强for循环即foreach底层实现就是一个迭代器，</span></span><br><span class="line"><span class="string">迭代器中是不允许使用集合中删除方法进行数据删除的，如果删除ConcurrentModificationException就出现这个异常&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="center-foreach方法遍历-center"><center>foreach方法遍历</center></h2>
<p>foreach是Java8中提供一个新增的方法，主要是以一个方法形态可以遍历打印集合中数据，因为这个方式Java8中提供，所以这个方法支持lambda表达式和匿名内部类实现</p>
<p>PS: 这个方法主要就是用于打印，其他方式较少</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8ForArrayList</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供一个ArrayList集合对象</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line">        arrayList.add(<span class="number">2</span>);</span><br><span class="line">        arrayList.add(<span class="number">3</span>);</span><br><span class="line">        arrayList.add(<span class="number">4</span>);</span><br><span class="line">        arrayList.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//方法内部可以指定打印效果</span></span><br><span class="line">        <span class="comment">//匿名内部类的形式</span></span><br><span class="line">        arrayList.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这个方法中就是咱们打印集合中数据的形式</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Object o)</span> &#123;<span class="comment">//Object类型o参数</span></span><br><span class="line">            可以获取到集合每一个数据</span><br><span class="line">            System.out.println(o);</span><br><span class="line">            <span class="comment">//提供一些判断打印效果，根据具体需求来，这个方法没</span></span><br><span class="line">            有返回值，所以打印效果是不会影响实际存储数据的</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//Lambda表达式实现</span></span><br><span class="line">        arrayList.forEach(o -&gt; System.out.println(o));</span><br><span class="line">        <span class="comment">//提供Lambda中方法引用操作</span></span><br><span class="line">        arrayList.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点四：ArrayList底层实现原理</center></h1>
<img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271931515.WebP" alt="ArrayList底层实现原理" style="zoom: 50%;">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListDemo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1、构造方法初始化一个长度为0的Object数组</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * ArrayList底层的元素是数组</span></span><br><span class="line"><span class="comment">         * add方法的原理</span></span><br><span class="line"><span class="comment">         * 1、当第一次添加元素的时候，初始化一个长度为10的数组</span></span><br><span class="line"><span class="comment">         *  当添加元素超过数组的长度的时候，会对数组进行扩容，扩容到1.5倍</span></span><br><span class="line"><span class="comment">         * 2、将当前的元素添加到数组指定的下标位置上</span></span><br><span class="line"><span class="comment">         *    elementData[size++] = e;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *数组数据结构的特点：增删慢，查询快</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点五：迭代器</center></h1>
<p>Java中专门针对Collection集合提供了一种遍历方式，这种遍历方式是根据Iterable接口来决定，只要是Collection的集合接口在子接口基本上都会具备Iterable这个接口，这个接口中主要提供一个方法</p>
<table>
<thead>
<tr>
<th>Iterator</th>
<th>iterator() 返回按适当顺序在列表的元素上进行迭代的迭代器</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>这个方法会返回一个按照集合顺序并存储集合数据的一个迭代器对象</td>
</tr>
</tbody>
</table>
<h2 id="center-1-迭代器原理-center"><center>1、迭代器原理</center></h2>
<p>迭代是重复反馈过程的活动,其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”,而每一次迭代得到的结果会作为下一次迭代的初始值</p>
<img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291911167.WebP" alt="原理" style="zoom: 50%;">
<h2 id="center-2-获取迭代器对象-center"><center>2、获取迭代器对象</center></h2>
<p>Iterator 变量名 = Collection的变量名.iterator();</p>
<h2 id="center-3-迭代器的三个方法-center"><center>3、迭代器的三个方法</center></h2>
<p>（1）判断迭代器是否有下一个元素</p>
<p>    变量名.hasNext();</p>
<p>    返回值boolean类型</p>
<p>（2）获取当前游标对应元素并将游标向后移动一位</p>
<p>    变量名.next()</p>
<p>    返回迭代的下一个元素</p>
<p>（3）移除当前迭代器上对应的元素</p>
<p>    变量名.remove();</p>
<p>    说明：可以利用Iterator中提供三个核心方法操作迭代器影响集合中数据</p>
<img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292037504.WebP" alt="迭代器方法" style="zoom:50%;">
<p>PS： 迭代器中在没有使用泛型之前，next方法的返回值类型都是统一Object，所以将方法中返回E看做是Object即可，迭代器提供自身remove方法，所以在迭代器中删除数据时要调用迭代器提供remove，而不是集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorArrayList</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//基础迭代器</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line">        arrayList.add(<span class="number">2</span>);</span><br><span class="line">        arrayList.add(<span class="number">3</span>);</span><br><span class="line">        arrayList.add(<span class="number">4</span>);</span><br><span class="line">        arrayList.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//需要使用ArrayList集合对象调用iterator方法获取迭代器对象</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> arrayList.iterator();</span><br><span class="line">        <span class="comment">//利用迭代器对象调用hasNext进行操作判断迭代器中是否还存在下一个元素</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        while(iterator.hasNext())</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            //通过next方法获取迭代器中数据</span></span><br><span class="line"><span class="comment">            System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//迭代器使用问题--》删除数据</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> ((Integer) iterator.next());</span><br><span class="line">            <span class="keyword">if</span> (integer.equals(<span class="number">2</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//删除掉2这个值</span></span><br><span class="line">                <span class="comment">//iterator.remove();//使用迭代器中提供删除[删除迭代器中存储数据的同时会删除集合中对应数据]</span></span><br><span class="line">                <span class="comment">//千万不要调用集合中提供删除方法</span></span><br><span class="line">                <span class="comment">//ConcurrentModificationException --&gt; 就会出现并发迭代修改异常</span></span><br><span class="line">                </span><br><span class="line">                arrayList.remove(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-4-强化迭代器-center"><center>4、强化迭代器</center></h2>
<p>强化迭代器只有List集合具备，专门为List集合提供一个增强迭代器，因为原始迭代器中只有三个方法，不利于对集合数据的操作，增强迭代器就新增多个方法进行迭代器操作</p>
<p>ListIterator是List集合在Iterator迭代器接口之上提供一个更多方法操作的迭代器，ListIterator在原始迭代器基础上增加，新增数据，修改数据，从后向前遍历【获取数据】的操作，还可以获取下标</p>
<table>
<thead>
<tr>
<th>void</th>
<th>add(E e) 将指定的元素插入列表（可选操作）</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>hasNext() 以正向遍历列表时，如果列表迭代器有多个元素，则返回 true （换句话说，如果 next 返回一个元素而不是抛出异常，则返回 true ）</td>
</tr>
<tr>
<td>boolean</td>
<td>hasPrevious() 如果以逆向遍历列表，列表迭代器有多个元素，则返回 true</td>
</tr>
<tr>
<td>void</td>
<td>add(E e) 将指定的元素插入列表（可选操作）</td>
</tr>
<tr>
<td>E</td>
<td>next() 返回列表中的下一个元素</td>
</tr>
<tr>
<td>int</td>
<td>nextIndex() 返回对 next 的后续调用所返回元素的索引</td>
</tr>
<tr>
<td>E</td>
<td>previous() 返回列表中的前一个元素</td>
</tr>
<tr>
<td>int</td>
<td>previousIndex() 返回对 previous 的后续调用所返回元素的索引</td>
</tr>
<tr>
<td>void</td>
<td>remove() 从列表中移除由 next 或 previous 返回的最后一个元素（可选操作）</td>
</tr>
<tr>
<td>void</td>
<td>set(E e) 用指定元素替换 next 或 previous 返回的最后一个元素（可选操作）</td>
</tr>
</tbody>
</table>
<p>PS：在没有使用泛型之前，方法所有使用E的部分都看做是Object类型即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListIteratorArrayList</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//基础迭代器</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line">        arrayList.add(<span class="number">2</span>);</span><br><span class="line">        arrayList.add(<span class="number">3</span>);</span><br><span class="line">        arrayList.add(<span class="number">4</span>);</span><br><span class="line">        arrayList.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//需要使用ArrayList集合对象调用listiterator方法获取迭代器对象</span></span><br><span class="line">        <span class="type">ListIterator</span> <span class="variable">iterator</span> <span class="operator">=</span> arrayList.listIterator();</span><br><span class="line">        <span class="comment">//如果你想调用逆向遍历操作时，需要现将光标向后移动才可以，光标最先开始是在第一个元素位置上</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时对迭代器进行逆向遍历【从后向前】</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasPrevious())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(iterator.previous());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&quot;listIterator同样是遵守一个原则，不要再迭代器中使用后集合删除方法删除数据，要使用迭代器提供方法进行删除&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="center-5-迭代器注意事项-center"><center>5、迭代器注意事项</center></h2>
<p>（1）迭代器迭代完成之后，迭代器的位置在最后一位。 所以迭代器只能迭代一次</p>
<p>（2）迭代器在迭代的时候，不要调用多次next方法，可能会出错 NoSuchElementException</p>
<p>（3）在迭代器迭代的时候，不能向集合中添加或者删除元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionDemo03</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="string">&quot;jeck&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;马冬梅&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;Lisi&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、迭代器不能使用多次，如果要多次使用那么要多次获取</span></span><br><span class="line"><span class="comment">//        Iterator it = coll.iterator();</span></span><br><span class="line"><span class="comment">//        while (it.hasNext())</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(it.next());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        while (it.hasNext())</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(it.next());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、在同一次迭代中，不能多次使用next方法</span></span><br><span class="line"><span class="comment">//        Iterator it = coll.iterator();</span></span><br><span class="line"><span class="comment">//        while (it.hasNext())</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            //第一种</span></span><br><span class="line"><span class="comment">//            Object obj = it.next();</span></span><br><span class="line"><span class="comment">//            System.out.println(obj);</span></span><br><span class="line"><span class="comment">//            //第二种</span></span><br><span class="line"><span class="comment">//            System.out.println(it.next());</span></span><br><span class="line"><span class="comment">//            //不能这么多次使用</span></span><br><span class="line"><span class="comment">//            Object obj = it.next();</span></span><br><span class="line"><span class="comment">//            System.out.println(it.next());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、迭代器在迭代的过程中不能调用add或者remove方法</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            coll.add(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点六：List集合之LinkedList集合</center></h1>
<h2 id="center-1-说明-center"><center>1、说明</center></h2>
<p>LinkedList集合也是List集合接口中主要实现类，这个LinkedList的主要实现结构有【链表】，除了链表结构之外LinkeList还使用栈、 队	列、数组，LinkedList是允许存重复数据化并且可以快速插入数据</p>
<p><strong>LinkedList中实现的数据结构</strong></p>
<p><strong>栈</strong>：stack,又称堆栈，它是运算受限的线性表，其限制是仅允许在表的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</p>
<p>简单的说：采用该结构的集合，对元素的存取有如下的特点</p>
<p><strong>先进后出</strong>（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹</p>
<p><strong>栈的入口、出口的都是栈的顶端位置</strong></p>
<img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291919875.WebP" alt="栈的位置" style="zoom:67%;">
<p>这里两个名词需要注意：</p>
<p>    <strong>压栈</strong>：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置</p>
<p>    <strong>弹栈</strong>：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置</p>
<p><strong>队列</strong>：队列和栈有一些类似，也是一种受到限制的线性表，其限制是仅允许在表的一表进行插入，另外一段进行取出和删除，这样队列叫做单向队列【Queue】</p>
<p>队列是存在一个特点：先进先出</p>
<img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291920090.WebP" alt="队列" style="zoom: 33%;">
<p>队列：除了单向队列之外，还提供一种非受限制线性表，这表就是双端队列，依旧遵守先进先出原则，<strong>双端队列</strong>【Deque】</p>
<img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291921569.WebP" alt="双端队列" style="zoom:33%;">
<p>链表：链表属于一个线性表，线性表中包含了存储链接位置和数据的位置，利用链接位置进行相连接，使数据之间呈现一种链接状态，链表可以理解为：老鹰抓小鸡</p>
<img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291921058.WebP" alt="链表" style="zoom:50%;">
<p>链表和队列差不多，链表也分为单向和双向链表，类似于现实生活中的【火车】通过链接方式就可以获取得到链表中数据</p>
<p>单向链表和双向链表是有本质上区别的，单向链表包含两个区域【存储链接位置和数据存储位置】，通过【存储链接位置】让每一个单独链接节点进行相连，形成一个单向链表，即单向链表只能向一个方法进行遍历操作，双向链表包含是三个区域【2个存储链接位置和1个数据存储位置】 ，利用双向链表中两个存储链接的位置进行前后节点的链接，此时链表就形成了一个双向通道，即可以从头到尾，也可以从到头，允许直接在头尾两端进行操作</p>
<h2 id="center-2-分析linkedlist的执行效率-center"><center>2、分析LinkedList的执行效率</center></h2>
<p>主要实现方式是【双向链表】，所以使用LinkedList效果</p>
<ol>
<li>
<p>保存数据 ：只要执行一次即可【API中也提供 addFirst 和addLast】</p>
</li>
<li>
<p>删除操作： 只要执行一次即可【API中也提供 removeFirst 和removeLast】，就选中间节点(1+N)/2</p>
</li>
<li>
<p>查询操作和修改操作：平均值(N+1)/2</p>
</li>
</ol>
<p>结论：LinkedList增删执行效率是高的，但是查询和修改执行效率是低的</p>
<h2 id="center-3-常用方法-center"><center>3、常用方法</center></h2>
<p>常用的方法与ArrayList一致。自己独有一些向首尾添加移除等方法(可以模拟对列、堆栈等数据结构)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListAPIDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//因为LinkedList实现了List集合接口，所以具备所有List集合</span></span><br><span class="line">        操作方法</span><br><span class="line">        <span class="comment">//LinkedList中List方法操作完全参考ArrayList即可</span></span><br><span class="line">        <span class="comment">//LinkedList集合独有方法</span></span><br><span class="line">        <span class="comment">//1.创建LinkedList对象</span></span><br><span class="line">        <span class="comment">//1.1 创建一个空的LinkedList集合对象</span></span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="comment">//1.2使用参数中Collection集合对象中存储数据初始化LinkedList集合对象</span></span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">linkedList1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>(linkedList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//独有API        </span></span><br><span class="line">        <span class="comment">//1.向集合开头的位置添加元素</span></span><br><span class="line">        linkedList.addFirst(<span class="number">1</span>);</span><br><span class="line">        System.out.println(linkedList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.向集合结尾的位置添加元素</span></span><br><span class="line">        linkedList.addLast(<span class="number">2</span>);</span><br><span class="line">        System.out.println(linkedList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.获取集合第一个元素的数据【但是不删除集合数据】</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">element</span> <span class="operator">=</span> linkedList.element();</span><br><span class="line">        System.out.println(element);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.获取集合中第一个数据和最后一个数据【但是不删除集合数据】</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">first</span> <span class="operator">=</span> linkedList.getFirst();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">last</span> <span class="operator">=</span> linkedList.getLast();</span><br><span class="line">        <span class="comment">//PS： LinkedList允许使用下标形式进行数据获取</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> linkedList.get(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.添加元素到集合的末尾</span></span><br><span class="line">        linkedList.offer(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//添加到第一个位置offerFirst和最后一个位置offerLast</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6.获取集合集合第一个元素但是【不删除集合数据】，有元素就返回，没有就是null</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">peek</span> <span class="operator">=</span> linkedList.peek();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> linkedList.peekFirst();</span><br><span class="line">        <span class="comment">//获取最后一个元素的值，有元素就返回，没有就是null</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> linkedList.peekLast();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7.poll系列也是也可以获取集合中第一个和最后一个元素的【删除数据】</span></span><br><span class="line">        <span class="comment">//在获取数据的同时删除集合中数据</span></span><br><span class="line">        <span class="comment">// Object poll = linkedList.poll();</span></span><br><span class="line">        <span class="comment">// Object o3 = linkedList.pollFirst();</span></span><br><span class="line">        <span class="comment">// Object o4 = linkedList.pollLast();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//8. 弹出集合中第一个数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">pop</span> <span class="operator">=</span> linkedList.pop();</span><br><span class="line">        <span class="comment">//向集合中添加数据</span></span><br><span class="line">        linkedList.push(<span class="number">4</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//9.删除集合中第一个或最后一个元素值</span></span><br><span class="line">        linkedList.removeFirst();</span><br><span class="line">        linkedList.removeLast();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10.List集合特点就是允许存储重复数据，下面两个方法的作用就是遍历集合</span></span><br><span class="line">        <span class="comment">//First的方法从前之后 Last的方法从后向前</span></span><br><span class="line">        <span class="comment">//遇到第一个相同数据删除</span></span><br><span class="line">        linkedList.removeFirstOccurrence(<span class="number">1</span>);</span><br><span class="line">        linkedList.removeLastOccurrence(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//LinkedList有一个独有的迭代器，允许逆向的遍历迭代器中数据值</span></span><br><span class="line">        <span class="comment">//但是它的操作方式和iterator是一样</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> linkedList.descendingIterator();</span><br><span class="line">        <span class="comment">//它的方式只有三个 hasNext next 和 remove</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//不同点在于：它的光标最先开始是放置在迭代器最后一个元素的位置，你hasNext是向前判断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-4-linkedlist实现原理-center"><center>4、LinkedList实现原理</center></h2>
<img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291923333.WebP" alt="实现原理" style="zoom:50%;">
<h1><center>知识点七：List集合总结</center></h1>
<p>List集合是Collection集合子集合即List集合是继承与Collection集合，因为List集合是接口所以无法直接操作，Java就提供了两个可以便捷操作List集合实现类ArrayList和LinkedList</p>
<p>List集合的特点：允许存储重复数据并给存储数据是有顺序</p>
<p>在官方API文档中可以查看到：public interface List extends Collection</p>
<p>有序的 collection（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素</p>
<p><strong>所有已知实现类</strong>： ArrayList 和 LinkedList</p>
<p><strong>所有超级接口</strong>： Collection 和 Iterable</p>
<p>因为也继承了Iterable所以List集合中是支持的迭代器【Iterator】</p>
<p>List接口中提供常用方法已经在ArrayList集合中完全进行演示，所以使用List集合时只要参考ArrayList提供方法演示就可以操作集合</p>
<p>ArrayList和LinkedList实现类是实现List接口，所以List相当于是他们的父类，所以List集合接口支持多态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List集合接口允许这样这样创建对象</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">或者</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line"><span class="string">&quot;这样直接使用较少，多用于在方法中如果需要设置List集合参数，优先会</span></span><br><span class="line"><span class="string">将List作为参数类型，而不是实现类&quot;</span></span><br><span class="line"><span class="string">&quot;因为这样做可以接收ArrayList或LinkedList&quot;</span></span><br><span class="line"><span class="string">&quot;上面这种方式是不使用泛型，所以默认数据类型时Object，操作时就一定</span></span><br><span class="line"><span class="string">注意转换问题【对象的向下转型】&quot;</span></span><br><span class="line"><span class="string">&quot;Java中所有集合都是有泛型语法，所以可以使用泛型方式进行创建对象&quot;</span></span><br><span class="line">    List&lt;数据类型&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="string">&quot;泛型语法形式：&quot;</span></span><br><span class="line">    集合的数据类型&lt;数据类型&gt; 集合对象名字 = <span class="keyword">new</span> 集合数据类型&lt;&gt;();</span><br><span class="line"><span class="string">&quot;集合都是使用new关键字创建，所以它是引用类型&quot;</span></span><br><span class="line"><span class="string">&quot;现在学习ArrayList和LinkedList都是线程不安全的集合，在多线程操</span></span><br><span class="line"><span class="string">作前提下是不能使用这两个集合进行数据存储操作，这两个集合只适合在单线程下使用&quot;</span></span><br></pre></td></tr></table></figure>
<p>List集合接口还有一个<strong>实现类Vector</strong></p>
<p>Vector在JDK1.0的时候就已经存在，这个类其实是ArrayList集合类“前身”，在JDK1.2时候Java开始强调了集合框架概念，所以提供Collection集合框架，在Collection下面提供List和Set，Vector的实现也是数组，所以被归类到了List接口的实现类中，现在开发已经不在使用Vector这个类，主要使用ArrayList这个类</p>
<p>Vector和ArrayList之间相似点和区别在于什么？</p>
<p>相似点：都是List集合接口的实现类，都使用数组作为集合数据结构进行实现</p>
<p>不同点：Vector这个集合是线程安全的，但是效率低，提供较早并且使用率低</p>
<p>    ArrayList这个集合是线程不安全，但是效率高，提供较晚并且使用率高</p>
<p>PS：就算Vector是线程安全的，但实际开发中也不会使用Vector，还是使用ArrayList</p>
<p>从Java5开始提供ArrayList和LinkeList线程安全处理模式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;集合中是存在一个工具类，这个类叫做Collections，这个工具类提供</span></span><br><span class="line"><span class="string">了如果将线程不安全集合转换为线程安装集合的方法&quot;</span></span><br><span class="line">Collections.synchronizedList(List集合对象); ---》可以将</span><br><span class="line">一个线程不安全集合转换为线程安全</span><br><span class="line"><span class="string">&quot;除了这种处理方式之外,现在主要处理方式可以使用Java在JDK1.5中提</span></span><br><span class="line"><span class="string">供的一个新包java.util.concurrent 并发工具包，</span></span><br><span class="line"><span class="string">这个包中提供大量的线程安全处理时可以使用的集合&quot;</span></span><br></pre></td></tr></table></figure>
<p>Stack(栈集合)和Queue、Deque(队列集合)</p>
<p>Stack是List集合的实现类，而Queue、Deque集合接口：有专门实现类来实现主要体现在于LinkedList</p>
<h1><center>知识点八：泛型基本使用</center></h1>
<h2 id="center-1-作用-center"><center>1、作用</center></h2>
<p>什么是泛型？</p>
<p>    泛型是一个特殊类型，泛型是统称指代任何引用数据类型，泛型本身代表【通用类型含义】，在定义泛型时如果没有对泛型进行数据类型赋值之前，泛型本身是不具备任何含义，只有赋值为具体数据类型时，泛型才会真正意义</p>
<p>为什么要使用这个泛型?</p>
<p>    泛型解决了集合中存储数据类型的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CenericityList</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在学习集合之前，是没有使用泛型，所以集合中默认类型就是Object</span></span><br><span class="line"><span class="comment">            我们面临的问题就是取出数据时，需要进行向下转型操作才可以</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//对集合存储的数据进行计算求和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span><span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(Object obj : list)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += ((Integer) obj);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//因为不使用泛型默认类型时Object类型所以和这个集合中就可以存储任何数据类型只要是Object子类</span></span><br><span class="line">        list.add(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line">        list.add(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//如果你在不清楚集合中存储在什么样数据类型数据时，如果进行转换操作？代码就无形中增加开发成本</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            所以在这种情况下，集合建议使用泛型，来约束集合中存储数据</span></span><br><span class="line"><span class="comment">            一旦集合使用泛型就要可以约束集合只能 存储泛型中提供的数据类型对应数据，从而减少转换操作</span></span><br><span class="line"><span class="comment">            此时list1这个集合中只能存储Integer类型数据，使用泛型作为约束</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list1.add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//list1.add(&quot;1&quot;);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer i : list1)</span><br><span class="line">        &#123;</span><br><span class="line">            sum1+=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS： 如何定义泛型集合？</p>
<h3 id="语法">语法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">集合数据类型&lt;存储数据的数据类型&gt; 集合对象名 = <span class="keyword">new</span> 集合数据类型&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>此时就可以使用【存储数据的数据类型】约束集合中存储的数据了</p>
<p>PS：集合泛型你就可以理解为 就是创建数组是</p>
<p>数组中存储元素数据类型[] —》相当于 集合数据类型&lt;存储数据的数据类型&gt;	只能引用数据类型</p>
<p>泛型解决通用性问题</p>
<p>编程原则：DRY【不要重复你自己（不要写重复性代码）】</p>
<p>需求： 求点中x和y的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer x;</span><br><span class="line">    <span class="keyword">private</span> Integer y;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Double x;</span><br><span class="line">    <span class="keyword">private</span> Double y;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Long x;</span><br><span class="line">    <span class="keyword">private</span> Long y;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String x;</span><br><span class="line">    <span class="keyword">private</span> String y;</span><br><span class="line">&#125; </span><br><span class="line">为了Point类型可以获得不同参数类型数据，需要提供大量相同逻辑类，此时就触发DRY原则，</span><br><span class="line">现有解决方案就是将数据类型替换成Object类型，但</span><br><span class="line">是我们需要面临数据类型转换和传递非计算类型问题，有没有什么方式可以</span><br><span class="line">动态决定类中x和y属性类型操作，根据外界传递类型来进行x和y的限制操作 ---》 可以使用<span class="string">&quot;泛型&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="keyword">private</span> T y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-2-定义-center"><center>2、定义</center></h2>
<p>PS：泛型中会出现一个【占位符】的概念，这个占位符本身是没有任何意义，就是一个占位，对泛型进行赋值时，占位符才会有具体的意义</p>
<p>泛型的概念是Java5开始引入到Java中，它可以通过对泛型赋值进行对数据赋值约束，通过泛型动态决定数据类型时什么</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;占位符&gt;</span><br><span class="line">PS：这种语法在Java中叫做<span class="string">&quot;菱形语法&quot;</span>，这样语法与占位符组合就是成</span><br><span class="line">为<span class="string">&quot;泛型&quot;</span></span><br><span class="line">这个语法可以使用在 <span class="string">&quot;类、方法和接口&quot;</span>上</span><br><span class="line">占位符<span class="string">&quot;一般是一个大写字母[A~Z]&quot;</span>,不建议使用其他形式进行占位符定义</span><br><span class="line">习惯书写占位符是 <span class="string">&quot;T&quot;</span> --&gt; <span class="string">&quot;Type(类型)&quot;</span> ---&gt; &lt;T&gt; 泛型T</span><br><span class="line">占位符可以在一个语法存在多个需要使用<span class="string">&quot;,&quot;</span>分隔，使用占位符的多少就相</span><br><span class="line">当于你定义多个泛型</span><br><span class="line">泛型语法:只能存在在编译时期，一旦程序运行泛型就会自动消失<span class="string">&quot;称之为泛型擦除&quot;</span></span><br><span class="line">        定义的泛型在编译字节码文件中即[.class文件]看不到</span><br></pre></td></tr></table></figure>
<h2 id="center-3-泛型的使用之集合-center"><center>3、泛型的使用之集合</center></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CenericityList</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 集合的数据类型&lt;泛型赋值数据类型&gt; 集合对象名字 = new 集合的数据类型&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// 声明的就是带有泛型集合，泛型可以作为集合类型一部分，可以出现在方法参数位置和返回值类型的位置</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list1.add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//一旦集合使用泛型之后，集合只允许使用泛型定义数据类型，非泛型定义数据类型时无法存储到集合中</span></span><br><span class="line">        <span class="comment">//list1.add(&quot;1&quot;);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//集合使用泛型之后，确定了集合中存储数据的数据类型，在集合中的数据就无需向下转型操作</span></span><br><span class="line">        <span class="keyword">for</span>(Integer i : list1)</span><br><span class="line">        &#123;</span><br><span class="line">            sum1+=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showList</span><span class="params">(ArrayList&lt;Integer&gt; list)</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title function_">showList</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-4-泛型的使用之泛型类-center"><center>4、泛型的使用之泛型类</center></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    当前类在没有使用任何其他修饰符之前【final 或 abstract】,没有使用泛</span></span><br><span class="line"><span class="comment">型语法之前 都是一个普通类</span></span><br><span class="line"><span class="comment">    public class CenericityClass </span></span><br><span class="line"><span class="comment">    &#123;&#125;</span></span><br><span class="line"><span class="comment">    利用泛型语法 &lt;占位符&gt; 可以将当前类变成泛型类</span></span><br><span class="line"><span class="comment">    语法：</span></span><br><span class="line"><span class="comment">        public class 类名&lt;占位符&gt;    //这个类就是泛型类</span></span><br><span class="line"><span class="comment">        &#123; </span></span><br><span class="line"><span class="comment">            此时这个泛型是定义在类上，所以在类中成员变量和成员方法都可以使用</span></span><br><span class="line"><span class="comment">            这个泛型</span></span><br><span class="line"><span class="comment">作为数据类型使用</span></span><br><span class="line"><span class="comment">        &#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CenericityClass</span>&lt;T&gt; <span class="comment">// 使用泛型是 T 这个T现在是没有意义 只是一个占位符号</span></span><br><span class="line">&#123;     </span><br><span class="line">    <span class="comment">//此时这个T是没意义，为了保证语法不错误，占位使用</span></span><br><span class="line">    <span class="comment">//泛型T只有被赋值之后【数据类型（必须是引用数据类型）】 T才会有意义</span></span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="keyword">public</span> T y;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CenericityClass</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CenericityClass</span><span class="params">(T x, T y)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//在类上定义泛型，如何确定泛型数据类型，只要在创建类的对象时对泛型进行赋值，泛型就有具体的数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 类名&lt;泛型赋值数据类型&gt; 对象名字 = new 类名&lt;&gt;();</span></span><br><span class="line">        CenericityClass&lt;Integer&gt; cc = <span class="keyword">new</span></span><br><span class="line">        <span class="title class_">CenericityClass</span>&lt;&gt;();</span><br><span class="line">        cc.y = <span class="number">1</span>;</span><br><span class="line">        cc.show(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//这样创建对象,创建泛型的同时不对泛型进行赋值操作</span></span><br><span class="line">        <span class="comment">//此时没有对泛型进行赋值，所以泛型类型默认使用Object</span></span><br><span class="line">        <span class="type">CenericityClass</span> <span class="variable">cc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CenericityClass</span>();</span><br><span class="line">        cc1.y = <span class="number">1</span>;</span><br><span class="line">        cc1.y = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        cc1.show(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">PS：泛型在动态决定数据类型时什么的时候，不存在继承关系&quot;</span></span><br><span class="line"><span class="string">&quot;不要这样写，这个语法是错误，对泛型进行赋值什么数据类型时，就决定这个数类型，所不允许赋值为其他类&quot;</span></span><br><span class="line">CenericityClass&lt;Object&gt; cc = <span class="keyword">new</span></span><br><span class="line"><span class="title class_">CenericityClass</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>
<h2 id="center-5-泛型使用之泛型方法-center"><center>5、泛型使用之泛型方法</center></h2>
<p>泛型方法的定义主要是为了摆脱使用泛型类上或泛型接口上的泛型约束问题，就相当于方法向使用自己定义泛型作为类型操作，就可以定义为泛型方法</p>
<p>泛型类和泛型接口上定义泛型，不能在静态方法上使用，所以只能定义泛型方法对方法进行泛型使用修饰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericityMethod</span>&lt;T&gt; <span class="comment">// 使用泛型是 T 这个T现在是没有意义 只是一个占位符号</span></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个成员方法 泛型类上定义泛型就可以在方法中使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//泛型类上定义泛型是不能在静态方法上使用</span></span><br><span class="line">    <span class="comment">//public static void showInfos(T t)&#123; &#125;</span></span><br><span class="line">    <span class="comment">//给方法添加泛型</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        泛型静态方法：</span></span><br><span class="line"><span class="comment">            访问权限修饰符 static&lt;占位符&gt; 返回值类型 方法名(参数列表)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                此时这个占位符可以使用在返回值类型上 和 参数列表定义中</span></span><br><span class="line"><span class="comment">            &#125; </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;E&gt; <span class="keyword">void</span> <span class="title function_">showInfos</span><span class="params">(E e)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//E a;// 方法上泛型主要是为了 返回值类型和参数类型而提供的，在内部就不在使用</span></span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        泛型成员方法：</span></span><br><span class="line"><span class="comment">            访问权限修饰符&lt;占位符&gt; 返回值类型 方法名(参数列表)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                此时这个占位符可以使用在返回值类型上 和 参数列表定义中</span></span><br><span class="line"><span class="comment">            &#125; </span></span><br><span class="line"><span class="comment">        此时不仅可以使用泛型方法上定义泛型，也可以使用类上或接口上定义泛型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span>&lt;F&gt; <span class="keyword">void</span> <span class="title function_">showInfoss</span><span class="params">(F f,T t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//F a;// 方法上泛型主要是为了 返回值类型和参数类型而提供的，在内部就不在使用</span></span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//定义泛型方法泛型，不能单独使用在方法返回值类型位置，需要配合使用参数列表定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;O&gt; O <span class="title function_">showInfosss</span><span class="params">(O o)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//静态方法可以这样操作，成员的不可以</span></span><br><span class="line">        <span class="comment">//return o;</span></span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如何给方法定义泛型进行赋值操作---》赋值数据类型</span></span><br><span class="line">        <span class="comment">//在调用方法对泛型定义参数列表赋值时，可以决定方法的泛型是什么，定义泛型方法时</span></span><br><span class="line">        <span class="comment">//一定要将泛型定义在参数列表中，以确定数据类型是什么</span></span><br><span class="line">        GenericityMethod.showInfos(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="type">GenericityMethod</span> <span class="variable">genericityMethod</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">        <span class="title class_">GenericityMethod</span>();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> GenericityMethod.showInfosss(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-6-泛型使用之接口泛型-center"><center>6、泛型使用之接口泛型</center></h2>
<p>接口泛型和泛型类差不多，在接口上定义泛型，这个泛型可以在接口内部使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    public interface 接口名&lt;占位符&gt;</span></span><br><span class="line"><span class="comment">    &#123;&#125;泛型接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenericityInterface</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在接口上定义泛型可以在接口内部使用</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(T t)</span>;</span><br><span class="line">    <span class="comment">//支持抽象方法自定义泛型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span>&lt;E&gt; <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(E e)</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//1. 在使用类实现接口时可以对泛型接口的泛型进行赋值，决定泛型类型是什么 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">GenericityInterface</span>&lt;Integer&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在接口中定义方法使用泛型位置都会变成数据类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Integer integer)</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(E e)</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 使用泛型类实现泛型接口，使用泛型类中泛型作为接口中新泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo2</span>&lt;P&gt; <span class="keyword">implements</span> <span class="title class_">GenericityInterface</span>&lt;P&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在创建泛型类对象时可以决定泛型类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(P p)</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(E e)</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        GenericityInterface&lt;Double&gt; gi = <span class="keyword">new</span> <span class="title class_">Demo2</span>&lt;&gt;();</span><br><span class="line">        gi.run(<span class="number">1.0</span>);</span><br><span class="line">        Demo2&lt;String&gt; demo2 = <span class="keyword">new</span> <span class="title class_">Demo2</span>&lt;&gt;();</span><br><span class="line">        demo2.run(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">//这种操作其实就是List集合中使用List集合创建对象的方式</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Long&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//3.直接使用匿名内部类的形似进行泛型接口上泛型的赋值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">GenericityInterface</span>&lt;Integer&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Integer integer)</span> </span><br><span class="line">            &#123;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(E e)</span> </span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-7-泛型的限定-center"><center>7、泛型的限定</center></h2>
<p>泛型限定其实就是定义泛型可以赋值哪些数据类型，只有满足限定要求的数据类型才可以进行定义赋值操作</p>
<p><strong>泛型通配符【?】</strong></p>
<p>?代表未知，可以作为通配符使用，但是不能作为参数类型单独使用，通配符多用于在泛型限定上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericityDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ? 是一个通配符</span></span><br><span class="line">        List&lt;?&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>); <span class="comment">// 这里是无法确定数据类型，无法单独使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>&lt; ? extends 类&gt; 这是使用途径 此时 ？ 就代表着可以接收extends关键字后的相同类型或子类</strong></p>
<p><strong>&lt; ? super 类&gt; 这是使用途径 此时 ？ 就代表着可以接收super关键字后的相同类型或父类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericityDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供4个List集合对象</span></span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Number&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Object&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//调用泛型的上限操作，即参数类型使用的是List&lt;? extends Number&gt;进行限制</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            泛型限定必须是 Number类型或Number子类</span></span><br><span class="line"><span class="comment">            而list1是Integer类型即Number子类 list3是Number类型即</span></span><br><span class="line"><span class="comment">Number类型所以可以进行传递</span></span><br><span class="line"><span class="comment">            而list2和list4分别是String和Object，既不是Number类型也</span></span><br><span class="line"><span class="comment">不是Number子类，所以无法传递到方法中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        doWork1(list1);</span><br><span class="line">        <span class="comment">//doWork1(list2);</span></span><br><span class="line">        doWork1(list3);</span><br><span class="line">        <span class="comment">//doWork1(list4);</span></span><br><span class="line">        <span class="comment">//调用泛型下限操作，即参数类型使用的是List&lt;? super Number&gt;进行限制</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            泛型限定必须是Number类型或Number父类</span></span><br><span class="line"><span class="comment">            而list1和list2分别是Integer和String，既不是Number类型也不是Number父类，所以无法传递到方法中</span></span><br><span class="line"><span class="comment">            list3和list4 分别是Number和Object 满足了必须是Number类型或Number父类，所以传递到方法中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//doWork2(list1);</span></span><br><span class="line">        <span class="comment">//doWork2(list2);</span></span><br><span class="line">        doWork2(list3);</span><br><span class="line">        doWork2(list4);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//泛型的上限，此时的泛型中?(通配符) 必须是Number的类型或Number子类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doWork1</span><span class="params">(List&lt;? extends Number&gt; list)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//泛型的下限，此时的泛型中?(通配符) 必须是Number的类型或Number父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doWork2</span><span class="params">(List&lt;? <span class="built_in">super</span> Number&gt; list)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-8-特点-center"><center>8、特点</center></h2>
<p>（1）泛型集合在存储元素的时候，支持多态(不推荐使用)</p>
<p>（2）泛型定义的时候，不存在多态</p>
<p>    Collection coll1 = new ArrayList(); err</p>
<p>（3）泛型擦除</p>
<p>    在JDK1.7之后，右边的&lt;&gt;中不需要定义泛型类型</p>
<p>    集合的泛型不能是基本数据类型，要使用它们的包装类</p>
<p>CollectionDemo01类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionDemo01</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型：参数化类型     JKD1.5之后</span></span><br><span class="line"><span class="comment">     * 泛型作用：因为在没有使用泛型之前，向集合中存储实际上是Object类型的数据，所以获取的时候也是Object类型</span></span><br><span class="line"><span class="comment">     *         如果想要使用这个对象，需要发生向下转型，那么在整个集合存储元素的时候，不停的发生向上和向下转型,可能会发生异常</span></span><br><span class="line"><span class="comment">     * 泛型的好处：类型转换的操作提前到了编译器</span></span><br><span class="line"><span class="comment">     *泛型特点：</span></span><br><span class="line"><span class="comment">     *      泛型集合在存储元素的时候，支持多态(不推荐使用)</span></span><br><span class="line"><span class="comment">     *      泛型定义的时候，不存在多态</span></span><br><span class="line"><span class="comment">     *         Collection&lt;Person&gt; coll1 = new ArrayList&lt;Student&gt;(); err</span></span><br><span class="line"><span class="comment">     *      泛型擦除</span></span><br><span class="line"><span class="comment">     *          在JDK1.7之后，右边的&lt;&gt;中不需要定义泛型类型</span></span><br><span class="line"><span class="comment">     *      集合的泛型不能是基本数据类型，要使用它们的包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        Collection coll = new ArrayList();</span></span><br><span class="line"><span class="comment">//        coll.add(new Student(&quot;jack&quot;,28));</span></span><br><span class="line"><span class="comment">//        coll.add(new Student(&quot;尼古拉斯&quot;,23));</span></span><br><span class="line"><span class="comment">//        coll.add(new Teacher(&quot;rose&quot;,32));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //遍历集合  迭代器</span></span><br><span class="line"><span class="comment">//        Iterator it = coll.iterator();</span></span><br><span class="line"><span class="comment">//        while (it.hasNext())</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            //没有向下转型时时Object类</span></span><br><span class="line"><span class="comment">//            //System.out.println(it.next().play());</span></span><br><span class="line"><span class="comment">//            Object obj = it.next();</span></span><br><span class="line"><span class="comment">//            Student stu = (Student) obj;</span></span><br><span class="line"><span class="comment">//            stu.play();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        Collection&lt;Student&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;niu&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        Iterator&lt;Student&gt; it = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> it.next();</span><br><span class="line">            student.play();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//泛型集合在存储元素的时候，支持多态</span></span><br><span class="line">        Collection&lt;Person&gt; coll1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        coll1.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        coll1.add(<span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;sdf&quot;</span>,<span class="number">34</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不能用基本数据类型</span></span><br><span class="line">        <span class="comment">//Collection&lt;int&gt; coll2 = new ArrayList&lt;&gt;();</span></span><br><span class="line">        Collection&lt;Integer&gt; coll3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Person类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Student类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Student类中的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student玩。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Teacher类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Teacher&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点九：Set集合的介绍</center></h1>
<p><img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291933362.WebP" alt="set集合"></p>
<h1><center>知识点十：Set集合实现类HashSet</center></h1>
<p>HashSet集合是Set集合主要实现类，也是日常开发使用最常用Set集合实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span> <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>
<p>HashSet集合继承了Set集合的特点，向hashSet集合中存储数据时，是不允许出现重复数据，如果有存储重复数据HashSet集合会进行自动排重操作，<strong>HashSet集合的主要实现数据结构“Hash表”</strong>,存储数据顺序是无序，<strong>通过观察API文档发现HashSet集合的所有方法都是Set集合接口提供，本身没有任何特殊方法</strong></p>
<p>特点:</p>
<ul>
<li>无序 （插入顺序）</li>
<li>无下标</li>
<li>不可重复</li>
</ul>
<h2 id="center-1-hash表-center"><center>1、Hash表</center></h2>
<p><strong>什么是hash表？</strong></p>
<p>    Hash 一般被翻译为“散列”，也可以直接音译为“哈希”，它是基于【快速存取的角度而设计的一种存储结构】，而且是一个典型【空间换时间】的做法，利用Hash表的原理进行数据存储操作</p>
<p>    Hash表其实就是【“数组+链表”】的组合形式，在Hash表数组起到作用提供存储位置，在Hash表链表起到作用提供数据存储结构</p>
<img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291936873.WebP" alt="Hash表" style="zoom:50%;">
<p>上图中是典型Hash表的结构，Hash表也别称之为【散列表(Hashtable)】，Hash表是根据键值对（Key-value）而直接进行访问的数据结构，也就是说【通过把key值映射到表中一个位置来记录访问位置】，以加快查找数据（这个操作就是确定数据在Hash表中存储的位置），这个操作也被称之为【散列函数】，通过散列函数计算出存储位置会后，会将存储数据以链表形似挂载在存储位置中，这种方式成为【桶】如果存储70个元素，但是存储70个元素时申请100个空间，70/100 = 0.7 ，这个0.7这个值就称之为“负载（加载）因子”，通过这个因子对hash表进行扩容操作</p>
<p>因为Hash表是基于【快速存取】的操作，所以Hash表会尽量的平均将数据分配到Hash表中进行存储，但是在存储过程中就会触发，在同一个存储空间中出现重复数据问题，此时Hash就会启动自动排重操作，原则就是equals比较，只要equals比较结果为true，就不在这个空间存储相同数据</p>
<p>假如：向上面Hash表中存储12这个数据如果进行存储计算</p>
<p>第一步：通过散列函数计算12需要存储的位置 --》hash(key)%len【散列函数】</p>
<p>hash(key) —》 key 是要存储数据 hash(key) —》<strong>计算key的hash值即Java中hashcode值</strong></p>
<p>len —》其实就是存储Hash表中数组长度，上图中数组长度为16所以散列函数计算效果</p>
<p>hash(12) % 16 —》 12%16 ----》 余数12 ，利用12这个值去数组中提供存储位置对别查找存</p>
<p><strong>Hash表的扩容机制？</strong></p>
<p>    Hash表示一个自动扩容机制，<strong>当达到【加载因子】参数要求时，Hash表就会进行自动扩容</strong></p>
<p>    Java中使用<strong>Hash表默认大小给16，加载因子0.75</strong>当16个存储位置发生了75%位置都存储了数据即16*0.75 = 12，也就说12个下标位置中都存储数据，Hash表就会发生自动扩容，扩容机制就以2的幂次进行扩容【16是2^4】扩容之后2^5即hash表每次扩容之后都是原有容量一倍，就会从原有16扩容到32</p>
<p>    在介绍HashSet时说过HashSet中存储数据不能保证存储位置永久不变，只要Hash表发生一次扩容，那么Hash表中存储的数据就要重新计算存储位置</p>
<p>原始数据28 存储在大小为16的hash表中 计算位置 28%16 --》 余数12</p>
<p>一旦扩容大小从16变成32 此时原始数据28可就要重新计算存储位置</p>
<p>在hash表 计算位置 28%32 —》 余数 28</p>
<p><strong>总结：Hash表数据存储和查找是非常优秀，但是一旦扩容就会降低Hash表的性能</strong></p>
<h2 id="center-2-hashset基本使用-center"><center>2、HashSet基本使用</center></h2>
<h3 id="1-语法">(1）语法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;泛型&gt; 变量名 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>HashSet是实现Set集合接口，查看API时可以发现HashSet中并没有任何特殊方法，所以知己使用Set接口提供方法就完成HashSet集合操作【<strong>HashSet集合中操作方法方式和ArrayList集合中介绍方式是一样的，只不过HashSet带有排重的效果，可以完全参考ArrayList集合中API使用在HashSet中进行使用</strong>】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetAPI</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建HashSet集合对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            表面上代码操作是在创建一个HashSet集合，但是实际底层操作过程中是在创建HashMap集合</span></span><br><span class="line"><span class="comment">            向HashSet集合存储的数据其实就是在想HashMap中key的位置存储</span></span><br><span class="line"><span class="comment">数据，为什么要这样会做</span></span><br><span class="line"><span class="comment">            Hash表存储数据值是以【key-value】进行数据存储操作 --》</span></span><br><span class="line"><span class="comment">Java集合中可以提供Key-value形式存储只有Map集合</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//1.提供一个空的HashSet集合对象【默认容量16,加载因子0.75】</span></span><br><span class="line">        HashSet&lt;Integer&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//PS：HashSet是Set集合的实现类，也就相当于是Set集合&quot;子类&quot;</span></span><br><span class="line">        <span class="comment">//利用Set集合接口使用多态形式创建Set集合对象</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.可以利用参数Collection集合对象中存储数据初始化HashSet集合对象</span></span><br><span class="line">        HashSet&lt;Integer&gt; hashSet1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;</span><br><span class="line">(hashSet);</span><br><span class="line">        <span class="comment">//3.指定HashSet集合初始化容量大小【使用默认加载因子0.75】</span></span><br><span class="line">        <span class="comment">//遵守大小原则是2次幂来定义的，但是不要小于16</span></span><br><span class="line">        HashSet&lt;Double&gt; hashSet2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;</span><br><span class="line">(((<span class="type">int</span>)Math.pow(<span class="number">2</span>,<span class="number">5</span>)));    <span class="comment">//2的5次幂(double类型)强转int</span></span><br><span class="line">        <span class="comment">//4.指定HashSet集合初始化容量大小和加载因子 第二参数加载因子是float类型</span></span><br><span class="line">        HashSet&lt;Character&gt; hashSet3 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt; (((<span class="type">int</span>)Math.pow(<span class="number">2</span>,<span class="number">5</span>)),<span class="number">0.85f</span>);</span><br><span class="line">        <span class="comment">//常用API</span></span><br><span class="line">        <span class="comment">//向集合中添加数据</span></span><br><span class="line">        hashSet.add(<span class="number">1</span>);</span><br><span class="line">        hashSet.add(<span class="number">20</span>);</span><br><span class="line">        hashSet.add(<span class="number">4</span>);</span><br><span class="line">        hashSet.add(<span class="number">9</span>);</span><br><span class="line">        hashSet.add(<span class="number">7</span>);</span><br><span class="line">        hashSet.add(<span class="number">17</span>);</span><br><span class="line">        <span class="comment">//hashSet是可以对存储在集合数据提供排重操作的</span></span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将参数集合对象中数据存储到当前HashSet中</span></span><br><span class="line">        <span class="comment">//addAll(Collection集合对象); </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//清空HashSet集合中数据</span></span><br><span class="line">        <span class="comment">//hashSet.clear();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断HashSet集合是否为空【指没有任何数据，而不是当前hashset地址为null】</span></span><br><span class="line">        <span class="comment">//isEmpty();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断HashSet集合中是否存在指定元素</span></span><br><span class="line">        <span class="keyword">if</span>(hashSet.contains(<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;返回true证明存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;返回false证明不存在&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//containsAll(Collection集合对象) 判断Collection集合对象中个存储数据是否存在在Hashset集合对象中</span></span><br><span class="line">        <span class="comment">//因为HashSet不存在下标的概念所以HashSet是不支持普通for循环的</span></span><br><span class="line">        <span class="comment">//HashSet支持循环方式有</span></span><br><span class="line">        <span class="comment">// 增强for循环</span></span><br><span class="line">        <span class="keyword">for</span>(Integer integer : hashSet)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(integer);</span><br><span class="line">            <span class="comment">//不要调用集合删除方法</span></span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// foreach方法</span></span><br><span class="line">        hashSet.forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//普通迭代器(HashSet集合只支持普通迭代器，不支持增强迭代器即listIterator)</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = hashSet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">            <span class="comment">//删除数据就调用 迭代器中remove</span></span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除集合中数据 参数是要删除的数据</span></span><br><span class="line">        hashSet.remove(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//删除参数结合提供提供数据所在HashSet集合对象中数据</span></span><br><span class="line">        <span class="comment">//removeAll(Collection集合对象);</span></span><br><span class="line">        <span class="comment">//保留参数集合对象中数据在HashSet集合中然后删除剩余HashSet集合中数据</span></span><br><span class="line">        <span class="comment">//retainAll(Collection集合对象);</span></span><br><span class="line">        hashSet.removeIf(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Integer&gt;() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Integer integer)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> integer%<span class="number">2</span> ==<span class="number">0</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        hashSet.removeIf(integer -&gt; integer%<span class="number">2</span> ==<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取集合中存储元素的个数</span></span><br><span class="line">        System.out.println(hashSet.size());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//转换成数组</span></span><br><span class="line">        Object[] objects = hashSet.toArray();</span><br><span class="line">        Integer[] integers = hashSet.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[hashSet.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-hashset集合的排重操作">(2)HashSet集合的排重操作</h3>
<p>需求:创建一个Person对象，提供属性名字和年龄【按照标准JavaBean提供，提供toString重写】在提供PersonTest类型在类中创建两个Person对象，赋值为张三，18，存储在HashSet集合中，然后打印集合中数据，查看是否排重？如果没有排重如何处理？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        HashSet&lt;Person&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        <span class="comment">//利用HashSet中存储机制【Hash表】可以存储重复数据进行排重操作</span></span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line">        HashSet&lt;Integer&gt; hashSet1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet1.add(<span class="number">1</span>);</span><br><span class="line">        hashSet1.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(hashSet1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashSet底层实现是什么？—》</p>
<p>使用Hash表实现的，Hash表示如何进行数据存储的？ —》</p>
<p>使用Hash表提供散列函数，散列函数是什么？ —》</p>
<p>这是散列函数 hash(key)%len， hash(key)得到结果什么？len得到结果什么？ —》</p>
<p><strong>hash(key)计算存储数据所在内存中hashcoded地址值</strong></p>
<p>len是Hash表中容量的大小，默认是16 —》</p>
<p>利用散列函数【 hash(key)%len】 求得存储在Hash表中位置以进行数据的存储</p>
<p>Hash表的排重机制是：通过散列函数计算出数据存储的位置进行数据存储，如果出现同一个数据计算出位置相同，此时也会向存储位置进行插入存储，但是要进行equals比较，如果equals 比较结果为false就整存储位置中，没有与之相同数据，以链表存储，如果equals比较结果为true，证明这个存储位置有与之相同数据，此时就会放弃新添加的数据存，从而不会进行存储数据操作，那么些就是HashSet即Hash表排重机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        HashSet&lt;Person&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        hashSet.add(p1);</span><br><span class="line">        hashSet.add(p2);</span><br><span class="line">        System.out.println(<span class="string">&quot;p1对象的hashcode值：&quot;</span>+ p1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;p2对象的hashcode值:&quot;</span>+ p2.hashCode());</span><br><span class="line">        <span class="comment">//利用HashSet中存储机制【Hash表】可以存储重复数据进行排重操作</span></span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line">        HashSet&lt;Integer&gt; hashSet1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet1.add(<span class="number">1</span>);</span><br><span class="line">        hashSet1.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(hashSet1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么存储自定类的对象到HashSet集合没有进行排重？</p>
<p>就是因为自动以类并没对对象提供同一个hashcode的实现并且在Person类中也没有一共equals方法的实现，所以我们根本没有提供排重操作的原则，所以向HashSet中存储自定义类的对象是无法排重</p>
<p><strong>如果需要向HashSet集合存储自定义类的对象并提供排重机制，那么自定义类必须提供equals和hashcode方法的重写</strong></p>
<p>从写hashcode的目的在于：</p>
<ol>
<li>在Java中认为两个对象相等是通过equals方决定，决定原则在于类中提供属性完全或部分相等，认为两个对象相等，既然两个对象已经相等了，那么他们的地址也要相等，但是Java语言是无法直接操作真实内存地址的，但是我们可以获取到真实内存地址映射hashcode值，所以将equals比较相等对象的hashcode修改为相等就间接的满足【真实内存地址相等】</li>
<li>当向HashSet集合存储数据时候，HashSet集合底层实现是Hash表，而Hash表有需要通过hashcode计算存数据位置，只有在hash表存储位置相同才可能出现相同数据，这样一来就需要提供相同对象hashcode地址是相同的，通过这个方法将对象计算到同一个存储位置，在通过equals方法计算相等操作触发Hash表排重机制</li>
</ol>
<p>综上所述：对Person这类提供equals和hashcode的重写操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Objects;</span><br><span class="line">public class Person </span><br><span class="line">&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public Person() </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    public Person(String name, int age) </span><br><span class="line">    &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    public String getName() </span><br><span class="line">    &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125; </span><br><span class="line">    public void setName(String name) </span><br><span class="line">    &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    public int getAge() </span><br><span class="line">    &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125; </span><br><span class="line">    public void setAge(int age) </span><br><span class="line">    &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() </span><br><span class="line">    &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">        &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">        &quot;, age=&quot; + age +</span><br><span class="line">        &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">        IDEA编译器提供两个版本的equals和hashcode的重写</span><br><span class="line">        这两个版本都是可以，只能二选一不能共存</span><br><span class="line">    */    </span><br><span class="line">    </span><br><span class="line">    //这个版本IDEA默认版本</span><br><span class="line">    /*</span><br><span class="line">        生成equals和hashcode方法是最后选项中有一个non-null</span><br><span class="line">        这里不建议勾选这个选中给提供属性，因为引用类型还是进行非null判断</span><br><span class="line">        如果你勾选在那么系统就默认认为引用类型时为null值</span><br><span class="line">        就会使用这个引用类型方法，如果此时你引用类型属性被赋值null，必</span><br><span class="line">出空指针异常</span><br><span class="line">    */</span><br><span class="line">    //勾选之后 non-null选项之后提供 equals实现</span><br><span class="line">    /* </span><br><span class="line">        @Override</span><br><span class="line">        public boolean equals(Object o) </span><br><span class="line">        &#123;</span><br><span class="line">            if (this == o) return true;</span><br><span class="line">            if (o == null || getClass() != o.getClass())</span><br><span class="line">            return false;</span><br><span class="line">            Person person = (Person) o;</span><br><span class="line">            if (age != person.age) return false;</span><br><span class="line">            return name.equals(person.name);</span><br><span class="line">        &#125;</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    //没有勾选 non-null选项之后提供 equals实现</span><br><span class="line">    /* </span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) </span><br><span class="line">    &#123;</span><br><span class="line">        //比较了地址，这个地址是真实地址，如果真实地址都相等 必然是同一个对象</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        */</span><br><span class="line">        /*</span><br><span class="line">            如果输入对象引用地址null那么 必然对象不同一个</span><br><span class="line">getClass方法的作用是用过字节码文件[.class]文件进行对象获</span><br><span class="line">取</span><br><span class="line">            只要是同一个类创建对象，他们字节码文件都是同一个【唯一】</span><br><span class="line">            两个对象字节码文件都不一样必然不是同一个对象</span><br><span class="line">        */</span><br><span class="line">        /*</span><br><span class="line">            if (o == null || getClass() != o.getClass())</span><br><span class="line">            return false;</span><br><span class="line">            //多态向下转型操作</span><br><span class="line">            Person person = (Person) o;</span><br><span class="line">        */        </span><br><span class="line">        //如果当前对象age属性与传入对象的age属性不一致 返回false，</span><br><span class="line">如果相等就不做任何操作</span><br><span class="line">        /*</span><br><span class="line">        if (age != person.age) return false;</span><br><span class="line">        */</span><br><span class="line">        /*</span><br><span class="line">        提供引用类型非null判断</span><br><span class="line">		只要当前对象的name属性值不为null 就通过name调用String类</span><br><span class="line">		equals方法</span><br><span class="line">        与传入对象name进行比较 相等为true，不相等为false</span><br><span class="line">        如果对象的name属性为null 就判断传入对象的name属性是否为null</span><br><span class="line">        如果也为null 结果就是true 否则就是false</span><br><span class="line">        */</span><br><span class="line">        /*</span><br><span class="line">        return name != null ? name.equals(person.name) :</span><br><span class="line">        person.name == null;</span><br><span class="line">    &#125; </span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() </span><br><span class="line">    &#123;</span><br><span class="line">        //获取引用类hashcode值作为新的hashcode值计算</span><br><span class="line">        int result = name != null ? name.hashCode() : 0;</span><br><span class="line">        //使用31这个值 乘以 引用类型hashcode值 然后加上 值类型属性值 得到最终hashcode</span><br><span class="line">        //最大的限度保证hashcode不出现重复</span><br><span class="line">        result = 31 * result + age;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    //这个版本IDEA使用Java7中提供Objects工具类</span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) </span><br><span class="line">    &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (o == null || getClass() != o.getClass())</span><br><span class="line">        return false;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        /*</span><br><span class="line">            变化现在使用:值类型比较融入到返回值比较结果中</span><br><span class="line">            调用了Objects工具类中equals方法进行 引用类型比较 --》原码实现</span><br><span class="line">            public static boolean equals(Object a, Object b)</span><br><span class="line">            &#123;</span><br><span class="line">            地址相等就是同一个对象或者判断 a 参数不为null 然后用a调用equals进行比较</span><br><span class="line">            return (a == b) || (a != null &amp;&amp; a.equals(b));</span><br><span class="line">            &#125; </span><br><span class="line">        */</span><br><span class="line">        return age == person.age &amp;&amp;</span><br><span class="line"> Objects.equals(name, person.name);</span><br><span class="line">    &#125; </span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() </span><br><span class="line">    &#123;</span><br><span class="line">        /*</span><br><span class="line">        Objects工具类中提供 hash方法 这个方法可以计算新的hashcode值</span><br><span class="line">        */</span><br><span class="line">        return Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-底层原理">(3)底层原理</h3>
<p>HashSet底层实现原理是HashMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet.add(<span class="number">3</span>);</span><br><span class="line">        hashSet.add(<span class="number">2</span>);</span><br><span class="line">        hashSet.add(<span class="number">1</span>);</span><br><span class="line">        hashSet.add(<span class="number">4</span>);</span><br><span class="line">        hashSet.add(<span class="number">4</span>);</span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//HashSet没有特殊方法，它的方法与Collection中学的方法是一致的</span></span><br><span class="line">        <span class="comment">//Set集合的遍历方式(迭代器)</span></span><br><span class="line">        Iterator&lt;Integer&gt; it = hashSet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//foreach遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Integer integer :</span><br><span class="line">                hashSet)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(integer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//HashSet的底层实现原理：HashSet底层实现原理是HashMap</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十一：LinkedHashSet类</center></h1>
<p>特点：</p>
<ul>
<li>有序</li>
<li>无下标</li>
<li>不可重复</li>
</ul>
<p>与父类的方法(HashSet)一致,去重的原理，也与父类一致</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSetDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 特点：</span></span><br><span class="line"><span class="comment">     *     1、有序（插入顺序）</span></span><br><span class="line"><span class="comment">     *     2、不重复</span></span><br><span class="line"><span class="comment">     *     3、无下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        LinkedHashSet&lt;String&gt; linkedHashSet = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        System.out.println(linkedHashSet);</span><br><span class="line">        <span class="comment">//1、底层实现 (LinkedHashMap)</span></span><br><span class="line">        <span class="comment">//2、去重原理 (与hashSet一致)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十二：Set集合实现类TreeSet</center></h1>
<p>TreeSet是Set集合接口实现类之一，它是一个特殊集合【这个集合不仅可以排重而且可以对存储到集合中的数据提供升序排序】，在以往开发中可以利用TreeSet这个特性对需要排序数据进行操作</p>
<p>PS：从Java8开始List集合专门提供方法sort方法，List集合也可以调用集合提供Sort方法进行对数据排序操作，但是不能排重，所以学习TreeSet的目的为类接触可以排序接口</p>
<p>在API文档中有说明：基于 TreeMap 的 NavigableSet 实现。使用元素的 自然顺序Comparable 对元素进行排序，或者根据创建 set 时提供的 自定义排序Comparator 进行排序，具体取决于使用的构造方法</p>
<p>Set集合系列主要实现都是依赖于Map集合，HashSet底层实现是HashMap，TreeSet底层实现是TreeMap，在Java8之前TreeSet底层实现的结构【二叉树+Hash表】，从Java8开始之后将底层实现的结构【红黑树+Hash表】</p>
<p>TreeSet中的使用API可以完全参考Set集合即可，其余API文档中提供方法自行查看</p>
<p>提供一个基础的TreeSet使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//向TreeSet中存储系统提供数据类型</span></span><br><span class="line">        TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        set.add(<span class="number">100</span>);</span><br><span class="line">        set.add(<span class="number">20</span>);</span><br><span class="line">        set.add(<span class="number">17</span>);</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        set.add(<span class="number">6</span>);</span><br><span class="line">        set.add(<span class="number">88</span>);</span><br><span class="line">        set.add(<span class="number">66</span>);</span><br><span class="line">        set.add(<span class="number">33</span>);</span><br><span class="line">        set.add(<span class="number">77</span>);</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//存储数据中提供两个1进行存储 ---》 自动排重和排序操作【默认是升序】</span></span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向TreeSet中存储自定义类的对象Student，根据学生年龄进行排序操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> height, <span class="type">int</span></span></span><br><span class="line"><span class="params"> weight)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">int</span> height)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">int</span> weight)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">        <span class="string">&quot;, height=&quot;</span> + height +</span><br><span class="line">        <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供TreeSet集合对象用于存储Student类的对象</span></span><br><span class="line">        TreeSet&lt;Student&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">178</span>,<span class="number">100</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>,<span class="number">181</span>,<span class="number">200</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">16</span>,<span class="number">200</span>,<span class="number">10</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;赵六&quot;</span>,<span class="number">19</span>,<span class="number">145</span>,<span class="number">150</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;田七&quot;</span>,<span class="number">21</span>,<span class="number">190</span>,<span class="number">160</span>));</span><br><span class="line">        System.out.println(treeSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题：使用TreeSet存储系统提供数据类型时，可以对数据进行排重与排序操作，但是向TreeSet中添加自定义类对象时，并没有进行排重排序操作，出现了一个异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException:com.qfedu.TreeSet.</span><br><span class="line">    Student cannot be cast tojava.lang.Comparable</span><br></pre></td></tr></table></figure>
<p>问题原因所在：当用TreeSet的无参构造方法时创建Set集合对象，【该 set 根据其元素的自然顺序进行排序。插入该 set 的所有元素都必须实现 Comparable 接口】，刚刚插入到TreeSet集合中Student类的对象并没有实现Comparable接口，所以出现ClassCastException</p>
<h1><center>知识点十三：Comparable接口【自然排序接口】</center></h1>
<p>官方文档说明:此接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 compareTo 方法被称为它的自然比较方法,【间接的说明Comparable接口是一个自然排序接口，对与实现接口类会提供排序操作，这个排序操作需要完成compareTo这个方法】</p>
<p>当前调用TreeSet集合的无参构造方法时，就要求向TreeSet中存储的数据必须实现Comparbale</p>
<p>实现Comparbale接口就需要实现接口中给提供方法</p>
<table>
<thead>
<tr>
<th>int</th>
<th>compareTo(T o) 比较此对象与指定对象的顺序</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>compareTo这个方法使用接口上泛型作为方法参数泛型，所以在实现Comparable的时候需要指定接口中泛型是什么类型，这样可以避免不必要向下转型，泛型T如何赋值，Comparbale提供谁进行比较这个类型就是谁Comparable提供compareTo方法对数据进行比较时遵守的原则 比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。compareTo这个方法的返回值类型时int类型，这个方法返回值是一个数字</td>
</tr>
</tbody>
</table>
<p>PS：compareTo这个方法不建议理解为比较方法，理解为交换方法即通过这个方法的得到返回值决定如何进行数据交换【存储】</p>
<p>之前有接触过一些排序的操作，例如冒泡、选择这些手写排序，但是这些排序中都会有一个必要的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提供比较操作，进行数据交换</span></span><br><span class="line"><span class="keyword">if</span>(arr[i] &gt; arr[i+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[i+<span class="number">1</span>];</span><br><span class="line">    arr[i+<span class="number">1</span>] = tmp;</span><br><span class="line">&#125; </span><br><span class="line">-------------------------------------</span><br><span class="line"><span class="keyword">if</span>(arr[i] &lt; arr[i+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[i+<span class="number">1</span>];</span><br><span class="line">    arr[i+<span class="number">1</span>] = tmp;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//通过修改比较操作中 大于号 或 小于号 可以决定 排序顺序</span></span><br><span class="line"><span class="comment">//那么Comparable接口中compareTo得到的int类型数值就是决定数据如何排序</span></span><br></pre></td></tr></table></figure>
<p>需要对CompareTo方法进行深入的理解【万能公式】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;CompareTo这方法会返回三个值 正整数、 负整数 和 0&quot;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    一般来说自定义类中提供比较属性基本上都是系统类型，就可以通过两个数</span></span><br><span class="line"><span class="comment">据之间记性“差值计算”从而得到 正整数、 负整数 和 0</span></span><br><span class="line"><span class="comment">    Student类为例 需要比较是年龄 --》年龄的属性是 int类型</span></span><br><span class="line"><span class="comment">    用两个int类型进行相减 得到结果就是 正整数、 负整数 和 0 正好满</span></span><br><span class="line"><span class="comment">足了CompareTo方法需求</span></span><br><span class="line"><span class="comment">    谁减谁可以得到什么结果，如果不是基本数据类型时引用类型减也不能计</span></span><br><span class="line"><span class="comment">算？</span></span><br><span class="line"><span class="comment">    不用担心引用类型问题，基本上能用来比较的引用类型都实现了</span></span><br><span class="line"><span class="comment">Comparable，</span></span><br><span class="line"><span class="comment">    所以比较引用类型调用这个引用类型中对应CompareTo方</span></span><br><span class="line"><span class="comment">法就可以</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="string">&quot;需要区分当前对象和传入对象&quot;</span></span><br><span class="line"><span class="string">&quot;调用CompareTo方法的就是当前对象使用【this表示】&quot;</span></span><br><span class="line"><span class="string">&quot;对CmpareTo方法参数赋值的就是传入对象使用【other表示】&quot;</span></span><br><span class="line"><span class="string">&quot;由此就可以得到一个万能公式：</span></span><br><span class="line"><span class="string">&quot;</span>当前对象 - 传入对象 【得到排序结果就是升序】<span class="string">&quot; ---》 正整数</span></span><br><span class="line"><span class="string">&quot;</span>传入对象 - 当前对象 【得到排序结果就是降序】<span class="string">&quot; ---》 负整数</span></span><br><span class="line"><span class="string">&quot;</span>切记：TreeSet的排重机制并不是equals和HashCode，而是实现排序</span><br><span class="line">接口中CompareTo或Compare方法的返回值，只要返回值为<span class="number">0</span>，TreeSet</span><br><span class="line">就会认为是同一个对象，进行排重操作<span class="string">&quot;</span></span><br><span class="line"><span class="string">//当前使用万能公式做计算时，如果遇到得到0时，出现排重效果，建议在得到0时在提供一个排序条件操作，或者使用List中sort方法排序</span></span><br><span class="line"><span class="string">使用这个公式进行排序时会面临到问题：</span></span><br><span class="line"><span class="string">问题1：此时排序数据类型时自定义类Student</span></span><br><span class="line"><span class="string">我们是不能使用 Student - Student 也不可能</span></span><br><span class="line"><span class="string">Student.CompareTo(Student)</span></span><br><span class="line"><span class="string">对自定义对象排序时，排序时*自定义对象的属性*，将当前公式变形为</span></span><br><span class="line"><span class="string">&quot;</span>当前对象.属性 - 传入对象.属性 【得到排序结果就是升序】<span class="string">&quot; ---》正整数</span></span><br><span class="line"><span class="string">&quot;</span>传入对象.属性 - 当前对象.属性 【得到排序结果就是降序】<span class="string">&quot; ---》负整数</span></span><br><span class="line"><span class="string">问题2：此时排序数据类型时系统类型Integer</span></span><br><span class="line"><span class="string">&quot;</span>当前对象 - 传入对象 【得到排序结果就是升序】<span class="string">&quot; ---》 正整数</span></span><br><span class="line"><span class="string">&quot;</span>传入对象 - 当前对象 【得到排序结果就是降序】<span class="string">&quot; ---》 负整数</span></span><br><span class="line"><span class="string">问题3: 如果遇到是引用类型无法使用减号进行计算时</span></span><br><span class="line"><span class="string">&quot;</span>当前对象.compareTo(传入对象) 【得到排序结果就是升序】<span class="string">&quot; ---》正整数</span></span><br><span class="line"><span class="string">&quot;</span>传入对象.compareTo(当前对象) 【得到排序结果就是降序】<span class="string">&quot; ---》负整数</span></span><br></pre></td></tr></table></figure>
<p>修改Student类进行年龄属性排序操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> height, <span class="type">int</span> weight)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125; </span><br><span class="line">    p</span><br><span class="line">ublic <span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">int</span> height)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125; </span><br><span class="line">    p</span><br><span class="line">ublic <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">int</span> weight)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">        <span class="string">&quot;, height=&quot;</span> + height +</span><br><span class="line">        <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student other)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//比较的是student类中age属性值 [升序排序]</span></span><br><span class="line">        <span class="comment">//return this.age - other.age;</span></span><br><span class="line">        <span class="comment">//比较的是student类中age属性值 [降序排序]</span></span><br><span class="line">        <span class="comment">//return other.age - this.age;</span></span><br><span class="line">        <span class="comment">//防止出现比较结果为0的时候怎么办？ ---&gt; 在提供一个比较数据即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age - other.age == <span class="number">0</span> ? <span class="built_in">this</span>.height - other.height : <span class="built_in">this</span>.age - other.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十四：Comparator接口【自定义排序接口】</center></h1>
<p>除了TreeSet集合中可以使用Comparable接口进行自然排序之外，还有一个更加灵活方便的接口Comparator，在系统API文档中说明：强行对某个对象 collection 进行整体排序 的比较函数。可以将Comparator 传递给 sort 方法（如 Collections.sort 或Arrays.sort ），从而允许在排序顺序上实现精确控制。还可以使用Comparator 来控制某些数据结构（如 有序 set 或 有序映射）的顺序，或者为那些没有 自然顺序的对象 collection 提供排序</p>
<p><strong>综上所述：Comparator接口不仅可以对TreeSet提供排序操作，而且可以针对Java系统API提供sort方法进行自定义排序操作</strong></p>
<p>Comparator接口中的核心比较方法</p>
<table>
<thead>
<tr>
<th>int</th>
<th>compare(T o1, T o2) 比较用来排序的两个参数</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>compare这个方法和Comparable接口中compareTo方法是一个道理也是返回 正整数、负整数和0 代表对象 大于 小于和等于</td>
</tr>
</tbody>
</table>
<p>刚刚在Comparable中提供万能公式可以直接使用在Comparator</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">这里是需要注意的是：</span></span><br><span class="line"><span class="string">&quot;</span>Comparator接口中compare方法有两个参数,两个参数谁是当前对象，谁是传入对象<span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span>compare方法中第一个参数 即 o1 就是当前对象即<span class="built_in">this</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span>compare方法中第二个参数 即 o2 就是传入对象即other<span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span>由此就可以得到一个万能公式：</span><br><span class="line"><span class="string">&quot;当前对象 - 传入对象 【得到排序结果就是升序】&quot;</span> ---》 正整数</span><br><span class="line"><span class="string">&quot;传入对象 - 当前对象 【得到排序结果就是降序】&quot;</span> ---》 负整数</span><br><span class="line"><span class="string">&quot;切记：TreeSet的排重机制并不是equals和HashCode，而是实现排序</span></span><br><span class="line"><span class="string">接口中CompareTo或Compare方法的返回值，</span></span><br><span class="line"><span class="string">只要返回值为0，TreeSet就会认为是同一个对象，进行排重操作&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当前使用功能公式做计算时，如果遇到得到0时，出现排重效果，建议在</span></span><br><span class="line">得到<span class="number">0</span>时在提供一个排序条件操作，或者算着List中sort方法排序</span><br><span class="line">使用这个公式进行排序时会面临到问题：</span><br><span class="line">问题<span class="number">1</span>：此时排序数据类型时自定义类Student</span><br><span class="line">我们是不能使用 Student - Student 也不可能</span><br><span class="line"> Student.CompareTo(Student)</span><br><span class="line">对自定义对象排序时，排序时自定义对象的属性，将当前公式变形为</span><br><span class="line"><span class="string">&quot;当前对象.属性 - 传入对象.属性 【得到排序结果就是升序】&quot;</span> ---》正整数</span><br><span class="line"><span class="string">&quot;传入对象.属性 - 当前对象.属性 【得到排序结果就是降序】&quot;</span> ---》负整数</span><br><span class="line">问题<span class="number">2</span>：此时排序数据类型时系统类型Integer</span><br><span class="line"><span class="string">&quot;当前对象 - 传入对象 【得到排序结果就是升序】&quot;</span> ---》 正整数</span><br><span class="line"><span class="string">&quot;传入对象 - 当前对象 【得到排序结果就是降序】&quot;</span> ---》 负整数</span><br><span class="line">问题<span class="number">3</span>: 如果遇到是引用类型无法使用减号进行计算时</span><br><span class="line"><span class="string">&quot;当前对象.compareTo(传入对象) 【得到排序结果就是升序】&quot;</span> ---》正整数</span><br><span class="line"><span class="string">&quot;传入对象.compareTo(当前对象) 【得到排序结果就是降序】&quot;</span> ---》负整数</span><br></pre></td></tr></table></figure>
<p><strong>复制Student类创建Student2来进行Comparator接口操作</strong></p>
<p>Comparator接口对应的是TreeSet中有参构造方法，所以要使用Comparator进行排序就需要使用当前这个有参构造方法【传入实现Comparator接口的实现类对象】方可进行排序操作</p>
<p><strong>提供两种实现Comparator接口的方式</strong>:</p>
<p>    第一种:提供一个比较原则类实现Comparator接口，实现compare方法定义排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student2</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student2</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> height, <span class="type">int</span> weight)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">int</span> height)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125; </span><br><span class="line">    p</span><br><span class="line">ublic <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">int</span> weight)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">        <span class="string">&quot;, height=&quot;</span> + height +</span><br><span class="line">        <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="comment">//提供一个类实现Comparator接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortGZ</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student2&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student2 o1, Student2 o2)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.getAge()-o1.getAge();</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用TreeSet中具备Comparator接口方法,参数赋值就是实现Comparator接口的对象</span></span><br><span class="line">        TreeSet&lt;Student2&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">SortGZ</span>());</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">178</span>,<span class="number">100</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>,<span class="number">181</span>,<span class="number">200</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">16</span>,<span class="number">200</span>,<span class="number">10</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;赵六&quot;</span>,<span class="number">19</span>,<span class="number">145</span>,<span class="number">150</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;田七&quot;</span>,<span class="number">21</span>,<span class="number">190</span>,<span class="number">160</span>));</span><br><span class="line">        treeSet.forEach(System.out::println);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>    第二种方式：就是使用匿名内部类或者lambda表达式实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest3</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用TreeSet中具备Comparator接口方法,参数赋值就是实现</span></span><br><span class="line">        Comparator接口的对象</span><br><span class="line">        <span class="comment">//匿名内部类版本</span></span><br><span class="line">        TreeSet&lt;Student2&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span></span><br><span class="line">        <span class="title class_">Comparator</span>&lt;Student2&gt;() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student2 o1, Student2 o2)</span> </span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">178</span>,<span class="number">100</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>,<span class="number">181</span>,<span class="number">200</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">16</span>,<span class="number">200</span>,<span class="number">10</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;赵六&quot;</span>,<span class="number">19</span>,<span class="number">145</span>,<span class="number">150</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;田七&quot;</span>,<span class="number">21</span>,<span class="number">190</span>,<span class="number">160</span>));</span><br><span class="line">        treeSet.forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Lambda表达式</span></span><br><span class="line">        TreeSet&lt;Student2&gt; treeSet2 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((o1,o2) -&gt; o2.getAge()-o1.getAge());</span><br><span class="line">        treeSet2.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">178</span>,<span class="number">100</span>));</span><br><span class="line">        treeSet2.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>,<span class="number">181</span>,<span class="number">200</span>));</span><br><span class="line">        treeSet2.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">16</span>,<span class="number">200</span>,<span class="number">10</span>));</span><br><span class="line">        treeSet2.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;赵六&quot;</span>,<span class="number">19</span>,<span class="number">145</span>,<span class="number">150</span>));</span><br><span class="line">        treeSet2.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;田七&quot;</span>,<span class="number">21</span>,<span class="number">190</span>,<span class="number">160</span>));</span><br><span class="line">        treeSet2.forEach(System.out::println);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结comparable和comparator接口">总结Comparable和Comparator接口</h2>
<p>    现在Java而言不仅只有TreeSet能排序，List集合也可以排序，Map集合也可以排序，合理规划使用排序即可，Comparable这个接口值专门针对TreeSet集合进行排序而设计一个接口，它的局限性在于它只适合自定义类存储在TreeSet进行使用，其他位置提供Sort方法是不使用Comparable作为参数，Comparator属于自定义排序接口，使用比较广泛，除了在TreeSet中可以使用之外，List集合中提供Sort和JavaAPI中提供其他Sort方法基本上都是使用Comparator参数类型，所以这两个接口建议优先掌握Comparator接口【使用广泛】，其次Comparable</p>
<h1><center>知识点十五：Set集合总结</center></h1>
<p>Set集合是一个接口继承与Collection接口和Iterable接口,Set集合本身具备排重功能和存储无序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Set</span> &lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p>Set集合集合主要的实现类有HashSet、LinkedHashSet和TreeSet，所以Set集合接口是支持多态创建对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">Set&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">Set&lt;Integer&gt; set3 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>Set集合中提供可操作集合都是线程不安全，所以面临多线程处理数据的时候</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.synchronizedSet(Set集合的对象); --》将一个Set集合对象变成线程安全集合</span><br></pre></td></tr></table></figure>
<p>除了这种方式之外可以使用Java5开始提供java.util.concurrent包下提供线程集合完全类来进行操作</p>
<p><strong>HashSet它是Set集合主要实现类，也是实际开发中使用比较广泛的一个类</strong>，这个类的主要实现是Hash表，底层实现是创建一个HashMap对象作为HashSet的具体实现，并且向HashSet存储数据时，其实是向HashMap中key值的位置进行数据存储</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//添加数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashSet的默认容量是16，加载因子是0.75，扩容大小是原有一倍</p>
<p>在Java8之前HashSet底层主要实现是Hash表【数组+链表】形式，从Java8开始对底层存储进行优化，提供存储和查询效果将原有Hash表进行优化【数组+链表或红黑树】，向Hash表中如果存储数据，<strong>某个存储位置中链表长度大达到8的时候【存储了8个数据】，就将链表修改为红黑树，从而提高查询效率</strong></p>
<img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291950536.WebP" alt="红黑树" style="zoom:50%;">
<p>HashSet存储自定义类对象时，如果需要进行排重操作，需要提供equals和hashcode重写</p>
<p>LinkedHashSet是HashSet子类，本身不具备任何特殊方法，所有都是来源于Set接口，唯一特点就是提供一个链表来记录存储顺序，开发中是几乎与不用，它操作可有完全仿照HashSet</p>
<p>TreeSet 是Set集合中一个排序排重的集合，这个集合使用 红黑树+Hash表，当使用TreeSet的无参构造方法创建对象时，向TreeSet集合存数据，这个存储的数据必须实现Comparable接口，也可使用TreeSet的有参构造方法，方法参数是Comparator类型，实现Comparator接口进行存储数据的自定义排序</p>
<p>PS:不是只有TreeSet才可以排序，List和Map集合都可以进行排序操作，但是这个俩个集合都会使用到Comparator</p>
<h1><center>知识点十六：Collection集合</center></h1>
<img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291950700.WebP" alt="Collection集合" style="zoom:50%;">
<p>Collection集合接口是List和Set集合接口父接口，Collection集合接口继承Iterable接口，所以List和Set集合接口都是支持迭代器操作，因为List和Set集合接口都是Collection集合子接口，所以List和Set集合接口的实现了可以作为Collection集合接口的实现类使用，所以支持多态创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Collection集合接口创建对象</span></span><br><span class="line">Collection &lt;Integer&gt; c1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collection &lt;Integer&gt; c2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">Collection &lt;Integer&gt; c3 = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">Collection &lt;Integer&gt; c4 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">Collection &lt;Integer&gt; c5 = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">Collection &lt;Integer&gt; c6 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>因为Collection是集合接口，所以里面的方法都已经讲解完毕</p>
<p>PS：在实际开发中List集合接口中最常用类是ArrayList，Set集合接口中最常用类是HashSet</p>
<h1><center>知识点十七：Collections工具类</center></h1>
<p>将集合中的元素反转</p>
<p>    Collections.reverse(List list)</p>
<p>将集合中的元素随机打乱</p>
<p>    Collections.shuffle(List list)</p>
<p>将集合中的元素排序 （必须要实现Comparable接口）</p>
<p>    Collections.sort(List list)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;大娃&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;二娃&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;妖怪&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;蛇妖&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;蛇妖&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//按照字典顺序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将集合元素进行翻转</span></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将集合中的元素进行随机打乱</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Arrays数组工具类 Collections集合工具类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十七：Map集合</center></h1>
<p><img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291953280.WebP" alt="Map集合"></p>
<h2 id="center-1-map集合介绍-center"><center>1、Map集合介绍</center></h2>
<p>    Map集合是两大集合之一和Collection之间是并存关系，Map不是Collection的子类，Map一般会和List和Set这两个集合并称三大集合【List、Set和Map】，因为Map和Collection并没有什么关系，所以Map集合和Iterable接口也没有任何关系，所以Map集合是不提供迭代器操作</p>
<p>    Map集合在Java提供一种存储数据方式，这种方式称之为“映射”【keyvalue键值对】，通过映射这种关系将将两个数据进行相连形成数据存储形式就是key-value键值对</p>
<p>PS：key和value值不要过分纠结，只要提供Map存储数据数据类型就可以决定key值存储什么value值存储什么，他们在底层存储形式是以一种键值对相连的【情侣】</p>
<p>    映射的说明: 在数学中假设A，B两个非空集合，如果存在一个法则F，使用A集合中每一个元素按照法则F在B集合中有一个唯一对应，则成F为A到B集合映射关系</p>
<p>在做映射关系时：</p>
<p>    提供key值要求是唯一的 ，A集合中相当于存储Key而<strong>Key是唯一</strong>的，所以可以想象存储key的集合其实就是Set集合提供vlaue值是可以不唯一的，B集合相当于存储Value而<strong>value是不唯一的</strong>，所以可以想象存储value的集合其实就是List集合</p>
<p>提供一个链接法则【链接原则】 让A集合key可以和B集合中value进行一个链接形成一个键值对，Map提供存储方式就是这个方法Entry(key-value),Map中存储大量Entry实体存储就是相当与键值对存储了</p>
<img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291954387.WebP" alt="介绍" style="zoom:50%;">
<h2 id="center-2-map集合主要实现类hashmap-center"><center>2、Map集合主要实现类HashMap</center></h2>
<p>HashMap与Map接口之间关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>
<p>    HashMap的主要实现接就是Map，HashMap也是Map接口的最主要实现类HashMap在官方文档中说明：基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外， HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变</p>
<p>    说明：HashMap的主要实现使用Hash表，但是在Java7之前使用的是原始Hash表的形式即【数组+链表】形式存储数据，但是从Java8开始HashMap集合提供Hash表实现从【数组+链表】转换为【数组+链表或红黑树】，当前向HashMap中某个“桶节点【即存储位置】”，添加的数据达到8个时，就会将链表结构转换红黑树，8这个数字在链表中的查询效果是可以控制，因为链表的查询方式是线性查询【从前之后】，所以最快效率是1，最慢效率N，平均值(1+N)/2,随着N值不断变大，这个查询效率会逐渐降低，所以在8节点时将链表转换为红黑树，就是为提高查询效率而是用，红黑树是平衡树，而且树的查询效率是【2倍效率】</p>
<p>HashMap集合是线程不安全集合，在多线程前提现可以使用</p>
<p>Hashtable【之前做法】，现在开发不在使用Hashtable，如何解决线程不安全问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>()); ---&gt; 得到一个线程安全集合或者</span><br><span class="line">                                                    使用线程安全Map集合---》ConcurrentHashMap集合</span><br></pre></td></tr></table></figure>
<p>HashMap是存储key-value键值对形式集合，所以创建HashMap对象时需要提供Key和Value的泛型的数据类型，HashMap毕竟底层是Hash表所以在Java中初始容量16,加载因子0.75，扩容方式是原有容量2倍，并且会重新计算所有存储在HashMap中数据存储位置即从新计算key的存储位置</p>
<p>HashMap在Java8之前和Java8之后API有很大的变化，将Java8之前API看做是基础API，将Java8提供API看做增强操作API即可</p>
<h2 id="center-3-hashmap常用方法-java8之前-center"><center>3、HashMap常用方法(Java8之前)</center></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiConsumer;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供HashMap的对象创建方式</span></span><br><span class="line">        <span class="comment">//1.1创建一个空HashMap集合对象【默认初始容量16，加载因子0.75】 ---&gt; 常用</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//1.2创建一个提供初始容量大小的HashMap集合对象【加载因子0.75】</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">32</span>);</span><br><span class="line">        <span class="comment">//1.3创建一个提供初始容量大小和加载因子的HashMap对象---》提供的容量是16的倍数，加载因子不易过小</span></span><br><span class="line">        HashMap&lt;Character,Double&gt; map3 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt; (<span class="number">32</span>,<span class="number">0.5f</span>);</span><br><span class="line">        <span class="comment">//1.4将参数Map集合对象中存储数据赋值给当前HashMap集合对象进行存储 ---&gt; 偶尔</span></span><br><span class="line">        HashMap&lt;String, Integer&gt; map4 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt; (map);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//提供常用API;</span></span><br><span class="line">        <span class="comment">//1.向HashMap集合对象中添加数据 [第一个参数是存储的key值，第二个参数参数存储是value值]</span></span><br><span class="line">        map.put(<span class="string">&quot;1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(map);<span class="comment">//HashMap已经重写toString方法所以直接打印集合对象查看结果</span></span><br><span class="line">        <span class="comment">//PS：在使用put方法向map集合对象中添加 &quot;1&quot;,2 键值对</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1.向Map集合添加Key-value键值对时 key值必须是唯一的，又使用key = &quot;1&quot; 那么系统并没有</span></span><br><span class="line"><span class="comment">                提示任何语法错误信息和异常信息，是否会出现运行时异常呢？ ---》不会出现异常</span></span><br><span class="line"><span class="comment">            2.put方法的第二个作用：修改指定key对应value值</span></span><br><span class="line"><span class="comment">                当使用put方法提供一个已经在map集合对象中存在key时，将put操作认为是覆盖原有已经存在map集合中key-value</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        map.put(<span class="string">&quot;1&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//putAll(Map集合对象) --&gt; 将参数Map集合对象中存储的数据赋值给Map集合</span></span><br><span class="line">        <span class="comment">// clear() ---&gt; 将Map集合中存储数据清空，map对象的引用是保留</span></span><br><span class="line">        <span class="comment">// isEmpty() ---&gt;判断Map集合中是否有存储数据 存储数据返回false 没有存储返回true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断Map集合中是否存在指定key值 --&gt; 存储返回true 不存在返回false</span></span><br><span class="line">        System.out.println(map.containsKey(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">        <span class="comment">//判断Map集合中是否存在指定value值 --&gt;存储返回true 不存在返回false</span></span><br><span class="line">        System.out.println(map.containsValue(<span class="number">2</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取存储在Map集合value值时 ---》key存在会得到对应value，key不存在会得到null值</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> map.get(<span class="string">&quot;2&quot;</span>);    <span class="comment">//参数：key值</span></span><br><span class="line">        <span class="keyword">if</span>(Objects.nonNull(integer)) <span class="comment">//建议添加非null判断</span></span><br><span class="line">        &#123; </span><br><span class="line">            integer.intValue();</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将存储在Map集合中key-value键值对删除，条件是一个key值</span></span><br><span class="line">        map.remove(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;获取Map集合中存储元素的个数：&quot;</span>+map.size());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Map集合遍历方式比较麻烦，没有迭代器，不支持普通for循环遍历，不支持增强for</span></span><br><span class="line">        <span class="comment">//获取map集合中所有key的值存储在一个Set集合中</span></span><br><span class="line">        Set&lt;String&gt; strings = map.keySet(); <span class="comment">//通过这种方式获取到所有key</span></span><br><span class="line">        <span class="comment">//获取map集合中所有value的值存储在一个Collection集合中</span></span><br><span class="line">        Collection&lt;Integer&gt; values = map.values(); <span class="comment">//通过这种方式获取到所有value值</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Map提供了一种遍历方式entrySet方法 --&gt;返回值是一个Set集合</span></span><br><span class="line"><span class="comment">            Set集合存在一个泛型类型 Map.Entry ---》Set集合中存储的数据类型</span></span><br><span class="line"><span class="comment">            Map.Entry&lt;String,Integer&gt; --&gt; 相当Map.Entry类型中存储数据是 String类型key 和 Integer类型value</span></span><br><span class="line"><span class="comment">            通过entrySet这个方法，返回一个Set集合这个集合存储这个Entry的类型，Entry类型的内部存储的是key-value兼职对</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; map5 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map5.put(<span class="string">&quot;key1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        map5.put(<span class="string">&quot;key2&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        map5.put(<span class="string">&quot;key3&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        map5.put(<span class="string">&quot;key4&quot;</span>,<span class="number">4</span>);</span><br><span class="line">        map5.put(<span class="string">&quot;key5&quot;</span>,<span class="number">5</span>);</span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map5.entrySet();</span><br><span class="line">        System.out.println(entries);</span><br><span class="line">        <span class="comment">//提供Set集合之增强for循环遍历</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : entries)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//entry就得到了存储在Set集合中key-value键值对 即 key1=1</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Key的值是：&quot;</span>+entry.getKey());</span><br><span class="line">            System.out.println(<span class="string">&quot;Value的值是：&quot;</span>+entry.getValue());</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//在Java8中时提供一个foreach方法可以便捷遍历集合中key和value</span></span><br><span class="line">        map5.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;String, Integer&gt;() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * </span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> s map集合中key值</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> integer map集合汇总value</span></span><br><span class="line"><span class="comment">            * 这个方法被出触发时可以获取map集合中每一对：keyvalue</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s, Integer integer)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//这个可以进行操作但是只是打印的结果，不会影响最终map集合中的结果</span></span><br><span class="line">                System.out.println(s);</span><br><span class="line">                System.out.println(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        map5.forEach((k,v)-&gt; System.out.println(k+<span class="string">&quot;=&quot;</span>+v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-4-hashmap常用方法-java8之后-center"><center>4、HashMap常用方法(Java8之后)</center></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 提供HashMap基础API【Java8之后】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapAPIDemo_2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供HashMap的对象创建方式</span></span><br><span class="line">        <span class="comment">//1.1创建一个空HashMap集合对象【默认初始容量16，加载因子0.75】 ---&gt; 常用</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//新Java8中方法</span></span><br><span class="line">        <span class="comment">//1向map集合中添加数据 ---&gt;如果key已经存在则不添加，否则添加数据 【建议向Map集合存储数据使用】</span></span><br><span class="line">        map.putIfAbsent(<span class="string">&quot;1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        map.putIfAbsent(<span class="string">&quot;2&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        map.putIfAbsent(<span class="string">&quot;3&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        map.putIfAbsent(<span class="string">&quot;1&quot;</span>,<span class="number">1000</span>);</span><br><span class="line">        map.putIfAbsent(<span class="string">&quot;1&quot;</span>,<span class="number">10000</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">//2.提供了一个全系列对map集合中k和v进行存储的方法 ---》computeXXX方法</span></span><br><span class="line">        <span class="comment">//2.1 map集合中指定key在map集合进行操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        执行原理:</span></span><br><span class="line"><span class="comment">            无论key是否存在都会执行参数中提供Lambda表达式</span></span><br><span class="line"><span class="comment">            1.如果key值存在，后面提供Lambda表达式就会取出key所对应value并在Lambda表达式中进行操作，然后修改原有k和v值</span></span><br><span class="line"><span class="comment">            2.如果key值不存在，后面提供Lambda表达式就会将key进行存到 map集合操作</span></span><br><span class="line"><span class="comment">                第一个参数就是key值，第二个参数就是提供操作key对应Lambda表达式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        map.compute(<span class="string">&quot;3&quot;</span>,(k,v) -&gt; v == <span class="literal">null</span> ? <span class="number">0</span> : v+<span class="number">1</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        map.compute(<span class="string">&quot;4&quot;</span>,(k,v) -&gt; v == <span class="literal">null</span> ? <span class="number">0</span> : v+<span class="number">1</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">//2.2 判断map集合key是否存在提供对应操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        执行原理：</span></span><br><span class="line"><span class="comment">            1.如果key存在，后面提供Lambda表达式就不会执行，并返回key对应value值</span></span><br><span class="line"><span class="comment">            2.如果key不存储，后面提供Lambda表达式就会执行操作者并将Lambda表达式中处理</span></span><br><span class="line"><span class="comment">            之后value值与key一起存储到map集合中</span></span><br><span class="line"><span class="comment">            PS：Lambda表达式是你如何处理这个value操作 ，你自己决定</span></span><br><span class="line"><span class="comment">            但是一定要返回这个value即添加return</span></span><br><span class="line"><span class="comment">            第一个参数就是key值，第二个参数就是提供操作key对应Lambda表达式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> map.computeIfAbsent(<span class="string">&quot;3&quot;</span>,key -&gt; <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">5</span>));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        map.computeIfAbsent(<span class="string">&quot;5&quot;</span>,key -&gt; <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">5</span>));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">//2.3 判断map集合key是否存在提供对应操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        执行原理：</span></span><br><span class="line"><span class="comment">            1.如果key存在，就执行后lambda表达式，并修改map集合key所对应value值</span></span><br><span class="line"><span class="comment">            2.如果key不存在，就不会执行后面lambda表达式，不会像Map集合中做任何操作，但是方法会返回一个null</span></span><br><span class="line"><span class="comment">            第一个参数就是key值，第二个参数就是提供操作key对应Lambda表达式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        map.computeIfPresent(<span class="string">&quot;3&quot;</span>,(k,v) -&gt; v+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            相当于 你调用map.containsKey() --》 在调用 map.get()--》得到value之后进行操作</span></span><br><span class="line"><span class="comment">            在调用 ---&gt;map.put 这个存储回去</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(map);</span><br><span class="line">        map.computeIfPresent(<span class="string">&quot;6&quot;</span>,(k,v) -&gt; v+<span class="number">1</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            getOrDefault这个方法作用是通过key值获取对应value，这个方法根get方法最大区别在于</span></span><br><span class="line"><span class="comment">            这个方法提供一个默认值，如果key不存在则返回对应默认值， 存在则返回value值</span></span><br><span class="line"><span class="comment">            get方法在则返回value不在则返回null值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//第一个参数是key值 第二个参数是默认值</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">orDefault</span> <span class="operator">=</span> map.getOrDefault(<span class="string">&quot;7&quot;</span>, Integer.MAX_VALUE);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//merge(合并) --》方法含义 对存在在map集合中kv键值对进行更新操作【更新value值】</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一个参数 是map集合存在key值</span></span><br><span class="line"><span class="comment">            第二个参数 这个参数的作用是向Lambda表达式中提供方法参数中</span></span><br><span class="line"><span class="comment">            第二个参数赋值 即 newVal</span></span><br><span class="line"><span class="comment">            第三个参数 需要对存在在集合key所对应value所提供更新数据操作 --》 提供一个lambda</span></span><br><span class="line"><span class="comment">            lambda中第一个参数即oldVal是获取出提供key所对应的value值</span></span><br><span class="line"><span class="comment">            第二个参数即newVal或获取方法中第二个参数值</span></span><br><span class="line"><span class="comment">            提供这两个参数计算更新key所对应value值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        map.merge(<span class="string">&quot;1&quot;</span>,<span class="number">2</span>,(oldVal,newVal)-&gt;oldVal+newVal);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除方法--》根据提供k和v值进行删除，如果存在在map中删除成功返回true，如果不存在删除失败返回false</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">remove</span> <span class="operator">=</span> map.remove(<span class="string">&quot;1&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(remove);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Java8中提供一个操作，官方文档意思在于使用这个方法替代put方法修改操作</span></span><br><span class="line">        <span class="comment">//根据key值替换存储对应value值，如果key存在则替换，不存在则不替换</span></span><br><span class="line">        map.replace(<span class="string">&quot;2&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">// 多参数版本 提供完整key-value键值对，进行替换操作 如果key和value匹配成功存在则替换，不存在则替换</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一个参数是 key值</span></span><br><span class="line"><span class="comment">            第二个参数是 key对应原理的value值</span></span><br><span class="line"><span class="comment">            第三个参数是 新替换value值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        map.replace(<span class="string">&quot;2&quot;</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//只要满足lambda表达式提供替换条件，就会将value值进行替换</span></span><br><span class="line">        map.replaceAll((key,value)-&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供替换操作者条件</span></span><br><span class="line">            <span class="keyword">if</span>(key.length() &gt;= <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//提供替换操作</span></span><br><span class="line">                value = <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//需要将替换的value值提提供return返回</span></span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">// forEach打印方法</span></span><br><span class="line">        map.forEach((k,v)-&gt; System.out.println(k+<span class="string">&quot;=&quot;</span>+v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashMap有一个子类LinkedHashMap这个集合 操作方式和HashMap是一样，只不过就是存储结构有所变化多了一个链表存储，Hashtable已经不在使用了，所以这个API执行查看和HashMap操作一样的</p>
<h2 id="center-5-map集合之treemap集合-center"><center>5、Map集合之TreeMap集合</center></h2>
<p>TreeMap集合是Map集合实现类之一，TreeMap集合提供排序操作，TreeMap集合排序操作和TreeSet道理相同的，需要提供Comparator和Comaprable接口，根据使用TreeMap中构造方法决定说那个那个接口来实现排序操作</p>
<p>在官方的API文档中的介绍：基于红黑树（Red-Black tree）的NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法</p>
<p>TreeMap集合的排序点在于存储的键值key，将要排序数据存储到key中就可以进行排序操作</p>
<p>当调用无参构造方法创建TreeMap对象时，使用Comparable进行的比较操作</p>
<p>TreeMap() 使用键的自然顺序构造一个新的、空的树映射</p>
<p>当调用有参构造方法创建TreeMap对象时，使用Comparator进行的比较操作</p>
<p>TreeMap(Comparator comparator) 构造一个新的、空的树映射，该映射根据给定比较器进行排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMapDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        TreeMap&lt;Integer,String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">10</span>,<span class="string">&quot;value10&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">8</span>,<span class="string">&quot;value8&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">15</span>,<span class="string">&quot;value15&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">7</span>,<span class="string">&quot;value7&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">1</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">9</span>,<span class="string">&quot;value9&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">20</span>,<span class="string">&quot;value20&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">13</span>,<span class="string">&quot;value13&quot;</span>);</span><br><span class="line">        System.out.println(treeMap);</span><br><span class="line">        </span><br><span class="line">        TreeMap&lt;Integer,String&gt; treeMap2 = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt; (<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> </span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">10</span>,<span class="string">&quot;value10&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">8</span>,<span class="string">&quot;value8&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">15</span>,<span class="string">&quot;value15&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">7</span>,<span class="string">&quot;value7&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">1</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">9</span>,<span class="string">&quot;value9&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">20</span>,<span class="string">&quot;value20&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">13</span>,<span class="string">&quot;value13&quot;</span>);</span><br><span class="line">        System.out.println(treeMap2);</span><br><span class="line">        </span><br><span class="line">        TreeMap&lt;Integer,String&gt; treeMap3= <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt; ((o1,o2)-&gt;o2 - o1);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">10</span>,<span class="string">&quot;value10&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">8</span>,<span class="string">&quot;value8&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">15</span>,<span class="string">&quot;value15&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">7</span>,<span class="string">&quot;value7&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">1</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">9</span>,<span class="string">&quot;value9&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">20</span>,<span class="string">&quot;value20&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">13</span>,<span class="string">&quot;value13&quot;</span>);</span><br><span class="line">        System.out.println(treeMap3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TreeMap集合排序的时候也是会对key值进行排重操作，这个排重操作依据是提供Comparable和Comparator接口中方法实现时，如果结果为0，就会进行排重操作</p>
<h2 id="center-6-collections工具类-center"><center>6、Collections工具类</center></h2>
<p>Collections工具类类似于Arrays工具类，Collections工具类是为了给Collection集合提供便捷操作工具类，虽然Collection集合已经提供很多方法了，但是Collections工具类也提供一些操作方法，弥补开发时所需要自行定义方法</p>
<p>Collections工具类提供方法大部分都是给Collection集合使用，极少部分是给Map集合使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsAPIDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.一次性向Collection集合对象中添加多个数据--》【推荐】</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//向集合中存这些数据：【 321,34,3,1,4,4231,4123,353,1】</span></span><br><span class="line">        list.add(<span class="number">321</span>);</span><br><span class="line">        list.add(<span class="number">34</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">4231</span>);</span><br><span class="line">        list.add(<span class="number">4123</span>);</span><br><span class="line">        list.add(<span class="number">353</span>);</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//不用上面这样麻烦操作了,直接使用addAll方法就可以了</span></span><br><span class="line">        <span class="comment">//这个方法的第一个参数是 Collection集合对象， 第二个参数就是要存储值使用【,】分隔即可</span></span><br><span class="line">        Collections.addAll(list,<span class="number">321</span>,<span class="number">34</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">4231</span>,<span class="number">4123</span>,<span class="number">353</span>,<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.提供Collection集合排序操作【针对是List集合】</span></span><br><span class="line">        Collections.sort(list); <span class="comment">//默认是升序排序操作【要去排序数据要么实现Comparable要么实现Comparator】</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//可以使用Collections工具类中提供静态方法进行降序排序【仅针对集合中存储系统引用类型有效】</span></span><br><span class="line">        Collections.sort(list,Collections.reverseOrder());</span><br><span class="line"></span><br><span class="line">        System.out.println(list); <span class="comment">//指针对系统类型</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//自定义排序操作</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> o1 - o2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Collections.sort(list,(o1,o2)-&gt;o2-o1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从Java8开始List集合接口提供sort方法，所以可以直接调用List集合的sort方法进行排序操作</span></span><br><span class="line">        list.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> o1-o2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        list.sort((o1,o2)-&gt;o2-o1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将List、set和Map集合转换为线程安全的集合</span></span><br><span class="line">        List&lt;Integer&gt; lists = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        Set&lt;String&gt; sets = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;());</span><br><span class="line">        Map&lt;String, Integer&gt; maps = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 提供二分查找【要排序数据】 找到 下标 找不到 负数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Collections.binarySearch(list, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//交换List集合存储元素的位置 位置参数是下标</span></span><br><span class="line">        Collections.swap(list,<span class="number">0</span>,list.size()-<span class="number">1</span>);<span class="comment">//第一个元素和最后一个元素互换</span></span><br><span class="line">        <span class="comment">//打乱List集合对象中存储数据的顺序【将有序存储数据打乱存储】</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        <span class="comment">//向List集合中填充同一个数据</span></span><br><span class="line">        Collections.fill(list,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-7-collection集合和map集合的总结-center"><center>7、Collection集合和Map集合的总结</center></h2>
<p>Collection是Java集合框架中根接口也是List和Set集合的父接口，Collection集合接口也继承Iterable接口所有Collection系的集合都支持迭代器进行遍历操作，在Collection集合接口中常用的就是List和Set接口，List和Set接口中常用的实现类集合<strong>ArrayList【允许存储重复数据并且使用数组实现】和HashSet【不允许存储重复数据并且使用Hash表实现】</strong></p>
<p>Map集合本身没是不在Collection范围内容，它是一个独立的集合，Map提供一种【键值对】即key-value的形式进行数据存储操作，在存储数据时要求key值必须是唯一的，value值可以不唯一，<strong>在Map集合接口中主要使用实现类是HashMap</strong></p>
<p><strong>PS：List集合使用ArrayList 、Set集合使用HashSet、Map集合使用HashMap</strong></p>
<h2 id="center-8-hashmap应用-center"><center>8、HashMap应用</center></h2>
<ul>
<li>可以使用Map 表示一个实体类</li>
<li>可以使用List&gt; 表示一个实体类集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapDemo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在java一个用户对象</span></span><br><span class="line"><span class="comment">     *      一个用户对象</span></span><br><span class="line"><span class="comment">     *      public class user</span></span><br><span class="line"><span class="comment">     *      &#123;</span></span><br><span class="line"><span class="comment">     *          private String username;</span></span><br><span class="line"><span class="comment">     *          private String password;</span></span><br><span class="line"><span class="comment">     *          private int age;</span></span><br><span class="line"><span class="comment">     *          private String phone;</span></span><br><span class="line"><span class="comment">     *          private String address;</span></span><br><span class="line"><span class="comment">     *          ......</span></span><br><span class="line"><span class="comment">     *      &#125;</span></span><br><span class="line"><span class="comment">     *      User user = new User(&quot;admin&quot;,&quot;123&quot;,30);</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      多个用户对象</span></span><br><span class="line"><span class="comment">     *      以前：User[]</span></span><br><span class="line"><span class="comment">     *      现在：List&lt;User&gt;</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     * 在实战开发中，如果这个类使用不多，那么这个时候就没有必要创建一个User类</span></span><br><span class="line"><span class="comment">     * 可以使用Map来代替</span></span><br><span class="line"><span class="comment">     *      一个用户对象</span></span><br><span class="line"><span class="comment">     *       HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">     *       map.put(&quot;username&quot;,&quot;admin&quot;);</span></span><br><span class="line"><span class="comment">     *       map.put(&quot;password&quot;,&quot;123&quot;);</span></span><br><span class="line"><span class="comment">     *       map.put(&quot;age&quot;,20);</span></span><br><span class="line"><span class="comment">     *       多个用户对象</span></span><br><span class="line"><span class="comment">     *       List&lt;Map&lt;String,Object&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-9-hashmap底层实现原理-center"><center>9、HashMap底层实现原理</center></h2>
<img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292004683.WebP" alt="实现原理" style="zoom: 50%;">
<h2 id="center-10-put的过程原码-center"><center>10、put的过程原码</center></h2>
<p>put流程</p>
<img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292004096.WebP" alt="put流程" style="zoom:50%;">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//tab表示存放Node节点的数据 p表示当前节点 n表示长度 i表示节点在数组中的下标</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">//判断数组如果为空或者数组长度为0，那么就对数组进行扩容，数组默认初始大小为16</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//将数组的长度-1与hash值进行与运算(计算的结果一定是0~数组长度-1)得到元素应该存放的下标</span></span><br><span class="line">    <span class="comment">//如果当前下标位置为空，那么直接将Node节点存放在当前位置</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//如果当前位置不为空(分为三种情况)</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//情况1：要添加的元素与当前位置上的元素相同(hash(hashCode)、key(equals)一致),则直接替换</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//情况2:如果要添加的元素是红黑树节点，那么将其添加到红黑树上</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//情况3:如果要添加的元素是链表，则需要遍历</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//将当前元素的下一个节点赋给e</span></span><br><span class="line">                <span class="comment">//如果e为空，则创建新的元素节点放在当前位置的下一个元素上，并退出循环</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//如果链表的元素个数大于8个(且当数组中的元素个数大于64)，则将其转换成红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)     <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//要添加的元素与当前位置上的元素相同(hash(hashCode)、key(equals)一致),则直接退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; </span><br><span class="line">          <span class="comment">//如果返回的e不为null</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="literal">null</span>)</span><br><span class="line">          &#123; </span><br><span class="line">              <span class="comment">// existing mapping for key</span></span><br><span class="line">              <span class="comment">//将e的值赋给oldValue</span></span><br><span class="line">              <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                  e.value = value;afterNodeAccess(e);</span><br><span class="line">                  <span class="comment">//返回以前的值(当添加的元素已经存在返回的是以前的值)</span></span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//如果数组的元素个数大于阈值则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-11-resize过程原码-center"><center>11、resize过程原码</center></h2>
<p>扩容流程</p>
<img src= "/img/loading.avif" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292005741.WebP" alt="扩容时机" style="zoom:50%;">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//oldTab 表示原来数组(如果是第二次扩容：长度为16的那个)</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//oldCap 表示原数组的容量(长度)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//oldThr 表示数组原来的阈值 12</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="comment">//newCap 新数组的容量 newThr 新数组的阈值</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">        &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;<span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//新数组的容量扩大一半 newCap 32</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">        <span class="comment">//新阈值扩大老阈值的一半 newThr 24</span></span><br><span class="line">        newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)     <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?(<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//threshold 24</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">//创建一个长度为32的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    <span class="comment">//table指向新数组</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将原数组中的元素拷贝到新数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">//如果当前位置元素不为空</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//情况1：当前位置上的下一个元素为空，则直接将这个元素拷贝到新数组中</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//情况2：当前位置上的元素红黑树类型，则需要进行切割</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">//情况3：当前位置上的元素链表类型，则需要进行分散拷贝</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                             loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-12-get的过程原码-center"><center>12、get的过程原码</center></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e;</span><br><span class="line">    <span class="type">int</span> n;K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;(first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当前first与要找到的hash和key都相等直接返回当前这个first元素</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">            <span class="comment">//如果当前first不为空(有两种情况)</span></span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//当前位置是一个红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//根据hash、key从红黑树上找到对应的元素z</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="comment">//当前位置是一个链表</span></span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//循环进行比较直到找到向的hash和key的元素，并返回</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">     &#125; </span><br><span class="line">    <span class="comment">//如果数组的为空、数组的长度为0、当前下标位置上的值为null,这三种情况都返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十八：常见的集合面试面试题</center></h1>
<ul>
<li>1、简述：ArrayList、LinkedList、Vector的区别</li>
<li>2、简述：HashSet、TreeSet的去重原理</li>
<li>3、ArrayList、LinkedList底层实现</li>
<li>4、HashMap、HashTable的区别</li>
<li>5、HashMap底层实现原理</li>
<li>6、HashMap扩容机制</li>
<li>7、HashMap的数组容量为什么是2的次方数</li>
<li>8、HashMap的负载因子为什么是0.75</li>
<li>9、HashMap添加元素的过程</li>
<li>10、谈谈了解的数据结构</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author_group"><a class="post-copyright__author_img" target="_blank" rel="noopener" href="https://68565200.xyz/about/"><img class="post-copyright__author_img_front" src= "/img/loading.avif" data-lazy-src="https://i.postimg.cc/wjTxDpBF/image.jpg/banner"></a><div class="post-copyright__author_name">星仔极客</div><div class="post-copyright__author_desc">珍惜当下 不负此生</div></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div id="quit-box" onclick="RemoveRewardMask()"></div></div></div><div class="social-share"><a class="social-share-ico icon-qq" target="_blank" rel="noopener" href="https://connect.qq.com/widget/shareqq/index.html?url=https%3A%2F%2Fxinzaigeek.68565200.xyz%2Fpost%2F9e25cba9.html&amp;title=5.%E9%9B%86%E5%90%88&amp;desc=undefined&amp;summary=undefined&amp;site=5.%E9%9B%86%E5%90%88&amp;pics=https%3A%2F%2Fimg.picgo.net%2F2024%2F09%2F23%2F7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" title="分享到QQ"><i class="solitude fab fa-qq"></i></a><div class="social-share-ico icon-link" onclick="utils.copy(&quot;https://xinzaigeek.68565200.xyz/post/9e25cba9.html&quot;)" title="复制文章链接"><i class="solitude fas fa-link"></i></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本文是原创文章，采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>协议，完整转载请注明来自<a href="/">星仔极客</a></span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E8%AF%AD%E8%A8%80/"><span class="tags-punctuation"><i class="solitude fa-solid fa-hashtag"></i>Java语言<span class="tagsPageCount">12</span></span></a></div></div></div><nav class="needEndHide pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/a24af109.html"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">6.异常、File类和递归</div></div></a></div><div class="next-post pull-right"><a href="/post/a920af81.html"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">4.常用工具类</div></div></a></div></nav>
        <div class="relatedPosts">
            <div class="headline">
                <i class="solitude fa-solid fa-star"></i>
                <span>喜欢这篇的人也看了</span>
                <div class="relatedPosts-link">
                    <a onclick="event.preventDefault(); toRandomPost();" href="javascript:void(0);" rel="external nofollow" data-pjax-state="">随便逛逛</a>
                </div>
            </div>
            <div class="relatedPosts-list">
            <div>
                <a href="/post/f1dbdc9f.html" title="25.网络编程">
                    <img class="cover" src= "/img/loading.avif" data-lazy-src="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" alt="cover">
                    <div class="content is-center">
                        <div class="title">25.网络编程</div>
                    </div>
                </a>
            </div>
            <div>
                <a href="/post/5883a4af.html" title="26.反射">
                    <img class="cover" src= "/img/loading.avif" data-lazy-src="https://img.picgo.net/2024/09/23/7a200ebfaa1f89d9e09c4d12880fc543c06c25fc343d4bbf.webp" alt="cover">
                    <div class="content is-center">
                        <div class="title">26.反射</div>
                    </div>
                </a>
            </div>
            </div>
        </div><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="solitude fa-solid fa-comment"></i><span> 评论</span><span class="count"> (<span class="waline-comment-count"><i class="solitude fa-solid fa-spinner fa-spin"></i></span>)</span></div></div><div class="comment-wrap"><div id="waline-wrap"></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><div class="author-info__top-group"><div class="author-info__sayhi" id="author-info__sayhi" onclick="sco.changeSayHelloText()">sayhello.morning</div></div></div><div class="avatar-img-group"><img class="avatar-img" alt="头像" src= "/img/loading.avif" data-lazy-src="https://i.postimg.cc/wjTxDpBF/image.jpg/banner"></div><div class="author-info__description_group"><div class="author-info__description"></div><div class="author-info__description2"></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about/"><div class="author-info__name">星仔极客</div><div class="author-info__desc">珍惜当下 不负此生</div></a><div class="card-info-social-icons is-center"><a class="social-icon" target="_blank" rel="noopener" href="https://juejin.cn/user/745920887002011" title="稀土掘金"><i class="solitude  fas fa-blog"></i></a><a class="social-icon" target="_blank" rel="noopener" href="https://space.bilibili.com/488963146?spm_id_from=333.1007.0.0" title="Bilibili"><i class="solitude  fab fa-bilibili"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="solitude fa-solid fa-bars"></i><span>文章目录</span></div><div class="toc-content" id="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点一：集合框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-%E6%A6%82%E5%BF%B5-center"><span class="toc-text">1、概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-2-%E9%9B%86%E5%90%88%E6%9E%B6%E6%9E%84-center"><span class="toc-text">2、集合架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-3-list%E9%9B%86%E5%90%88-center"><span class="toc-text">3、List集合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点二：List集合之ArrayList集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-%E5%88%86%E6%9E%90arraylist%E7%9A%84%E6%95%88%E7%8E%87-center"><span class="toc-text">1、分析ArrayList的效率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-2-%E8%AF%AD%E6%B3%95-center"><span class="toc-text">2、语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-center"><span class="toc-text">3、常用方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点三：List集合三种遍历方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-%E6%99%AE%E9%80%9Afor%E5%BE%AA%E7%8E%AF-center"><span class="toc-text">普通for循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF-foreach%E5%BE%AA%E7%8E%AF-center"><span class="toc-text">增强for循环【foreach循环】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-foreach%E6%96%B9%E6%B3%95%E9%81%8D%E5%8E%86-center"><span class="toc-text">foreach方法遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点四：ArrayList底层实现原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点五：迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8E%9F%E7%90%86-center"><span class="toc-text">1、迭代器原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-2-%E8%8E%B7%E5%8F%96%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AF%B9%E8%B1%A1-center"><span class="toc-text">2、获取迭代器对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-3-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95-center"><span class="toc-text">3、迭代器的三个方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-4-%E5%BC%BA%E5%8C%96%E8%BF%AD%E4%BB%A3%E5%99%A8-center"><span class="toc-text">4、强化迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-5-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-center"><span class="toc-text">5、迭代器注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点六：List集合之LinkedList集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-%E8%AF%B4%E6%98%8E-center"><span class="toc-text">1、说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-2-%E5%88%86%E6%9E%90linkedlist%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87-center"><span class="toc-text">2、分析LinkedList的执行效率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-center"><span class="toc-text">3、常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-4-linkedlist%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-center"><span class="toc-text">4、LinkedList实现原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点七：List集合总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点八：泛型基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-%E4%BD%9C%E7%94%A8-center"><span class="toc-text">1、作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-text">语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-2-%E5%AE%9A%E4%B9%89-center"><span class="toc-text">2、定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-3-%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%8B%E9%9B%86%E5%90%88-center"><span class="toc-text">3、泛型的使用之集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-4-%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%8B%E6%B3%9B%E5%9E%8B%E7%B1%BB-center"><span class="toc-text">4、泛型的使用之泛型类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-5-%E6%B3%9B%E5%9E%8B%E4%BD%BF%E7%94%A8%E4%B9%8B%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95-center"><span class="toc-text">5、泛型使用之泛型方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-6-%E6%B3%9B%E5%9E%8B%E4%BD%BF%E7%94%A8%E4%B9%8B%E6%8E%A5%E5%8F%A3%E6%B3%9B%E5%9E%8B-center"><span class="toc-text">6、泛型使用之接口泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-7-%E6%B3%9B%E5%9E%8B%E7%9A%84%E9%99%90%E5%AE%9A-center"><span class="toc-text">7、泛型的限定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-8-%E7%89%B9%E7%82%B9-center"><span class="toc-text">8、特点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点九：Set集合的介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点十：Set集合实现类HashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-hash%E8%A1%A8-center"><span class="toc-text">1、Hash表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-2-hashset%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-center"><span class="toc-text">2、HashSet基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AF%AD%E6%B3%95"><span class="toc-text">(1）语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-hashset%E9%9B%86%E5%90%88%E7%9A%84%E6%8E%92%E9%87%8D%E6%93%8D%E4%BD%9C"><span class="toc-text">(2)HashSet集合的排重操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">(3)底层原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点十一：LinkedHashSet类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点十二：Set集合实现类TreeSet</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点十三：Comparable接口【自然排序接口】</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点十四：Comparator接口【自定义排序接口】</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93comparable%E5%92%8Ccomparator%E6%8E%A5%E5%8F%A3"><span class="toc-text">总结Comparable和Comparator接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点十五：Set集合总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点十六：Collection集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点十七：Collections工具类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点十七：Map集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-1-map%E9%9B%86%E5%90%88%E4%BB%8B%E7%BB%8D-center"><span class="toc-text">1、Map集合介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-2-map%E9%9B%86%E5%90%88%E4%B8%BB%E8%A6%81%E5%AE%9E%E7%8E%B0%E7%B1%BBhashmap-center"><span class="toc-text">2、Map集合主要实现类HashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-3-hashmap%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-java8%E4%B9%8B%E5%89%8D-center"><span class="toc-text">3、HashMap常用方法(Java8之前)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-4-hashmap%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-java8%E4%B9%8B%E5%90%8E-center"><span class="toc-text">4、HashMap常用方法(Java8之后)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-5-map%E9%9B%86%E5%90%88%E4%B9%8Btreemap%E9%9B%86%E5%90%88-center"><span class="toc-text">5、Map集合之TreeMap集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-6-collections%E5%B7%A5%E5%85%B7%E7%B1%BB-center"><span class="toc-text">6、Collections工具类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-7-collection%E9%9B%86%E5%90%88%E5%92%8Cmap%E9%9B%86%E5%90%88%E7%9A%84%E6%80%BB%E7%BB%93-center"><span class="toc-text">7、Collection集合和Map集合的总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-8-hashmap%E5%BA%94%E7%94%A8-center"><span class="toc-text">8、HashMap应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-9-hashmap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-center"><span class="toc-text">9、HashMap底层实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-10-put%E7%9A%84%E8%BF%87%E7%A8%8B%E5%8E%9F%E7%A0%81-center"><span class="toc-text">10、put的过程原码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-11-resize%E8%BF%87%E7%A8%8B%E5%8E%9F%E7%A0%81-center"><span class="toc-text">11、resize过程原码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#center-12-get%E7%9A%84%E8%BF%87%E7%A8%8B%E5%8E%9F%E7%A0%81-center"><span class="toc-text">12、get的过程原码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">知识点十八：常见的集合面试面试题</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="solitude fa-solid fa-map"></i><span>最近发布</span></div><div class="aside-list"><a class="aside-list-item" href="/post/a2c247c4.html" title="项目"><div class="thumbnail"><img alt="项目" src= "/img/loading.avif" data-lazy-src="https://img.picgo.net/2024/11/13/c12889d56cf9e0078ed87b335eb8b0b321601f0548e324aa.png"></div><div class="content"><span class="title" href="/post/a2c247c4.html" title="项目">项目</span><span class="article-recent_post_categories" href="/post/a2c247c4.html">鸿蒙next应用开发</span></div></a><a class="aside-list-item" href="/post/d98607ab.html" title="0.ArkTS基础语法"><div class="thumbnail"><img alt="0.ArkTS基础语法" src= "/img/loading.avif" data-lazy-src="https://img.picgo.net/2024/11/13/c12889d56cf9e0078ed87b335eb8b0b321601f0548e324aa.png"></div><div class="content"><span class="title" href="/post/d98607ab.html" title="0.ArkTS基础语法">0.ArkTS基础语法</span><span class="article-recent_post_categories" href="/post/d98607ab.html">鸿蒙next应用开发</span></div></a><a class="aside-list-item" href="/post/de777d6b.html" title="1.界面开发"><div class="thumbnail"><img alt="1.界面开发" src= "/img/loading.avif" data-lazy-src="https://img.picgo.net/2024/11/13/c12889d56cf9e0078ed87b335eb8b0b321601f0548e324aa.png"></div><div class="content"><span class="title" href="/post/de777d6b.html" title="1.界面开发">1.界面开发</span><span class="article-recent_post_categories" href="/post/de777d6b.html">鸿蒙next应用开发</span></div></a><a class="aside-list-item" href="/post/36f99b3f.html" title="2.交互开发"><div class="thumbnail"><img alt="2.交互开发" src= "/img/loading.avif" data-lazy-src="https://img.picgo.net/2024/11/13/c12889d56cf9e0078ed87b335eb8b0b321601f0548e324aa.png"></div><div class="content"><span class="title" href="/post/36f99b3f.html" title="2.交互开发">2.交互开发</span><span class="article-recent_post_categories" href="/post/36f99b3f.html">鸿蒙next应用开发</span></div></a><a class="aside-list-item" href="/post/9d10e9f6.html" title="4.Linux应用编程"><div class="thumbnail"><img alt="4.Linux应用编程" src= "/img/loading.avif" data-lazy-src="https://i.postimg.cc/MKRR79pj/7777777.jpg"></div><div class="content"><span class="title" href="/post/9d10e9f6.html" title="4.Linux应用编程">4.Linux应用编程</span><span class="article-recent_post_categories" href="/post/9d10e9f6.html">Linux</span></div></a></div></div></div></div></main><footer id="footer"><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div class="copyright">© 2023 - 2025 By&nbsp;<a class="footer-bar-link" href="/"><img class="author-avatar" src= "/img/loading.avif" data-lazy-src="https://img.picgo.net/2024/09/24/811513a1eaacadb85ae79568d39c3337b8b87d11b124d4ab.png">星仔极客</a></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/everfu/hexo-theme-solitude" alt="Theme">Theme</a></div></div></div><div class="comment-barrage needEndHide"></div></footer></div><!-- right_menu--><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="solitude fa-solid fa-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="solitude fa-solid fa-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="solitude fa-solid fa-arrows-rotate"></i></div><div class="rightMenu-item" id="menu-top"><i class="solitude fa-solid fa-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="solitude fa-solid fa-clone"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="solitude fa-solid fa-clipboard"></i><span>粘贴文本</span></div><div class="rightMenu-item" id="menu-commenttext"><i class="solitude fa-solid fa-comment-medical"></i><span>引用到评论</span></div><div class="rightMenu-item" id="menu-newwindow"><i class="solitude fa-regular fa-window-maximize"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="solitude fa-solid fa-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="solitude fa-solid fa-clone"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="solitude fa-solid fa-cloud-arrow-down"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-search"><i class="solitude fa-solid fa-magnifying-glass"></i><span>站内搜索</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><div class="rightMenu-item" id="menu-darkmode" onclick="sco.switchDarkMode()"><i class="solitude fa-solid fa-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></div></div></div><div id="rightmenu-mask"></div><!-- inject body--><div><script src="/js/utils.js?v=2.1.15"></script><script src="/js/main.js?v=2.1.15"></script><script src="/js/third_party/waterfall.min.js?v=2.1.15"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/19.1.3/lazyload.iife.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.36/fancybox/fancybox.umd.min.js"></script><script>const coverColorConfig = {
  api: 'https://api.qjqq.cn/api/Imgcolor?img=',
  time: 43200000
}</script><script src="/js/covercolor/api.js?v=2.1.15"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.75.6/instantsearch.production.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/5.18.0/algoliasearch.umd.min.js"></script><script src="/js/right_menu.js?v=2.1.15"></script><div class="js-pjax"><script>(() => {
    let walineInitFunction = window.walineFn || null

    function initWaline(initFn) {
        const walineOptions = {
            el: '#waline-wrap',
            serverURL: 'https://waline.68565200.xyz',
            pageview: true,
            dark: 'html[data-theme="dark"]',
            path: window.location.pathname,
            comment: true,
            ...{"lang":"zh-CN","dark":"auto","requiredMeta":["nick","mail"],"wordLimit":500,"pageSize":10,"commentCount":true}
        }
        const walineInstance = initFn(walineOptions)
        utils.addGlobalFn('pjax', () => walineInstance.destroy(), 'destroyWaline')
        GLOBAL_CONFIG.lightbox && utils.lightbox(document.querySelectorAll('#comment .wl-content img:not(.wl-emoji)'))
        sco.owoBig({
            body: '.wl-emoji-popup',
            item: '.wl-tab-wrapper button'
        })
    }

    async function loadWaline() {
        if (walineInitFunction) initWaline(walineInitFunction)
        else {
            await utils.getCSS('https://cdnjs.cloudflare.com/ajax/libs/waline/3.4.2/waline.min.css')
            const {init} = await import('https://cdnjs.cloudflare.com/ajax/libs/waline/3.4.2/waline.min.js')
            walineInitFunction = init || Waline.init
            initWaline(walineInitFunction)
            window.walineFn = walineInitFunction
        }
        true && barrageWaline()
    }

    if (true || true) {
        if (true) utils.loadComment(document.getElementById('waline-wrap'), loadWaline)
        else loadWaline()
    } else window.loadTwoComment = loadWaline
})()
</script><script>async function barrageWaline() {
    const url = new URL('https://waline.68565200.xyz/api/comment')
    const params = {path: window.location.pathname, sortBy: 'insertedAt_asc'}
    Object.entries(params).forEach(([key, value]) => url.searchParams.append(key, value))
    await fetch(url).then(async res => {
        if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`)
        const data = await res.json();
        const regex = /<img [^>]*class="wl-emoji"[^>]*>/;
        const init = () => {
            initializeCommentBarrage(data.data.data
                .map(item => ({
                    nick: item.nick,
                    mailId: item.avatar,
                    content: item.comment.replace(regex, ''),
                    id: item.objectId
                })))
        }
        if (typeof initializeCommentBarrage === "undefined") await utils.getScript('/js/third_party/barrage.min.js?v=2.1.15').then(init)
        else init()
    }).catch(error => console.error("An error occurred while fetching comments: ", error))
}</script></div></div><!-- pjax--><script>const pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: ["title","#body-wrap","#site-config","meta[name=\"description\"]",".js-pjax","meta[property^=\"og:\"]","#config-diff",".rs_show",".rs_hide"],
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
})

document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
})

document.addEventListener('pjax:complete', () => {
    window.refreshFn()

    document.querySelectorAll('script[data-pjax]').forEach(item => {
        const newScript = document.createElement('script')
        const content = item.text || item.textContent || item.innerHTML || ""
        Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
        newScript.appendChild(document.createTextNode(content))
        item.parentNode.replaceChild(newScript, item)
    })

    GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

})

document.addEventListener('pjax:error', (e) => {
    if (e.request.status === 404) {
        pjax.loadUrl('/404.html')
    }
})</script><!-- google adsense--><!-- search--><div id="algolia-search"><div class="search-dialog"><div class="algolia-navbar"><div class="search-dialog__title" id="algolia-search-title">搜索</div><div class="algolia-tips"><i class="solitude fab fa-algolia"></i><span class="algolia-tips-text">Algolia</span></div><span class="search-close-button"><i class="solitude fa-solid fa-xmark"></i></span></div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><div id="search-results"><div id="algolia-hits"></div></div><div id="algolia-tips"><div id="algolia-pagination"></div><div id="algolia-stats"></div></div></div><div id="search-mask"></div></div><script src="/js/search/algolia.js?v=2.1.15"></script><!-- Tianli-Talk--><!-- music--></body></html>
        <script>
            const posts = ["post/a2c247c4.html","post/d98607ab.html","post/de777d6b.html","post/36f99b3f.html","post/9d10e9f6.html","post/55a07e0f.html","post/f705831.html","post/68ec1b16.html","post/c24675b4.html","post/4e3021ff.html","post/dd99ee0d.html","post/69f8b9de.html","post/ff4327d1.html","post/fd908b52.html","post/288a7e13.html","post/bcf1b676.html","post/de55e8eb.html","post/e5f15f94.html","post/49f85af0.html","post/e9f3074a.html","post/a1db912f.html","post/54659a9b.html","post/8a87b27f.html","post/96c26968.html","post/520176db.html","post/99cd7d8.html","post/adb202b7.html","post/eb0bc4a3.html","post/2c4c3bc3.html","post/f71d0ad2.html","post/6928cd3f.html","post/bfd038f5.html","post/f5fba2c3.html","post/e8bc8f26.html","post/f0812160.html","post/52772f76.html","post/acb77072.html","post/bd740709.html","post/c4236caa.html","post/63d3dd68.html","post/32e9e993.html","post/c6b2a2fd.html","post/74750b31.html","post/81b224e1.html","post/2e5216dd.html","post/f736596e.html","post/f5fba2c3.html","post/8212ff63.html","post/93c966f3.html","post/def84ee6.html","post/1f293ccb.html","post/79959306.html","post/5f6e69ef.html","post/2ec6e870.html","post/f1dbdc9f.html","post/5883a4af.html","post/fbc0ae86.html","post/3e1167ea.html","post/8f9052f9.html","post/a24af109.html","post/9e25cba9.html","post/a920af81.html","post/fe7ab1f0.html","post/76fa8c0d.html","post/fbc82303.html","post/ca0fcd03.html","post/6ac19130.html","post/6f76074c.html","post/cb87841d.html","post/6271a51c.html","post/7422213c.html","post/3b48d11a.html","post/df718222.html","post/804ae251.html","post/b70ae4e7.html","post/3ec1fd44.html","post/bec635c1.html","post/5bdb5548.html","post/9b06d854.html","post/e2246be5.html"];
            function toRandomPost() {
                const randomPost = posts[Math.floor(Math.random() * posts.length)];
                pjax.loadUrl(GLOBAL_CONFIG.root + randomPost);
            }
        </script>