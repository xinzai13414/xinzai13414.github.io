<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>23.IO流 | 星仔人生录</title><noscript>开启JavaScript才能访问本站哦~</noscript><link rel="icon" href="/img/pwa/favicon.ico"><!-- index.css--><link rel="stylesheet" href="/css/index.css?v=2.0.9"><!-- inject head--><link rel="canonical" href="http://example.com/post/3e1167ea.html"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css"><!-- aplayer--><!-- swiper--><!-- fancybox ui--><!-- katex--><!-- Open Graph--><meta name="description" content="知识点一：概念PS：IO很简单主要记忆的就是IO中进行文件读写操作 Java中IO流的作用：IO流在Java中作用就是将内存中数据写入到磁盘进行保存，程序运行时将磁盘中的数据读取到内存中进行处理 在Java中在没有学习到IO流之前，在程序中所有处理数据都是在内存中进行存储的【栈和堆】，在内存中存储的"><!-- pwa--><meta name="apple-mobile-web-app-capable" content="星仔人生录"><meta name="theme-color" content="var(--efu-main)"><meta name="apple-mobile-web-app-status-bar-style" content="var(--efu-main)"><link rel="bookmark" href="/img/pwa/favicon.ico"><link rel="apple-touch-icon" href="/img/pwa/favicon.ico" sizes="180x180"><script>console.log(' %c Solitude %c ' + '2.0.9' + ' %c https://github.com/everfu/hexo-theme-solitude',
    'background:#35495e ; padding: 1px; border-radius: 3px 0 0 3px;  color: #fff',
    'background:#ff9a9a ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff',
    'background:unset ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff')
</script><script>(()=>{
        const saveToLocal = {
            set: function setWithExpiry(key, value, ttl) {
                if (ttl === 0)
                    return
                const now = new Date()
                const expiryDay = ttl * 86400000
                const item = {
                    value: value,
                    expiry: now.getTime() + expiryDay
                }
                localStorage.setItem(key, JSON.stringify(item))
            },
            get: function getWithExpiry(key) {
                const itemStr = localStorage.getItem(key)
    
                if (!itemStr) {
                    return undefined
                }
                const item = JSON.parse(itemStr)
                const now = new Date()
    
                if (now.getTime() > item.expiry) {
                    localStorage.removeItem(key)
                    return undefined
                }
                return item.value
            }
        };
        window.utils = {
            saveToLocal: saveToLocal,
            getCSS: (url, id = false) => new Promise((resolve, reject) => {
              const link = document.createElement('link')
              link.rel = 'stylesheet'
              link.href = url
              if (id) link.id = id
              link.onerror = reject
              link.onload = link.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                link.onload = link.onreadystatechange = null
                resolve()
              }
              document.head.appendChild(link)
            }),
            getScript: (url, attr = {}) => new Promise((resolve, reject) => {
              const script = document.createElement('script')
              script.src = url
              script.async = true
              script.onerror = reject
              script.onload = script.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                script.onload = script.onreadystatechange = null
                resolve()
              }
    
              Object.keys(attr).forEach(key => {
                script.setAttribute(key, attr[key])
              })
    
              document.head.appendChild(script)
            }),
            addGlobalFn: (key, fn, name = false, parent = window) => {
                const globalFn = parent.globalFn || {}
                const keyObj = globalFn[key] || {}
        
                if (name && keyObj[name]) return
        
                name = name || Object.keys(keyObj).length
                keyObj[name] = fn
                globalFn[key] = keyObj
                parent.globalFn = globalFn
            },
        }
    })()</script><!-- global head--><script>const GLOBAL_CONFIG = {
    root: '/',
    algolia: undefined,
    localsearch: undefined,
    runtime: '2023-04-20 00:00:00',
    lazyload: {
        enable: false,
        error: '/img/error_load.avif'
    },
    copyright: false,
    highlight: {"limit":200,"expand":true,"copy":true,"syntax":"highlight.js"},
    randomlink: false,
    lang: {"theme":{"dark":"已切换至深色模式","light":"已切换至浅色模式"},"copy":{"success":"复制成功","error":"复制失败"},"backtop":"返回顶部","time":{"day":"天前","hour":"小时前","just":"刚刚","min":"分钟前","month":"个月前"},"day":" 天","f12":"开发者模式已打开，请遵循GPL协议。","totalk":"无需删除空行，直接输入评论即可"},
    aside: {
        sayhello: {
            morning: "✨ Good morning. It's a new day",
            noon: "It's time for a midday break",
            afternoon: "Tea time. 🍵",
            night: "early bedtime",
            goodnight: "Good night 😴",
        },
        sayhello2: [],
        sayhello3: {
            prefix: '好久不见，',
            back: '欢迎再次回来，',
        },
    },
    covercolor: {
        enable: false
    },
    comment: false,
    lightbox: 'null',
    post_ai: false,
    right_menu: false,
    lure: false,
    expire: false,
};</script><!-- page-config head--><script id="config-diff">var PAGE_CONFIG = {
    is_post: true,
    is_page: false,
    is_home: false,
    page: '',
    toc: true,
    comment: false,
    ai_text: false
}</script><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="星仔人生录" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body id="body"><!-- universe--><!-- background img--><!-- loading--><!-- console--><!-- sidebar--><div id="sidebar" style="zoom: 1;"><div id="menu-mask" style="display: none;"></div><div id="sidebar-menus"><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">95</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a></div></div></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><span class="darkmode_switchbutton menu-child" onclick="sco.switchDarkMode()"><i class="solitude fa-solid fa-circle-half-stroke"></i><span>显示模式</span></span></div><span class="sidebar-menu-item-title">标签</span><div class="card-widget card-tags card-archives card-webinfo card-allinfo"><div class="card-tag-cloud"><a href="/tags/32%E5%8D%95%E7%89%87%E6%9C%BA/">32单片机<sup>12</sup></a><a href="/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/">51单片机<sup>9</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/">C语言<sup>13</sup></a><a href="/tags/Java%E8%AF%AD%E8%A8%80/">Java语言<sup>26</sup></a><a href="/tags/office%E6%97%A0%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96VisualBasic/">office无法初始化VisualBasic<sup>1</sup></a><a href="/tags/%E4%BA%91%E5%9B%BE%E5%BA%8A/">云图床<sup>1</sup></a><a href="/tags/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/">图片压缩在线工具<sup>1</sup></a><a href="/tags/%E8%A7%A3%E5%86%B3443%E7%AB%AF%E5%8F%A3%E8%A2%ABvmware%E5%8D%A0%E7%94%A8/">解决443端口被vmware占用<sup>1</sup></a><a href="/tags/win10%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87%E5%8F%98%E7%99%BD/">win10桌面图标变白<sup>1</sup></a><a href="/tags/%E6%8F%92%E4%BB%B6/">插件<sup>1</sup></a><a href="/tags/GitHub-Picgo%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/">GitHub+Picgo图片上传<sup>1</sup></a><a href="/tags/ST-LINK%E6%9C%AA%E8%83%BD%E4%B8%B2%E5%8F%A3keil%E8%AF%86%E5%88%AB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">ST-LINK未能串口keil识别解决方案<sup>1</sup></a><a href="/tags/GitHub%E5%90%8C%E6%AD%A5gitee%E5%B9%B6%E9%83%A8%E7%BD%B2/">GitHub同步gitee并部署<sup>1</sup></a><a href="/tags/STM32CubeIDE%E4%BB%A3%E7%A0%81%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F/">STM32CubeIDE代码字体大小<sup>1</sup></a><a href="/tags/IDE%E4%B8%8EMX%E5%BA%93%E6%96%87%E4%BB%B6%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AE%BE%E7%BD%AE/">IDE与MX库文件安装路径自定义设置<sup>1</sup></a><a href="/tags/%E5%8A%A0%E9%80%9Fgithub%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE/">加速github博客访问<sup>1</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/">博客使用手册<sup>1</sup></a><a href="/tags/%E5%B0%8F%E7%8B%BC%E6%AF%AB%E8%BE%93%E5%85%A5%E6%B3%95/">小狼毫输入法<sup>1</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2%E5%8A%A0%E9%80%9F%E5%9B%BE%E5%BA%8A/">博客加速图床<sup>1</sup></a><a href="/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">个人博客迁移<sup>1</sup></a><a href="/tags/%E8%B5%84%E6%BA%90%E6%90%9C%E7%B4%A2/">资源搜索<sup>1</sup></a><a href="/tags/%E9%AD%94%E6%B3%95/">魔法<sup>1</sup></a><a href="/tags/%E6%94%BF%E6%B2%BB/">政治<sup>14</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E7%A1%80/">计算机程序与基础<sup>1</sup></a></div></div></div></div><!-- keyboard--><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav class="show" id="nav"><div id="nav-group"><div id="blog_name"><a id="site-name" href="/" title="返回博客主页"><span class="title">Solitude</span><i class="solitude fa-solid fa-home"></i></a></div><div id="page-name-mask"><div id="page-name"><a id="page-name-text" onclick="sco.toTop()">23.IO流</a></div></div><div id="menus"></div><div id="nav-left"></div><div id="nav-right"><div class="nav-button" id="nav-totop" onclick="sco.toTop()"><a class="totopbtn"><i class="solitude fa-solid fa-arrow-up"></i><span id="percent">0</span></a></div><div id="toggle-menu"><a class="site-page"><i class="solitude fa-solid fa-bars"></i></a></div></div></div></nav><div class="coverdiv" id="coverdiv"><img class="nolazyload" id="post-cover" src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292029940.WebP" alt="23.IO流"></div><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original" title="该文章为原创文章，注意版权协议">原创</a><span class="post-meta-categories"><a class="post-meta-categories" href="/categories/Java%E8%AF%AD%E8%A8%80/">Java语言</a></span><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E8%AF%AD%E8%A8%80/"><span class="tags-name tags-punctuation"><i class="solitude fa-solid fa-hashtag"></i>Java语言</span></a></div></div></div></div><h1 class="post-title">23.IO流</h1><div id="post-meta"><div class="meta-secondline"></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="知识点一：概念"><a href="#知识点一：概念" class="headerlink" title="知识点一：概念"></a><center>知识点一：概念</center></h1><p><strong>PS：IO很简单主要记忆的就是IO中进行文件读写操作</strong></p>
<p>Java中IO流的作用：IO流在Java中作用就是将内存中数据写入到磁盘进行保存，程序运行时将磁盘中的数据读取到内存中进行处理</p>
<p>在Java中在没有学习到IO流之前，在程序中所有处理数据都是在内存中进行存储的【栈和堆】，在内存中存储的好处在于【执行效率高】坏处【数据无法持久存储】</p>
<p>内存中存储体现在于【DVD操作系统】：所有数据使用集合存储之后依旧是在内存中进行存储，每次执行程序时，都会在内存从新初始化集合中数据，这样就造成无论你如何修改集合中数据，只要程序重新运行数据使用保持原始状态</p>
<p>所以需要将内存中数据保存到磁盘中进行持久保存【将内存中数据写成文件中内容进行保存操作】，如果将内存中数据写到磁盘中，就需要使用到IO流【使用输出流】，数据存存储在磁盘文件之后，程序运行时需要加载磁盘中文件数据【将磁盘文件中内容读取到内存中进行处理】，如果需要将磁盘中文件内读取到内存中，就需要使用到IO流【使用输入流】</p>
<p>什么是IO流？</p>
<p>I —》 顾名思义 —》IN(读取、输入、读入) –》将磁盘中文件内容读取到内存中</p>
<p>O—》 顾名思义 –》OUT(输出、写出、写入) —》将内存中数据写入到磁盘文件中</p>
<p><strong>IO流就是内存与磁盘【存储设备】之间数据传输通道</strong></p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011942738.WebP" alt="传输过程" style="zoom:33%;">

<p>在程序中所有的数据都是以流的方式进行传输与保存，程序需要数据时使用输入流读取数据，当程序需要保存数据时使用输出流保存数据</p>
<p>除了对数据保存之外，实际在网页中的文件上传与下载操作就是IO流完成</p>
<p><strong>PS：IO操作属于“长连接”，需要管理这个连接操作，如果不管理这个连接操作，会造成IO流操作会持续在内存中存在，会造成内存浪费，所以在不使用IO操作下，一定要关闭IO流</strong></p>
<h1 id="知识点二：Java中提供常用IO流"><a href="#知识点二：Java中提供常用IO流" class="headerlink" title="知识点二：Java中提供常用IO流"></a><center>知识点二：Java中提供常用IO流</center></h1><p>IO流其实就是建立起内存与硬盘【存设备】之间数据传输通道，通过这个通道可以将数据进行读取与写入操作，这个就是IO流本质</p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011943586.WebP" alt="输入输出关系" style="zoom:50%;">

<p>可以根据IO流进行简单的分类</p>
<p>根据流的流向：</p>
<p>&ensp;&ensp;&ensp;&ensp;输入流： 把存储在磁盘中数据读取到内存中</p>
<p>&ensp;&ensp;&ensp;&ensp;输出流 : 把内存中数据写入到磁盘中</p>
<p>根据流中数据：</p>
<p>&ensp;&ensp;&ensp;&ensp;字节流： 无论是输入还是输出流中数据都是byte类型</p>
<p>&ensp;&ensp;&ensp;&ensp;字符流： 无论是输入还是输出流中数据都是char类型</p>
<h1 id="知识点三：字节输入输出流"><a href="#知识点三：字节输入输出流" class="headerlink" title="知识点三：字节输入输出流"></a><center>知识点三：字节输入输出流</center></h1><p>这个流中数据类型就是byte，这个流既可以进行输入操作【读取】，也可以进行输出操作【写出】</p>
<h2 id="1、InputStream【字节输入流】"><a href="#1、InputStream【字节输入流】" class="headerlink" title="1、InputStream【字节输入流】"></a><center>1、InputStream【字节输入流】</center></h2><p>InputStream流是所有字节输入流的父类，所有字节输入流都要直接或间接继承InputStream</p>
<p>这个流是一个抽象类不能直接创建对象，所以需要使用到这个流的子类来完成对字节输入流操作</p>
<p>在API文档中提供创建语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InputStream</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span></span><br></pre></td></tr></table></figure>

<p>在API文档中已知实现之类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AudioInputStream, ByteArrayInputStream,<span class="string">&quot;FileInputStream&quot;</span>, FilterInputStream, InputStream,</span><br><span class="line">ObjectInputStream, PipedInputStream,SequenceInputStream, StringBufferInputStream</span><br></pre></td></tr></table></figure>

<p>这里多子类中，使用那个之类来操作呢？学习流目的在于什么？–》将内存数据写出到磁盘中【持久保存】，程序需要使用时将磁盘中文件存储内容读取到内存中，整个操作过程中都需要使用磁盘文件，所以就需要操作一个处理文件的流来进行操作 –》需要使用其之类FileInputStream</p>
<h2 id="2、FileInputSteam【文件字节输入流】"><a href="#2、FileInputSteam【文件字节输入流】" class="headerlink" title="2、FileInputSteam【文件字节输入流】"></a><center>2、FileInputSteam【文件字节输入流】</center></h2><p>FileInputStream是InputStream字节入的子类，这个流主要提供是对文件读取操作，这个文件是泛指【指代的是：所有文档二进制文件（文本文件、音频、视频、压缩包、图片等等）】，都可以通过</p>
<p>FileInputStream进行读取操作，FileInputSteam是字节输入流所以流中数据是【<strong>byte类型</strong>】</p>
<p>在API文档中提供创建定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span></span><br></pre></td></tr></table></figure>

<p>PS：Java中提供原生流【系统API中定义好流】只能对文本文件中内容进行操作即【txt】文件，无法对Office文件记性操作，如果需要对这些文件进行操作需要导入【第三方jar包（别人封装好实现）】</p>
<h3 id="（1）核心构造方法"><a href="#（1）核心构造方法" class="headerlink" title="（1）核心构造方法"></a>（1）核心构造方法</h3><table>
<thead>
<tr>
<th align="center">构造方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FileInputStream(File file) 通过一个File对象创建FileInputStream字节输入流对象</td>
</tr>
<tr>
<td align="center">FileInputStream(String name) 通过一个String对象(文件的路径)创建FileInputStream字节输入流对象</td>
</tr>
</tbody></table>
<p>PS：这两个构造方法创建出对象方式是一样的，只是参数不一样，个人选取</p>
<h3 id="（2）核心API方法"><a href="#（2）核心API方法" class="headerlink" title="（2）核心API方法"></a>（2）核心API方法</h3><table>
<thead>
<tr>
<th align="center">返回值类型</th>
<th align="center">方法说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int</td>
<td align="center">read() 一次读取一个字节的数据</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">read(byte[] bs) 一次读取参数字节数组长度的数据并存储在字节数组中[常用]</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">read(byte[] bs, int off, int len) 一次读取字节数组长度的数据,根据len读取实际内容长度,并从off位置开始入写到字节数组中</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">close() IO流式一个长连接,所以需要需要关闭流对象【常用】</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamAPIDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//文件字节输入流操作</span></span><br><span class="line">        <span class="comment">//1.提供文件字节输入流对象创建</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这个构造方法中一共提供两种参数</span></span><br><span class="line"><span class="comment">            第一种传入File --&gt;FileInputStream fis = new FileInputStream(new File(&quot;绝对或相对文件路径&quot;));</span></span><br><span class="line"><span class="comment">            第二种传入String类型参数 --》 String类型赋值时一个路径</span></span><br><span class="line"><span class="comment">            	FileInputStream fis = new FileInputStream(&quot;绝对或相对文件路径&quot;);</span></span><br><span class="line"><span class="comment">            在创建文件字节输入流对象同时需要处理创建对象时提供 编译时异常</span></span><br><span class="line"><span class="comment">                         	Unhandled exception:java.io.FileNotFoundException</span></span><br><span class="line"><span class="comment">            今天---》使用try-catch进行处理 ---》 特殊用途</span></span><br><span class="line"><span class="comment">            明天---》 throws处理 --》 开发通用</span></span><br><span class="line"><span class="comment">            后续流开发如果出现异常行，自行选择处理方式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//先声明流资源对象赋值为null值</span></span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//IO流的链接是长链接，所以在不使用IO流前提下要进行关闭操作</span></span><br><span class="line">            <span class="comment">//在try代码块进行流对象具体赋值操作</span></span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/file1.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//读取文件中数据的read方法都有编译时异常Unhandled exception: java.io.IOException</span></span><br><span class="line">            <span class="comment">//1. 一次读取一个字节的内容--》几乎与不使用</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> fis.read();    <span class="comment">//返回文件内容中对应的ASCII，所以要看到读取内容效果需要强制类型转换</span></span><br><span class="line">            System.out.println(<span class="string">&quot;一次读取一个字节的内容是:&quot;</span>+ ((<span class="type">char</span>)read));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//2. 一次读取参数中字节数组长度内容，并且将内容存存储到字节数组中 --》【常用】</span></span><br><span class="line">            <span class="comment">//2.1 需要提供一个字节数组</span></span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="comment">//2.2通过字节输入流对象调用read方法参数是字节数组</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                千万不要理解为:通过fis流对象读取字节数组bs中内容【错误理解】</span></span><br><span class="line"><span class="comment">                真正含义:通过fis流对象读取文件中内容，读取文件中内容是参数bs数组长度，并且将读取到内容存储到bs数组中</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            fis.read(bs);</span><br><span class="line">            <span class="comment">//因为byte类型数组，存储都是整数，所以存储都是文件内容中字符对应十进制形式</span></span><br><span class="line">            System.out.println(Arrays.toString(bs)); <span class="comment">//相当于查看字节数内容，但是不是具体文件中内容</span></span><br><span class="line">            <span class="comment">//利用String这个类构造方法将字节数组转换成字符串查看内容</span></span><br><span class="line">            System.out.println(<span class="string">&quot;读取文件中内容是：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(bs));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//3.一次读取参数中字节数组长度内容并且存储在字节数组中，根据off参数指定下标为开始写入数据，</span></span><br><span class="line">            <span class="comment">// 再根据len参数为基础进行实际读取内容长度作为写入数组中内容长度</span></span><br><span class="line">            <span class="comment">//3.1提供一个byte类型数组</span></span><br><span class="line">            <span class="type">byte</span>[] bs2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line">            <span class="comment">//3.2在通过文件字节输入流对象调用read方法进行读取</span></span><br><span class="line">            fis.read(bs2,<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">            System.out.println(Arrays.toString(bs2));</span><br><span class="line">            System.out.println(<span class="string">&quot;读取文件中内容是:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(bs2));</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (Exception e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//无论try代码块是否出现异常，finally语句代码块都会执行，多用于资源释放 ---》 管理流就是资源释放</span></span><br><span class="line">            <span class="comment">//因为是在try外界创建对象赋值为null，如果赋值成功会存在堆中地址，这样才有关闭价值</span></span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(fis))    <span class="comment">//判断数据是否为null</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//释放流资源--》关闭流 --&gt;close方法也有一个编译时异常Unhandled exception: java.io.IOException</span></span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题：如果使用FileInputStream文件字节输入流读取一个文件，这个文件大小未知（文件存储内容不确定），使用刚刚讲解API中 read(byte[]bs) 进行文件内容读取，此时提供byte数组应该多大？，如何获取到文件中所有内容？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamLoopReadFile</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供文件字节输入流对象【因为InputStream是</span></span><br><span class="line">        FileInputStream父类，所以可以利用多态创建】</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/FileInputStreamAPIDemo.java&quot;</span>));</span><br><span class="line">            <span class="comment">//提供字节数组 ---》 1024 --&gt;给读取文件数组中大小即 1024</span></span><br><span class="line">            <span class="comment">//在开发中如果使用流进行操作，提供byte类型数组或char类型数组使用初始化大小默认给1024</span></span><br><span class="line">            <span class="comment">//如果1024并不能满足你读取文件内容需求，建议倍数递增</span></span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//因为给定初始容量1024，但是不能完全读取文件中所有内容</span></span><br><span class="line">            <span class="comment">//is.read(bs);</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                只需要让读取文件中内容操作重复执行就行--》提供循环让is.read可以去重复去读文件内容</span></span><br><span class="line"><span class="comment">                提供死循环确实可以让读取操作重复执行，但是需要提供读取文件停止方式，不然话程序执行是不合理</span></span><br><span class="line"><span class="comment">                只需要知道是否读取到文件的末尾，就可以停止循环操作了，如何得到读取到文件末尾的操作？</span></span><br><span class="line"><span class="comment">                read 方法在读取文件数据时，如果读取到文件的末尾返回-1作为提示</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">                //提供一个变量len 存储read读取到长度</span></span><br><span class="line"><span class="comment">                int len = 0;</span></span><br><span class="line"><span class="comment">                while(true)</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    len = is.read(bs);</span></span><br><span class="line"><span class="comment">                    if(len == -1)</span></span><br><span class="line"><span class="comment">                    &#123;</span></span><br><span class="line"><span class="comment">                        break;</span></span><br><span class="line"><span class="comment">                    &#125; </span></span><br><span class="line"><span class="comment">                    System.out.println(new String(bs));</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                通过文件字节读取到数据之后进行打印，发现输出内容末尾的位置多出了一些内容，但是在源文件中是不存在</span></span><br><span class="line"><span class="comment">                当调用read方法读取文件中内容时，是按照bs数组的长度进行读取，然后写入到bs数组中，这是一次读取</span></span><br><span class="line"><span class="comment">                下一次循环读取时，也会按照bs数组的长度进行读取，然后是覆盖写入到bs数组中，即不会清除原有数组中存的内容</span></span><br><span class="line"><span class="comment">                而是直接覆盖进新读取到文件内容到数组</span></span><br><span class="line"><span class="comment">                例如：现在读取文件大小是 4063字节 存储数据数组的大小1024字节</span></span><br><span class="line"><span class="comment">                第一次读取时 4063-1024 --》剩余字节 3039 但是读取到 1024字节内容</span></span><br><span class="line"><span class="comment">                第二次读取时 3039-1024 --》剩余字节 2015 但是读取到 1024字节内容</span></span><br><span class="line"><span class="comment">                第二次读取时 2015-1024 --》剩余字节 991 但是读取到 1024字节内容</span></span><br><span class="line"><span class="comment">                第四次读取时 读取字节是991 并没有填充满1024 --》 实际读取991个字节</span></span><br><span class="line"><span class="comment">                991个字节覆盖到byte数组中之后 会剩余33个字节没有进行覆盖内容</span></span><br><span class="line"><span class="comment">                所以通过new String方式打印数组内容时，就会将33个没有覆盖内容数据打印出来</span></span><br><span class="line"><span class="comment">                read(byte[] bs)这个方法的返回值不仅可以返回读取到文件末尾-1值</span></span><br><span class="line"><span class="comment">                                而且这个方法还可以返回读取到实际文件内容长度的实际值</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//提供流循环读取文件内容的while循环书写方式</span></span><br><span class="line">            <span class="comment">//需要提供一个存储实际读取文件内容长度变量【包括文件末尾值】</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(bs))!=-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//循环内部对数组中存储内容进行操作</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    第一个参数是存储数据数组</span></span><br><span class="line"><span class="comment">                    第二个参数是从数组中什么位置开始获取数据【默认值是0(使用是下标值)】</span></span><br><span class="line"><span class="comment">                    第三个参数 实际读取文件内容长度，因为可以避免输出书中没有被覆盖掉内容</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bs,<span class="number">0</span>,len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (Exception e) </span><br><span class="line">        &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(is))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、OutputStream字节输出流"><a href="#3、OutputStream字节输出流" class="headerlink" title="3、OutputStream字节输出流"></a><center>3、OutputStream字节输出流</center></h2><p>OutputStream字节输出流是所有字节输出的父类，所有字节输入出流都是直接或间接继承OutputStream类</p>
<p>根据API文档中提供类创建方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OutputStream</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span>, Flushable</span><br></pre></td></tr></table></figure>

<p>OutputStream是抽象类无法直接创建对象使用，所以需要提供子类来完成对流操作</p>
<p>根据API文档中提供子类有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayOutputStream, *FileOutputStream*,</span><br><span class="line">FilterOutputStream, ObjectOutputStream, OutputStream, PipedOutputStream</span><br></pre></td></tr></table></figure>

<p>根据现在操作数据原则，将数据从磁盘文件读取到内容，将内存中数据写出到磁盘文件中，始终要处理是File文件，所以使用<strong>子类是FileOutputStream文件字节输出流</strong></p>
<h2 id="4、FileOutputStream文件字节输出流"><a href="#4、FileOutputStream文件字节输出流" class="headerlink" title="4、FileOutputStream文件字节输出流"></a><center>4、FileOutputStream文件字节输出流</center></h2><p>FileOutputStream文件字节输出流类是OutputStream的子类，这个类主要用用于将内存中存储数据写入到磁盘文件中进行保存操作，这里的文件是泛指【<strong>指代是二进制文件（文本文件、音频、视频、图片、压缩包等等）</strong>】都可以使用FileOutputStream这个流对象将数据写入到磁盘中</p>
<p>根据API文档中说明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStream</span> <span class="keyword">extends</span> <span class="title class_">OutputStream</span></span><br></pre></td></tr></table></figure>

<p><strong>核心构造方法</strong></p>
<table>
<thead>
<tr>
<th align="center">构造方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FileOutputStream(File file) 通过一个File对象(封装的文件路径)创建文件字节输出流对象</td>
</tr>
<tr>
<td align="center">FileOutputStream(File file, boolean append)通过一个File对象(封装的文件路径)创建文件字节输出流对象,并根据第二个参数的值决定是否是对文件进行追加写入数据 true是追加 false 不追加</td>
</tr>
<tr>
<td align="center">FileOutputStream(String name) 通过一个String对象(封装的文件路径)创建文件字节输出流对象</td>
</tr>
<tr>
<td align="center">FileOutputStream(String name, boolean append)通过一个String对象(封装的文件路径)创建文件字节输出流对象,并根据第二个参数的值决定是否是对文件进行追加写入数据 true是追加 false不追加</td>
</tr>
</tbody></table>
<h3 id="（1）核心API方法"><a href="#（1）核心API方法" class="headerlink" title="（1）核心API方法"></a>（1）核心API方法</h3><table>
<thead>
<tr>
<th align="center">void</th>
<th align="center"><strong>close() 关闭此文件输出流并释放与此流有关的所有系统资源 【常用】</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">void</td>
<td align="center">write(byte[] b) 将以字节数组长度的内容写入到磁盘文件中</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center"><strong>write(byte[] b, int off, int len) 将实际len长度的内容****从数组b中off位置开始写入到磁盘文件中【常用】</strong></td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">write(int b) 一次写一个字节的内容写入到磁盘文件中</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center"><strong>flush() 加快流的流速,强制清空缓冲区中数据</strong>【加快输出效果（在使用网络流的时候一定要添加）】</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStreamAPIDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建文件字节输出流对象【一个参数的版本】</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            一个参数的版本参数可以传递两种方式</span></span><br><span class="line"><span class="comment">            第一种：传入File对象 --》fos = new FileOutputStream(new File(&quot;绝对或相对路径文件&quot;));</span></span><br><span class="line"><span class="comment">            第二种：传入String类型对象(代表的是文件的路径)</span></span><br><span class="line"><span class="comment">                                fos = new FileOutputStream(&quot;绝对或相对路径文件&quot;);</span></span><br><span class="line"><span class="comment">            在创建文件字节输出流对象时，需要处理编译时异常 Unhandled exception: java.io.FileNotFoundException</span></span><br><span class="line"><span class="comment">            处理方式 要么 try-catch 要么 throws</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                创建文件字节输出流对象【两个参数的版本】</span></span><br><span class="line"><span class="comment">                第一个参数可以是File对象或String类型对象，只要提供文件绝对或相对路径</span></span><br><span class="line"><span class="comment">                第二个参数需要注意是一个boolean类型参数，传入true时会开启追加写入操作</span></span><br><span class="line"><span class="comment">                    new FileOutputStream(&quot;绝对或相对路径文件&quot;,true);</span></span><br><span class="line"><span class="comment">                或者</span></span><br><span class="line"><span class="comment">                    new FileOutputStream(new File(&quot;绝对或相对路径文件&quot;),true);</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//写出数据到磁盘中时，磁盘中可以不存在这个文件，在写数据时会自动创建这个文件</span></span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;dir/file2.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//常用写出方法中都存在一个编译时异常Unhandledexception: java.io.IOException</span></span><br><span class="line">            <span class="comment">//1.一次向文件中写入一个字节的数据</span></span><br><span class="line">            <span class="comment">//fos.write(65);     //参数是int类型对应ASCII值的字符</span></span><br><span class="line">            <span class="comment">//不是“连续”向文件中写入内容，而是再次向file2.txt内容时，覆盖写入</span></span><br><span class="line">            <span class="comment">//2.向文件中一次性写过字节数组中的所有内容</span></span><br><span class="line">            <span class="comment">//getBytes()--&gt;将字符串转换为字节数组</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                如果是分批写入数据，为了防止文件中内容被后一次书写数据进行覆盖，</span></span><br><span class="line"><span class="comment">                可以使用FileOutputStream中构造方法【两个参数版本】，开启追加写入</span></span><br><span class="line"><span class="comment">                一般追加写入的作用都是生成日志文件，记录用户写入一些数据到文件中，一般不追加的比较常用</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            fos.write(<span class="string">&quot;BCDEFGHIJKLMN&quot;</span>.getBytes());    <span class="comment">//getBytes()将字符串转换成字节数组</span></span><br><span class="line">            <span class="comment">//3.从字节数组中将内容写入到文件中，从off参数提供的位置读取数据开始写，写len提供长度内容</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                第一个参数是存储数据字节数组</span></span><br><span class="line"><span class="comment">                第二个参数是从字节数组什么位置开始读取和写出数据【默认0（下标）】</span></span><br><span class="line"><span class="comment">                第三个参数实际写出内容长度（一般会配合输入流中read方法获取实际长度进行写出）</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            fos.write(<span class="string">&quot;BCDEFGHIJKLMN&quot;</span>.getBytes(),<span class="number">6</span>,<span class="string">&quot;HIJKMLN&quot;</span>.length());</span><br><span class="line">            <span class="comment">//执行刷新操作</span></span><br><span class="line">            fos.flush();</span><br><span class="line">            System.out.println(<span class="string">&quot;老子写完了！！！&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (FileNotFoundException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(fos))    <span class="comment">//也可以是 fos != null</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//存在一个编译时异常要处理</span></span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、图片拷贝案例"><a href="#5、图片拷贝案例" class="headerlink" title="5、图片拷贝案例"></a><center>5、图片拷贝案例</center></h2><p>利用文件字节输入输出流完成图片拷贝操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.InputStreamAndOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCopy</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供文件字节输入输出流对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/1_io.WebP&quot;</span>));</span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/1_io.WebP&quot;</span>));</span><br><span class="line">            <span class="comment">//2.一定明确在使用是什么流【字节或字符】-》提供对应数组进行数据存储与接收</span></span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];    <span class="comment">//提供存储读取数据的字节数组</span></span><br><span class="line">            <span class="comment">//3. 提供一个变量存储读取文件实际内容长度【存储读取到文件末尾-1的值】</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//4.提供流的循环读写操作【读和写都是有编译时异常的要处理】</span></span><br><span class="line">            <span class="keyword">while</span>((len = is.read(bs))!=-<span class="number">1</span>)    <span class="comment">//循环读取数据并存储在bs数组中</span></span><br><span class="line">            &#123; </span><br><span class="line">                <span class="comment">//将存储在bs数组中数据写出到磁盘文件中</span></span><br><span class="line">                os.write(bs,<span class="number">0</span>,len);</span><br><span class="line">            &#125; </span><br><span class="line">            os.flush();    <span class="comment">//刷新</span></span><br><span class="line">            System.out.println(<span class="string">&quot;老子写完了！！！&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (FileNotFoundException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//谁先创建谁最后关闭</span></span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(os))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(is))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、利用字节流将文件中的内容进行拷贝赋值操作"><a href="#6、利用字节流将文件中的内容进行拷贝赋值操作" class="headerlink" title="6、利用字节流将文件中的内容进行拷贝赋值操作"></a><center>6、利用字节流将文件中的内容进行拷贝赋值操作</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.InputStreamAndOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCopy2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供字节输入输出流对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/1.txt&quot;</span>));</span><br><span class="line">            ois = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/1.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//2.明确使用是字节流还是字符流</span></span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//3.提供循环读写操作【处理编译时异常】</span></span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read(bs))!=-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// ois.write(bs,0,len);</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bs,<span class="number">0</span>,len));</span><br><span class="line">            &#125; </span><br><span class="line">            ois.flush();</span><br><span class="line">            System.out.println(<span class="string">&quot;老子写完了！！！&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (FileNotFoundException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(ois))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    ois.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(fis))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:字节输入输出流在文件进行操作，因为字节流中使用数据类型byte类型主要针对是二进制的文件，所以<strong>字节流主要对的是【图片、音频、视频、压缩包】这类的二进制文件</strong>，在读取和写出文本文件时，会在处理文件时出现一些乱码问题�，所以字节流主要是处理二进制文件而使用，如果处理文件文件的数据就不太建议使用字节流来完成操作，就是因为容易出现乱码问题�</p>
<h1 id="知识点四：字符输入输出流"><a href="#知识点四：字符输入输出流" class="headerlink" title="知识点四：字符输入输出流"></a><center>知识点四：字符输入输出流</center></h1><p>字符输入输出流是专门用于对文本文件进行操作流，用于弥补字节流对文本文件操作时容易出现乱码的为题，所以用字符输入输出流对文本文件进行处理操作</p>
<h2 id="1、Reader字符输入流"><a href="#1、Reader字符输入流" class="headerlink" title="1、Reader字符输入流"></a><center>1、Reader字符输入流</center></h2><p>Reader是字符输入的父类，所有字符输入流都要直接或间接继承与Reader类，因为这个流是字符流，所以流中数据是char，要提供数组也是char类型数组</p>
<p>根据API文档中描述可以发现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Reader</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Readable</span>, Closeable</span><br></pre></td></tr></table></figure>

<p>提供已知的之类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader, CharArrayReader, FilterReader, InputStreamReader, PipedReader, StringReader</span><br></pre></td></tr></table></figure>

<p>操作文件FileReader这个类并不是Reader的直接子类，而是间接子类，操作文件FileReader类是继承与InputStreamReader这个类，InputStreamReader这个类是Reader直接子类，可以利用FileReader进行文件操作</p>
<h2 id="2、FileReader文件字符输入流"><a href="#2、FileReader文件字符输入流" class="headerlink" title="2、FileReader文件字符输入流"></a><center>2、FileReader文件字符输入流</center></h2><p>FileReader是Reader的间接子类，FileReader的直接父类是InputStreamReader，InputStreamReader这个类提供文件编码集和缓冲区操作，API文档中也说明【此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的】</p>
<p>通过流操作文本文件时，文本文件是存在编码集的，在使用FileReader类操作是使用就是默认编码集，这个默认编码集是根据系统进行获取，编码集的目的【提供文件的编码让文件可以达到统一性Unicode(UTF-8)】</p>
<p>在使用字节流时，API文档中是没有描述字节流具备缓冲区，但是在使用字符流的时，API文档提供缓冲区的概念，当使用流写出数据时，有一个方法<strong>flush方法</strong>，这个方法就是专门针对缓冲区进行设计，提供缓冲这个概念可以大大提高，流的使用效率</p>
<p>在API文档中提供FileReader中定义描述</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReader</span> <span class="keyword">extends</span> <span class="title class_">InputStreamReader</span></span><br></pre></td></tr></table></figure>

<p><strong>常用构造方法</strong></p>
<table>
<thead>
<tr>
<th align="center">构造方法摘要</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FileReader(File file) 通过一个File对象(封装着文件路径)创建一个FileReader对象进行数据读取</td>
</tr>
<tr>
<td align="center">FileReader(String fileName) 通过一个String对象(封装着文件路径)创建一个FileReader对象进行数据读取</td>
</tr>
</tbody></table>
<h3 id="（1）常用API方法"><a href="#（1）常用API方法" class="headerlink" title="（1）常用API方法"></a>（1）常用API方法</h3><table>
<thead>
<tr>
<th align="center">方法摘要</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">void</td>
<td align="center"><strong>close() 关闭该流并释放与之关联的所有资源</strong></td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">read() 读取单个字符</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center"><strong>read(char[] cbuf) 读取字符数组长度的内容(常用)</strong></td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">read(char[] cbuf, int off, int len) 将读取len的长度内容写入到cbuf数组中并且从off的位置开始在数组中写入</td>
</tr>
</tbody></table>
<p>PS:直接参考FileInputStream即可，只要将byte数组换char数组就可以了</p>
<h2 id="3、Writer字符输出流"><a href="#3、Writer字符输出流" class="headerlink" title="3、Writer字符输出流"></a><center>3、Writer字符输出流</center></h2><p>Writer字符输入流是所有字符输入流父类，所有字符输入流都要直接或间接继承与Writer，因为这个流是字符流，所以流中数据是char类型，需要提供char类型数组</p>
<p>根据API文档中描述</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Writer</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, Closeable, Flushable</span><br></pre></td></tr></table></figure>

<p>它是一个抽象类不能直接创建流对象进行操作，所以需要使用到其子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedWriter, CharArrayWriter, FilterWriter, OutputStreamWriter, PipedWriter, PrintWriter, StringWriter</span><br></pre></td></tr></table></figure>

<p>操作文件的FileWriter这个类不是Writer的直接子类，而是间接子类，但是FileWriter可以完成对文件写出操作</p>
<h2 id="4、FileWriter文件字符输出流"><a href="#4、FileWriter文件字符输出流" class="headerlink" title="4、FileWriter文件字符输出流"></a><center>4、FileWriter文件字符输出流</center></h2><p>FileWriter是Writer的间接子类，FileWriter的直接父类是OutputStreamWriter，OutputStreamWriter个类提供文件编码集和缓冲区操作，API文档中也说明【此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的】</p>
<p>通过流操作文本文件时，文本文件时存在编码集的，在使用FileWriter类操作时使用就是默认编码集，这个默认编码集是根据系统进行获取，编码集的目的【提供文件的编码让文件可以达到统一性Unicode(UTF-8)】</p>
<p>在使用字节流时，API文档中是没有描述字节流具备缓冲区，但是在使用字符流的时，API文档提供缓冲区的概念，当使用流写出数据时，有一个方法flush方法，这个方法就是专门针对缓冲区进行设计，提供缓冲这个概念可以大大提高，流的使用效率</p>
<h3 id="（1）常用构造方法"><a href="#（1）常用构造方法" class="headerlink" title="（1）常用构造方法"></a>（1）常用构造方法</h3><table>
<thead>
<tr>
<th align="center">常用构造方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FileWriter(File file) 构建了一个文件对象FileWriter对象</td>
</tr>
<tr>
<td align="center">FileWriter(File file, boolean append) 构建了一个文件对象FileWriter对象</td>
</tr>
<tr>
<td align="center">FileWriter(String fileName) 构造给定文件名的FileWriter对象</td>
</tr>
<tr>
<td align="center">FileWriter(String fileName, boolean append) 构造FileWriter对象给出一个文件名与一个布尔值，指示是否附加写入的数据</td>
</tr>
</tbody></table>
<p>PS:构建方法中多了一个第二参数，是boolean参数值作用就是提供文件追加写入操作，当设置参数为true时，当前写入文件中数据操作就是追加写入【主要适合：记录日志的工作】，如果是连续写出数据，可以不开启这个操作</p>
<h3 id="（2）常用API方法"><a href="#（2）常用API方法" class="headerlink" title="（2）常用API方法"></a>（2）常用API方法</h3><table>
<thead>
<tr>
<th align="center">void</th>
<th align="center">close() 关闭此流，但要先刷新它</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void</td>
<td align="center">flush() 刷新该流的缓冲</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">write(char[] cbuf) 写入字符数组</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">write(char[] cbuf, int off, int len) 从cbuf数组读取数据并写入到文件中,len是实际写出数据长度,off是从cbuf数组中什么位置开始写出 (使用字符数组时核心方法)</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">write(int c) 写入单个字符</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">write(String str) 写入字符串(非常有用的核心方法)</td>
</tr>
</tbody></table>
<p>PS: 在写出数据到文件中时，只有字符流中会提供一个参数为String类型write方法，这个方法可以帮我们便捷将数据写出到文件中，这个方法极其重要</p>
<p>FileWriter操作可以完全参考FileOutputStream这个类，基本上是一模一样，只不过将byte类型转换char类型即可</p>
<h2 id="5、使用字符输入输出流进行文本文件的拷贝操作"><a href="#5、使用字符输入输出流进行文本文件的拷贝操作" class="headerlink" title="5、使用字符输入输出流进行文本文件的拷贝操作"></a><center>5、使用字符输入输出流进行文本文件的拷贝操作</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.ReaderAndWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderAndFileWriterCopyFile</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供字符输入输出流对象创建</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//在创建对象时要处理编译时异常Unhandled exception: java.io.FileNotFoundException 处理方法和字节流一样</span></span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/1.txt&quot;</span>));</span><br><span class="line">            writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/2.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//2.一定要明确使用是什么流--》字符流</span></span><br><span class="line">            <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//3. 提供循环读写操作</span></span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = reader.read(buf))!=-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf,<span class="number">0</span>,len));</span><br><span class="line">                <span class="comment">//writer.write(buf,0,len);</span></span><br><span class="line">            &#125; </span><br><span class="line">            writer.flush();</span><br><span class="line">            System.out.println(<span class="string">&quot;老子写完了！！！！&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(writer))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(reader))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、使用字符输入输出流进行图片的拷贝操作"><a href="#6、使用字符输入输出流进行图片的拷贝操作" class="headerlink" title="6、使用字符输入输出流进行图片的拷贝操作"></a><center>6、使用字符输入输出流进行图片的拷贝操作</center></h2><p>打开拷贝之后图片，观察拷贝之后图片与原来图片的大小</p>
<p>使用字符流进行图片复制拷贝操作是不可以完成，图片出现问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.ReaderAndWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderAndFileWriterCopyFile2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供字符输入输出流对象创建</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//在创建对象时要处理编译时异常Unhandled exception: java.io.FileNotFoundException</span></span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/1_io.WebP&quot;</span>));</span><br><span class="line">            writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/2_io.WebP&quot;</span>));</span><br><span class="line">            <span class="comment">//2.一定要明确使用是什么流--》字符流</span></span><br><span class="line">            <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//3. 提供循环读写操作</span></span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = reader.read(buf))!=-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                writer.write(buf,<span class="number">0</span>,len);</span><br><span class="line">            &#125; </span><br><span class="line">            writer.flush();</span><br><span class="line">            System.out.println(<span class="string">&quot;老子写完了！！！！&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(writer))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(reader))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点五：字节流和字符流之间区别"><a href="#知识点五：字节流和字符流之间区别" class="headerlink" title="知识点五：字节流和字符流之间区别"></a><center>知识点五：字节流和字符流之间区别</center></h1><p>字节流和字符流是有本质上区别：</p>
<ol>
<li>流中数据是不同，字节流流中的数据是byte而字符流流中数据是char</li>
<li>根据流中不同数据类型所以字节流主要处理是二进制文件【图片、音频、视频、压缩包的等等】也可以处理【文本文件】但是容易出现乱码，而字符流主要是处理文本文件提供流，它是无处理二进制文件的</li>
<li>字节流和字符流之间还有一个很大区别</li>
</ol>
<p>&ensp;&ensp;&ensp;&ensp;字节流在操作流的过程中是【没有使用缓冲区】，直接对文件本身进行操作</p>
<p>&ensp;&ensp;&ensp;&ensp;字符流在操作流的过程中是【使用了缓冲区】，通过缓冲区进行进行对文件操作</p>
<p><strong>什么是缓冲区？</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;缓冲区可以理解为一段特殊区域，某些情况下，如果一个程序频繁的操作一个资源（如文件或数据库），则会出现性能下降的问题，此时为了提升性能，就可以将内存中部分数据读取到一个内存区域中，以后直接从这个区域进行数据去读，这样化就可以提升系统的性能，那么这个提供区域就是“缓冲区”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span></span><br><span class="line">Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在同等条件下进行操作</span></span><br><span class="line"><span class="comment">            创建文件字节输出流和文件字符输出流对象，将数据通过流写入到文件中</span></span><br><span class="line"><span class="comment">            创建了字节和字符文件输出流对象，进行数据书写到文件中并关闭了流资源，此时外界文件中是可以存在数据</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            OutputStream os = new FileOutputStream(new File(&quot;desc/字节流文件.txt&quot;));</span></span><br><span class="line"><span class="comment">            os.write(&quot;Hello World&quot;.getBytes());</span></span><br><span class="line"><span class="comment">            os.close();</span></span><br><span class="line"><span class="comment">            Writer writer = new FileWriter(new File(&quot;desc/字符流文件.txt&quot;));</span></span><br><span class="line"><span class="comment">            //自有字符流中提供可以将字符串写入到文件中方法</span></span><br><span class="line"><span class="comment">            writer.write(&quot;Hello world&quot;);</span></span><br><span class="line"><span class="comment">            writer.close();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//-------------------------------------------------------------------------------------</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在同等条件下进行操作            创建文件字节输出流和文件字符输出流对象，将数据通过流写入到文件中，但是不添加close方法</span></span><br><span class="line"><span class="comment">            字节流可以将数据直接写出到磁盘文件中，在没有使用close方法前提下程序正常结束也可以将流中数据写入到文件中</span></span><br><span class="line"><span class="comment">            字符流在没有使用close方法的前提下，程序正常结束是没有办法将数据写入到文件中的</span></span><br><span class="line"><span class="comment">            就是因为 字符流使用 缓冲区技术即使用“缓冲区”</span></span><br><span class="line"><span class="comment">            在字符流操作过程中，所有字符都是在“内存中形成”的，在输出前会将“所有的暂时保存在内存中内容”输出到文件中</span></span><br><span class="line"><span class="comment">            使用close这个方法在在关闭流资源自后会将缓冲区中数据输出文件中(有flush功能)，所以字符流就要更加要关闭流资源</span></span><br><span class="line"><span class="comment">            但是为了防止忘记书写close方法，并且共缓冲区的利用率，Java对所有输出流都提供了一个方法flush</span></span><br><span class="line"><span class="comment">            flush这个方法可以强制的刷新出缓冲区中数据，所以就算没有关闭流资源可以将字符流中数据写出到文件中</span></span><br><span class="line"><span class="comment">            所以建议在所有写出数据操作中添加flush这个方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/字节流文件.txt&quot;</span>));</span><br><span class="line">        os.write(<span class="string">&quot;Hello World&quot;</span>.getBytes());</span><br><span class="line">        <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/字符流文件.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//自有字符流中提供可以将字符串写入到文件中方法</span></span><br><span class="line">        writer.write(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用字符流还是使用字节流？</p>
<p>&ensp;&ensp;&ensp;&ensp;区分场景而言文本文件使用字符流，二进制文件使用字节流，但是字节流处理场景明显要比字符流多，所以建议优先使用字节流处理数据，如果数据是文本文件在考虑转换流操作</p>
<h1 id="知识点六：字符编码"><a href="#知识点六：字符编码" class="headerlink" title="知识点六：字符编码"></a><center>知识点六：字符编码</center></h1><p>阶段1:</p>
<p>&ensp;&ensp;&ensp;&ensp;所以规定使用的字节的最高位是0.每一个字节都是以【0~127之间的数字来表示】,比如A对应65,a对应97.这就是美国标准信息交换码【ASCII】.</p>
<p>‘A’<del>‘Z’ ‘a’</del>‘z’ ‘0’~‘9’</p>
<p><strong>阶段2:</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;随着计算机在全球的普及,很多国家和地区都把自己的字符引入了计算机,比如汉字.</p>
<p>&ensp;&ensp;&ensp;&ensp;此时发现一个字节能表示数字范围太小,不能包含所有的中文汉字那么就规定使用两个字节来表示一个汉字.</p>
<p>&ensp;&ensp;&ensp;&ensp;规定:原有的ASCII字符的编码保持不变,仍然使用一个字节表示,为了区别一个中文字符和ASCII码字符中文字符的每个字节最高位规定为1(中文的二进制是负数).这个规范就是【GB2312】编码,后来在GB2312的基础上增加了更多的中文字符,比如汉字,也就出现了【GBK】.</p>
<p>阶段3:</p>
<p>&ensp;&ensp;&ensp;&ensp;新的问题,在中国是认识汉字的,但是如果把汉字传递给其他国家,该国家的码表中没有收录汉字,其实就显示另一个符号或者乱码为了解决各个国家因为本地化字符编码带来的影响,咱们就把全世界所有的符号统一进行编码-【Unicode万国码】编码.此时某一个字符在全世界任何地方都是固定的,比如【哥】,在任何地方都是以十六进制的【54E5】来表示.Unicode的编码字符都占有【2个字节大小】</p>
<p>常用字符编码集</p>
<p>&ensp;&ensp;&ensp;&ensp;ASCII码： 占一个字节，只能包含128个符号，不能表示汉字</p>
<p>&ensp;&ensp;&ensp;&ensp;ISO-8859-1【latin-1】占一个字节，收录的是西欧语言，不能表示汉字 —》properties</p>
<p>&ensp;&ensp;&ensp;&ensp;ANSI【GB2312】占两个字节，在简体中文操作系统中ANSI就是值的GB2312(淘汰了)</p>
<p>&ensp;&ensp;&ensp;&ensp;GB18030&#x2F;GBK 占两个字节，支持中文</p>
<p>&ensp;&ensp;&ensp;&ensp;UTF-8：是一种针对Unicode的可变长字符编码，又称万国码，UTF-8是Unicode的实现方式之一，这个编码兼容ASCII码 UTF-8表示汉字’\u0000’~’\uffff’</p>
<p>ps：在UTF家族中提供了其他编码 UTF-8E ，UTF-16 ,UTF-32， 这里有一个特殊编码集千万不要使用，这个编码集是MS公司搞出来UTF-8 BOM，默认3个字节一个汉字【不要使用】</p>
<h1 id="知识点七：InputStreamReader-字节字符转换输入流"><a href="#知识点七：InputStreamReader-字节字符转换输入流" class="headerlink" title="知识点七：InputStreamReader 字节字符转换输入流"></a><center>知识点七：InputStreamReader 字节字符转换输入流</center></h1><p>字节字符转换输入流的作用：<strong>将字节流转换为字符流，并且可以设置文件编码集</strong></p>
<p>“特别说明：<strong>InputStreamReader的父类是Reader类，所以这个流中数据是char类型</strong>”</p>
<p>&ensp;&ensp;&ensp;&ensp;“<strong>InputStreamReader是FileReader的直接父类</strong>”</p>
<h2 id="1、核心构造方法"><a href="#1、核心构造方法" class="headerlink" title="1、核心构造方法"></a><center>1、核心构造方法</center></h2><table>
<thead>
<tr>
<th align="center">常用构造方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">InputStreamReader(InputStream in) 通过参数InputStream流的对象构建InputStreamReader流对象并使用的是默认编码集</td>
</tr>
<tr>
<td align="center">InputStreamReader(InputStream in, Charset cs) 通过参数</td>
</tr>
<tr>
<td align="center">InputStream流的对象构建InputStreamReader流对象并用过Charset设置读取文件编码集</td>
</tr>
<tr>
<td align="center">InputStreamReader(InputStream in, String charsetName)通过参数InputStream流的对象构建InputStreamReader流并用过字符串设置读取文件编码集</td>
</tr>
</tbody></table>
<p>PS： 转换输入流，所以构建InputStreamReader对象时，需要提供一个字节输入流作为转换对象</p>
<p>通过InputStreamReader可以设置编码集，设置编码集方式是通过InputStreamReader构造方法中第二参数进行设置，这里设置有两种方式</p>
<p>&ensp;&ensp;&ensp;&ensp;第一种方式：使用Charset类型进行设置 —》 Charset.forName(“编码集名字”)</p>
<p>&ensp;&ensp;&ensp;&ensp;第二种方式：使用String类型进行设置 —》 “编码集名字”</p>
<h2 id="2、核心API方法"><a href="#2、核心API方法" class="headerlink" title="2、核心API方法"></a><center>2、核心API方法</center></h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">常用方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void</td>
<td align="center">close() 关闭流并释放与它相关联的任何系统资源</td>
</tr>
<tr>
<td align="center">String</td>
<td align="center">getEncoding() 返回此流使用的字符编码的名称。(在读取文件的同时读取文件编码集)</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">read() 读取单个字符</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">read(char[] cbuf, int offset, int length) 将字符读入一个数组的一部分</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">read(char[] cbuf) 将读取的数据存储到字符数组中</td>
</tr>
</tbody></table>
<h1 id="知识点八：OutputStreamWriter-字节字符转换输出流"><a href="#知识点八：OutputStreamWriter-字节字符转换输出流" class="headerlink" title="知识点八：OutputStreamWriter 字节字符转换输出流"></a><center>知识点八：OutputStreamWriter 字节字符转换输出流</center></h1><p>字节字符转换输出流作用:将字符流转换为字节流输出，并可以设置编码集</p>
<p>特别注意:”<strong>OutputStreamWriter的父类是Writer,所以这个流中数据是char类型</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;”<strong>OutputStreamWriter是FileWriter的父类</strong>“</p>
<h2 id="1、核心构造方法-1"><a href="#1、核心构造方法-1" class="headerlink" title="1、核心构造方法"></a><center>1、核心构造方法</center></h2><table>
<thead>
<tr>
<th align="center">常用构造方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">OutputStreamWriter(OutputStream out) 通过OutputStream对象创建OutputStreamWriter对象并使用默认编码集写出数据</td>
</tr>
<tr>
<td align="center">OutputStreamWriter(OutputStream out, Charset cs) 通过OutputStream对象创建OutputStreamWriter对象并使用Charset设置写出文件编码集</td>
</tr>
<tr>
<td align="center">OutputStreamWriter(OutputStream out, StringcharsetName) 通过OutputStream对象创建OutputStreamWriter对象并使用String类型设置写出文件编码集</td>
</tr>
</tbody></table>
<p>PS： 转换输出流，所以构建OutputStreamWriter对象时，需要提供一个字节输出流作为转换对象</p>
<p>通过OutputStreamWriter可以设置编码集，设置编码集方式是通过OutputStreamWriter构造方法中第二参数进行设置，这里设置有两种方式</p>
<p>&ensp;&ensp;&ensp;&ensp;第一种方式：使用Charset类型进行设置 —》 Charset.forName(“编码集名字”)</p>
<p>&ensp;&ensp;&ensp;&ensp;第二种方式：使用String类型进行设置 —》 “编码集名字”</p>
<h2 id="2、核心的API方法"><a href="#2、核心的API方法" class="headerlink" title="2、核心的API方法"></a><center>2、核心的API方法</center></h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">常用方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void</td>
<td align="center">close() 关闭流，冲洗它</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">flush() 冲流</td>
</tr>
<tr>
<td align="center">String</td>
<td align="center">getEncoding() 返回此流使用的字符编码的名称</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">write(char[] cbuf, int off, int len) 写入一个字符数组的一部分</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">write(int c) 写一个字符</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">write(String str, int off, int len) 写入字符串的一部分</td>
</tr>
</tbody></table>
<p>PS： 因为OutputStreamWriter是父类Writer方法，所以也会继承到Writer方法中参数为String类方法，所以提供直接输出字符串的方法</p>
<p><strong>这两流的操作可以完全操作FileRader和FileWriter进行操作</strong></p>
<p>需求：使用转换流在设置编码集的前提下进行文件的赋值与粘贴</p>
<ol>
<li>读取文件使用UTF-8编码集进行，输出文件时将文件编码集修改为GBK</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.BufferedInputStreamAndBufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileEncodingCopyDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用转换流进行文件的编码集设置操作</span></span><br><span class="line">        <span class="comment">//1.提供创建字节字符转换输入输出流对象</span></span><br><span class="line">        <span class="comment">//在创建转换流对象时，是存在一个编译时异常 UnsupportedEncodingException【不支持设置编码集】</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/1.txt&quot;</span>)),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">//只有读对了才可以写对</span></span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/1.txt&quot;</span>)),</span><br><span class="line">        Charset.forName(<span class="string">&quot;GBK&quot;</span>));</span><br><span class="line">        <span class="comment">//2.这两个转换流是父类都是字符类型，所以流中的数据都是char类型</span></span><br><span class="line">        <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//提供一个变量存储实际读取到文件长度【包括文件末尾-1的返回值】</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//3.循环读取数据并将当前数据输出</span></span><br><span class="line">        <span class="keyword">while</span>((len = isr.read(buf))!=-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            osw.write(buf,<span class="number">0</span>,len);</span><br><span class="line">        &#125; </span><br><span class="line">        osw.flush();</span><br><span class="line">        osw.close();</span><br><span class="line">        isr.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;老子写完了！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需求：仿照上面代码提供一个通用方法可以设置文件编码集并且使用转换流进行拷贝与粘贴操作</p>
<ol>
<li>读取文件使用UTF-8编码集进行，输出文件时将文件编码集修改为GBK</li>
<li>读取文件使用GBK编码集进行，输出文件时将文件编码集修改为UTF-8</li>
<li>使用GBK编码集读取一个UTF-8文件，输出文件时使用UTF-8编码集输出</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.BufferedInputStreamAndBufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileEncodingCopyDemo2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. 读取文件是UTF-8，写出文件GBK</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            copyFile(new File(&quot;dir/1.txt&quot;),&quot;UTF-8&quot;,new File(&quot;desc/1.txt&quot;),&quot;GBK&quot;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//2. 读取文件是GBK ，写出文件是UTF-8编码</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            copyFile(new File(&quot;desc/1.txt&quot;),&quot;GBK&quot;, new File(&quot;dir/UFT-8文件.txt&quot;),&quot;UTF-8&quot;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 3. 读取一个UTF-8的编码文件使用GBK编码，写出文件是使用UTF-8写出</span></span><br><span class="line">        copyFile(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/UFT-8文件.txt&quot;</span>),<span class="string">&quot;GBK&quot;</span>, <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/将UFT-8文件设置为GBK之后修</span></span><br><span class="line"><span class="string">                                                                                改为UTF-8.txt&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 设置文件编码集进行赋值粘贴的方法</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> srcFile 源文件</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> srcCharset 源文件编码集</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> descFile 目标文件</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> descCharset 目标文件编码集</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> Exception 代表方法所有要抛出的编译时异常</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(File srcFile,String srcCharset,File descFile,String descCharset)</span><span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供字节字符转换输入输出流对象</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile),srcCharset);</span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(descFile),descCharset);</span><br><span class="line">        <span class="comment">//2.使用的是什么流，流中数据是什么 --》 他们都是字符流</span></span><br><span class="line">        <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = isr.read(buf))!=-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            osw.write(buf,<span class="number">0</span>,len);</span><br><span class="line">        &#125; </span><br><span class="line">        osw.flush();</span><br><span class="line">        osw.close();</span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>转换流的总结：</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>转换流的目的在于提供了字节与字符流之间的一种转换效果，我们可以通过转换流将字符流和字节流进行转化，除此之外还可以设置文件的编码集进行文件的读取和写出操作</strong>，这样可以完成文件的编码集转换操作【文件编码集的转换操作原则是：只有读取文件时编码集设置正确，才可在写出文件时将编码集设置正确】</p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012007515.WebP" alt="字符流转字节流" style="zoom: 67%;">

<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012008623.WebP" alt="字节流转字符流" style="zoom:67%;">

<h1 id="知识点九：缓冲流"><a href="#知识点九：缓冲流" class="headerlink" title="知识点九：缓冲流"></a><center>知识点九：缓冲流</center></h1><p>有了缓冲流之后，不建议使用原始流进行操作，缓冲流效率是远远高于原始流，缓冲流提供缓冲区让流可以进行操作</p>
<p>原始流指的是：InputStream和OutputStream 或者 Reader和Writer不使用缓冲区的流</p>
<p>PS：需要注意的是 字符流 默认使用了缓冲区，所以和缓冲流的效果差不多</p>
<h2 id="1、字节缓冲流"><a href="#1、字节缓冲流" class="headerlink" title="1、字节缓冲流"></a><center>1、字节缓冲流</center></h2><p>字节缓冲流是针对原始字节流而提供一种流，这个中流可以更加高效处理流中操作</p>
<p><strong>BufferedInputStream字节缓冲输入流 和 BufferedOutputStrem 字节缓冲输出流</strong></p>
<p>BufferedInputStream字节缓冲输入流是InputStream字节输入流的子类，这个流提供一个缓冲区，这个缓冲区可以帮组流进行数据缓冲与操作，<strong>这个缓冲区的大小默认是8192K</strong>,提供BufferedInputStream这个流可以包装一个普通字节输入流进行缓冲操作，这个缓冲区大小是可以用过BufferedInputStream构造方法进行设置，但是<strong>这个缓冲区的设置不要低于8192，设置时按照1024倍数设置即可</strong></p>
<h3 id="（1）BufferedInputStream常用构造方法"><a href="#（1）BufferedInputStream常用构造方法" class="headerlink" title="（1）BufferedInputStream常用构造方法"></a>（1）BufferedInputStream常用构造方法</h3><table>
<thead>
<tr>
<th align="center">常用构造方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BufferedInputStream(InputStream in) 创建一个BufferedInputStream 和保存它的参数，输入流 in ，供以后使用</td>
</tr>
<tr>
<td align="center">BufferedInputStream(InputStream in, int size) 创建一个具有指定的缓冲区大小 BufferedInputStream ，并保存它的参数，输入流 in ，供以后使用</td>
</tr>
</tbody></table>
<p>PS：缓冲流的使用其实就是对原始流进行二次“包装”，让原始就具备一个缓冲区可以快速进行流操作，所以构建字节缓冲输入流对象时，<strong>需要提供一个“InputStream字节输入流对象”</strong>，不仅如此还可以设置缓冲区的默认大小，<strong>不要低于8192这个数据，设置时按照1024倍数设置即可</strong>，缓冲流输入流是唯一支持字节输入流父类中提供mark和reset方法【但是没有任何效果】</p>
<h3 id="（2）BufferedInputStream常用API方法"><a href="#（2）BufferedInputStream常用API方法" class="headerlink" title="（2）BufferedInputStream常用API方法"></a>（2）BufferedInputStream常用API方法</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">常用方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void</td>
<td align="center">close() <strong>关闭此输入流并释放与流关联的任何系统资源</strong></td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">read() 看到的 InputStream 的 read 方法一般合同</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">read(byte[] b) <strong>读取文件存储到数组中</strong>【常用】</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">read(byte[] b, int off, int len) 从这个字节的输入流读取到指定的字节数组中的字节，从给定的偏移量开始</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">markSupported() 如果输入流的支持 mark 和reset 方法【无用】</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">mark(int readlimit) 看到的 InputStream 的mark 方法一般合同【无用】</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">reset() 看到的 InputStream 的 reset 方法一般合同【无用】</td>
</tr>
</tbody></table>
<p>&ensp;&ensp;&ensp;&ensp;BufferedOutputStream字节缓冲输出流是OutputStream字节输出流子类，这个流提供一个缓冲区，这个缓冲区可以帮组流进行数据缓冲与操作，<strong>这个缓冲区的大小默认是8192K</strong>,提供BufferedOutputStream这个流可以包装一个普通字节输出流进行缓冲操作，这个缓冲区大小是可以用过BufferedOutputStream构造方法进行设置，<strong>但是这个缓冲区的设置不要低于8192，设置时按照1024倍数设置即可</strong></p>
<h3 id="（3）BufferedOutputStream常用构造方法"><a href="#（3）BufferedOutputStream常用构造方法" class="headerlink" title="（3）BufferedOutputStream常用构造方法"></a>（3）BufferedOutputStream常用构造方法</h3><table>
<thead>
<tr>
<th align="center">常用构造方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BufferedOutputStream(OutputStream out) 创建一个新的缓冲输出流，将数据写入到指定的基本输出流中</td>
</tr>
<tr>
<td align="center">BufferedOutputStream(OutputStream out, int size) 创建一个新的缓冲输出流，用指定的缓冲区大小写数据到指定的基本输出流中</td>
</tr>
</tbody></table>
<p>PS：缓冲流的使用其实就是对原始流进行二次“包装”，让原始就具备一个缓冲区可以快速进行流操作，所以构建字节缓冲输出流对象时，<strong>需要提供一个“OutputStream字节输出流对象”</strong>，不仅如此还可以设置缓冲区的默认大小，<strong>不要低于8192这个数据，设置时按照1024倍数设置即可</strong></p>
<h3 id="（4）BufferedOutputStream常用API方法"><a href="#（4）BufferedOutputStream常用API方法" class="headerlink" title="（4）BufferedOutputStream常用API方法"></a>（4）BufferedOutputStream常用API方法</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">常用方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void</td>
<td align="center">flush() 刷新缓冲输出流</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">write(byte[] b, int off, int len) 写 len 字节指定字节数组中的起始偏移 off 这个缓冲输出流</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">write(int b) 将指定的字节写入该缓冲输出流中</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">close() 关闭此输出流并释放与此流关联的任何系统资源</td>
</tr>
</tbody></table>
<p>PS:字节缓冲输入输出流没有任何特殊方法，这个操作可以完全参考FileInputStream 和FileOutputStream</p>
<p>字节缓冲输入输出流就是提供缓冲区提高操作效率而已</p>
<p>性能对比： 使用缓冲字节流和普通字节流进行 大于2GB文件拷贝操作计算时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span></span><br><span class="line">com.qfedu.BufferedInputStreamAndBufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCopyTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span></span><br><span class="line">Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供一个开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//先提供字节输入输出流拷贝操作</span></span><br><span class="line">     <span class="comment">//copyFileToByte(new File(&quot;C:\\Users\\jkmaster\\Desktop\\23_IO流1.zip&quot;),new File(&quot;C:\\abc\\23_IO流1.zip&quot;));</span></span><br><span class="line">        <span class="comment">//在提供缓冲字节输入输出流拷贝操作</span></span><br><span class="line">        copyFileToBufferedByte(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\jkmaster\\Desktop\\23_IO流1.zip&quot;</span>),</span><br><span class="line">                                                                        <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\abc\\23_IO流1.zip&quot;</span>));</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//System.out.println(&quot;缓冲字节输入输出流拷贝文件的时间</span></span><br><span class="line">                                                    <span class="comment">//是：&quot;+(endTime-beginTime)+&quot;毫秒&quot;);5869毫秒 --》约等于 6秒</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;普通字节输入输出流拷贝文件的时间</span></span><br><span class="line">                                                   <span class="comment">//是：&quot;+(endTime-beginTime)+&quot;毫秒&quot;);21387毫秒 --》约等于 21秒</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 普通字节输入输出流拷贝文件操作</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> srcFile 源文件</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> descFile 目标文件</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception 抛出所有编译时异常信息    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileToByte</span><span class="params">(File srcFile, File descFile)</span><span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供字节输入输出对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(descFile);</span><br><span class="line">        <span class="comment">//2.提供byte类型数组</span></span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//3.提供一个变量存储读取实际文件长度【读取文件末尾-1值】</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(bs))!=-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            os.write(bs,<span class="number">0</span>,len);</span><br><span class="line">        &#125; </span><br><span class="line">        os.flush();</span><br><span class="line">        os.close();</span><br><span class="line">        is.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;字节输入输出流拷贝文件结束！&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 提供缓冲字节输入输出流拷贝文件操作</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> srcFile 源文件</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> descFile 目标文件</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception 抛出所有编译时异常信息    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileToBufferedByte</span><span class="params">(File srcFile, File descFile)</span><span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供缓冲字节输入输出对象</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile));</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(descFile));</span><br><span class="line">        <span class="comment">//2.提供byte类型数组</span></span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//3.提供一个变量存储读取实际文件长度【读取文件末尾-1值】</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(bs))!=-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            bos.write(bs,<span class="number">0</span>,len);</span><br><span class="line">        &#125; </span><br><span class="line">        bos.flush();</span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲字节输入输出流拷贝文件结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//PS：能用缓冲流就用缓冲流，不要使用普通字节流</span></span><br></pre></td></tr></table></figure>

<h2 id="2、字符缓冲流"><a href="#2、字符缓冲流" class="headerlink" title="2、字符缓冲流"></a><center>2、字符缓冲流</center></h2><p>PS：这个流才是我们真记忆，他符合内容数据写入到磁盘，在从磁盘将数据读取到内容使用流</p>
<p>字符缓冲流对于将内存中数据写入到磁盘中和将磁盘中数据读取到内容中有非常好支持，所以只要是这样数据操作就一定使用这个流</p>
<p>字符缓冲流也是缓冲流，所有字符缓冲输入输出流都具备缓冲区，默认大小也是8192K，如果要修改缓冲区大小需要比8192K大，并且是提供1024倍数进行修改</p>
<p>BufferedReader缓冲字符输入流是Reader字节输入的子类，提供8192K缓冲区，可以包装一个普通的字符输入流提高操作效率</p>
<h3 id="（1）BufferedReader常用构造方法"><a href="#（1）BufferedReader常用构造方法" class="headerlink" title="（1）BufferedReader常用构造方法"></a>（1）BufferedReader常用构造方法</h3><table>
<thead>
<tr>
<th align="center">构造方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BufferedReader(Reader in) 创建一个使用默认大小输入缓冲区的缓冲字符输入流</td>
</tr>
<tr>
<td align="center">BufferedReader(Reader in, int sz) 创建一个使用指定大小的输入缓冲区的缓冲字符输入流</td>
</tr>
</tbody></table>
<p>PS：BuffereReader是缓冲字符输入流，所以需要提供一个字符输入流作为对象传入到缓冲字符输入流中进行对象创建，除此之外提供修改默认缓冲区大小</p>
<h3 id="（2）BufferedReader常用API方法"><a href="#（2）BufferedReader常用API方法" class="headerlink" title="（2）BufferedReader常用API方法"></a>（2）BufferedReader常用API方法</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">常用方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">string</td>
<td align="center">readLine() 读一行文本【强烈推荐】</td>
</tr>
</tbody></table>
<p>说明：</p>
<ol>
<li>BufferedReader是一个流，所以也需要调用close方法</li>
<li>BufferedReader读取数据方式一共有两种：</li>
</ol>
<p>&ensp;&ensp;&ensp;&ensp;2.1 使用原始字符输入流的方式进行数据读取 –》 提供char数组，使用read方法读取数据【不推荐】</p>
<p>&ensp;&ensp;&ensp;&ensp;2.2 使用BufferedReader中独有的方法进行数据读取 —》 readLine方法【强烈推荐】</p>
<p> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;readLine这个方法是返回读取一次文本中内一行内容，这个方法的返回值是String</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.BufferedReaderAndBufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReaderDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建字符缓冲输入流BufferedReader对象</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/UFT-8文件.txt&quot;</span>)));</span><br><span class="line">        <span class="comment">//2.提供两种读取数据的方式</span></span><br><span class="line">        <span class="comment">//2.1 使用char数组的方式进行读取</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            char[] buf = new char[1024];</span></span><br><span class="line"><span class="comment">            int len;</span></span><br><span class="line"><span class="comment">            while((len = br.read(buf))!=-1)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(new String(buf,0,len));</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//2.1 使用 readLine进行数据读取，一次读取文件中一行内容</span></span><br><span class="line">        <span class="comment">//2.1.1 提供一个String类型变量接收读取到数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            readLine方法读取文件中每一个行内容时，一共有两种数据返回形态</span></span><br><span class="line"><span class="comment">            读取到数据就返回String类型字符串读，取到文件末尾就返回null值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">while</span>((content = br.readLine()) != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//可以在这个循环中对content得到String字符串数据即文件中读取到内容进行操作</span></span><br><span class="line">            System.out.println(content);</span><br><span class="line">        &#125; </span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）BufferedWriter缓冲字符输出流"><a href="#（3）BufferedWriter缓冲字符输出流" class="headerlink" title="（3）BufferedWriter缓冲字符输出流"></a>（3）BufferedWriter缓冲字符输出流</h3><p>BufferedWritrer缓冲字符输出流是Writer字符输出流子类，并且提供一个默认缓冲区大小为8192K，提供给包装普通字符输出流对象使用对字符输出流操作</p>
<h4 id="常用构造方法"><a href="#常用构造方法" class="headerlink" title="常用构造方法"></a>常用构造方法</h4><table>
<thead>
<tr>
<th align="center">常用构造方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BufferedWriter(Writer out) 创建一个使用默认大小输出缓冲区的缓冲字符输出流</td>
</tr>
<tr>
<td align="center">BufferedWriter(Writer out, int sz) 创建一个新的缓冲字符输出流，该流使用给定大小的输出缓冲区</td>
</tr>
</tbody></table>
<p>PS：BufferedWriter缓冲字符输出流是包装一个字符输出流对象，所以参数需要一个字符出流对象进行传入创建，并且可以设置默认缓冲区的大小，不建议低于8192K大小，提供设置默认值时要是1024的倍数</p>
<h4 id="常用API方法"><a href="#常用API方法" class="headerlink" title="常用API方法"></a>常用API方法</h4><table>
<thead>
<tr>
<th align="center">void</th>
<th align="center">write(String str) 写一个字符串【这个方法是专门应对readLine方法写出的】</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void</td>
<td align="center">newLine() 写行分隔符</td>
</tr>
</tbody></table>
<p>说明：</p>
<ol>
<li>BufferedWriter提供字符缓冲输出流操作，所以支持flush和close方法</li>
<li>BufferedWriter提供数据写出操作，提供两种方式应对BufferedReader的操作</li>
</ol>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2.1 如果BufferedReader使用是char类型数组进行数据读取操作BufferedWriter就提 ·writer(char[] buf,int off,int len)将数据写出</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2.2 如果BufferedReader使用是readLine这个方法进行数据读取操作者BufferedWriter就提供 write(String str) 将数据写出</p>
<p><strong>PS: 使用write(String str) 将数据写出时需要配合使用newLine()这个方法以保证写出文件正确格式</strong></p>
<p>需求： 使用缓冲字符输入输出流对象进行数据拷贝操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyFileDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span></span><br><span class="line">Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供缓冲字符输入输出流对象</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/UFT-8文件.txt&quot;</span>)));</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;desc/file文件.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//1.提供char数组方式进行写入写出操作</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            char[] buf = new char[1024];</span></span><br><span class="line"><span class="comment">            int len;</span></span><br><span class="line"><span class="comment">            while((len = br.read(buf))!=-1)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                bw.write(buf,0,len);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//2.使用newLine来进行数据写入写出操作</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((str = br.readLine()) != <span class="literal">null</span>)    <span class="comment">//readLine这个方式不读取换行操作，不读取回车&quot;\n&quot;</span></span><br><span class="line">        &#123;</span><br><span class="line">        </span><br><span class="line">            bw.write(str);</span><br><span class="line">            <span class="comment">//所以为了保证写出数据的格式完整性</span></span><br><span class="line">            bw.newLine(); <span class="comment">//添加换行操作即添加&quot;\n&quot;</span></span><br><span class="line">        &#125; </span><br><span class="line">        bw.flush();</span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:</p>
<p>&ensp;&ensp;&ensp;&ensp;Java中提供缓冲流的效率是远远高于普通（原始）流，因为缓冲流提供缓冲区操作，<strong>缓冲字节输入输出流针对是二进制文件【视频、音频、图片、压缩包】等等，缓冲字符输入输出流针对的是文本文件，主要完成就是将内存中数据写入到文件中，将文件中数据在读取会内容，提供这个操作</strong></p>
<p>案例：使用字符输入流从控台读取数据【不用Scanner】，写入到文件中【默认记录聊天数据】，写出数据时使用</p>
<p>System.out打印到文件中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.BufferedReaderAndBufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadScannerToFile</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//不使用Scanner进行数据操作</span></span><br><span class="line">        <span class="comment">//可以提供字符缓冲输入流进行控制台数据读取</span></span><br><span class="line">        <span class="comment">//之所以可以在控制台获取到数据主要是因为使用标准字节输入流--》System.in</span></span><br><span class="line">        <span class="comment">//如果使用这种方法获取数据方式很单一只有readLine</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用System这个类中 setOut方法改变打印数据流向--》标准输出流重定向</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//需要提供一个字节打印流对象，提供流输出数据位置</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;desc/聊天记录.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//修改打印流的流向</span></span><br><span class="line">        System.setOut(ps);</span><br><span class="line">        <span class="comment">//提供循环进行数据获取</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供一个Date对象获取当前时间</span></span><br><span class="line">            <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">            <span class="comment">//读取控制台数据</span></span><br><span class="line">            content = br.readLine();</span><br><span class="line">            <span class="comment">//约定如果输入886结束程序</span></span><br><span class="line">            <span class="keyword">if</span>(content.equals(<span class="string">&quot;886&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//就将数据写入到文件中</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> sdf.format(date);</span><br><span class="line">            <span class="comment">//System.out.println(time);</span></span><br><span class="line">            System.out.println(content);</span><br><span class="line">        &#125; </span><br><span class="line">        br.close();</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//ps:已经将System.out的输出指定到文件中，如果需要将输出在指定会控制台打印如何做？</span></span><br></pre></td></tr></table></figure>

<h2 id="3、资源文件Properties"><a href="#3、资源文件Properties" class="headerlink" title="3、资源文件Properties"></a><center>3、资源文件Properties</center></h2><p>Properties文件是继承与Hashtable，Properties文件中存储数据方式就是以【key-value键值对】进行，对这个文件操作是将需要使用数据存储在value中，提供key可以访问外界访问到key获取到需要value值</p>
<p>Properties文件是可以通过代码进行创建，也可以在外界直接创建这个文件但是文件后缀名必须【.properties】这个文件被称之为资源文件，可以向这个文件中提供一些常用的配置信息【JDBC链接信息，Spring的配置信息、SpringBoot配置信息】等等，这个文件默认编码集是ISO-8859-1，所以不支持使用代码的形式创建文件中出现中文，如果出现中文是以Unicode码进行展示的。直接创建文件是支持写入中文但是要以注释形式存在</p>
<p><strong>案例：使用流方式来创建Properties文件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesFileDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在控制台上获取一些数据，存储在properties文件中</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="comment">//文件后缀名字必须是.properties</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;dir/config.properties&quot;</span>));</span><br><span class="line">        <span class="comment">//1.提供Properties对象的创建</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//循环获取到控制台输入的数据</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入key值：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">            <span class="comment">//当key值获取到over的时候停止循环操作</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;over&quot;</span>.equals(key))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            System.out.println(<span class="string">&quot;请输入value值：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">            <span class="comment">//调用Properties中方法将key-value键值对存储到 Properties对象中</span></span><br><span class="line">            p.setProperty(key,value);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//将存储在Properties对象中数据写入到文件中，properties文件中 #号是注释的意思</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            store方法需要传递输出流对象【字符或字节都可以】</span></span><br><span class="line"><span class="comment">            第二个参数是 注释--》通过代码写出文件中文是无法正确展示的，所以建议使用英文</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        p.store(bw,<span class="string">&quot;我是注释!!!&quot;</span>);</span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：使用流读取Properties文件【常用】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="comment">//读取资源文件的工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesUtil</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.提供一个私有静态Properties对象获取文件中数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties properties;</span><br><span class="line">    <span class="comment">//2.加载文件操作一般都会提前加载，而不是当用户使用到时候在加载</span></span><br><span class="line">    <span class="keyword">static</span>    <span class="comment">//使用静态代码块进行资源加载，只会执行一次不会出现重复加载问题</span></span><br><span class="line">    &#123; </span><br><span class="line">        </span><br><span class="line">        properties = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            调用load方法加载资源文件，将资源文件中内容读取到properties对象中</span></span><br><span class="line"><span class="comment">            这个方法参数既可以是字节流也可以是字符流</span></span><br><span class="line"><span class="comment">            这个操作会存在编译时异常，static静态代码块中是不能throws，只能try-catch</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dir/config.properties&quot;</span>));</span><br><span class="line">        &#125; </span><br><span class="line">            <span class="keyword">catch</span> (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;资源文件加载失败，无法加载：&quot;</span>+e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        提供一个方法可以获取Properties资源文件中值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getValue</span><span class="params">(String key)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过key值获取到vlaue值        </span></span><br><span class="line">        <span class="keyword">return</span> properties.getProperty(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取用户名字请输入username:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> input.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> PropertiesUtil.getValue(username);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名：&quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结Properties核心方法：</p>
<ol>
<li>创建对象—》new Properties();</li>
<li>存储key和value键值对 —》setProperty(key,value)</li>
<li>创建Properties文件 —》 store(字节或字符输出流对象，”文件内容注释”)</li>
<li>读取Properties文件 —》 load(字节或字符输入流对象)</li>
<li>获取value值 —》 getProperty(key)</li>
</ol>
<h2 id="4、序列化和反序列化【对象流】"><a href="#4、序列化和反序列化【对象流】" class="headerlink" title="4、序列化和反序列化【对象流】"></a><center>4、序列化和反序列化【对象流】</center></h2><p>序列化和反序列化？</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>对象序列化</strong> : <strong>把一个【对象转换二进制数据】这种方式称之为序列化</strong>，序列化之后对象可以方便实现对象【<strong>存储与传输</strong>】</p>
<p><strong>&ensp;&ensp;&ensp;&ensp;对象反序列化</strong>：<strong>把一个【二进制数据转换成对象】这种方式称之为反序列化</strong>,通过反序列化操作就可以得到存储在文件中对象内的数据了</p>
<p><strong>Serializable接口</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;如果需要将某个对象进行序列化操作，那么这个对象描述类就需要实现<strong>Serializable接口</strong>，这样才可以允许对当前对象进行序列化和反序列化</p>
<p>&ensp;&ensp;&ensp;&ensp;API文档中对Serializable接口的说明： 类通过实现java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段，仅用于标识可序列化的语义</p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012018417.WebP" alt="兼容问题" style="zoom:50%;">

<h3 id="（1）对象字节输入输出流"><a href="#（1）对象字节输入输出流" class="headerlink" title="（1）对象字节输入输出流"></a>（1）对象字节输入输出流</h3><p>使用对象字节输入流读取文件称之为【反序列化】，从磁盘文件中将对象读取到内存使用是【ObjectInputStream】</p>
<p>使用对象字节输出流写出文件称之为【序列化】，从内存将对象写入到文件中使用是【ObjectOutputStream】</p>
<p><strong>ObjectOutputStream常用构造方法和常用方法</strong></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">常用构造方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center">ObjectOutputStream(OutputStream out)创建一个对象写入到指定的输出流，参数需要是一个字节输出流对象</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">常用方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void</td>
<td align="center">writeObject(Object obj) 将对象写入到对象流中【对象的序列化】</td>
</tr>
</tbody></table>
<p>因为需要将对象序列化到文件中所以构造方法中需要提供字节输出流对象，配套使用是FileOutputStream，核心方法就是序列化对象，所以使用writeObject方法，还支持很多其他的写入方法，但是使用较少，支持关闭和刷新流</p>
<p><strong>ObjectInputStream常用的构造方法和常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">常用构造方法</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectInputStream</span><span class="params">(InputStream in)</span></span><br><span class="line">创建一个对象输入流读取从指定的输入流，参数需要一个字节输入流对象</span><br><span class="line">常用方法</span><br><span class="line">Object <span class="title function_">readObject</span><span class="params">()</span> 从对象输入流读取对象【反序列化】 </span><br><span class="line">读取的是文件中内容，所以参数需要一个字节输入流对象，匹配使用是FileInputStream，核心方法就是反序列化对象，</span><br><span class="line">所以使用readObject这个方法，特别注意返回值类型时Object，这个流也需要关闭</span><br></pre></td></tr></table></figure>

<p>案例：单个对象序列和反序列化操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//java.io.NotSerializableException: com.qfedu.serializable.Student</span></span><br><span class="line">        <span class="comment">//出现这个异常原因是因为没有实现：Serializable接口</span></span><br><span class="line">        <span class="comment">// Student student = new Student(&quot;成龙&quot;,68);</span></span><br><span class="line">        <span class="comment">// serializableObject(student);</span></span><br><span class="line">        deSerializableObject();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        对象序列化操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serializableObject</span><span class="params">(Student student)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建序列化对象的流对象</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;dir/序列化单个对象的文件&quot;</span>));</span><br><span class="line">        <span class="comment">//2.代用writeObject方法进行序列化操作</span></span><br><span class="line">        oos.writeObject(student);</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化成功！&quot;</span>);</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        对象反序列化操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deSerializableObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供反序列化流对象</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dir/序列化单个对象的文件&quot;</span>));</span><br><span class="line">        <span class="comment">//2.调用readObject方法反序列化操作</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> ois.readObject();    <span class="comment">//这个方法返回值是Boject类型，如果需要对数据进行具体化操作需要对象向下转型</span></span><br><span class="line">        System.out.println(<span class="string">&quot;验证o对象是否是Student类型：&quot;</span>+(o <span class="keyword">instanceof</span> Student));</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：多个对象序列化和反序列化【创建5个Student对象进行序列化和反序列化操作要求在同一个文件中（一个文件5个对象）】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">//多个对象序列化与反序列化操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三1&quot;</span>,<span class="number">19</span>),<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三2&quot;</span>,<span class="number">20</span>), <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三3&quot;</span>,<span class="number">21</span>),</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三4&quot;</span>,<span class="number">22</span>), <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三5&quot;</span>,<span class="number">23</span>),<span class="literal">null</span>);<span class="comment">//追加null就是结尾证明没有数据了</span></span><br><span class="line">        <span class="comment">//serializableMoreObject(list);</span></span><br><span class="line">        <span class="comment">//deSerializableMoreObject();</span></span><br><span class="line">        <span class="comment">// --------------------------------------------------</span></span><br><span class="line">        <span class="comment">//serializableMoreObject2(list);</span></span><br><span class="line">        deSerializableMoreObject2();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供第一个处理方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serializableMoreObject</span><span class="params">(List&lt;Student&gt; list)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;dir/多个对象序列化文件&quot;</span>));</span><br><span class="line">        <span class="comment">//此时要序列化操作，但是现在所有的对象都是存在List集合中，所以直接序列化集合即可</span></span><br><span class="line">        <span class="comment">//这个操作只是取巧，不是多个对象序列化， 只是序列化了一个List集合对象</span></span><br><span class="line">        oos.writeObject(list);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deSerializableMoreObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dir/多个对象序列化文件&quot;</span>));</span><br><span class="line">        <span class="comment">//readObject这个方法的返回值是Object类型，所以需要操作数据时需要向下转型</span></span><br><span class="line">        List&lt;Student&gt; stus = ((List&lt;Student&gt;)ois.readObject());</span><br><span class="line">        <span class="keyword">for</span> (Student student : stus) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//----------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//第二种序列化和反序列化方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serializableMoreObject2</span><span class="params">(List&lt;Student&gt; list)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;dir/多个对象序列化文件2&quot;</span>));</span><br><span class="line">        <span class="comment">//此时要序列化操作，但是现在所有的对象都是存在List集合中，需要从集合中获取所有对象</span></span><br><span class="line">        <span class="keyword">for</span> (Student student : list) </span><br><span class="line">        &#123;</span><br><span class="line">            oos.writeObject(student); <span class="comment">//这样才是5对象序列化</span></span><br><span class="line">        &#125; </span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deSerializableMoreObject2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dir/多个对象序列化文件2&quot;</span>));</span><br><span class="line">        <span class="comment">//提供一个集合存储读取对象数据</span></span><br><span class="line">        List&lt;Student&gt; stus = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            readObject这个方法的返回值是Object类型，所以需要操作数据时需要向下转型</span></span><br><span class="line"><span class="comment">            因为文件中存储的5个对象，如果对象么有值使用什么代表--》null值</span></span><br><span class="line"><span class="comment">            利用这个原则进行数据读取操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用这种读取方式readObject提示一个EOFException含义</span></span><br><span class="line"><span class="comment">            此异常主要被数据输入流用来表明到达流的末尾</span></span><br><span class="line"><span class="comment">            证明是争取读取到文件中每一个数据并且读取到文件末尾，才会出现这个异常</span></span><br><span class="line"><span class="comment">            在while循环中提供判断是无法生效，它是无法获取到文件末尾的null，即没有这个null</span></span><br><span class="line"><span class="comment">            只能以异常形式停止，所以如何处理这个问题，会在集合存储的最后一个位置添加一个null作为结尾</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">while</span>((obj = ois.readObject())!=<span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stus.add(((Student)obj));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            while(true)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                try </span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    obj = ois.readObject();</span></span><br><span class="line"><span class="comment">                    stus.add(((Student)obj));</span></span><br><span class="line"><span class="comment">                &#125; </span></span><br><span class="line"><span class="comment">                catch (EOFException e) </span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    break;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ois.close();</span><br><span class="line">        stus.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author_group"><a class="post-copyright__author_img" href="/about/"><img class="post-copyright__author_img_front" src="/img/pwa/favicon.ico"></a><div class="post-copyright__author_name">星仔人生录</div><div class="post-copyright__author_desc">珍惜当下 不负此生</div></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div id="quit-box" onclick="RemoveRewardMask()"></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本文是原创文章，采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>协议，完整转载请注明来自<a href="/">星仔人生录</a></span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E8%AF%AD%E8%A8%80/"><span class="tags-punctuation"><i class="solitude fa-solid fa-hashtag"></i>Java语言<span class="tagsPageCount">26</span></span></a></div></div></div><nav class="needEndHide pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/fbc0ae86.html"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">24.多线程</div></div></a></div><div class="next-post pull-right"><a href="/post/8f9052f9.html"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">22.File类和递归</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><div class="author-info__top-group"><div class="author-info__sayhi" id="author-info__sayhi" onclick="sco.changeSayHelloText()">sayhello.morning</div></div></div><div class="avatar-img-group"><img class="avatar-img" alt="头像" src="/img/avatar.avif"></div><div class="author-info__description_group"><div class="author-info__description"></div><div class="author-info__description2"></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about/"><div class="author-info__name">星仔</div><div class="author-info__desc">珍惜当下 不负此生</div></a><div class="card-info-social-icons is-center"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="solitude fa-solid fa-bars"></i><span>文章目录</span></div><div class="toc-content" id="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80%EF%BC%9A%E6%A6%82%E5%BF%B5"><span class="toc-text">知识点一：概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C%EF%BC%9AJava%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%B8%B8%E7%94%A8IO%E6%B5%81"><span class="toc-text">知识点二：Java中提供常用IO流</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89%EF%BC%9A%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-text">知识点三：字节输入输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81InputStream%E3%80%90%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81%E3%80%91"><span class="toc-text">1、InputStream【字节输入流】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81FileInputSteam%E3%80%90%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81%E3%80%91"><span class="toc-text">2、FileInputSteam【文件字节输入流】</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">（1）核心构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%A0%B8%E5%BF%83API%E6%96%B9%E6%B3%95"><span class="toc-text">（2）核心API方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81OutputStream%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-text">3、OutputStream字节输出流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81FileOutputStream%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-text">4、FileOutputStream文件字节输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%A0%B8%E5%BF%83API%E6%96%B9%E6%B3%95"><span class="toc-text">（1）核心API方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%9B%BE%E7%89%87%E6%8B%B7%E8%B4%9D%E6%A1%88%E4%BE%8B"><span class="toc-text">5、图片拷贝案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E5%88%A9%E7%94%A8%E5%AD%97%E8%8A%82%E6%B5%81%E5%B0%86%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9%E8%BF%9B%E8%A1%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-text">6、利用字节流将文件中的内容进行拷贝赋值操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B%EF%BC%9A%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-text">知识点四：字符输入输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Reader%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-text">1、Reader字符输入流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81FileReader%E6%96%87%E4%BB%B6%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-text">2、FileReader文件字符输入流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%B8%B8%E7%94%A8API%E6%96%B9%E6%B3%95"><span class="toc-text">（1）常用API方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Writer%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-text">3、Writer字符输出流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81FileWriter%E6%96%87%E4%BB%B6%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-text">4、FileWriter文件字符输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">（1）常用构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%B8%B8%E7%94%A8API%E6%96%B9%E6%B3%95"><span class="toc-text">（2）常用API方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%93%8D%E4%BD%9C"><span class="toc-text">5、使用字符输入输出流进行文本文件的拷贝操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E8%BF%9B%E8%A1%8C%E5%9B%BE%E7%89%87%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%93%8D%E4%BD%9C"><span class="toc-text">6、使用字符输入输出流进行图片的拷贝操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%94%EF%BC%9A%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B9%8B%E9%97%B4%E5%8C%BA%E5%88%AB"><span class="toc-text">知识点五：字节流和字符流之间区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%85%AD%EF%BC%9A%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"><span class="toc-text">知识点六：字符编码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%83%EF%BC%9AInputStreamReader-%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-text">知识点七：InputStreamReader 字节字符转换输入流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%A0%B8%E5%BF%83%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">1、核心构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%A0%B8%E5%BF%83API%E6%96%B9%E6%B3%95"><span class="toc-text">2、核心API方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%85%AB%EF%BC%9AOutputStreamWriter-%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-text">知识点八：OutputStreamWriter 字节字符转换输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%A0%B8%E5%BF%83%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-1"><span class="toc-text">1、核心构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%A0%B8%E5%BF%83%E7%9A%84API%E6%96%B9%E6%B3%95"><span class="toc-text">2、核心的API方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%9D%EF%BC%9A%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-text">知识点九：缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-text">1、字节缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89BufferedInputStream%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">（1）BufferedInputStream常用构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89BufferedInputStream%E5%B8%B8%E7%94%A8API%E6%96%B9%E6%B3%95"><span class="toc-text">（2）BufferedInputStream常用API方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89BufferedOutputStream%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">（3）BufferedOutputStream常用构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89BufferedOutputStream%E5%B8%B8%E7%94%A8API%E6%96%B9%E6%B3%95"><span class="toc-text">（4）BufferedOutputStream常用API方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-text">2、字符缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89BufferedReader%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">（1）BufferedReader常用构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89BufferedReader%E5%B8%B8%E7%94%A8API%E6%96%B9%E6%B3%95"><span class="toc-text">（2）BufferedReader常用API方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89BufferedWriter%E7%BC%93%E5%86%B2%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-text">（3）BufferedWriter缓冲字符输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">常用构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8API%E6%96%B9%E6%B3%95"><span class="toc-text">常用API方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6Properties"><span class="toc-text">3、资源文件Properties</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E3%80%90%E5%AF%B9%E8%B1%A1%E6%B5%81%E3%80%91"><span class="toc-text">4、序列化和反序列化【对象流】</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%AF%B9%E8%B1%A1%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-text">（1）对象字节输入输出流</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="solitude fa-solid fa-map"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/bd740709.html" title="11.SPI通信"><img alt="11.SPI通信" src="https://img.picgo.net/2024/08/18/b00d09a505b4c64d80be90a32eefd8a84d5e1e15395f28e1.jpeg"></a><div class="content"><span class="title" href="/post/bd740709.html" title="11.SPI通信">11.SPI通信</span><span class="article-recent_post_categories" href="/post/bd740709.html">32单片机</span></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/acb77072.html" title="10.DMA"><img alt="10.DMA" src="https://img.picgo.net/2024/08/18/b00d09a505b4c64d80be90a32eefd8a84d5e1e15395f28e1.jpeg"></a><div class="content"><span class="title" href="/post/acb77072.html" title="10.DMA">10.DMA</span><span class="article-recent_post_categories" href="/post/acb77072.html">32单片机</span></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/52772f76.html" title="9.DAC(数字信号转模拟信号)"><img alt="9.DAC(数字信号转模拟信号)" src="https://img.picgo.net/2024/08/18/b00d09a505b4c64d80be90a32eefd8a84d5e1e15395f28e1.jpeg"></a><div class="content"><span class="title" href="/post/52772f76.html" title="9.DAC(数字信号转模拟信号)">9.DAC(数字信号转模拟信号)</span><span class="article-recent_post_categories" href="/post/52772f76.html">32单片机</span></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/f0812160.html" title="8.看门狗(WDG)"><img alt="8.看门狗(WDG)" src="https://img.picgo.net/2024/08/18/b00d09a505b4c64d80be90a32eefd8a84d5e1e15395f28e1.jpeg"></a><div class="content"><span class="title" href="/post/f0812160.html" title="8.看门狗(WDG)">8.看门狗(WDG)</span><span class="article-recent_post_categories" href="/post/f0812160.html">32单片机</span></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/e8bc8f26.html" title="7.实时时钟(RTC)"><img alt="7.实时时钟(RTC)" src="https://img.picgo.net/2024/08/18/b00d09a505b4c64d80be90a32eefd8a84d5e1e15395f28e1.jpeg"></a><div class="content"><span class="title" href="/post/e8bc8f26.html" title="7.实时时钟(RTC)">7.实时时钟(RTC)</span><span class="article-recent_post_categories" href="/post/e8bc8f26.html">32单片机</span></div></div></div></div></div></div></main><footer id="footer"><div id="footer_deal"></div><div id="st-footer"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div class="copyright">© 2023 - 2024 By&nbsp;<a class="footer-bar-link" href="/">星仔</a></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/everfu/hexo-theme-solitude" alt="Theme">Theme</a></div></div></div></footer></div><!-- right_menu--><!-- inject body--><div><script src="/js/utils.js?v=2.0.9"></script><script src="/js/main.js?v=2.0.9"></script><script src="/js/third_party/waterfall.min.js?v=2.0.9"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script><div class="js-pjax"></div></div><!-- pjax--><script>const pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: ['title','#body-wrap','#site-config','meta[name="description"]','.js-pjax','meta[property^="og:"]','#config-diff'],
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
})

document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
})

document.addEventListener('pjax:complete', () => {
    window.refreshFn()

    document.querySelectorAll('script[data-pjax]').forEach(item => {
        const newScript = document.createElement('script')
        const content = item.text || item.textContent || item.innerHTML || ""
        Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
        newScript.appendChild(document.createTextNode(content))
        item.parentNode.replaceChild(newScript, item)
    })

    GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

})

document.addEventListener('pjax:error', (e) => {
    if (e.request.status === 404) {
        pjax.loadUrl('/404.html')
    }
})</script><!-- theme--><script>initTheme = () => {
    let isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const cachedMode = utils.saveToLocal.get('theme');
    if (cachedMode === undefined) {
        const nowMode =
            isDarkMode ? 'dark' : 'light'
        document.documentElement.setAttribute('data-theme', nowMode);
    } else {
        document.documentElement.setAttribute('data-theme', cachedMode);
    }
    typeof rm === 'object' && rm.mode(cachedMode === 'dark' && isDarkMode)
}
initTheme()</script><!-- google adsense--><!-- search--><!-- Tianli-Talk--><!-- music--></body></html><script>const posts=["post/bd740709.html","post/acb77072.html","post/52772f76.html","post/f0812160.html","post/e8bc8f26.html","post/f5fba2c3.html","post/6928cd3f.html","post/bfd038f5.html","post/f71d0ad2.html","post/2c4c3bc3.html","post/b94c2cf2.html","post/a06b5fda.html","post/3e643b17.html","post/b7e3ace9.html","post/eb0bc4a3.html","post/a3ad0b3a.html","post/43a9b762.html","post/c4236caa.html","post/63d3dd68.html","post/32e9e993.html","post/362c3b0.html","post/adb202b7.html","post/99cd7d8.html","post/93c966f3.html","post/8212ff63.html","post/f5fba2c3.html","post/f736596e.html","post/2e5216dd.html","post/81b224e1.html","post/74750b31.html","post/f8f1fb54.html","post/c6b2a2fd.html","post/def84ee6.html","post/1f293ccb.html","post/79959306.html","post/5f6e69ef.html","post/d20e58f5.html","post/6c3f8114.html","post/2ec6e870.html","post/812d49a5.html","post/df95841.html","post/f1dbdc9f.html","post/5883a4af.html","post/fbc0ae86.html","post/3e1167ea.html","post/8f9052f9.html","post/a24af109.html","post/9e25cba9.html","post/a920af81.html","post/fe7ab1f0.html","post/76fa8c0d.html","post/86a3300e.html","post/6749388c.html","post/43a94ea1.html","post/ded373.html","post/74955f2f.html","post/75e75572.html","post/6a2c2bbd.html","post/5c2f197a.html","post/4a789563.html","post/c46a5cd3.html","post/1b3fd879.html","post/26831432.html","post/3cc3da73.html","post/fbc82303.html","post/3ccb602.html","post/ca0fcd03.html","post/6ac19130.html","post/8c9aed93.html","post/66861d4a.html","post/de801b7c.html","post/ee96f7a4.html","post/a8259cf6.html","post/2d17b932.html","post/57da986d.html","post/a0b1b02e.html","post/72b1c7b1.html","post/17bf8c68.html","post/7821492f.html","post/cf0c504a.html","post/e2246be5.html","post/9b06d854.html","post/5bdb5548.html","post/bec635c1.html","post/3ec1fd44.html","post/b70ae4e7.html","post/804ae251.html","post/df718222.html","post/3b48d11a.html","post/7422213c.html","post/6271a51c.html","post/6f76074c.html","post/8212f318.html","post/cb87841d.html","post/b2041fc0.html"];function toRandomPost(){ pjax.loadUrl(GLOBAL_CONFIG.root+posts[Math.floor(Math.random()*posts.length)]); }</script>