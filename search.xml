<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0.Java概述</title>
    <url>/post/ca0fcd03.html</url>
    <content><![CDATA[<h1><center>IDEA快捷键</center></h1>
<p>1、类名写错 ：alt+回车键</p>
<p>2、选中全部：ctrl+shift + 选中范围最后一个</p>
<p>3、面向对象创建：alt + INS  或  右键选 Generate（一键三连）(JavaBean)</p>
<p>    进入后：选Constructor  + 选全部 + ok ==&gt; 生成全参构造方法</p>
<p>    进入后：选Constructor  + 不用选 + Select None ==&gt; 生成无参构造</p>
<p>    进入后：选Getter and Setter  + 选全部 + ok ==&gt; 生成公共访问</p>
<p>    进入后：选toString + 选全部 + ok ==&gt;生成重写父类的toString方法</p>
<p>4、打开计算器：win + R  输入  calc</p>
<p>5、若子类继承父类，在子类中可以直接打父类里面有的方法名，会直接生成重写方法格式</p>
<p>6、快速生成main方法 有两个快捷输入 psvm 或者 main</p>
<p>7、多行批量编辑</p>
<p>    shift+alt 快捷键组合加上鼠标点击每行需要修改的起始位置（这个适合数据量比较少的情况）</p>
<p>    鼠标中键可以拉选多行，然后就可以做批量的编辑和修改了（数据量大的情况下真的很实用）</p>
<p>8、替换：ctrl+R：上面是要替换掉的数据，下面是要替换的数据</p>
<p>9、Java命令窗口编译及运行</p>
<p>    进入Java文件目录 --》javac 文件名.java(源文件) --》生成class文件(字节码文件) --》java 文件名</p>
<h1><center>JDK安装目录介绍</center></h1>
<table>
<thead>
<tr>
<th style="text-align:center">目录名称</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bin</td>
<td style="text-align:center">该路径下存放了JDK的各种工具命令。javac和java就放在这个目录</td>
</tr>
<tr>
<td style="text-align:center">conf</td>
<td style="text-align:center">该路径下存放了JDK的相关配置文件</td>
</tr>
<tr>
<td style="text-align:center">include</td>
<td style="text-align:center">该路径下存放了一些平台特定的头文件</td>
</tr>
<tr>
<td style="text-align:center">jmods</td>
<td style="text-align:center">该路径下存放了JDK的各种模块</td>
</tr>
<tr>
<td style="text-align:center">legal</td>
<td style="text-align:center">该路径下存放了JDK各模块的授权文档</td>
</tr>
<tr>
<td style="text-align:center">lib</td>
<td style="text-align:center">该路径下存放了JDK工具的一些补充JAR包</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Java语言</category>
      </categories>
      <tags>
        <tag>Java语言</tag>
      </tags>
  </entry>
  <entry>
    <title>1.Java基本语法</title>
    <url>/post/fbc82303.html</url>
    <content><![CDATA[<p>项目中各层说明</p>
<img src="https://s2.loli.net/2024/09/23/E31GNSbztWRh7Ly.png" alt="说明" style="zoom:40%;">
<h1><center>注释、关键字及命名规则</center></h1>
<p><code>类</code>可以简单理解成一个<code>Java程序</code></p>
<p>Java严格区分大小写</p>
<blockquote>
<p>行注释</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注释内容....</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>块注释</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注释内容....</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>文档注释</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 标识作者</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 标识版本</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//@return 标识方法返回值 @param 标识方法参数</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>标签</strong></th>
<th style="text-align:center"><strong>描述</strong></th>
<th style="text-align:center"><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>@author</strong></td>
<td style="text-align:center"><strong>标识一个类的作者</strong></td>
<td style="text-align:center"><strong>@author  description</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>@deprecated</strong></td>
<td style="text-align:center"><strong>指名一个过期的类或成员</strong></td>
<td style="text-align:center"><strong>@deprecated  description</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>{@docRoot}</strong></td>
<td style="text-align:center"><strong>指明当前文档根目录的路径</strong></td>
<td style="text-align:center"><strong>Directory  Path</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>@exception</strong></td>
<td style="text-align:center"><strong>标志一个类抛出的异常</strong></td>
<td style="text-align:center"><strong>@exception  exception-name explanation</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>{@inheritDoc}</strong></td>
<td style="text-align:center"><strong>从直接父类继承的注释</strong></td>
<td style="text-align:center"><strong>Inherits a  comment from the immediate surperclass.</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>{@link}</strong></td>
<td style="text-align:center"><strong>插入一个到另一个主题的链接</strong></td>
<td style="text-align:center"><strong>{@link  name text}</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>{@linkplain}</strong></td>
<td style="text-align:center"><strong>插入一个到另一个主题的链接，但是该链接显示纯文本字体</strong></td>
<td style="text-align:center"><strong>Inserts an  in-line link to another topic.</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>@param</strong></td>
<td style="text-align:center"><strong>说明一个方法的参数</strong></td>
<td style="text-align:center"><strong>@param  parameter-name explanation</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>@return</strong></td>
<td style="text-align:center"><strong>说明返回值类型</strong></td>
<td style="text-align:center"><strong>@return  explanation</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>@see</strong></td>
<td style="text-align:center"><strong>指定一个到另一个主题的链接</strong></td>
<td style="text-align:center"><strong>@see  anchor</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>@serial</strong></td>
<td style="text-align:center"><strong>说明一个序列化属性</strong></td>
<td style="text-align:center"><strong>@serial  description</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>@serialData</strong></td>
<td style="text-align:center"><strong>说明通过writeObject( ) 和 writeExternal( )方法写的数据</strong></td>
<td style="text-align:center"><strong>@serialData  description</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>@serialField</strong></td>
<td style="text-align:center"><strong>说明一个ObjectStreamField组件</strong></td>
<td style="text-align:center"><strong>@serialField  name type description</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>@since</strong></td>
<td style="text-align:center"><strong>标记当引入一个特定的变化时</strong></td>
<td style="text-align:center"><strong>@since  release</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>@throws</strong></td>
<td style="text-align:center"><strong>和  @exception标签一样.</strong></td>
<td style="text-align:center"><strong>The  @throws tag has the same meaning as the @exception tag.</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>{@value}</strong></td>
<td style="text-align:center"><strong>显示常量的值，该常量必须是static属性</strong></td>
<td style="text-align:center"><strong>Displays  the value of a constant, which must be a static field.</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>@version</strong></td>
<td style="text-align:center"><strong>指定类的版本</strong></td>
<td style="text-align:center"><strong>@version  info</strong></td>
</tr>
</tbody>
</table>
<blockquote>
<p>关键字</p>
</blockquote>
<img src="https://p26-juejin-sign.byteimg.com/tos-cn-i-k3u1fbpfcp/4b397f1ddbc6438eaa994aa3bfc141de~tplv-k3u1fbpfcp-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6:q75.awebp?rk3s=bb34011d&x-expires=1727144826&x-signature=Ckvid%2F1lBQMCspJpKzLxhaiXG3I%3D" alt="关键字" style="zoom: 67%;">
<blockquote>
<p>命名规则</p>
</blockquote>
<blockquote>
<p>包名：小写</p>
<p>类名和接口：首字母大写</p>
<p>常量名：所有字母大写</p>
<p>变量名、方法名：第一个单词首字母小写，第二个单词字母开始首字母大写</p>
</blockquote>
<h1><center>数据类型</center></h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//整数类型</span></span><br><span class="line"><span class="type">byte</span> <span class="number">1</span>字节、<span class="type">short</span> <span class="number">2</span>字节、<span class="type">int</span> <span class="number">4</span>字节</span><br><span class="line"><span class="type">long</span> <span class="number">8</span>字节(<span class="type">long</span>类型数据需要在最后添加  L、l)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//浮点类型</span></span><br><span class="line"><span class="type">float</span> 单精度(<span class="type">float</span>类型数据需要在最后添加  F、f)</span><br><span class="line"><span class="type">double</span> 双精度(浮点数默认是<span class="type">double</span>类型)</span><br><span class="line"><span class="comment">//字符型</span></span><br><span class="line"><span class="type">char</span></span><br><span class="line"><span class="comment">//字符串常量</span></span><br><span class="line"><span class="string">&quot;helloworld&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//布尔类型</span></span><br><span class="line"><span class="type">boolean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引用类型</span></span><br><span class="line"><span class="comment">//在一切用 &quot;&quot; 包裹起来的类型都是String类型（也就是表示字符串）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>空白符号：’\u0000’</p>
</blockquote>
<h1><center>类型转换</center></h1>
<h2 id="强制类型转换">强制类型转换</h2>
<blockquote>
<p>定义</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(目标类型)变量名;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> a;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">a = (<span class="type">byte</span>)b;</span><br></pre></td></tr></table></figure>
<h2 id="基本数据类型和-string-类型转换">基本数据类型和 String 类型转换</h2>
<blockquote>
<p>在将 String 类型转成 基本数据类型时，比如 我们可以把 “123” , 转成一个整数，但是不能把 “hello” 转成一个整数</p>
</blockquote>
<p>定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本类型转String类型</span></span><br><span class="line">基本类型的值 + <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//String类型转基本类型</span></span><br><span class="line">调用包装类 parseXX 方法</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringToBasic</span> &#123;</span><br><span class="line">    <span class="comment">//编写一个 main 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//基本数据类型-&gt;String</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1.1F</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">4.5</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> n1 + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> f1 + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> d1 + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> b1 + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        System.out.println(s1 + <span class="string">&quot; &quot;</span> + s2 + <span class="string">&quot; &quot;</span> + s3 + <span class="string">&quot; &quot;</span> + s4);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//String-&gt;对应的基本数据类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        <span class="comment">//会在 OOP 讲对象和方法的时候讲详细</span></span><br><span class="line">        <span class="comment">//解读 使用 基本数据类型对应的包装类的相应方法，得到基本数据类型</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(s5);</span><br><span class="line">        <span class="type">double</span> <span class="variable">num2</span> <span class="operator">=</span> Double.parseDouble(s5);</span><br><span class="line">        <span class="type">float</span> <span class="variable">num3</span> <span class="operator">=</span> Float.parseFloat(s5);</span><br><span class="line">        <span class="type">long</span> <span class="variable">num4</span> <span class="operator">=</span> Long.parseLong(s5);</span><br><span class="line">        <span class="type">byte</span> <span class="variable">num5</span> <span class="operator">=</span> Byte.parseByte(s5);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        <span class="type">short</span> <span class="variable">num6</span> <span class="operator">=</span> Short.parseShort(s5);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">        System.out.println(num1);<span class="comment">//123</span></span><br><span class="line">        System.out.println(num2);<span class="comment">//123.0</span></span><br><span class="line">        System.out.println(num3);<span class="comment">//123.0</span></span><br><span class="line">        System.out.println(num4);<span class="comment">//123</span></span><br><span class="line">        System.out.println(num5);<span class="comment">//123</span></span><br><span class="line">        System.out.println(num6);<span class="comment">//123</span></span><br><span class="line">        System.out.println(b);<span class="comment">//true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//怎么把字符串转成字符 char -&gt; 含义是指 把字符串的第一个字符得到</span></span><br><span class="line">        <span class="comment">//解读 s5.charAt(0) 得到 s5 字符串的第一个字符 &#x27;1&#x27;</span></span><br><span class="line">        System.out.println(s5.charAt(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>运算符</center></h1>
<h2 id="逻辑运算符">逻辑运算符</h2>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">范例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">与</td>
<td style="text-align:center">t&amp;t=t 其它f</td>
</tr>
<tr>
<td style="text-align:center">|</td>
<td style="text-align:center">或</td>
<td style="text-align:center">只要有t则t</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">异或</td>
<td style="text-align:center">t^t=f t^f = t 不同为t</td>
</tr>
<tr>
<td style="text-align:center">!</td>
<td style="text-align:center">非</td>
<td style="text-align:center">取反</td>
</tr>
<tr>
<td style="text-align:center">&amp;&amp;</td>
<td style="text-align:center">短路与</td>
<td style="text-align:center">t&amp;t=t 其它f</td>
</tr>
<tr>
<td style="text-align:center">||</td>
<td style="text-align:center">短路或</td>
<td style="text-align:center">只要有一个t则t</td>
</tr>
</tbody>
</table>
<blockquote>
<p>&amp;&amp;短路与： 如果第一个条件为 false，则第二个条件不会判断，最终结果为 false，效率高</p>
<p>||短路或：如果第一个条件为 true，则第二个条件不会判断，最终结果为 true，效率高</p>
</blockquote>
<h1><center>变量、方法定义与使用</center></h1>
<h2 id="变量">变量</h2>
<blockquote>
<p>定义与初始化</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line">数据类型 变量名;</span><br><span class="line">数据类型 变量<span class="number">1</span>，变量<span class="number">2</span>，变量<span class="number">3.</span>..;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">数据类型 变量名 = 数据;   <span class="comment">//第一种</span></span><br><span class="line">数据类型 变量名<span class="number">1</span> = 值，变量名<span class="number">2</span> = 值， 变量名<span class="number">3</span> = 值...;</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line">数据类型 变量名;</span><br><span class="line">变量名 = 数据;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int x = 0,y;</span><br><span class="line">y = 12；</span><br></pre></td></tr></table></figure>
<h2 id="成员方法">成员方法</h2>
<blockquote>
<p>定义</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问权限修饰符 (其他修饰符) 返回值类型 方法名(参数类型 形参名<span class="number">1</span>, 参数类型 形参名<span class="number">2</span>,....)&#123;</span><br><span class="line">    执行语句;</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printRectangle</span><span class="params">(<span class="type">int</span> height, <span class="type">int</span> width)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造方法">构造方法</h2>
<blockquote>
<p>注意：</p>
<p><code>构造方法名称</code>必须与<code>类名</code>一致</p>
<p>构造方法名称前不能有任何返回类型的声明</p>
<p>不能在构造方法中使用return返回一个值，但可以单独写return语句作为方法结束</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//带参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String n, <span class="type">int</span> a)</span>&#123;</span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了有参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//普通方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是:&quot;</span>+name+<span class="string">&quot;,年龄:&quot;</span>+age<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example06</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []age)</span>&#123;</span><br><span class="line">        <span class="comment">//实例化Student对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">//this关键字调用read成员方法</span></span><br><span class="line">        stu.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Java中每个类<code>至少</code>有一个构造方法，如果在一个类中没有定义构造方法，系统会自动为这个类创建一个默认的构造方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种==第二种</span></span><br></pre></td></tr></table></figure>
<h2 id="方法重载">方法重载</h2>
<blockquote>
<p>每个方法的方法签名是唯一【方法签名 == 方法名+参数列表】</p>
<p>重载：方法名相同，参数列表不同（只要满足其一即可：“参数定义类型不同、参数定义个数不同、参数定义顺序不同”）</p>
<p>作用：减少同样逻辑方法名字的定义（就是方法参数不同，实现逻辑是一样的）编译器会自动选择最合适方法进行操作</p>
</blockquote>
<p>使用重载，完成两个数的求和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverloadMethodDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//只需要记忆getSum这个方法可以求得两个数据之和就可以了</span></span><br><span class="line">        <span class="comment">//IDEA就会动态选择合适方法提供给我们调用实现，这样就可以减少程序员对方法名字记忆，方法调用</span></span><br><span class="line">        getSum(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提供一个方法，求两个数的和。getSum这个方法就发生重载，方法名字相同，但参数列表定义不同</span></span><br><span class="line">    <span class="comment">//设置参数尽量都是同时一个数据类型，这样可以避免出现二义性问题 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getSum</span><span class="params">(<span class="type">double</span> d1,<span class="type">double</span> d2)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d1+d2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法递归">方法递归</h2>
<blockquote>
<p>递归：在方法内部再次调用自身方法</p>
<p>注意：设置有效的出口条件，可以让调用链上的每个方法都可以正确返回，避免无穷递归</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求某个数的阶乘 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> jc(<span class="number">5</span>);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">jc</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num * jc(num-<span class="number">1</span>);  <span class="comment">//jc()相当于调用(重复调用达到循环效果)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>可变参数</center></h1>
<blockquote>
<p>参数的个数是动态的，可有可没有，可以多个</p>
<p>必须放在参数列表末尾（即一个方法只能有一个可变参数）</p>
<p>可以直接当做是一个数组来使用（可变参数不能等同于数组）</p>
</blockquote>
<p>定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型... 参数名 </span><br></pre></td></tr></table></figure>
<p>使用：定义方法求和，参数个数不确定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo7</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果传递null，在方法内部使用，容易出现“NullPointerException”</span></span><br><span class="line">        <span class="comment">//showInfosIntArray(null);    //err：NullPointerException</span></span><br><span class="line">        <span class="comment">//外界调用可变参数方法时：</span></span><br><span class="line">        showInfosIntArray2(<span class="literal">true</span>); <span class="comment">//可变参数不赋值</span></span><br><span class="line">        showInfosIntArray2(<span class="literal">false</span>,<span class="number">1</span>);<span class="comment">//赋值一个参数</span></span><br><span class="line">        showInfosIntArray2(<span class="literal">true</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);<span class="comment">//赋值多个</span></span><br><span class="line">        showInfosIntArray2(<span class="literal">false</span>,<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;); <span class="comment">//允许赋值数组</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供一个方法 方法参数类型是一个int类型数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showInfosIntArray</span><span class="params">(<span class="type">int</span>[] arr)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在方法中使用可变参数需要注意：</span></span><br><span class="line"><span class="comment">        1. 一个方法中参数列表只允许定义一个可变参数</span></span><br><span class="line"><span class="comment">        2. 定义可变参数必须在参数列表中 定义的最后一个位置</span></span><br><span class="line"><span class="comment">        3. 可变参数定义语法: 数据类型... 变量名</span></span><br><span class="line"><span class="comment">        4. 允许使用一维数组进行赋值操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showInfosIntArray2</span><span class="params">(<span class="type">boolean</span> res,<span class="type">int</span>... arr)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//可变参数在方法内部的操作就是数组操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>类定义与调用</center></h1>
<blockquote>
<p>定义</p>
</blockquote>
<blockquote>
<p>访问控制权限</p>
</blockquote>
<table>
<thead>
<tr>
<th>控制符</th>
<th>访问范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>privat</td>
<td>同个类</td>
</tr>
<tr>
<td>default</td>
<td>同个类、同个包中的类</td>
</tr>
<tr>
<td>protected</td>
<td>同个类、同个包中的类、不同包的子类</td>
</tr>
<tr>
<td>public</td>
<td>同个类、同个包中的类、不同包的子类、全局范围</td>
</tr>
</tbody>
</table>
<blockquote>
<p>一个源文件中，只能有一个公开类(public)</p>
<p><strong>public修饰的类名只能与源文件名相同</strong></p>
<p>一个类中，只能有一个主方法，每个类都可以有自己的主方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类定义</span></span><br><span class="line">修饰符 class 类名&#123;</span><br><span class="line">    成员变量;</span><br><span class="line">    成员方法;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象创建与使用</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br><span class="line"><span class="comment">//创建对象后，访问对象属性和方法的使用</span></span><br><span class="line">对象名.属性名</span><br><span class="line">对象名.方法名</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    string sex;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;大家好);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">//对象创建与使用</span></span><br><span class="line"><span class="string">Student stu = new Student();</span></span><br><span class="line"><span class="string">//创建对象后，访问对象属性和方法使用</span></span><br><span class="line"><span class="string">stu.name = &quot;</span>小明<span class="string">&quot;;</span></span><br><span class="line"><span class="string">stu.read();</span></span><br></pre></td></tr></table></figure>
<h1><center>包的定义</center></h1>
<p>采用域名倒置的规则：<a href="http://www.baidu.com">www.baidu.com</a> -&gt; <a href="http://com.baidu.xxx">com.baidu.xxx</a></p>
<h1><center>选择循环语句</center></h1>
<h2 id="选择语句">选择语句</h2>
<p>if和switch</p>
<h3 id="if">if</h3>
<blockquote>
<p>定义</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//形式1</span></span><br><span class="line"><span class="keyword">if</span>(判断条件)&#123;</span><br><span class="line">    执行语句;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//形式2</span></span><br><span class="line"><span class="keyword">if</span>(判断条件)&#123;</span><br><span class="line">    执行语句<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    执行语句<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//形式3</span></span><br><span class="line"><span class="keyword">if</span>(判断条件<span class="number">1</span>)&#123;</span><br><span class="line">    执行语句<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(判断条件<span class="number">2</span>)&#123;</span><br><span class="line">    执行语句<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    执行语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//形式1</span></span><br><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">10</span>)&#123;</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//形式2</span></span><br><span class="line"><span class="keyword">if</span>(num % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;num为偶数&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;num为奇数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//形式3</span></span><br><span class="line"><span class="keyword">if</span>(grade &gt; <span class="number">80</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;成绩优&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(grade &gt; <span class="number">70</span>)&#123;</span><br><span class="line">    <span class="comment">//不满足grade&gt;80,但 满足条件grade&gt;70</span></span><br><span class="line">    System.out.println(<span class="string">&quot;成绩良&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;成绩差&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三元运算符">三元运算符</h3>
<blockquote>
<p>定义</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//判断条件为真执行 表达式1 为假执行表达式2</span><br><span class="line">判断条件?表达式1:表达式2;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> x&gt;y?x:y;  <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<h3 id="switch">switch</h3>
<blockquote>
<p>定义</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 目标值<span class="number">1</span>:</span><br><span class="line">        执行语句<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 目标值<span class="number">2</span>:</span><br><span class="line">        执行语句<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        执行语句n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">week</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">switch</span>(week)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">//判断case后数字哪个等于5执行哪个</span></span><br><span class="line">        System.out.println(<span class="string">&quot;星期一&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;星期二&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//都不为5，则执行这个</span></span><br><span class="line">        System.out.println(<span class="string">&quot;输入不正确&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h2 id="循环语句">循环语句</h2>
<h2 id="while">while</h2>
<blockquote>
<p>定义</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件)&#123;</span><br><span class="line">    执行语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(x &lt;= <span class="number">4</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;x = &quot;</span> + x);</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="do-while">do…while</h3>
<blockquote>
<p>定义</p>
</blockquote>
<p>至少运行循环内代码一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    执行语句;</span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;成绩差&quot;</span>);</span><br><span class="line">    x++;</span><br><span class="line">&#125;<span class="keyword">while</span>(x &lt;= <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<h3 id="for">for</h3>
<blockquote>
<p>定义</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式; 循环条件; 操作表达式)&#123;</span><br><span class="line">    执行语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">4</span>; i++)&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="增强for循环">增强for循环</h2>
<blockquote>
<p>增强for循环只适合简单打印和计算，不适合对数据中值进行改变操作（增删改查）</p>
<p>在idea中快捷键：<code>数组名.for+回车</code></p>
</blockquote>
<p>定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(数组元素数据类型 变量名 : 数组名字)&#123;</span><br><span class="line">	<span class="comment">//此时for循环中小括号中变量会分别获取数组每一个数据的值，可以在循环体内操作这个变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> a:arr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//a变量就会获取数组中每一个数据值</span></span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>数组</center></h1>
<p>定义：数组在内存中是一块 连续的空间，可以保存 相同类型 多个数据的容器</p>
<h2 id="一维数组">一维数组</h2>
<blockquote>
<p>定义及初始化</p>
<p>数组下标范围为：0 ~ <code>数组长度-1</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不初始化时，不同类型默认初始值不同</span></span><br><span class="line"></span><br><span class="line">类型 [] 数组名 = &#123;元素, 元素, ....&#125;;   <span class="comment">//方法一</span></span><br><span class="line">类型 [] 数组名 = <span class="keyword">new</span> 类型[]&#123;元素, 元素, ....&#125;;  <span class="comment">//方法二</span></span><br><span class="line"><span class="comment">//方法三</span></span><br><span class="line">类型 [] 数组名 = <span class="keyword">new</span> 类型[长度];</span><br><span class="line">数组名[第几个] = 元素;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="type">int</span> [] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="type">int</span> [] arr = <span class="keyword">new</span> <span class="title class_">int</span> arr[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法三</span></span><br><span class="line"><span class="type">int</span> [] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>获得数组长度</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line">数组名.length</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">arr.length</span><br></pre></td></tr></table></figure>
<blockquote>
<p>数组遍历</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> [] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>数组长度获取：数组名.length</p>
</blockquote>
<h2 id="二维数组">二维数组</h2>
<blockquote>
<p>定义</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line">数据类型 [][] 数组名 = <span class="keyword">new</span> 数据类型[行数][列数];</span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line">数据类型 [][] 数组名 = <span class="keyword">new</span> 数据类型[行数][];</span><br><span class="line"><span class="comment">//方法三</span></span><br><span class="line">数据类型 [][] 数组名 = &#123;&#123;第<span class="number">0</span>行初始值&#125;, &#123;第一行初始值&#125;, &#123;第三行初始值&#125;&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="type">int</span> [][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="type">int</span> [][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">11</span>, <span class="number">12</span>&#125;;</span><br><span class="line"><span class="comment">//方法三</span></span><br><span class="line"><span class="type">int</span> [][] arr = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;, &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>遍历</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) <span class="comment">//遍历每个一维数组（行数）</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) <span class="comment">//遍历一维数组的元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(arr[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组拷贝">数组拷贝</h2>
<h3 id="system类拷贝方法">System类拷贝方法</h3>
<p>定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.arraycopy(src,srcPos,dest,destPos,length);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数说明：</span></span><br><span class="line"><span class="comment">    src：原数组</span></span><br><span class="line"><span class="comment">    srcPos：指定原数组的起始地址</span></span><br><span class="line"><span class="comment">    dest：目标数组</span></span><br><span class="line"><span class="comment">    destPos：目标起始位置</span></span><br><span class="line"><span class="comment">	length：拷贝元素的个数*/</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">11</span>,<span class="number">33</span>,<span class="number">66</span>&#125;;</span><br><span class="line">        <span class="type">int</span> newArr[] = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length+<span class="number">5</span>];</span><br><span class="line">        System.arraycopy(arr,<span class="number">1</span>,newArr,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; newArr.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(newArr[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="arrays类拷贝方法">Arrays类拷贝方法</h3>
<p>定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">新数组类型 新数组名 = Arrays.copyOf(original,newLength);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数说明：</span></span><br><span class="line"><span class="comment">    original：原数组</span></span><br><span class="line"><span class="comment">    newLength：新数组的长度</span></span><br><span class="line"><span class="comment">    返回值：返回新数组*/</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">11</span>,<span class="number">33</span>,<span class="number">66</span>&#125;;</span><br><span class="line">        <span class="type">int</span> newArr[] = Arrays.copyOf(arr,arr.length+<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; newArr.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(newArr[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="arrays工具类排序">Arrays工具类排序</h2>
<blockquote>
<p>String排序规则：每一个字符在Unicode码表中都对应有一个数据</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Arrays工具类的使用【常用方法】</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraysDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Arrays工具类中方法都是使用static修饰</span></span><br><span class="line"><span class="comment">            如果使用static修饰方法在同一个类中（文件）调用是可以直接使用方法名方式进行调用</span></span><br><span class="line"><span class="comment">            如果使用static修饰方法在不同类中（文件）调用此时就需要明确这个方法出自于那个类</span></span><br><span class="line"><span class="comment">            方式：类名.静态方法(参数赋值操作);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//1. toString方法 ---》可以将数组中内容转换为字符串形式可以方便打印查看</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];	<span class="comment">//提供一个int类型数组，数组存储一些数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//强转int，Math.random：产生随机数</span></span><br><span class="line">            arr[i] = (<span class="type">int</span>)(Math.random()*<span class="number">100</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;数组中存储的数据是：&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.对数组中数据提供排序操作 参数就是排序的数组</span></span><br><span class="line">        Arrays.sort(arr); <span class="comment">//默认是升序</span></span><br><span class="line">        System.out.println(<span class="string">&quot;排序之后数组中数据是：&quot;</span>+Arrays.toString(arr));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这个方法是可以降序的，但是以现在所学暂时做不到，所以降序排序还是需要提供【选择或冒泡】排序</span></span><br><span class="line"><span class="comment">            如果使用这个方法进行降序排序，需要实现一个Comparator接口指定排序规则才可以降序操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            3.提供二分查找【使用这个方法之前必须对数组进行排序操作，如果在数组中找到数据则返回对应数据下标</span></span><br><span class="line"><span class="comment">            如果找不到数据就返回一个负数】</span></span><br><span class="line"><span class="comment">            第一个参数：要查找的数组</span></span><br><span class="line"><span class="comment">            第二个参数：要在数组中查找的数据</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr, <span class="number">55</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;55这个数据是否存在arr数组中？&quot;</span>+(index &gt;= <span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            4. 这个方法更加便捷进行数组的扩容 和 减容操作</span></span><br><span class="line"><span class="comment">            copyOf 提供一个可以对数据进行复制（数组中内容）的方法，并且这个方法会得到一个返回</span></span><br><span class="line"><span class="comment">            值【新的数组】</span></span><br><span class="line"><span class="comment">            第一个参数是要复制的数组</span></span><br><span class="line"><span class="comment">            第二个参数是要新数组长度</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span>[] ints = Arrays.copyOf(arr, <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;复制arr数组之后的全新数组ints中的内容：&quot;</span>+Arrays.toString(ints));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            5. 可以使用这个方法对数据中某个范围数据进行复制并生成一个全新数组</span></span><br><span class="line"><span class="comment">            PS:复制位置是数据下标位置</span></span><br><span class="line"><span class="comment">            第一个参数是复制的数组</span></span><br><span class="line"><span class="comment">            第二个参数是从那个下标位置开始复制（这个位置是包含在内）</span></span><br><span class="line"><span class="comment">            第三个参数是到那个下标位置结束复制（这个位置是不包含在内）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span>[] ints1 = Arrays.copyOfRange(arr, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println(Arrays.toString(ints1));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            6. 如何判断两个数组是相等的</span></span><br><span class="line"><span class="comment">            数组是引用类型，所以判断引用类型是否相等是不可以使用 基本数据类型中使用 == 进行比较操作</span></span><br><span class="line"><span class="comment">            如果使用 == 比较两个引用类型，那么比较就是引用类型【实际在内存中地址】</span></span><br><span class="line"><span class="comment">            如果两个引用类型都是new出来，地址是不会相等，所有引用类型是不可以使用 == 进行比较作</span></span><br><span class="line"><span class="comment">            所以需要比较两个引用类型是否相等，就需要使用到Java中所提供equals方法</span></span><br><span class="line"><span class="comment">            即如果两个数组中存储数据 个数和内容是完全一样，那么equals方法就会认为这两个数组是相等</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] arr2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用 == 比较arr1和arr2是否相等？&quot;</span>+ (arr1 == arr2));</span><br><span class="line">        System.out.println(<span class="string">&quot;使用equals方法比较arr1和arr2是否相等？&quot;</span>+Arrays.equals(arr1,arr2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>this关键字</center></h1>
<h2 id="this关键字调用本类中的属性">this关键字调用本类中的属性</h2>
<blockquote>
<p>使用this关键字制定当前对象属性</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//带参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//使用this关键字指定当前对象属性</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;调用了有参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//普通方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是:&quot;</span>+name+<span class="string">&quot;,年龄:&quot;</span>+age<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example06</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []age)</span>&#123;</span><br><span class="line">        <span class="comment">//实例化Student对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">//this关键字调用read成员方法</span></span><br><span class="line">        stu.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="this关键字调用成员方法">this关键字调用成员方法</h2>
<blockquote>
<p>这里this关键字可以省略不写</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">openMouth</span><span class="params">()</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> read&#123;</span><br><span class="line">        <span class="built_in">this</span>.openMouth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="this关键字调用构造方法">this关键字调用构造方法</h2>
<blockquote>
<p>注意：</p>
<p>只能在构造方法中使用this调用其他的构造方法，不能在成员方法中通过this调用构造方法</p>
<p>在构造方法中，使用this调用其他构造方法的语句必须位于第一行，且只能出现一次</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="comment">//调用无参构造方法</span></span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//使用this关键字指定当前对象属性</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//普通方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是:&quot;</span>+name+<span class="string">&quot;,年龄:&quot;</span>+age<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example06</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []age)</span>&#123;</span><br><span class="line">        <span class="comment">//实例化Student对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">//this关键字调用read成员方法</span></span><br><span class="line">        stu.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>构造块</center></h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是构造块&quot;</span>);  <span class="comment">//与构造方法同级</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是 Student 类的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example12</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mian</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>static关键字</center></h1>
<h2 id="静态属性">静态属性</h2>
<blockquote>
<p>static局部变量只被初始化一次，下一次的运算依据上一次的结果值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">static</span> 数据类型 属性名;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">String</span> <span class="variable">school</span> <span class="operator">=</span> <span class="string">&quot;A大学&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">19</span>);</span><br><span class="line">stu1.school;   <span class="comment">//类名.属性名;</span></span><br></pre></td></tr></table></figure>
<h2 id="静态方法">静态方法</h2>
<blockquote>
<p>不创建对象的情况下，通过类名直接调用某个方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line">修饰符 <span class="keyword">static</span> 返回值类型 方法名(参数类型 形参名<span class="number">1</span>, 参数类型 形参名<span class="number">2</span>,....)</span><br><span class="line">&#123;</span><br><span class="line">    执行语句;</span><br><span class="line">    <span class="keyword">return</span> 返回值; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setSchool</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    school = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问</span></span><br><span class="line">Student.setSchool(<span class="string">&quot;B大学&quot;</span>);   <span class="comment">//类名.方法名</span></span><br></pre></td></tr></table></figure>
<h2 id="静态代码块">静态代码块</h2>
<blockquote>
<p>在类第一次使用时才会被加载，且只被加载一次</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是静态代码块&quot;</span>);   <span class="comment">//只会加载一次(结果只会打印一次)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example15</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java语言</category>
      </categories>
      <tags>
        <tag>Java语言</tag>
      </tags>
  </entry>
  <entry>
    <title>22.File类和递归</title>
    <url>/post/8f9052f9.html</url>
    <content><![CDATA[<h1><center>知识点一：File类</center></h1>
<p>File类是Java中专门提供给代码进行对文件系统中【操作系统】文件夹或文件进行操作的类，这个File类中提供【创建、删除、重命名、判断文件状态、检查文件的属性】等等功能，就可以通过File对象将系统中文件或文件夹以，面向对象的方式进行操作，File类只能对文件进行管理操作，对于文件内容存储数据File类是无法进行操作</p>
<p>File类就是Java中表示系统文件或系统文件夹的一个抽象，可以提供一个【路径】将路径所描述文件或文件夹具体化，并且提供File类中给提供方法对文件或文件进行操作</p>
<p>PS：建议尽量不在C盘判断进行操作，极少部分电脑对C盘操作是需要</p>
<p>权限【管理员权限】</p>
<p>文件和文件夹路径和问题？</p>
<p>操作系统中文件或文件夹的路径分为两种**“绝对路径&quot;和”相对路径”**</p>
<p>PS:这里以windows系统为例：</p>
<p><strong>绝对路径： 是从系统盘符开始路径是绝对路径</strong>【在开发尽量少用】</p>
<p>windows系统中对绝对路径的路径分隔符号是【\】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">C:\File类\笔记 --》绝对路径</span><br></pre></td></tr></table></figure>
<p>这里问题在于，在Java代码中【\】是转义字符，针对\后的字母进行转义操作，所以为了避免提供绝路径出现歧义在编写代码的时候如果提供绝对路径，路径分隔符要写成【\】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">C:\\File类\\笔记 --》这样代码才可以读取这个绝对路径</span><br></pre></td></tr></table></figure>
<p>Java为了减少程序猿书写路径麻烦，Java会仿照Unix或Linux系统中提供路径分隔符进行路径分隔操作，提供是【/】 --》 得到路径是 --》/Users/jkmaster，即将绝对路径修改为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">C:/File类/笔记 --》这样代码才可以读取这个绝对路径 此时【/】 等价于 【\\】</span><br></pre></td></tr></table></figure>
<p>PS：windows系统是可以兼容使用Unix或Liunx路径分隔符号，但是Unix或Liunx是不兼容windows的路径分隔符号</p>
<p>例如： 提供一个Linux文件系统根路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/Users/jkmaster/app/File类/笔记 ---》 Linux路径但是不可以这样写</span><br><span class="line">\\Users\\jkmaster\\app\\File类\\笔记 ---&gt;错误无法读取</span><br></pre></td></tr></table></figure>
<p><strong>相对路径：主要针对的服务器或IDEA编译工具的路径作为参考路径，从而形成路径就是相对路径</strong></p>
<p>PS: 相对路径是不区分操作系统</p>
<p>以工程中类文件作为参考进行文件路径拷贝操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">绝对路径--》C:\IdeaProjects\File\src\com\qfedu\FileAPI\FileAPIDemo.java</span><br></pre></td></tr></table></figure>
<p>以工程中类文件作为参数进行文件路径的拷贝操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">相对路径：src/com/qfedu/FileAPI/FileAPIDemo.java</span><br></pre></td></tr></table></figure>
<p>相对路径的提供必须有一个路径参考存在，不能随意提供相对路径，相对路径参考必须是一个真实存在路径，相对路径是在有绝对路径前提下提供，所以必须提供一个参考，<strong>在IDEA编译器工程中提供相对路径参考就是IDEA工程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">不可以在代码中这样提供相对路径</span><br><span class="line">提供一个绝对的路径：</span><br><span class="line">	<span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;C:\\abc\123\\456&quot;</span>;    <span class="comment">//不是真实的路径</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">path2</span> <span class="operator">=</span> <span class="string">&quot;file.txt&quot;</span>; <span class="comment">//file.txt参考是path路径，这样完全错误</span></span><br></pre></td></tr></table></figure>
<p><strong>相对路径在什么位置提供针对的就是谁在进行参考</strong></p>
<p>PS：项目中是可以读取绝对路径，但是针对网络中读取本地的【视频或音频文件或图片】</p>
<p>    本地读取文件【操作系统】使用盘符，但是从服务端读取  <a href="http://xn--IP-im8ckc">http://IP地址</a>：端口号/文件路径</p>
<h2 id="center-1-file类中常用方法-center"><center>1、File类中常用方法</center></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileAPIDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供文件路径【文件路径分隔符号】</span></span><br><span class="line">        separator();</span><br><span class="line">        <span class="comment">//通过封装File对象获取文件或文件夹路径</span></span><br><span class="line">        showPath();</span><br><span class="line">        <span class="comment">//检查文件或文件夹的状态</span></span><br><span class="line">        checkFileState();</span><br><span class="line">        <span class="comment">//文件操作[记住]</span></span><br><span class="line">        operationFile();</span><br><span class="line">        <span class="comment">//文件夹操作[记录]</span></span><br><span class="line">        operationDirectory();</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">operationDirectory</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\123\\456\\789&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;判断file对象中是否存在文件夹：&quot;</span>+file.exists());</span><br><span class="line">        System.out.println(<span class="string">&quot;判断file是否是文件夹：&quot;</span>+file.isDirectory());</span><br><span class="line">        <span class="comment">//file.mkdir(); //创建文件夹【只能创建一个】</span></span><br><span class="line">        file.mkdirs();    <span class="comment">//同时创建多个文件夹</span></span><br><span class="line">        <span class="comment">//获取文件夹下所有文件或文件夹路径【String类型路径】</span></span><br><span class="line">        String[] list = file.list();</span><br><span class="line">        <span class="comment">//获取文件夹下所有文件或文件夹路径【File类型对象】</span></span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="comment">//提供系统所有盘符</span></span><br><span class="line">        File[] files1 = File.listRoots();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">operationFile</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//File对象另外的创建方式</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            提供父子路径进行拼接操作</span></span><br><span class="line"><span class="comment">            第一个参数是 父路径 ---》 一般是一个文件夹路径</span></span><br><span class="line"><span class="comment">            参数类型可以是一个File对象，也可以是String类型对象</span></span><br><span class="line"><span class="comment">            第二个参数是 子路径 ---》 一般是文件或文件夹路径</span></span><br><span class="line"><span class="comment">            参数类型可以是一个File对象，也可以是String类型对象</span></span><br><span class="line"><span class="comment">            子路径是不需要提供开始路径分隔符号：即 456.txt即可 无需</span></span><br><span class="line"><span class="comment">            \\456.txt</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\abc\\xxx\\123&quot;</span>,<span class="string">&quot;456.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//1. 判断file对象是否是文件</span></span><br><span class="line">        System.out.println(file.isFile());</span><br><span class="line">        <span class="comment">//2. 判断文件或文件夹是否存在</span></span><br><span class="line">        System.out.println(file.exists());</span><br><span class="line">        <span class="comment">//提供一个判断操作，判断文件是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(!file.exists())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                file.createNewFile();<span class="comment">//创建新的文件</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (IOException e) </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;文件创建失败：&quot;</span>+e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//删除文件</span></span><br><span class="line">            file.delete();</span><br><span class="line">            <span class="comment">//集【移动复制剪切粘贴重命名】与一身的方法</span></span><br><span class="line">            <span class="comment">// file.renameTo(new File(&quot;需要将文件或文件夹到什么</span></span><br><span class="line">            位置路径【移动路径中可以修改文件名字】<span class="string">&quot;));</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125; </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    private static void checkFileState() </span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        //File对象中是一个文件</span></span><br><span class="line"><span class="string">        File file = new</span></span><br><span class="line"><span class="string">        File(&quot;</span>C:\\abc\\xxx\\<span class="number">123</span>\\<span class="number">456.</span>txt<span class="string">&quot;);</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>文件是否可读：<span class="string">&quot;+file.canRead());</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>文件是否可写：<span class="string">&quot;+file.canWrite());</span></span><br><span class="line"><span class="string">        //这个方法主要是针对Linux和Unix系统文件 --》 系统文件是有三个符号表文件状态 r【读】w【写】x【执行】</span></span><br><span class="line"><span class="string">        //在windows中效果不是很明显</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>文件是否可执行：<span class="string">&quot;+file.canExecute());</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>判断文件是否是隐藏文件：<span class="string">&quot;+file.isHidden());</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>获取文件最后修改时间：<span class="string">&quot; + new Date(file.lastModified()));</span></span><br><span class="line"><span class="string">        //文件大小是根据存储内容大小决定</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>文件的大小：<span class="string">&quot; + file.length() + &quot;</span>字节<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    &#125; </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    private static void showPath() </span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        //1. File类创建对象的方式，以字符串为参数进行路径传入即可</span></span><br><span class="line"><span class="string">        【绝对路径或相对路径】</span></span><br><span class="line"><span class="string">        //通过文件路径将456.txt这个文件封装到File这个对象中，通过</span></span><br><span class="line"><span class="string">        File对象就可以对这个文件进行操作</span></span><br><span class="line"><span class="string">        File file = new File(&quot;</span>C:\\abc\\xxx\\<span class="number">123</span>\\<span class="number">456.</span>txt<span class="string">&quot;);</span></span><br><span class="line"><span class="string">        System.out.println(file);    //重写toString方法打印的是存储的路径</span></span><br><span class="line"><span class="string">        //(了解) ---&gt; 获取文件绝对路径【返回值类型时File】</span></span><br><span class="line"><span class="string">        System.out.println(file.getAbsoluteFile());</span></span><br><span class="line"><span class="string">        //(了解) ---&gt; 获取文件绝对路径【返回值类型是String】</span></span><br><span class="line"><span class="string">        System.out.println(file.getAbsolutePath());</span></span><br><span class="line"><span class="string">        //(了解) ---&gt; 获取当前路径的上一级路径【返回值类型是 String】</span></span><br><span class="line"><span class="string">        System.out.println(file.getParent());</span></span><br><span class="line"><span class="string">        //(了解) ---&gt; 获取当前路径的上一级路径【返回值类型是File】</span></span><br><span class="line"><span class="string">        System.out.println(file.getParentFile());</span></span><br><span class="line"><span class="string">        //(知道) ---&gt; 获取文件路径</span></span><br><span class="line"><span class="string">        System.out.println(file.getPath());</span></span><br><span class="line"><span class="string">        // (记住) ---&gt; 获取文件的名字</span></span><br><span class="line"><span class="string">        System.out.println(file.getName());</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    private static void separator()</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        //除了数据类型一样之外，剩下完全相同根据不同操作系统动态变化分隔符号</span></span><br><span class="line"><span class="string">        System.out.println(File.separator);    //String类型分隔符号</span></span><br><span class="line"><span class="string">        System.out.println(File.separatorChar);    //char类型分隔符号</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h1><center>知识点二：递归</center></h1>
<p>递归是方法一种【自身调用自身的一种方式】</p>
<p>递归调用时是一种特殊的调用形式，是方法自己调用自己即一个方法内部调用方法本身，这种方式被称之为递归，方法递归包含了一个隐式循环，它会重复执行某段代码，但是这个重复执行操作需要加以控制，否则就会出现&quot;栈溢出错误</p>
<p>&quot;递归的本身执行效率极高【在同时间内容所有资源都被递归所调用执行操作】，在开发中提供递归操作是需要特别注意</p>
<p>如何理解递归操作？</p>
<p>通俗：从前有座山，山里有座庙，庙里有一个老和尚和小和尚，老和尚在给小和尚讲故事，从前有座山，山里有座庙…【小和尚睡着（递归的停止条件）】</p>
<p><strong>递归的必要原则：一定要提供一个递归的停止点，如何让递归正确停止下来</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//StackOverflowError show方法并没有正确停止方式，所以在栈中会堆积大量的show调用</span></span><br><span class="line">        <span class="comment">//必须注意正确停止递归，不要出现StackOverflowError错误停止递归【JVM虚拟机停止了】</span></span><br><span class="line">        show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        show(); <span class="comment">//这就是递归【在show方法的内容调用自身show方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需求： 使用递归的方式计算1~5之间所有数据之和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.File;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDmo2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//正常解题</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        <span class="comment">//既然可以这样计算，也可以提供循环</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>; i &gt;= <span class="number">1</span>; i--) </span><br><span class="line">        &#123;</span><br><span class="line">            sum1 += i;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(sum1);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ToSum(<span class="number">5</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">&#125; </span><br><span class="line">    <span class="comment">//当我们需要计算1~某个数字之间所有数据之和的时候1是确定值，也就是计算的最后一个位置也是开始的位置</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        提供一个方法，方法可以帮组累加计算 参数num就是需要累加到数据位置</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ToSum</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;    <span class="comment">//当得到1的时候，证明计算到最后一个值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> num + ToSum(num - <span class="number">1</span>);    <span class="comment">//形成递归</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                第一次调用ToSum方法时 ，参数是 5 执行 num == 1 不等于 执行 num+ToSum(num-1);</span></span><br><span class="line"><span class="comment">                即 5+ ToSum(5-1) 再次触发 ToSum调用</span></span><br><span class="line"><span class="comment">                第二次调用ToSum方法时 ，参数是(5-1) 执行 num == 1不等于 执行 num+ToSum(num-1)</span></span><br><span class="line"><span class="comment">                即 4+ToSum(4-1) 再次触发 ToSum调用</span></span><br><span class="line"><span class="comment">                第三次调用ToSum方法时 ，参数是(4-1) 执行 num == 1不等于 执行 num+ToSum(num-1)</span></span><br><span class="line"><span class="comment">                即 3+ToSum(3-1) 再次触发 ToSum调用</span></span><br><span class="line"><span class="comment">                第四次调用ToSum方法时 ，参数是(3-1) 执行 num == 1不等于 执行 num+ToSum(num-1)</span></span><br><span class="line"><span class="comment">                即 2+ToSum(2-1) 再次触发 ToSum调用</span></span><br><span class="line"><span class="comment">                第五次调用ToSum方法时 ，参数是(2-1) 执行 num == 1等于 方法执行return 1</span></span><br><span class="line"><span class="comment">                就会返回给第四次调用 2+ToSum(2-1) 作为ToSum方法的返回值获取 即 2+1 = 3</span></span><br><span class="line"><span class="comment">                3这个结果值就会返回第三调用3+ToSum(3-1)作为ToSum方法的返回值获取 即3+3 = 6</span></span><br><span class="line"><span class="comment">                6这个结果值就会返回第二调用4+ToSum(4-1)作为ToSum方法的返回值获取 即4+6 = 10</span></span><br><span class="line"><span class="comment">                10这个结果值就会返回第一次调用5+ToSum(5-1)作为ToSum方法的返回值获取 即 5+10 = 15</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需求: 有6个人， 第6个人说 比 第5个人大3岁，第5个人说 比 第4个人大3岁，第4个人说 比 第3个人大3岁，第3个人说 比 第2个人大3岁，第2个人说 比 第1个人大3岁，第1个人说自己13岁，问第6个人多大</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提供一个计算年龄递归方法，参数是int类型，n代表的是人数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sumAge</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)    <span class="comment">//最后一个人的时候年龄是13</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> sumAge(n-<span class="number">1</span>)+<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>1、总结</center></h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;1. 写递归必须要有结束点【递归的停止】，否则会出现</span></span><br><span class="line"><span class="string">StackOverflowError栈溢出错误【终止递归】&quot;</span></span><br><span class="line"><span class="string">&quot;2. 明确这个方法的重复做什么事情，是否有重复做事情的条件，是否可</span></span><br><span class="line"><span class="string">以重复做到事情&quot;</span></span><br><span class="line"><span class="string">&quot;3. 简单递归都是使用【循环解决】，但是深层次的递归是无法使用循环</span></span><br><span class="line"><span class="string">替代的&quot;</span></span><br><span class="line"><span class="string">&quot;4. 一般项目中书写递归一定要慎重，一般递归出现在于无法使用循环解</span></span><br><span class="line"><span class="string">决操作或是进行执行效率优化时&quot;</span></span><br></pre></td></tr></table></figure>
<p>进阶案例演示：遍历操作系统中某个盘符，获取判断中所有文件夹和文件夹信息，打印层级</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="comment">//使用递归遍历盘符下所有信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileLoopDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供一个File对象进行路径封装</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\&quot;</span>);</span><br><span class="line">        showLayers(file,<span class="number">0</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 提供遍历盘符方法</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> file 封装盘符的对象</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> level 等级</span></span><br><span class="line"><span class="comment">    * 0是最高级别，依次递增，主要是为了提供层级拼接效果使用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showLayers</span><span class="params">(File file, <span class="type">int</span> level)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建一个字符串构建器进行层级拼接</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">bs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;|--&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;level;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            bs.insert(<span class="number">0</span>,<span class="string">&quot;|&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.判断是文件夹还是文件，如果是文件就停止访问</span></span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(files))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//判断 files数组中存储的是文件还是文件夹</span></span><br><span class="line">        <span class="keyword">for</span> (File tempFile : files)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//先获取名字然后再进行判断操作</span></span><br><span class="line">            System.out.println(bs.toString().concat(tempFile.getName()));</span><br><span class="line">            <span class="comment">//如果是目录，继续查找目录中数据</span></span><br><span class="line">            <span class="keyword">if</span>(tempFile.isDirectory())</span><br><span class="line">            &#123;</span><br><span class="line">                showLayers(tempFile,level+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java语言</category>
      </categories>
      <tags>
        <tag>Java语言</tag>
      </tags>
  </entry>
  <entry>
    <title>2.面向对象</title>
    <url>/post/76fa8c0d.html</url>
    <content><![CDATA[<h1><center>封装</center></h1>
<blockquote>
<p>封装是一个编程的要求，将信息隐藏起来，把不需要外界知道的信息隐藏，尽可能隐藏对象功能实现细节，向外直接提供他可以访问方法，保证外界无法破坏原有内部信息</p>
<p>为了保证成员变量安全，<code>private</code>私有化成员变量只是封装特定一个体现而已</p>
<p>属性使用private进行修饰之后，属性访问方式：<code>Getter</code>和<code>Setter</code>方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在封装获取私有属性方法</span></span><br><span class="line"><span class="comment">//必须有【返回值类型】与属性的【属性类型】一致即可</span></span><br><span class="line"><span class="comment">//方法名固定【getXXX】，XXX为属性名</span></span><br><span class="line"><span class="keyword">public</span> 返回值类型 getXXX()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> 属性名;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在封装修改私有属性方法</span></span><br><span class="line"><span class="comment">//方法名固定【setXXX】XXX为属性名，参数列表定义与属性定义相同即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setXXX</span><span class="params">(参数列表)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用定义参数对属性进行赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用封装提供访问私有属性的方法访问</span></span><br><span class="line"><span class="keyword">new</span> 关键字创建类的实例（<span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();）</span><br><span class="line"><span class="comment">//访问属性：通过对象的公共方法（getter 和 setter）来访问和修改属性</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> person.getName();;</span><br><span class="line">person.setName(<span class="string">&quot;Alice&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Encapsulation01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//如果要使用快捷键 alt+r, 需要先配置主类</span></span><br><span class="line">        <span class="comment">//第一次， 我们使用鼠标点击形式运算程序，后面就可以用</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用set方法设置属性</span></span><br><span class="line">        person.setName(<span class="string">&quot;韩顺平&quot;</span>);</span><br><span class="line">        person.setAge(<span class="number">30</span>);</span><br><span class="line">        person.setSalary(<span class="number">30000</span>);</span><br><span class="line">        System.out.println(person.info());</span><br><span class="line">        System.out.println(person.getSalary());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果我们自己使用构造器方法定属性</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">smith</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;smith&quot;</span>, <span class="number">80</span>, <span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;====smith 的信息======&quot;</span>);</span><br><span class="line">        System.out.println(smith.info());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    那么在 java 中如何实现这种类似的控制呢?</span></span><br><span class="line"><span class="comment">    请大家看一个小程序(com.hspedu.encap: Encapsulation01.java),</span></span><br><span class="line"><span class="comment">    不能随便查看人的年龄,工资等隐私， 并对设置的年龄进行合理的验证。 年龄合理就设置， 否则给默认</span></span><br><span class="line"><span class="comment">    年龄, 必须在 1-120, 年龄， 工资不能直接查看 ， name 的长度在 2-6 字符 之间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;	<span class="comment">//名字公开</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;	<span class="comment">//age 私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary; <span class="comment">//..</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(<span class="type">int</span> n,String name)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造方法 alt+insert</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有三个属性的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="comment">//我们可以将 set 方法写在构造器中， 这样仍然可以验证</span></span><br><span class="line">        setName(name);</span><br><span class="line">        setAge(age);</span><br><span class="line">        setSalary(salary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自己写 setXxx 和 getXxx 太慢， 我们使用快捷键</span></span><br><span class="line">    <span class="comment">//然后根据要求来完善我们的代码</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">//加入对数据的校验,相当于增加了业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span>(name.length() &gt;= <span class="number">2</span> &amp;&amp; name.length() &lt;=<span class="number">6</span> ) &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;名字的长度不对， 需要(2-6)个字符， 默认名字&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.name = <span class="string">&quot;无名人&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span>(age &gt;= <span class="number">1</span> &amp;&amp; age &lt;= <span class="number">120</span>) &#123;<span class="comment">//如果是合理范围</span></span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你设置年龄不对， 需要在 (1-120), 给默认年龄 18 &quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.age = <span class="number">18</span>;<span class="comment">//给一个默认年龄</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//可以这里增加对当前对象的权限判断</span></span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写一个方法，返回属性信息</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;信息为 name=&quot;</span> + name + <span class="string">&quot; age=&quot;</span> + age + <span class="string">&quot; 薪水=&quot;</span> + salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>继承</center></h1>
<p>在Java中需要完成继承操作，需要使用一个关键字【extends】 表示继承</p>
<blockquote>
<p>一个子类只能继承一个父类，但一个父类可以拥有多个子类</p>
<p>一个父类还可以继承另外一个类，java中最大的父类是Object（一个类没有显示的写出extends，那么这个继承Object类）</p>
<p>子类继承父类中的属性和方法也可以拥有自己独有的属性和方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义父类</span></span><br><span class="line"><span class="keyword">public</span> class 父类名字&#123;</span><br><span class="line">    成员变量;</span><br><span class="line">    构造方法;</span><br><span class="line">    Getter和Setter方法;</span><br><span class="line">    成员方法;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类与类之间继承</span></span><br><span class="line"><span class="keyword">public</span> class 子类名字 extends 父类名字&#123; </span><br><span class="line">    <span class="comment">/*子类可以得到父类所有的可见属性和方法【不是用private修饰】</span></span><br><span class="line"><span class="comment">    从父类继承而来就无需重复定义，直接使用即可</span></span><br><span class="line"><span class="comment">    除此之外，子类还可以提供子类自身定义的*/</span></span><br><span class="line">    成员变量;</span><br><span class="line">    构造方法;</span><br><span class="line">    Getter和Setter方法;</span><br><span class="line">    成员方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不能被继承情况：</p>
<ul>
<li>使用 <code>public\protected</code>属性和方法不能被子类继承</li>
<li>构造方法不能被继承（构造方法是用来创建类的对象）</li>
<li>父类中使用默认的修饰符(<code>default</code>)的修饰的属性和方法在不同包的子类中不能被继承</li>
</ul>
<h2 id="super关键字">super关键字</h2>
<p>只能在子类中使用，提供一个父类的引用</p>
<p>作用：调用父类的构造方法，辅助子类完成属性初始化</p>
<p>super() ：调用父类无参构造方法，super(参数赋值) ：调用父类的有参构造方法，调用父类构造方法必须在<code>子类构造方法</code>的第一句，如果子类的构造方法没有显式调用 <code>super()</code>，编译器会自动插入 <code>super()</code>，调用父类的无参构造方法</p>
<p>如果当子类和父类中没有重名的属性和方法时，super和this关键字都是调用父类的，如果当子类和父类中有重名的属性和方法时，super 表示：父类的，this表示：子类的</p>
<p>父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="type">char</span> gender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">char</span> gender)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提供Get和Set方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">getGender</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(<span class="type">char</span> gender)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        子类继承父类之后，可以得到父类中所有的可见属性和行为【非private】</span></span><br><span class="line"><span class="comment">        子类还可以提供自己独有属性和行为</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        发生继承之后 子类是不可以继承父类构造方法，所以子类需要提供自己的构造方法</span></span><br><span class="line"><span class="comment">        子类依旧要提供有参和无参构造方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Man</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Man</span><span class="params">(String name, <span class="type">char</span> gender,<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如何对父类初始化呢？ --&gt; 使用父类中提供set方法对父类属性初始化</span></span><br><span class="line">        <span class="comment">// setName(name); //问题在于 如果属性过多，子类构造方法就要大量调用set方法</span></span><br><span class="line">        <span class="comment">//此时就可以使用super关键字调用父类的构造方法来辅助子类初始化继承属性</span></span><br><span class="line">        <span class="comment">//super(); //调用无参构造方法</span></span><br><span class="line">        <span class="built_in">super</span>(name,gender);<span class="comment">// 调用父类的有参构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用父类中属性</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.gender);</span><br><span class="line">        <span class="comment">//调用父类中成员方法</span></span><br><span class="line">        <span class="built_in">super</span>.getGender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法重写">方法重写</h2>
<p>作用：父类的方法无法满足子类的需求，所以需要重写父类的方法</p>
<p>子类方法重写的格式：父类方法如何定义，子类方法就如何定义，只是子类将原有方法的实现重新完成(重写方法名回车)</p>
<p>在重写方法的时候，加上注解：<code>@Override</code>，检测是否是满足方法重写</p>
<p>重写完成要求：</p>
<ol>
<li>
<p>若<strong>父类的方法使用private、static或final修饰中任意一个修饰符修饰，那么子类都不可以重写这个方法</strong></p>
</li>
<li>
<p>重写方法必须所有继承关系，没有继承关系两个类是不可以重写对方方法</p>
</li>
<li>
<p>重写成员成员方法方法签名必须相同【方法签名=方法名+参数列表】</p>
</li>
<li>
<p>子类重写父类方法是，提供原有父类方法返回值类型的子类类型或同类型</p>
</li>
<li>
<p>在重写时，子类提供方法访问权限修饰符要大于等于父类的方法权限修饰符</p>
</li>
<li>
<p>在重写时，父类的方法提供异常类抛出，子类提供异常类型必须相同类型或子类类型</p>
</li>
</ol>
<p>需求: 创建一个父类鸟类（Brid），父类就提供一个方法fly，在创建两个子类麻雀类和鸵鸟类</p>
<p>父类鸟类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供一个飞翔方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;可以飞翔&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类麻雀</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sparrow</span> <span class="keyword">extends</span> <span class="title class_">Bird</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//子类可以得到父类提供公有fly方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类鸵鸟</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ostich</span> <span class="keyword">extends</span> <span class="title class_">Bird</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//子类可以得到父类提供公有fly方法</span></span><br><span class="line">    <span class="comment">//重写：父类方法如何定义，子类重写时就如何定义，只要提供不同的实现即可</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//注解，作用就是提供给编译器说明子类有重写父类方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// super.fly(); ---》 这种方式就可以调用到父类方法的原有实现</span></span><br><span class="line">        <span class="comment">//只需要在这个方法中提供子类自己实现方式即可---》 重写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我不会飞，但是跑的很快！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Sparrow</span> <span class="variable">sparrow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sparrow</span>();</span><br><span class="line">        <span class="type">Ostich</span> <span class="variable">ostich</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ostich</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            麻雀可以飞翔是没问题的，但是鸵鸟是不会飞的，所以如果鸵鸟这个对象调用</span></span><br><span class="line"><span class="comment">            fly方法打印出可以“可以飞翔”和明显不符合要求的</span></span><br><span class="line"><span class="comment">            触发了一个原则，父类提供方法无法满足子类需求，子类可以重写父类方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        sparrow.fly();</span><br><span class="line">        <span class="comment">//子类一旦重写父类方法之后在调用方法，必然是子类重写之后的实现啊</span></span><br><span class="line">        ostich.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>多态</center></h1>
<p>同一个方法，对不同对象触发可以得到不用表现形式</p>
<p>如果发生多态，那么无法调用子类独有的方法（编译看左边(左边是父类)）</p>
<p>如果发生多态，那么调用的一定是子类重写的方法（运行看右边）</p>
<p>多态产生条件：有继承、有方法重写、父类的引用指向子类的对象</p>
<h2 id="向上向下转型">向上向下转型</h2>
<p><strong>    向上转型</strong>：父类引用指向子类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">父类类型 对象名字 = <span class="keyword">new</span> 子类类型();</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个子类就会被默认提升为父类类型，当前对象只能调用父类中提供属性和行为，无法调用子类中提供自有属性和行为</span></span><br><span class="line"><span class="comment">//PS：这也是开发中唯一创建父类对象一种方式，不会使用父类直接创建对象</span></span><br></pre></td></tr></table></figure>
<p><strong>    向下转型</strong>：将父类引用强转成子类类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">子类类型 对象名 = (子类类型)提升为父类类型对象;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个对象就会被转换为原来子类类型，当前对象即可以调用父类中提供可见属性和行为，也可以调用子类自有属性和行为</span></span><br></pre></td></tr></table></figure>
<p>    如果发生多态，无法调用子类独有的方法。如果要调用子类独有的方法，必须发生向下转型，前提是先发生过向上转型，否则会报错</p>
<h2 id="instanceof关键字">instanceOf关键字</h2>
<p>    可以利用instanceof这个关键字检查 提升之后对象是否是某一个子类类型对象即【当前提升之后对象是否属于某个子类类型】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">    提升之后对象 <span class="keyword">instanceof</span> 子类类型</span><br><span class="line">    </span><br><span class="line">上面这个表达式就会帮组你判断，提升之后对象是否属于但当前提供子类类型</span><br><span class="line">返回值为 <span class="literal">true</span> 【证明当前对象是由当前子类类型提升而来】</span><br><span class="line">        <span class="literal">false</span> 【证明当前对象不是当前子类类型提升而来】</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类动物类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name, String gender)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGender</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(String gender)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类狗类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name,String gender,<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(name,gender);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类猫类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String kind;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name, String gender, String kind)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(name,gender);</span><br><span class="line">        <span class="built_in">this</span>.kind = kind;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getKind</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> kind;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKind</span><span class="params">(String kind)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.kind = kind;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供对象向上转型</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            父类引用可以接收一个子类的引用</span></span><br><span class="line"><span class="comment">            将Dog类型对象提升为父类Animal类型</span></span><br><span class="line"><span class="comment">            此时只能调用父类中属性和行为，不能调用子类自己属性和行为</span></span><br><span class="line"><span class="comment">            如果子类重写父类的方法，提升之后对象调用方法执行时，依旧执行子类重写效果</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        animal.getName();</span><br><span class="line">        <span class="comment">//animal.getAge(); //getAge方法是子类自身的，并不是父类的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.提供对象向下转型</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时会将提升之后父类对象animal转换为原有子类类型Dog</span></span><br><span class="line"><span class="comment">            转型之后不仅可以调用子类的属性和方法，而且也可以调用父类属性和方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog)animal;</span><br><span class="line">        dog.getName();</span><br><span class="line">        dog.getAge();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象向下转型会存在一个问题，如果转型失败会出现一个异常问题，而这个问题不会在编译阶段进行提示只能在运行时提示</span></span><br><span class="line">        <span class="comment">//此时明显animal是Dog类型提升的(前面将Dog提升)，并不是Cat，但是编译阶段是不会提示错误</span></span><br><span class="line">        <span class="comment">//系统就会提示 ClassCastException --&gt; 强制类型转换异常</span></span><br><span class="line">        <span class="comment">// Cat cat = (Cat)animal;</span></span><br><span class="line">        <span class="comment">//PS：在实际开发，如果你能确定子类类型是什么，那么就不写instanceof操作</span></span><br><span class="line">        <span class="comment">//使用instanceof这个关键字进行转换对象判断避免这个问题发生</span></span><br><span class="line">        <span class="keyword">if</span>(animal <span class="keyword">instanceof</span> Cat)</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">//判断animal对象是否是Cat类型对象</span></span><br><span class="line">            <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat)animal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;animal不是Cat类型无法进行对象向下转型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>abstract关键字</center></h1>
<p>抽象的，被abstract修饰的类称之为抽象类</p>
<p>PS：抽象类就是一个特殊父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//语法格式：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> class 类名    <span class="comment">//这个类就是抽象类</span></span><br><span class="line">&#123; </span><br><span class="line">    父类如何定义，抽象类的内部就如何定义</span><br><span class="line">    成员变量</span><br><span class="line">    构造方法</span><br><span class="line">    成员方法</span><br><span class="line">    静态变量</span><br><span class="line">    静态方法</span><br><span class="line">    方法重写</span><br><span class="line">    抽象方法</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//抽象类就是多了一个abstract关键字的父类</span></span><br></pre></td></tr></table></figure>
<p>PS：建议在以后开发中，<strong>如果确定这个类是一个父类就建议优先声明成“抽象类”</strong></p>
<p>    抽象类可以像普通类一样使用可以继承，可以实现，可以定义类中所有定义的东西，但是就是不允许直接创建抽象类对象【即 抽象类类名 对象 = new 抽象类类名();】，抽象类是它支持多态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建抽象类葵花宝典</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SunflowerBible</span> </span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象方法">抽象方法</h2>
<p>含义：使用abstract关键字修饰并且没有方法体，存在在抽象类中叫做抽象方法</p>
<p>抽象类我们一般用比较少，未来更多是使用接口</p>
<p>目的：为了让子类去重写</p>
<ul>
<li>抽象方法必须出现在抽象类中</li>
<li>抽象方法不能有方法体（方法的实现{}）并且在小括号后面添加<code>;</code></li>
<li>抽象方法<code>必须要在非抽象子类中重写</code></li>
<li>抽象方法修饰符不能使用private、static和final，只要使用这三个修饰符，这个方法就无法在进行重写实现了</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象方法的格式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名(参数列表);</span><br></pre></td></tr></table></figure>
<p>需求：实例化一个顺丰快递的对象，从控制台录入一个24以内的数据，如果数据在8~18点之间，顺丰营业。否则，顺丰快递公司休息</p>
<ul>
<li>
<p>设计一个公司抽象类，具有抽象方法 – 营业，休息</p>
</li>
<li>
<p>设计一个快递公司类作为公司类的子类</p>
</li>
<li>
<p>设计一个顺丰快递类，作为快递类的子类</p>
</li>
</ul>
<p>提供一个公司的抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Company</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String companyName;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Company</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Company</span><span class="params">(String companyName)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.companyName = companyName;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCompanyName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> companyName;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCompanyName</span><span class="params">(String companyName)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.companyName = companyName;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//营业的抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//休息的抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快递公司在需求中并没有做任何特殊说明，此时可以将这个类作为一个抽象类</p>
<p>使用一个抽象类继承与另外一个抽象类，当前这个抽象子类可以选择性实现或者不实现抽象父类中抽象方法</p>
<p>不是先父类抽象方法原因，是因为这个也是抽象类，也可以存储抽象方法所以抽象子类可以选择性实现抽象方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CourierServicesCompany</span> <span class="keyword">extends</span> <span class="title class_">Company</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CourierServicesCompany</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CourierServicesCompany</span><span class="params">(String companyName)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(companyName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺丰快递公司子类</p>
<p>如果使用一个普通类继承与抽象类，必须实现抽象类中所提供抽象方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SFCompany</span> <span class="keyword">extends</span> <span class="title class_">CourierServicesCompany</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SFCompany</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SFCompany</span><span class="params">(String companyName)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(companyName);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(getCompanyName()+<span class="string">&quot;正在营业，欢迎光临.....&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    System.out.println(getCompanyName()+<span class="string">&quot;下班休息，下次再来.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Test类（测试类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入时间:&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">time</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">        <span class="type">SFCompany</span> <span class="variable">sfCompany</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SFCompany</span>(<span class="string">&quot;顺丰快递&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(time &gt;= <span class="number">8</span> &amp;&amp; time &lt;= <span class="number">18</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sfCompany.open();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            sfCompany.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>final关键字</center></h1>
<h2 id="作用">作用</h2>
<ul>
<li>
<p>修饰类：不能被继承</p>
</li>
<li>
<p>修饰方法：不能被重写、继承</p>
</li>
<li>
<p>修饰属性：常量，定义时必须赋初值</p>
</li>
<li>
<p>注意：常量不能修改，引用类型地址不能改变</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Final01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E</span>();</span><br><span class="line">        <span class="comment">//e.TAX_RATE = 0.09;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果我们要求 A 类不能被其他类继承</span></span><br><span class="line"><span class="comment">//可以使用 final 修饰 A 类</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123; &#125;</span><br><span class="line"><span class="comment">//class B extends A &#123;&#125;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="comment">//如果我们要求 hi 不能被子类重写</span></span><br><span class="line">    <span class="comment">//可以使用 final 修饰 hi 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="comment">// @Override</span></span><br><span class="line">    <span class="comment">// public void hi() &#123;</span></span><br><span class="line">    <span class="comment">// 	System.out.println(&quot;重写了 C 类的 hi 方法..&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当不希望类的的某个属性的值被修改，可以用 final 修饰</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">TAX_RATE</span> <span class="operator">=</span> <span class="number">0.08</span>;	<span class="comment">//常量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当不希望某个局部变量被修改，可以使用 final 修饰</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//这时， NUM 也称为 局部常量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">double</span> <span class="variable">NUM</span> <span class="operator">=</span> <span class="number">0.01</span>;</span><br><span class="line">        <span class="comment">//NUM = 0.9;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;NUM=&quot;</span> + NUM);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java语言</category>
      </categories>
      <tags>
        <tag>Java语言</tag>
      </tags>
  </entry>
  <entry>
    <title>25.网络编程</title>
    <url>/post/f1dbdc9f.html</url>
    <content><![CDATA[<h1><center>知识点一：什么是网络编程</center></h1>
<p>Java是Internet上语言，它从语言级别上提供了对网络编程支持，程序猿可以利用Java语言进行网络应用程序编写，Java提供大量网络库，可以实现不同网络连接【TCP/UDP】，联网的底层实现已经被Java进行封装了，只需调用网络包中提供实现类方法就可以完成网络编程</p>
<p>网络编程就是提供互联网应用程序，互联网是什么？把分布在不同区域的计算机与专门外部设备进行通信相互链接在一起，提供一个强大网络关系，从而通过链接网络就可以方便计算机与计算机之间的信息传递，共享硬件，数据和软件信息</p>
<p>之所以计算机之间可以进行网络通信是因为提供网络连接【网线和wifi】</p>
<h1><center>知识点二：网络通信协议</center></h1>
<p>网络通信协议就是联网设备之间可以进行更好交互，需要遵守一套通信规则</p>
<p>通讯协议有两套【一套是理论协议和一套是实际操作协议】</p>
<h2 id="center-1-osi通信模型-网络7层协议-center"><center>1、OSI通信模型【网络7层协议】</center></h2>
<p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012250386.WebP" alt="OSI通信模型"></p>
<p>在7协议的基础至少之上进行网络协议修改，修改之后的协议更加适合现实生活中网络的实现【TCP/IP通信模型】</p>
<p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012250533.WebP" alt="层次"></p>
<p>在这个模型中 传输层和网络层是需要使用的，提供TCP/IP编程可以完成网络通信操作</p>
<h1><center>知识点三：网络编程三要素</center></h1>
<p><strong>协议、IP地址、端口号</strong>，在这三个要素的前提下得到到两种网络编程模式【软件结构】-&gt; <strong>C/S架构和B/S架构</strong></p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012251097.WebP" alt="三要素" style="zoom:50%;">
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012252229.WebP" alt="B/S结构" style="zoom:50%;">
<p>其实这两种框架开发时各有有点，但是无论是那种框架，都要离不开【“网络”】，需要提供网络编程，就可以架构通信操作了</p>
<h2 id="center-1-协议-center"><center>1、协议</center></h2>
<p>通信协议是计算必须遵守规则， 只有遵守规则才可以进行计算机与计算机之间通信，这就好比道路中行驶的汽车必须遵守交通规则，通讯协议也是一样的，通信协议中提供对数据的【传输格式、传输速率、传输步骤】等等都提供统一的规范，通讯双方必须遵守这个规范，最终完成数据的交换</p>
<h2 id="center-2-tcp协议-center"><center>2、TCP协议</center></h2>
<p>在 <a href="http://java.net">java.net</a> 这个包中就提供了这种常见协议：</p>
<p>TCP：传输控制协议，TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端需要建立起逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输</p>
<p>TCP协议的特点: <strong>面向连接、传输数据安全、传输速度低</strong></p>
<p>例如： 大宝发现了李四家里牛丢了</p>
<p>    TCP协议： 大宝一定要找到李四，面对面的告诉他你们家牛丢了</p>
<p>TCP如何保证面向连接安全？</p>
<p>    TCP在连接时会进行【<strong>三次握手</strong>】，TCP协议中，在发送数据的准备阶段，客户端与服务器之间进行三次交互，以保证可靠连接</p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012253925.WebP" alt="TCP协议" style="zoom:50%;">
<p>第一次握手： 客户端向服务器发送连接请求，等待服务器确认</p>
<p>第二次握手：服务器端接收客户端请求并向客户端回送一个响应，通知客户端收到了连接请求</p>
<p>第三次握手：客户端接收到服务器响应，再次向服务器端发送确认信息，确认连接</p>
<p>客户端与服务器之间就可以开始进行通信操作了</p>
<p>完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了，由于这种连接时面思连接的特性，所以TCP协议可以保证传输数据的安全，所以TCP通信协议被广泛的应用【HTTP协议（网页浏览）、文件上传、文件下载】等等</p>
<p>三次握手可以理解为打电话</p>
<p>    第一次握手就相当于 —》 你拿起电话开始拨号</p>
<p>    第二次握手就相当于 —》 对方拿起电话说“喂”</p>
<p>    第三次握手就相当于 —》 听到“喂”就说明两端连同，开始通话</p>
<h2 id="center-3-udp协议-center"><center>3、UDP协议</center></h2>
<p>在 <a href="http://java.net">java.net</a> 这个包中就提供了这种常见协议：</p>
<p>UDP被称之为 【数据报（文）协议】，UDP协议是一个面向无连接的协议，传输数据时候，不需要建立连接，不管对方服务器是否启动，【直接将数据，数据源和目的地都封装到数据包，直接发送】，每个数据包的大小被限制在64KB，因为连接不可靠而且是面向无连接，所以它传输速度快，但是容易丢包【数据】，日日常应用中：视频、游戏等等</p>
<p>例如： 大宝发现了李四家里牛丢了</p>
<p>UDP协议： 大宝在村里的广播站广播以下李四你家牛丢了，效率快</p>
<h2 id="center-4-ip地址-center"><center>4、IP地址</center></h2>
<p>IP地址：是互联网中协议地址，俗称IP，<strong>IP地址用来给一个网络中的计算机设备做唯一的编号</strong></p>
<p>IP地址分类</p>
<p>    IPv4：是一个32位的二进制数，通常被划分4个字节，表示形式D.D.D.D 形式表示</p>
<p>        例如： 192.168.10.27 这就是IP地址，其中的每一位即 D 范围是一个从0~255结束范围 ，最多表示42亿个IP地址，就算这样全世界的IPv4地址已经没有了</p>
<p>    IPv6：中国主导的，随着全世界互联网网络发展IPv4已经不能满足所有需求，但是网络资源地址还是需要的，使用IPv6来缓解IPv4的缺失，IPv6是一个128位的二进制数，每16个字节划分一组，8组16进制，表示形成 F.F.F.F.F.F.F.F</p>
<p>        例如： fdb2:2c26:f4e4:0:3421:943d:8040:8eef</p>
<p><strong>windows中CMD中 输入 ipconfig可以查看本机的IP地址</strong></p>
<p>所有的人电脑其实在出厂时都有自己的一个IP地址，这个IP地址是供给计算机内容进行通信使用，称之为“环形网络”–》这个IP地址是127.0.0.1 --》 称之为 localhost</p>
<h2 id="center-5-端口号-center"><center>5、端口号</center></h2>
<p>网络的通信，本质上是有两个进程（应用程序）的通信，每台计算机都有很多的进程，那么在网络通信时，如何区分是哪个进程呢？</p>
<p>如果说“IP地址”可以唯一标识网络中的设备，那么“端口号”就可以唯一标识设备中进程（应用程序)了</p>
<p>端口号：用两个字节标识的整数，它的取值范围是0~65535。其中，<strong>0~1023之间端口号用于一些知名的网络服务器与系统应用</strong>，普通的应用程序需啊哟使用1024以上的端口号。<strong>如果端口号被另外一个服务器或应用程序所占用，会导致当前程序启动失败</strong></p>
<p>开中常见端口号 ： MySQL ： 3306 Oracle 1521 或 1520 Tomcat： 8080</p>
<p>利用这个三个组合 <strong>协议 + IP地址 + 端口号</strong>就可以提供网络中进程（应用程序）</p>
<h1><center>知识点四：InteAddress类</center></h1>
<p>此类表示互联网协议 (IP) 地址，能够通过InetAddress这个类获取到IP地址，InteAddress也可以理解为一个IP地址的在Java代码中抽象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterAddressDemo</span> 。</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------创建局域网IP地址对象-------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//1.使用本机的IP地址创建对象</span></span><br><span class="line">        <span class="comment">//提供一个编译时异常Unhandled exception: java.net.UnknownHostException【无法获取主机（IP地址）】</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        <span class="comment">//获取封装在对象中IP地址</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ip地址：&quot;</span>+localHost.getHostAddress());</span><br><span class="line">        <span class="comment">//获取封装在对象中主机名</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主机名：&quot;</span>+localHost.getHostName());</span><br><span class="line">        <span class="comment">//通过赋值IP地址来创建IP地址对象 --》这个参数也可以赋值为 localhost(主机) ---》赋值网络域名</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">byName</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;10.211.55.3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------创建外网IP地址对象-------------------------------&quot;</span>);</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">byName1</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;百度IP地址：&quot;</span>+byName1.getHostAddress());</span><br><span class="line">        System.out.println(<span class="string">&quot;百度主机名：&quot;</span>+byName1.getHostName());</span><br><span class="line">        <span class="comment">//判断连接访问 ---》 ping命令</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2秒内是否可以访问到？&quot;</span>+ byName1.isReachable(<span class="number">2000</span>));    <span class="comment">// ping www.baidu.com</span></span><br><span class="line">        <span class="comment">//获取IP地址对象中所有的信息</span></span><br><span class="line">        InetAddress[] allByName = InetAddress.getAllByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(InetAddress ip : allByName)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(ip);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点五：TCP协议编程</center></h1>
<p>Java中TCP协议编程并不需要我们从头开始写，Java已经在net包中提供操作，专门提供两个类来完成TCP操作</p>
<p><strong>Socket</strong>【客户端】：此类实现客户端套接字（也可以就叫“套接字”）。套接字是两台机器间通信的端点</p>
<p><strong>ServerSocket</strong>【服务器】：此类实现服务器套接字。服务器套接字等待请求通过网络传入。它基于该请求执行某些操作，然后可能向请求者返回结果</p>
<p>因为TCP连接时面向连接的，也就是属于“长连接”，所以需要进行关闭操作，<strong>客户端是可以与服务器进行通信使用的是字节流</strong></p>
<p>案例1</p>
<p>    需求：客户端向服务器发送请求，并传递数据发送【服务你好】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.TCP.V1;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">//客户端程序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建客户端对象提供IP地址和端口号</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一个参数：字符串类型IP地址</span></span><br><span class="line"><span class="comment">            第二个参数：通信端口号</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;10.211.55.3&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端信息：&quot;</span>+client);</span><br><span class="line">        <span class="comment">//2.获取网络字节输出流对象【建立一条客户端通向服务器的通道】</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line">        <span class="comment">//利用字节输入流的对象向服务器发送数据即可</span></span><br><span class="line">        outputStream.write(<span class="string">&quot;服务器你好，我是客户端，来自远方问候.....嘿嘿(*^▽^*)！！！&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//强烈推荐在使用网路流传输数据时必须要写刷新</span></span><br><span class="line">        outputStream.flush();</span><br><span class="line">        <span class="comment">//3.关闭客户端</span></span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">package</span> com.qfedu.TCP.V1;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建服务器端对象，参数只有一个需要和客户端一样的端口号</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器在等待客户端的链接.......&quot;</span>);</span><br><span class="line">        <span class="comment">//2.通过服务器端对象调用 accept 方法获取到连接服务器的客户端对象进行操作</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">sClient</span> <span class="operator">=</span> server.accept();    <span class="comment">//返回的是客户端的信息(端口号等信息)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;恭喜!来自客户端&quot;</span>+sClient+<span class="string">&quot;已经链接上了.......&quot;</span>);</span><br><span class="line">        <span class="comment">//3.创建网络字节输入流对象，获取传输的数据【建立客户端与服务器连接通道】</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> sClient.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> inputStream.read(bs);</span><br><span class="line">        <span class="comment">//4.打印客户端的信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;来自客户端的信息是：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(bs,<span class="number">0</span>,len));</span><br><span class="line">        <span class="comment">//5.关闭服务器</span></span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>案例2</p>
<p>    需求：此时客户端与服务器之间是建立了连接发送了信息，客户端服务器发送了信息，服务器要给客户端予以响应</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.TCP.V2;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">//客户端程序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建客户端对象提供IP地址和端口号</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一个参数是字符串类型IP地址</span></span><br><span class="line"><span class="comment">            第二个参数通信端口号</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;10.211.55.3&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端信息：&quot;</span>+client);</span><br><span class="line">        <span class="comment">//2.获取网络字节输出流对象【建立一条客户端通向服务器的通道】</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line">        <span class="comment">//利用字节输入流的对象向服务器发送数据即可</span></span><br><span class="line">        outputStream.write(<span class="string">&quot;服务器你好，我是客户端，来自远方问候.....嘿嘿(*^▽^*)！！！&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//强烈推荐在使用网路流传输数据时必须要写刷新</span></span><br><span class="line">        outputStream.flush();</span><br><span class="line">        <span class="comment">//3.接收服务器的反馈信息[获取网络字节输入流对象]</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> client.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> inputStream.read(bs);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前来之服务器的反馈信息：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(bs,<span class="number">0</span>,len));</span><br><span class="line">        <span class="comment">//4.关闭客户端</span></span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">package</span> com.qfedu.TCP.V2;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建服务器端对象，参数只有一个需要和客户端一样的端口号</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器在等待客户端的链接.......&quot;</span>);</span><br><span class="line">        <span class="comment">//2.通过服务器端对象调用 accept 方法获取到连接服务器的客户端对象进行操作</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">sClient</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;恭喜!来自客户端&quot;</span>+sClient+<span class="string">&quot;已经链接上了.......&quot;</span>);</span><br><span class="line">        <span class="comment">//3.创建网络字节输入流对象，获取传输的数据【建立客户端与服务器连接通道】</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> sClient.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> inputStream.read(bs);</span><br><span class="line">        <span class="comment">//4.打印客户端的信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;来之客户端的信息是：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(bs,<span class="number">0</span>,len));</span><br><span class="line">        <span class="comment">//5.服务器向客户予以响应</span></span><br><span class="line">        <span class="comment">//5.1提供网络字节输出流对象</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> sClient.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;已收到信息，感谢访问(#^.^#)！&quot;</span>.getBytes());</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        <span class="comment">//6.关闭服务器</span></span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>案例3</p>
<p>    需求: 提供客户端与服务器之间聊天程序， 当某一个方输入 886 停止聊天</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.TCP.V3;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">//提供一个客户端程序，完成客户端接收与发送信息给服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供客户端对象</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;10.211.55.3&quot;</span>,<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2.提供网络字节输入输出流对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3.提供Scanner获取控制台信息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端向服务器说：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> input.next();</span><br><span class="line">            outputStream.write(content.getBytes());</span><br><span class="line">            outputStream.flush();</span><br><span class="line">            <span class="comment">//做了一个约定，如果哪一方输入886 就关闭聊天</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;886&quot;</span>.equals(content))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//提供数组存数据操作</span></span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> inputStream.read(bs);</span><br><span class="line">            System.out.println(<span class="string">&quot;来之服务器的信息：&quot;</span>+ <span class="keyword">new</span> <span class="title class_">String</span>(bs,<span class="number">0</span>,len));</span><br><span class="line">        &#125; </span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">package</span> com.qfedu.TCP.V3;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span></span><br><span class="line">Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建服务器端对象</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2.利用serverSocket对象中accept方法获取客户端连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        <span class="comment">//3.提供网络字节输入输出流对象完成信息发送</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> accept.getInputStream();</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> accept.getOutputStream();</span><br><span class="line">        <span class="comment">//4.提供控制台获取数据</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//4.1接收客户端向服务器发送的数据</span></span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> inputStream.read(bs);</span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bs,<span class="number">0</span>,len);</span><br><span class="line">            System.out.println(<span class="string">&quot;来之客户端的信息：&quot;</span>+content);</span><br><span class="line">            <span class="comment">//判断客户单输入的输入的数据是什么</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;886&quot;</span>.equals(content))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//4.2服务器向客户端发送数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;服务器端向客户端说：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> input.next();</span><br><span class="line">            outputStream.write(str.getBytes());</span><br><span class="line">            outputStream.flush();</span><br><span class="line">        &#125; </span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-1-使用tcp模拟tomcat服务器-center"><center>1、使用TCP模拟Tomcat服务器</center></h2>
<p>需求：利用浏览器进行网页访问，访问服务器中HTML页面，展示服务器端HTML页面在浏览器中</p>
<p>需要在项目中提供web目录并在web目录下提供html页面</p>
<p>在浏览器中访问地址时：</p>
<p>    IP地址:服务器端口号/访问资源路径 --》 相当于 --》127.0.0.1:9999/web/regist.html</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">//利用ServerSocket模拟Tomcat服务器提供网页访问服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TomcatServer</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.通过读取浏览器页面请求信息，获取浏览器需要访问的路径</span></span><br><span class="line">        <span class="comment">//提供ServerSocket服务器端对象</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//调用accept方法获取连接的客户端</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        <span class="comment">//通过返回socket对象获取网络字节输入流对象【建立连接通道】</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//将字节流转换为字符流【缓冲的】--》读取到字符串了</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">        <span class="comment">//利用字符缓冲输入流读取文件访问路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(path);</span><br><span class="line">        <span class="comment">//利用空格将path路径进行分隔，获取到访问资源路径</span></span><br><span class="line">        String[] s = path.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">//通过下标获取出资源路径，将路径最前面的/去掉</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> s[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;浏览器访问服务器的资源路径：&quot;</span>+realPath);</span><br><span class="line">        <span class="comment">//利用相对路径读取服务器中相对路径中资源反馈给浏览器</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(realPath);</span><br><span class="line">        <span class="comment">//在通过accept方法获取Socket对象获取网络字节输出流【将流中数据反馈给浏览器】</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//开始读写</span></span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8192</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="comment">//响应页面的时候需要将服务器返回给浏览器的必要信息</span></span><br><span class="line">        outputStream.write(<span class="string">&quot;HTTP/1.1 200OK\r\n&quot;</span>.getBytes());</span><br><span class="line">        outputStream.write(<span class="string">&quot;ContentType:text/html\r\n&quot;</span>.getBytes());</span><br><span class="line">        outputStream.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bs))!=-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            outputStream.write(bs,<span class="number">0</span>,len);</span><br><span class="line">        &#125; </span><br><span class="line">        outputStream.flush();</span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        fis.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点六：UDP协议编程（了解）</center></h1>
<p>Java中也提供UDP编程操作提供两个必要类：</p>
<p>    <strong>DatagramSocket【即是客户端也是服务器】 和DatagramPacket【UDP需要的数据包】</strong></p>
<p>UDP是无责任的发送模式类似于【广播电台】，UDP发送数据是不保证包安全，UDP的客户端与服务器是同一个类，发送数据时候需要使用DatagramPacket进行数据封装，包的限制64K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.UDP;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"><span class="comment">//UDP发送数据类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Send</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建UDP对象</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">sender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="comment">//2.提供信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;今天天气好晴朗，下班要下雨了，赶快跑路....&quot;</span>;</span><br><span class="line">        <span class="comment">//3.提供数据包将数据封装到包中</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(</span><br><span class="line">            content.getBytes(),            <span class="comment">//提供数据字节数组</span></span><br><span class="line">            content.getBytes().length,    <span class="comment">//字节数组的长度</span></span><br><span class="line">            InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="comment">//设置发送IP地址</span></span><br><span class="line">            <span class="number">9999</span>    <span class="comment">//发送端口号</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//发送信息</span></span><br><span class="line">        sender.send(packet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"><span class="comment">//UDP接收类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建UDP对象并指定接收数据端口号</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2.需要提供byte类型数据接收存数据</span></span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//3.创建数据包对象</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bs,bs.length);</span><br><span class="line">        <span class="comment">//接收数据存储在包对象中</span></span><br><span class="line">        receiver.receive(packet);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        拆包:</span></span><br><span class="line"><span class="comment">            getData() 获取包中字节数组</span></span><br><span class="line"><span class="comment">            getLength() 获取包中字节数组的长度</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(),<span class="number">0</span>,packet.getLength());</span><br><span class="line">        System.out.println(content);</span><br><span class="line">        receiver.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java语言</category>
      </categories>
      <tags>
        <tag>Java语言</tag>
      </tags>
  </entry>
  <entry>
    <title>26.反射</title>
    <url>/post/5883a4af.html</url>
    <content><![CDATA[<h1><center>知识点一：类的加载</center></h1>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012304354.WebP" alt="类的加载过程" style="zoom: 50%;">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.Demo03;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反射：在程序运行期获取的相关信息（对象、构造、方法、属性..）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 以前创建对象：通过new关键字去创建</span></span><br><span class="line"><span class="comment">     *      User user = new User();</span></span><br><span class="line"><span class="comment">     * 如果学习了反射，那么可以在代码运行期间创建类的对象（String）</span></span><br><span class="line"><span class="comment">     * 类的对象：通过new关键字创建的对象是类的对象（可以创建多个）</span></span><br><span class="line"><span class="comment">     * 类对象：在类加载的时候会产生一个类对象（包含类的所有的信息：属性、方法、构造方法、父类、接口、包名）（只会有一个）</span></span><br><span class="line"><span class="comment">     * 所有类的类对象的类型是Class类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 类加载的时机；</span></span><br><span class="line"><span class="comment">     *      1.创建对象</span></span><br><span class="line"><span class="comment">     *      2.创建子类对象</span></span><br><span class="line"><span class="comment">     *      3.调用类中的静态方法和属性</span></span><br><span class="line"><span class="comment">     *      4.通过Class.forName(&quot;&quot;);  主动触发类加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JVM中类的加载是有细分操作，当程序启动时候说那个到某个类，如果该类被加载到内存中，则JVM会通过三个步骤进行类的初始化操作【加载、连接和初始化】</p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012304757.WebP" alt="初始化" style="zoom: 50%;">
<h1><center>知识点二：什么是Class对象？</center></h1>
<p>PS：在Java中提供一个类这个类叫做Class，用于存储类的字节码文件对象【存储自定义类中描述信息】</p>
<p>例如：Java中需要创建某个类的对象</p>
<p>做法： Student stu = new Student(); —》通过Student类来创建stu这个对象，stu对象是Student类的实例，在创建过程中隐藏了一些内部实现的细节【类的加载】，就可以直接在代码中使用stu这个对象触发Student类中的属性和方法了</p>
<p>    Java是一门面向对象的语言，面向对象核心【世间万物皆对象】，所有东西都以对象角度为出发来进行思考，既然是这样那么就可以看待提供stu这个实例的类也是一个对象，那么Java就提供了一个可以描述自定义类的类Class【即描述类的类】，在整个类的加载过程中，反复提到了一点就是在类的字节文件【.class文件】加载到内存中时候，会生成一个【Class类的对象】，整个对象存中存储的就是类中所描述的信息，所以外界就可以提供Student stu = new Student(); —》通过Student类来创建stu这个对象</p>
<p>    但是除了这种创建方式之外，因为JVM中是存在Class类对象的，所以Java就提供了另外一种方式，可以直接通过Class类的对象加载出来对应类的对象操作，这个操作就叫做“【反射reflect】”</p>
<p>正常创建对象 —》 Student stu = new Student()；</p>
<p>但是在JVM中先得到Student类的.class字节码文件，通过字节码文件创建出Student这类的对象</p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012305610.WebP" alt="解说" style="zoom:50%;">
<h1><center>知识点三：获取Class对象</center></h1>
<p>如何获取Class对象,一共有三种方式获取类对象</p>
<p>    1、通过对象的getClass方法</p>
<p>        应用场景：必须有类的对象</p>
<p>    2、通过类的class属性</p>
<p>        应用场景：一般多用于方法传参</p>
<p>    3、通过Class类的forName方法</p>
<p>        应用场景：一般在运行期获取类对象(使用较多)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfeud.JDBC2.reflect;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过Class类的对象获取Student类的对象</span></span><br><span class="line">        <span class="comment">//1.正常创建Student类的对象操作</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;stu就是Student类的对象&quot;</span>);</span><br><span class="line">        <span class="comment">//通过反射获取到Student类的class对象并创建Student类的对象</span></span><br><span class="line">        <span class="comment">//1.通过Class类中静态方法，forName获取Student类的对象【Class对象】</span></span><br><span class="line">        <span class="comment">//参数需要是一个类的全限定名称【包名+类名】</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.qfeud.JDBC2.reflect.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//此时aClass对象就代表着Student类的【Class对象】</span></span><br><span class="line">        <span class="comment">//Class对象存储的就是Student类中提供描述信息，所以可以得到 Student类的对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;通过反射得到o对象是Student类的对象吗？&quot;</span>+(o <span class="keyword">instanceof</span> Student));</span><br><span class="line">        <span class="comment">//2.Java中每个类都有一个静态方法，Class类是描述类的类，那么所有类都是Class的实例(即Class对象)</span></span><br><span class="line">        <span class="comment">// Java中每个类都了一调用class这个静态方法获取到Class类的对象</span></span><br><span class="line">        Class&lt;Student&gt; studentClass = Student.class;    <span class="comment">//Class对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> studentClass.newInstance();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            3.利用了Object类中提供getClass方法获取到Class对象【强烈不推荐】</span></span><br><span class="line"><span class="comment">            PS：这个操作需要创建类的对象，并通过对象调用从Object类中继承而来的方法进行获取</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass1</span> <span class="operator">=</span> stu1.getClass();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> aClass1.newInstance();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Class类中提供方法有两个比较常用</span></span><br><span class="line"><span class="comment">            newInstance() 这个方法是可以通过Class对象创建出与之相关联的类的对象【调用时无参方法】</span></span><br><span class="line"><span class="comment">            getName()     这个方法可以获取到类的全限定名称 ---&gt; 包名+类名</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(aClass1.getName());</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">        <span class="comment">//强烈推荐第一种方式来获取Class对象，它不收到.java源文件的影响</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java中有九大内置Class对象【他们是JVM预先加载好的Class实例】 --》 【byte、short、int、long、float、double、char、boolean、void】其中八中基本数据类型对应包装类中存在一个静态属性Type，这个Type属性就可以获取到基本数据类型所对应Class对象</p>
<p>当执行 Integer.Type 等价于 int.class</p>
<p>除此之外Class对象还支持数组，得到数组的Class对象只能通过 数据类型[].class 或 数据对象.getClass()</p>
<h1><center>知识点四：反射操作</center></h1>
<p>反射其实可以帮组我们做很多的操作，通过分装性将属性和方法进行私有化操作，但是私有化的属性和方法之后，外界就无法获取到属性和方法，如果通过反射的形式来获取类属性和方法可以无视权限修饰符，在返回面前是没有权限修饰符可言，<strong>可以利用反射中操作形成【代理模式】，可以通过【代理模式】动态向类中添加方法【在不改变原码的前提下添加类中方法】—》spring框架（IOC/AOP）</strong>，反射可以作为资源文件加载操作方式</p>
<h2 id="center-1-class对象的常用方法-center"><center>1、Class对象的常用方法</center></h2>
<ul>
<li>c.getSimpleName() 获取类名</li>
<li>c.getName() 获取类的全限定名</li>
<li>c.getSuperclass(); 获取父类的类对象</li>
<li>c.getInterfaces(); 获取父接口的类对象，返回的是一个数组</li>
<li>newInstance(); 通过类对象创建的类的对象</li>
</ul>
<p>调用newInstance方法需要注意：</p>
<ul>
<li>1、这个了类必须有一个无参构造方法 InstantiationException</li>
<li>2、这个类的构造方法必须是public修饰 IllegalAccessException</li>
</ul>
<p>提供演示操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个是一个类的 ---&gt; 提供Student类中一些方法属性操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> age,String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个没有参数的方法&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个参数的方法&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> a ,String b)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是多个参数的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">package</span> com.qfeud.JDBC2.reflect;</span><br><span class="line"><span class="keyword">import</span> jdk.nashorn.internal.ir.CallNode;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//利用反射来处理这个类的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1. 获取到Student类的class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.qfeud.JDBC2.reflect.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//2.通过反射获取到类中所提供构造方法【Constructor】</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        相当于通过反射操作获取到Constructor构造方法对象，在通过这个对象创建类的对象</span></span><br><span class="line"><span class="comment">        这个方法可以获取到class对象中对应类的构造方法对象,参数是可变参数</span></span><br><span class="line"><span class="comment">        【这个参数如果不传递（不赋值得到就是无参构造方法）、这个参数进行传递(赋值操作，根据赋值个数决定获取对应构造方法)】</span></span><br><span class="line"><span class="comment">        getConstructor(Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//获取到的就是constructor对象【就是Student类中无参构造方法的对象】</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> aClass.getConstructor();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这个方法是使用constructor构造方法对象调用newInstance方法</span></span><br><span class="line"><span class="comment">            操作就相当于间接的调用对应构造方法得到这个class对象中存储类的对应对象</span></span><br><span class="line"><span class="comment">            newInstance(Object ... initargs) 方法中使用也是可变参数</span></span><br><span class="line"><span class="comment">            所以这个方法参数的传递时根据getConstructor这个方法的参数决定的，如果getConstructor方法没有设置参数</span></span><br><span class="line"><span class="comment">            newInstance这个方法也要没有参数 --》触发的就是无参构造方法</span></span><br><span class="line"><span class="comment">            如果如果getConstructor方法设置参数调用 newInstance这个方法也要给与参数，就是对构造方法参数的赋值</span></span><br><span class="line"><span class="comment">            PS：之前演示Class这个操作的时候，提供newInstance方法调用，并没有获取Constructor对象</span></span><br><span class="line"><span class="comment">            这样操作也是可以的，但是只能调用类中提供无参构造方法，无法选择有参构造方法</span></span><br><span class="line"><span class="comment">            这个方式调用构造方法必须是公有的</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;此时o这个对象得到是Student类的对象吗?&quot;</span>+(o <span class="keyword">instanceof</span> Student));</span><br><span class="line">        <span class="comment">//通过上面方式获取有参构造方法的操作 ---》 方法参数传递就是传递方法参数的 class对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            获取有参构造方法的对象必须传递方法参数class对象到getConstructor这个方法中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor1</span> <span class="operator">=</span> aClass.getConstructor(<span class="type">int</span>.class,String.class);</span><br><span class="line">        <span class="comment">//对构造方法中参数进行赋值操作了</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> constructor1.newInstance(<span class="number">18</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">//得到这个返回值类型时Object类型，所以得到操作是不能直接使用子类数据的</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> (Student)o1;</span><br><span class="line">        System.out.println(<span class="string">&quot;stu对象中age属性的值是：&quot;</span>+stu.age);</span><br><span class="line">        <span class="comment">//反射操作---》在反射面前是没有任何权限修饰符可言 ---》 利用反射操作获取到私有构造方法对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            获取到非public修饰的构造方法、属性或方法怎么办？</span></span><br><span class="line"><span class="comment">            在Class这个类中提供带有 Declared 单词的方法就是 ---》 翻译为暴力反射[无视权限修饰符]</span></span><br><span class="line"><span class="comment">            getDeclaredConstructor 这个方法的使用和getConstructor方法是一样的</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor2</span> <span class="operator">=</span> aClass.getDeclaredConstructor(String.class);</span><br><span class="line">        <span class="comment">//private权限是一个特殊权限，因为在权限修饰符中代表最低权限，为了防止外界恶意进行暴力反射</span></span><br><span class="line">        <span class="comment">//反射获取到操作对象之后，需要再次做一个操作，开启访问权限</span></span><br><span class="line">        <span class="comment">//setAccessible这个是开启权限的方法，参数是boolean类型，如果为true就开启权限，false就是不开启</span></span><br><span class="line">        constructor2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> constructor2.newInstance(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> (Student)o2;</span><br><span class="line">        System.out.println(<span class="string">&quot;stu对象中name属性的值是：&quot;</span>+stu2.getName());</span><br><span class="line">        <span class="comment">//类中通过反射访问类中属性</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            通过两个反射方法获取 getField() --&gt; 针对的public修饰的属性</span></span><br><span class="line"><span class="comment">                               DeclaredField() ---&gt; 针对非public(private)修饰的属性</span></span><br><span class="line"><span class="comment">            通过属性对象调用setAccessible(true)开启权限配合使用 ---》 针对private使用</span></span><br><span class="line"><span class="comment">            通过反射方法可以得到一个 Field对象 ---》这个对象可以操作类中属性</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> aClass.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        <span class="comment">//获取这个属性值如何操作？</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            只需要使用Field类中提供 get方法即可以获取到 属性值，但是get方法是有参数</span></span><br><span class="line"><span class="comment">            这个参数就是通过反射创建的对象即通过newInstance创建出来的对象</span></span><br><span class="line"><span class="comment">            PS:获取的是静态变量 get方法参数就是null值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o3</span> <span class="operator">=</span> age.get(stu);</span><br><span class="line">        System.out.println(<span class="string">&quot;stu这个对象中age属性的值是：&quot;</span>+o3);</span><br><span class="line">        <span class="comment">//对类中提供属性进行赋值操作？</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        只需要使用Field类中提供 set方法即可以对属性进行赋值</span></span><br><span class="line"><span class="comment">        这个方法有两个参数</span></span><br><span class="line"><span class="comment">            第一个参数:一共有两种赋值方式，原则是根据获取的数据类型决定【成员变量还是静态变量】</span></span><br><span class="line"><span class="comment">            如果是成员变量 ---》 这个参数就是通过反射创建的对象即通过newInstance创建出来的对象</span></span><br><span class="line"><span class="comment">            如果是静态变量 ---》 null ---》 对应的是Static修饰符</span></span><br><span class="line"><span class="comment">            第二个参数对属性赋值的具体数据</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        age.set(stu,<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;stu对象中age属性修改之后的数据是：&quot;</span>+age.get(stu));</span><br><span class="line">        <span class="comment">//【重点记忆】 ---》 获取类中方法操作【通过反射】</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            通过两个反射方法获取</span></span><br><span class="line"><span class="comment">                getMethod() --&gt; 针对的public修饰的方法</span></span><br><span class="line"><span class="comment">                DeclaredMethod() ---&gt; 针对非public修饰的方法</span></span><br><span class="line"><span class="comment">            通过属性对象调用</span></span><br><span class="line"><span class="comment">                setAccessible(true)开启权限配合使用 --&gt; 针对private</span></span><br><span class="line"><span class="comment">            通过反射获取方法的操作是需要两个参数的</span></span><br><span class="line"><span class="comment">                第一个参数 : 方法的名字</span></span><br><span class="line"><span class="comment">                第二个参数： 是一个可变参数，需要传递方法中参数的数据类型---》是class对象</span></span><br><span class="line"><span class="comment">                不传递参数赋值就是无参方法 传递参数赋值就是有参方法</span></span><br><span class="line"><span class="comment">                getMethod(String name, Class&lt;?&gt;...parameterTypes)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> aClass.getMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        <span class="comment">//得到是一个方法对象要执行方法</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            需要调用 invoke这个方法，这个方法也是有两个参数</span></span><br><span class="line"><span class="comment">            第一个参数:</span></span><br><span class="line"><span class="comment">                一共有两种赋值方式，原则是根据获取的方法类型决定【成员方法还是静态方法】</span></span><br><span class="line"><span class="comment">                    如果是成员变量 ---》 这个参数就是通过反射创建的对象即通过newInstance创建出来的对象</span></span><br><span class="line"><span class="comment">                    如果是静态变量 ---》 null ---》 对应的是Static修饰符</span></span><br><span class="line"><span class="comment">            第二个参数:</span></span><br><span class="line"><span class="comment">                需要和getMethod方法相配合 ，如果调用无参方法，这个可变参数就不传递数据</span></span><br><span class="line"><span class="comment">                如果调用有参反方，这个可变参数就需要进行赋值操作</span></span><br><span class="line"><span class="comment">                invoke(Object obj, Object... args)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        show.invoke(stu);</span><br><span class="line">        <span class="comment">//获取一个show方法对象，如果方法有参数，需要将方法参数类型Class对象传递到参数中</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">show1</span> <span class="operator">=</span> aClass.getMethod(<span class="string">&quot;show&quot;</span>, <span class="type">int</span>.class,</span><br><span class="line"><span class="type">int</span>.class);</span><br><span class="line">        show1.invoke(stu,<span class="number">1</span>,<span class="number">1</span>);    <span class="comment">//对应数据类型赋值即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<p>可以利用反射操作在没有【.java】文件的前提之下可以操作类【构造方法、属性和方法】</p>
<p>针对与使用public修饰构造方法、成员或静态属性和成员或静态方法 —》提供方法是</p>
<p>    getConstructor() ----》 获取构造方法  —》配套使用方法 —》 newInstance()</p>
<p>    getField() —》 获取属性的 —》配套使用方法—》 get获取 、 set赋值【这个方法中如果是成员属性需要传递反射创建对象，如果是静态属性传递null】</p>
<p>    getMethod —》 获取方法的 【重点记忆】—》 配套使用方法 --》 invoke() 【这个方法中如果是成员方	法需要传递反射创建对象，如果是静态方法传递null】</p>
<p>如果遇到非public修饰的，可以使用带有Declared单词的方法记性获取，并且如果修饰符是private修饰那么就需要配合使用setAccessible(true)开启权限</p>
<h2 id="center-2-利用反射可以直接加载properties文件-center"><center>2、利用反射可以直接加载properties文件</center></h2>
<p>这个操作是在开发中比较常见的一种方式，多用于对资源文件加载</p>
<p>在工程中创建文件夹就不能是普通文件夹，这里需要创建是一个资源文件夹【Source Folder】</p>
<p>这个文件在工程内部的特点：自动编译文件夹中所有文件并且添加到classPath路径【也就是说将文件添加到工程内部存储字节码文件的文件夹中】，就可以利用反射进行文件的加载</p>
<p>PS:资源文件夹在项目中是以【“蓝色标色”】，在工程中src这个文件夹就是资源文件夹</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfeud.JDBC2.reflect;</span><br><span class="line"><span class="keyword">import</span> jdk.nashorn.internal.ir.CallNode;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectReadPropertiesFile</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用这种方式加载文件，这个文件必须在资源文件夹中</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            利用的原理就是 使用类加载器对classPath路径中文件进行加载，会返回一个流资源对象</span></span><br><span class="line"><span class="comment">            类的加载器在加载这个文件时会去classPath(在IDEA中就是out目录)下寻找这个同名文件</span></span><br><span class="line"><span class="comment">            建立流资源进行读取操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//提供一个Properties资源文件对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//提供一个类的加载器【每一个类都有类的加载器】</span></span><br><span class="line">        <span class="comment">//利用线程对象获取类的加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">contextClassLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="comment">//利用本类的class对象获取类的加载器</span></span><br><span class="line">        <span class="comment">//ClassLoader classLoader = ReflectReadPropertiesFile.class.getClassLoader();</span></span><br><span class="line">        <span class="comment">//使用类的加载器对象加载资源文件夹--》这个方法的参数不需要路径，只要文件名字就可以了</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> contextClassLoader.getResourceAsStream(<span class="string">&quot;db.properties&quot;</span>);</span><br><span class="line">        <span class="comment">//通过字节输入流对象加载资源</span></span><br><span class="line">        p.load(resourceAsStream);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">resourceAsStream1</span> <span class="operator">=</span>ReflectReadPropertiesFile.class.getClassLoader()</span><br><span class="line">                                                            .getResourceAsStream(<span class="string">&quot;db.properties&quot;</span>);</span><br><span class="line">        <span class="comment">//这个方法只能在JavaSE中调用在，在后续学习中EE中是不可以调用</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">systemResourceAsStream</span> <span class="operator">=</span> contextClassLoader.getSystemResourceAsStream(<span class="string">&quot;db.properties&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-3-扩展：静态方法和数组参数如何传递-center"><center>3、扩展：静态方法和数组参数如何传递</center></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfeud.JDBC2.reflect;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>    <span class="comment">//这是一个员工类</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(<span class="type">int</span>... arr)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doWork1被调用了:&quot;</span>+ Arrays.toString(arr));</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(String... arr)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doWork1被调用了:&quot;</span>+ Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectInvokeStaticMethod</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里简化获取操作</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">employeeClass</span> <span class="operator">=</span> Employee.class;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">doWork</span> <span class="operator">=</span> employeeClass.getMethod(<span class="string">&quot;doWork&quot;</span>,<span class="type">int</span>[].class);</span><br><span class="line">        <span class="comment">//调用静态方法执行并对可变参数进行赋值操作</span></span><br><span class="line">        <span class="comment">//执行方法时，如果是静态方法第一个参数传递null值,第二个参数需要传递一个数组对象进来</span></span><br><span class="line">        doWork.invoke(<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">doWork1</span> <span class="operator">=</span> employeeClass.getMethod(<span class="string">&quot;doWork&quot;</span>, String[].class);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            如果此时方法的参数类型是存储引用类型数组，此时通过反射方式调用，编译器对方法参数的认知不是String</span></span><br><span class="line"><span class="comment">            认知为当前参数是一个Object类型的数组，这个数组中存储这个String类型数组</span></span><br><span class="line"><span class="comment">            即将String类型的数组作为Object类型数组的一个元素存储</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        doWork1.invoke(<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>&#125;&#125;);</span><br><span class="line">        <span class="comment">//提示：只要是数组作为方法的参数类型，无论是基本数据类型数据还是引用数据类型的数组</span></span><br><span class="line">        <span class="comment">// 统一作为反射调用方法参数传递时，都使用 new</span></span><br><span class="line">        Object[]&#123;具体数据值&#125;；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点五：Stream流</center></h1>
<h2 id="center-1-概念-center"><center>1、概念</center></h2>
<p>流（Stream）与集合类似，但集合中保存的是数据，而Stream中保存对集合或数组数据的操作</p>
<h2 id="center-2-stream特点-center"><center>2、Stream特点</center></h2>
<p>Stream 自己不会存储元素</p>
<p>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</p>
<p>Stream 操作是延迟执行的，会等到需要结果的时候才执行</p>
<h2 id="center-3-stream使用步骤-center"><center>3、Stream使用步骤</center></h2>
<p>创建：</p>
<p>    新建一个流</p>
<p>中间操作：</p>
<p>    在一个或多个步骤中，将初始Stream转化到另一个Stream的中间操作。</p>
<p>终止操作：</p>
<p>    使用一个终止操作来产生一个结果。该操作会强制之前的延迟操作立即执行，在此之后，该Stream就不能使用了</p>
<h2 id="center-4-创建stream的方法-center"><center>4、创建Stream的方法</center></h2>
<ol>
<li>通过Collection对象的stream()或parallelStream()方法</li>
<li>通过Arrays类的stream()方法</li>
<li>通过Stream接口的of()、iterate()、generate()方法</li>
<li>通过IntStream、LongStream、DoubleStream接口中的of、range、rangeClosed方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Stream对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;22&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;456557&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;56789&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    <span class="comment">//list.forEach(System.out::println);    //集合中有forEach遍历方法</span></span><br><span class="line">    <span class="comment">//通过集合对象获取Stream对象</span></span><br><span class="line">    Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">    stream.forEach(s -&gt; System.out.println(s));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取Stream对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(arr);    <span class="comment">//返回一种流</span></span><br><span class="line">    stream.forEach(System.out::println);    <span class="comment">//快捷方式：soutc</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//获取Stream对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-5-中间操作的方法-center"><center>5、中间操作的方法</center></h2>
<p>常见中间操作方法：</p>
<ul>
<li>filter、limit、skip、distinct、sorted</li>
<li>map</li>
<li>parallel</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Stream对象中常用的方法 中间操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;22&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;456557&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;56789&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    <span class="comment">//获取集合中长度大于3的元素</span></span><br><span class="line">    <span class="comment">//list.stream().filter(li -&gt; li.length()&gt;3).forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//获取集合的第一页数据（前三条）</span></span><br><span class="line">    <span class="comment">//list.stream().limit(3).forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//获取集合的第二页数据（4~6条）</span></span><br><span class="line">    <span class="comment">//list.stream().skip(3).limit(3).forEach(System.out::println);</span></span><br><span class="line">	<span class="comment">//第一个三是跳过几个元素,第二个是获取几个</span></span><br><span class="line">    <span class="comment">//获取集合中不重复的元素</span></span><br><span class="line">    <span class="comment">//list.stream().distinct().forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//将集合中的元素进行排序(注意：集合中的元素必须实现了Comparable接口)</span></span><br><span class="line">    <span class="comment">//list.stream().sorted().forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//将集合中的元素进行排序(按照元素的长度降序)</span></span><br><span class="line">    <span class="comment">//list.stream().sorted((o1, o2) -&gt; o2.length() - o1.length()).forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//将集合中的元素转换成int类型</span></span><br><span class="line">    <span class="comment">//list.stream().map(li -&gt; Integer.parseInt(li)+1).forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//list.stream().map(Integer::parseInt).forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//使用多线程操作集合中的元素</span></span><br><span class="line">    <span class="comment">// list.stream().forEach(li-&gt;    //单线程操作</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//     System.out.println(Thread.currentThread().getName()+&quot;=====&gt;&quot;+li);</span></span><br><span class="line">    <span class="comment">//&#125;);</span></span><br><span class="line">    list.stream().parallel().forEach(li-&gt;    <span class="comment">//多线程操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=====&gt;&quot;</span>+li);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-6-终止操作-center"><center>6、终止操作</center></h2>
<p>常见终止操作：</p>
<ul>
<li>forEach、min、max、count</li>
<li>reduce、collect</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Stream对象中常用的方法 终止操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m5</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;22&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;456557&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;562789&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    <span class="comment">//遍历集合中的元素</span></span><br><span class="line">    <span class="comment">//list.forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//list.stream().forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//获取集合中元素长度最小的元素</span></span><br><span class="line">    <span class="comment">//Optional&lt;String&gt; min = list.stream().min((o1, o2) -&gt; o1.length() - o2.length());</span></span><br><span class="line">    <span class="comment">//System.out.println(min.get());</span></span><br><span class="line">    <span class="comment">//Optional&lt;String&gt; max = list.stream().max((o1, o2) -&gt; o1.length() - o2.length());</span></span><br><span class="line">    <span class="comment">//System.out.println(max.get());</span></span><br><span class="line">    <span class="comment">//获取集合中长度为3的元素个数</span></span><br><span class="line">    <span class="comment">//long count = list.stream().filter(li -&gt; li.length() == 3).count();</span></span><br><span class="line">    <span class="comment">//System.out.println(count);</span></span><br><span class="line">    <span class="comment">//将集合中的元素转成int类型并计算总和(计算)</span></span><br><span class="line">    <span class="comment">//Integer result = list.stream().map(Integer::parseInt).reduce(0, (o1, o2) -&gt; o1 + o2);</span></span><br><span class="line">    <span class="comment">//System.out.println(result);</span></span><br><span class="line">    <span class="comment">//将Stream流对象转换成List、set、Map集合</span></span><br><span class="line">    List&lt;String&gt; collect = list.stream().filter(li -&gt; li.contains(<span class="string">&quot;2&quot;</span>)).collect(Collectors.toList());</span><br><span class="line">    collect.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java语言</category>
      </categories>
      <tags>
        <tag>Java语言</tag>
      </tags>
  </entry>
  <entry>
    <title>3.接口</title>
    <url>/post/fe7ab1f0.html</url>
    <content><![CDATA[<h1><center>基本语法</center></h1>
<p>接口中不能有普通属性、构造方法、静态代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名字</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> 数据类型 常量名 = 值;	<span class="comment">//静态常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名(参数列表);	<span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> 返回值类型 方法名(参数列表)	<span class="comment">//类中成员方法</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">//提供方法实现</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名(参数列表)    <span class="comment">//类中静态方法</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">//提供方法实现</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//PS：从Java9开始允许接口中定义 private 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现接口(implements)：</span></span><br><span class="line"><span class="keyword">public</span> class 实现类(子类) implements 接口</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-特点-center"><center>特点</center></h2>
<ol>
<li>
<p>接口是没有构造方法的，所以接口就更不可能直接创建对象，即 接口名 对象名 = new 接口名(); ----》这种操作是不可实现</p>
</li>
<li>
<p>上面语法中体现修饰符【public、static 、final、abstract】，都可以省略不写，接口是默认修饰原则，自动就添加了【static方法中static不可以省略，default方法中default不可以省略】</p>
</li>
<li>
<p>接口本意是让类来实现约束使用，所以接口修饰必须是public</p>
</li>
<li>
<p>类与接口建立联系时使用的【实现关系】，所以使用关键字是【 implements】</p>
</li>
<li>
<p>接口支持多态并且接口是引用类型</p>
</li>
<li>
<p>接口中的抽象方法必须要被非抽象类重写</p>
</li>
</ol>
<p>例：提供一个接口文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceForJDK_8</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1. 可以在接口中定义静态全局常量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">NUM</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//接口是一个默认修饰原则 ---》等价于 --》 public static final int</span></span><br><span class="line">    NUM = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.提供抽象方法的定义</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;	<span class="comment">//接口是一个默认修饰原则 ---》等价于 --》 public abstract void show();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.允许接口中提供default方法【这个方法带有方法体（相当于是类中成员方法）实现接口子类可以重写这个方法】</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">showInfosDefault</span><span class="params">()</span>	<span class="comment">//接口是一个默认修饰原则 ---》等价于 --》 public</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">showInfosDefault</span><span class="params">()</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接口中default方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.允许接口中提供static方法【这个方法带有方法体（相当于是类中静态方法），实现接口子类不可以重写这个方法】</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showInfosStatic</span><span class="params">()</span>    <span class="comment">//接口是一个默认修饰原则 ---》等价于--》public</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showInfosStatic</span><span class="params">()</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接口中static方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>普通类如果实现接口，必须实现接口中所有抽象方法【接口利用抽象方法约束类进行方法实现操作】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">InterfaceForJDK_8</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实现接口中show方法&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;可以在接口的实现类中调用接口中定义全局常量：&quot;</span>+NUM);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//选择向重写接口中提供default方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showInfosDefault</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里就间接证明类与接口属于间接继承效果</span></span><br><span class="line">        <span class="comment">//InterfaceForJDK_8.super.showInfosDefault();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;重写接口中default方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Test类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.可以使用接口的实现类创建对象完成操作</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.show();</span><br><span class="line">        person.showInfosDefault();</span><br><span class="line">        <span class="comment">//接口与类之间虽然是实现关系，但是属于隐式继承，所以可以使用多态效果创建接口对象</span></span><br><span class="line">        <span class="type">InterfaceForJDK_8</span> <span class="variable">interfaceForJDK8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        interfaceForJDK8.show();</span><br><span class="line">        interfaceForJDK8.showInfosDefault();</span><br><span class="line">        <span class="comment">//接口中静态方法与常量只能使用接口名调用</span></span><br><span class="line">        InterfaceForJDK_8.showInfosStatic();</span><br><span class="line">        System.out.println(InterfaceForJDK_8.NUM);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-注意事项-center"><center>注意事项</center></h2>
<ol>
<li>在开发中设计接口时，接口名字，都是以大写字母【I】开头，除非单词首字符是【I】除外，代表是一个接口，接口实现类命名在最后单词结尾要添加Impl，代表实现接口类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPerson</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showInfosPerson</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonImpl</span> <span class="keyword">implements</span> <span class="title class_">IPerson</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showInfosPerson</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>一类可以实现多个接口【相当于是多继承模拟】接口名逗号分隔，并给还可以继承另外一个类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPerson</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showInfosPerson</span><span class="params">()</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStudent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showInfosStudent</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Man</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OldMan</span> <span class="keyword">extends</span> <span class="title class_">Man</span> <span class="keyword">implements</span> <span class="title class_">IPerson</span>,IStudent&#123;&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>接口和接口之间存在继承关系，而且允许多继承【可以得到继承接口中所有操作】</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPerson</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showInfosPerson</span><span class="params">()</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStudent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showInfosStudent</span><span class="params">()</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMan</span> <span class="keyword">extends</span> <span class="title class_">IPerson</span>,IStudent&#123;&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>可以使用抽象类实现接口，选择性实现接口中抽象方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStudent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showInfosStudent</span><span class="params">()</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ManImpl</span> <span class="keyword">implements</span> <span class="title class_">IStudent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//抽象类可以选择性实现接口中抽象方法，也可以不实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>接口回调</center></h1>
<p>先有接口的使用者，后有接口的实现者</p>
<p>MyClass类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//后有接口的实现者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isZS</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; num; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MyInterface接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断一个数是否是质数</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isZS</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Test类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        gdbh(<span class="number">14</span>,<span class="keyword">new</span> <span class="title class_">MyClass</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先有接口的使用者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">gdbh</span><span class="params">(<span class="type">int</span> num,MyInterface myInterface)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">6</span> || num % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;传入参数不合法&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= num/<span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (myInterface.isZS(i) &amp;&amp; myInterface.isZS(num-<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(num + <span class="string">&quot;=&quot;</span> + i + <span class="string">&quot;+&quot;</span> + (num-i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>内部类</center></h1>
<p>定义在一个类的里面的类为内部类，在外面的类成为外部类</p>
<ol>
<li>成员内部类，内部类在定义时没有使用static修饰（知晓）</li>
<li>静态内部类，内部类在定义时使用static修饰【Java中唯一可以使用static修饰类的方法】(知晓)</li>
<li>局部内部类，内部类在定义时定义在方法体内部（了解）</li>
<li>匿名内部类，它属于局部类类的特殊形态（必须会用）</li>
</ol>
<p>PS： 数字是从1开始逐渐递增【随着类的增加而增加】</p>
<h2 id="成员内部类">成员内部类</h2>
<p>成员内部类是定义在类中，不使用static修饰，可以使用4种权限修饰符，可以使用abstract和final修饰，允许继承类与实现接口，成员内部类中不可以定义static修饰变量与方法，成员内部类是可以直接访问外部类定义属性和方法，<strong>如果成员内部类出现了与外部类属性重名，可以使用【this 和 外部类.this】进行区分</strong></p>
<p>创建成员内类的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类类名.内部类类名 内部类对象名 = <span class="keyword">new</span> 外部类().new 内部类();</span><br></pre></td></tr></table></figure>
<p>外部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outter</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//外部类中提供成员变量和方法、静态变量和方法</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小白&quot;</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showInfos</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类静态方法&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类的成员方法&quot;</span>);</span><br><span class="line">        <span class="comment">//需要提供内部类对象创建，才可以使用成员内部类中所提供成员变量和成员方法</span></span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        innerClass.name =<span class="string">&quot;z&quot;</span>;</span><br><span class="line">        innerClass.show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成员内部类，可以使用任何修饰符除static外</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>	<span class="comment">//成员内部类</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">//可以在成员内部类中提供类的基础定义，但是不可以提供static修饰的属性和方法</span></span><br><span class="line">        <span class="comment">//static double PI = 3.14;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小黑&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成员内部类中成员方法&quot;</span>);</span><br><span class="line">            <span class="comment">//this代表的是InnerClass对象，防止成员内部类和外部类同名属性</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//这种方式访问外部类的成员变量</span></span><br><span class="line">            System.out.println(Outter.<span class="built_in">this</span>.name);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//调用外部类的成员方法【重名时调用：外部类类名.this.方式】</span></span><br><span class="line">            display();</span><br><span class="line">            System.out.println(PI);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//成员内部类中是可以调用外部类静态属性和方法</span></span><br><span class="line">            System.out.println(age);</span><br><span class="line">            showInfos();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 外部类类名.内部类类名 内部类对象名 = new 外部类().new 成员内部类();</span></span><br><span class="line">        Outter.<span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>().<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        innerClass.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态内部类">静态内部类</h2>
<p>静态内部类和成员内部类几乎是一样的，不同在于静态内部类使用static进行了修饰</p>
<p>静态内部类创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类类名.静态内部类类名 对象名 = <span class="keyword">new</span> 外部类类名.静态内部类类名();</span><br></pre></td></tr></table></figure>
<p>静态内部就是使用static修饰类【Java中只有这个类可以使用static修饰】，可以使用所有权限修饰符，abstract和final修饰，静态内部类和静态属性和静态方法是一样都属于类，静态内部类中是可以定义【成员变量和方法、静态变量和方法】，静态内部类中不允许明确访问方式获取外部类this对象即【外部类类名.this】所以在静态内部类中访问外部类成员变量和成员方法，需要提供外部对象才可以，外部类静态变量和静态方法直接访问即可，如果有重名【外部类类名.静态变量/静态方法】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//外部类中提供成员变量和方法、静态变量和方法</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小白&quot;</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showInfos</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类静态方法&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类的成员方法&quot;</span>);</span><br><span class="line">        <span class="comment">//调用静态内部类中静态属性和方法 ---》 静态内部类类名.静态属性和静态方法即可</span></span><br><span class="line">        System.out.println(InnerClass.name);	<span class="comment">//如果要跨类调用，则需要前面加上外部类的类名</span></span><br><span class="line">        <span class="comment">//调用静态内部类中成员属性和方法 ---》 需要提供静态内部类的对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Outter</span>.InnerClass().show();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供静态成员内部类 ---》 静态内部类就是定义在类中类，可以使用static修饰符修饰</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>    <span class="comment">//静态内部类</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 静态内部类可以提供普通类中所有可以提供操作【成员变量和方法、静态变脸和方法】</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.15</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小黑&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//在静态内部类中是不用担心 属性重名问题</span></span><br><span class="line">            <span class="comment">//不是可以使用 外部类类名.this方法访问外部的属性【static中是不允许使用this和super关键字】</span></span><br><span class="line">            <span class="comment">//只能在静态内部类中创建外部类对象，才可以访问外部类成员变量和成员方法</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Outter</span>().name);</span><br><span class="line">            <span class="comment">//调用外部类静态方法和静态属性 --&gt; 外部类类名.静态属性或静态方法</span></span><br><span class="line">            System.out.println(Outter.age);</span><br><span class="line">            Outter.showInfos();</span><br><span class="line">            <span class="comment">//静态内部类中的属性和方法直接调用即可</span></span><br><span class="line">            System.out.println(PI);</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//提供静态内部类对象创建</span></span><br><span class="line">        <span class="comment">//外部类类名.静态内部类类名 对象名 = new 外部类类名.静态内部类类名();</span></span><br><span class="line">        Outter.<span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>.InnerClass();</span><br><span class="line">        innerClass.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="局部内部类">局部内部类</h2>
<p>不允许使用任何修饰符，只能定义在方法内部与局部变量是平级关系，<strong>访问作用域仅限在方法的内部</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outter</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供一个成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//局部变量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">        <span class="comment">//提供局部内部类【局部变量是平级关系】</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">InnerClass</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//局部内部类中是不允许定义static修饰属性和方法</span></span><br><span class="line">            <span class="comment">//允许提供成员变量和成员方法</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="string">&quot;男&quot;</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//在局部内部类中访问方法中局部变量</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    IDEA提供错误提示信息</span></span><br><span class="line"><span class="comment">                    Variable &#x27;age&#x27; is accessed from within inner class, needs to be</span></span><br><span class="line"><span class="comment">					final or effectively final</span></span><br><span class="line"><span class="comment">                    如果局部内部类使用方法提供的局部变量，这个局部变量必须是final修饰</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                System.out.println(age);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//局部内部类只能在方法体的内部创建对象和使用，外界是无法访问到这个类中</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InnerClass</span>().display();</span><br><span class="line">        <span class="comment">//在此在方法体的内部修改成员变量</span></span><br><span class="line">        <span class="comment">// age = 20;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名内部类">匿名内部类</h2>
<p>    作用：提供便捷接口实现，只会使用一次这样方式是最便捷</p>
<p>    某些方法进行接口参数传递时，只会使用这一次接口操作【即调用方法的位置使用一次接口就结束】，创建类实现接口，在创建类对象传递到方法中操作就十分繁琐，而且类只会方法中使用一次，类的存在就没有太大意义【<strong>所有在这种情况下，就可以利用匿名内部类方式完成对接口实现并传递到方法参数中</strong>】</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类()&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽烟接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ISmoking</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 抽烟方法</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name 抽烟的名字</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">smoke</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照以往的方法实现接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outter</span> <span class="keyword">implements</span> <span class="title class_">ISmoking</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">smoke</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在抽的烟是:&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用抽烟方法展示抽象操作</span></span><br><span class="line">        <span class="comment">//1.提供实现ISmoking接口对象</span></span><br><span class="line">        <span class="type">Outter</span> <span class="variable">outter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.通过outter对象调用smoke方法就可以执行抽烟操作</span></span><br><span class="line">        outter.smoke(<span class="string">&quot;华子&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这个方法可以接收的对象必须是实现ISmoking接口的对象【利用就是面向兑现中多态】</span></span><br><span class="line">        showInfosSmokeName(outter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//但是，如果当前实现接口类只使用一次，不在重复使用了，这样创建方式就比较繁琐也不利于管理</span></span><br><span class="line">        <span class="comment">//所以Java就提供了一个更加便捷处理方式，提供匿名内部类作为接口的实现操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一种 主要是针对与方法参数为接口类型进行赋值操作 --》完全匿名内部类</span></span><br><span class="line"><span class="comment">            new 接口名()</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                提供接口中抽象方法的实现;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ISmoking</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">smoke</span><span class="params">(String name)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;完全匿名内部类实现接口：&quot;</span>+name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.smoke(<span class="string">&quot;芙蓉王&quot;</span>); <span class="comment">//这种形式主要是针对方法参数赋值使用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用smoke方法而不是对于方法参数传递</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第二种方式，针对匿名内部类所创建对象进行存储操作</span></span><br><span class="line"><span class="comment">            接口名 对象名 = new 接口名()</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                接口抽象方法的实现</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//smoking 存储的就是匿名内部类的引用【使用 new ISmoking的形式将后面的匿名内部类进行对象向上转型】</span></span><br><span class="line">        <span class="type">ISmoking</span> <span class="variable">smoking</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ISmoking</span>() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">smoke</span><span class="params">(String name)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;使用匿名内部类创建了接口对象：&quot;</span>+name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        smoking.smoke(<span class="string">&quot;煊赫门&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以使用匿名内部类的这种语法便捷的对方法中参数进行赋值操作</span></span><br><span class="line">        showInfosSmokeName(<span class="keyword">new</span> <span class="title class_">ISmoking</span>()</span><br><span class="line">                           &#123;</span><br><span class="line">                               <span class="meta">@Override</span></span><br><span class="line">                               <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">smoke</span><span class="params">(String name)</span> </span><br><span class="line">                               &#123;</span><br><span class="line">                                   System.out.println(<span class="string">&quot;匿名内部类对接口参数赋值：&quot;</span>+name);</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;);    <span class="comment">// 使用匿名内部类形式对接口参数进行赋值操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个方法这个方法的参数类型是接口类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showInfosSmokeName</span><span class="params">(ISmoking smoking)</span></span><br><span class="line">    &#123;</span><br><span class="line">        smoking.smoke(<span class="string">&quot;小熊猫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>Lambda</center></h1>
<p>在Java中是为了解决匿名内部类繁琐实现</p>
<p>作用：简化匿名内部类实现代码作为方法接口实现参数的传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaDemo1</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//lambda表达式于匿名内部类之间区别</span></span><br><span class="line">        <span class="comment">//提供一个Integer类型数据【Integer理解为int类型】</span></span><br><span class="line">        Integer[] arr = &#123;<span class="number">23</span>,<span class="number">4132</span>,<span class="number">2</span>,<span class="number">123</span>,<span class="number">512345</span>,<span class="number">2463</span>,<span class="number">2234</span>,<span class="number">343</span>&#125;;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在Arrays工具类中有有一个排序方法，可以提供方给我们使用</span></span><br><span class="line"><span class="comment">            这个方法中有两个参数版本，这个版本中第二个参数就是接口，这个接口叫做Comparator接口</span></span><br><span class="line"><span class="comment">            Comparator接口是一个比较接口，对接口进行实现来执行排序的方式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> o2-o1; <span class="comment">//降序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;arr数据排序之后：&quot;</span>+Arrays.toString(arr));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用匿名内部类实现起来是比较繁琐的，代码太多了，看起来会比较繁琐</span></span><br><span class="line"><span class="comment">            此时就可以利用Lambda表达式代替匿名内部的实现进行方法中接口参数的传递操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Arrays.sort(arr,((o1,o2)-&gt;o2-o1));</span><br><span class="line">        System.out.println(<span class="string">&quot;lambda表达式的实现排序：&quot;</span>+Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>    Lambda表达式与匿名内部类一样，适合一次使用的效果，多次重复使用Lambda表达式就不是很便捷【根匿名内部类一样】，但是Lambda表达式可以更加便捷实现，替换匿名内部类的繁琐实现</p>
<h2 id="center-语法-center"><center>语法</center></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">()-&gt;&#123;&#125; 或者 (参数)-&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提供多个接口分别使用Lambda表达式实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceA</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showA</span><span class="params">()</span>;	<span class="comment">//定义一个无参的抽象方法</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceB</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showB</span><span class="params">(<span class="type">int</span> b)</span>;	<span class="comment">//定义一个有一个参数抽象方法</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceC</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showB</span><span class="params">(<span class="type">int</span> c,<span class="type">int</span> d)</span>;	<span class="comment">//定义一个有两个参数抽象方法</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceD</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">showD</span><span class="params">(<span class="type">int</span> c,<span class="type">int</span> d)</span>;	<span class="comment">//定义一个带有返回值和多个参数的方法</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在这个类中main中方法中使用Lambda表达式实现接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Lambda表达式对应的是接口中抽象方法 接口中抽象方法是如何定义的Lambda表达式就仿照定义</span></span><br><span class="line">        <span class="comment">//1.使用Lambda表达式实现一个接口【抽象方法是无返回值无参的状态】</span></span><br><span class="line">        <span class="type">InterfaceA</span> <span class="variable">a1</span> <span class="operator">=</span> () -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Lambda表达式实现接口中showA方法&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//调用接口中方法</span></span><br><span class="line">        a1.showA();</span><br><span class="line">        <span class="comment">//如果lambda表达式对抽象方法实现方式体只有一句代码可以省略大括号</span></span><br><span class="line">        <span class="type">InterfaceA</span> <span class="variable">a2</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Lambda表达式实现接口中showA方法&quot;</span>);</span><br><span class="line">        <span class="comment">//2.使用Lambda表达式实现一个接口【抽象方法是无返回值有一个参数的状态】</span></span><br><span class="line">        <span class="type">InterfaceB</span> <span class="variable">b1</span> <span class="operator">=</span> (<span class="type">int</span> b) -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Lambda表达式实现接口中showB方法：&quot;</span>+b);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//Lambda表达式可以对定义参数提供自动类型推断，省略参数中定义数据类型</span></span><br><span class="line">        <span class="type">InterfaceB</span> <span class="variable">b2</span> <span class="operator">=</span> (b) -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Lambda表达式实现接口中showB方法：&quot;</span>+b);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//Lambda表达式实现抽象方法是一个参数的，可以省略数据类型和小括号</span></span><br><span class="line">        <span class="comment">//如果实现方法体只有一句代码可以省略大括号</span></span><br><span class="line">        <span class="type">InterfaceB</span> <span class="variable">b3</span> <span class="operator">=</span> b -&gt; System.out.println(<span class="string">&quot;Lambda表达式实现接口中showB方法：&quot;</span>+b);</span><br><span class="line">        <span class="comment">//3.使用Lambda表达式实现一个接口【抽象方法是无返回值有多个参数的状态】</span></span><br><span class="line">        <span class="comment">//直接利用上面所提供有些优化策略直接操作者【数据类型自定推断（省略参数类型）】</span></span><br><span class="line">        <span class="type">InterfaceC</span> <span class="variable">c1</span> <span class="operator">=</span> (c,d)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Lambda表达式实现抽象方法showC&quot;</span>+(c+d));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//4.使用Lambda表达式实现一个接口【抽象方法是有返回值有多个参数的状态】</span></span><br><span class="line">        <span class="comment">//如果实现抽象方法只有一句执行语句，此时return关键字可以省略不写【这个方法需要带有返回值才可以】</span></span><br><span class="line">        <span class="type">InterfaceD</span> <span class="variable">d1</span> <span class="operator">=</span> (c,d)-&gt;c + d;</span><br><span class="line">        <span class="comment">//如果需要在使用Lambda表达式实现时有多个条代码语句，就需要书写return关键字</span></span><br><span class="line">        <span class="type">InterfaceD</span> <span class="variable">d2</span> <span class="operator">=</span> (c,d)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(c &gt; d)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> c+d;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> d-c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>练习：提供一个接口InterfaceE，在接口中定义一个抽象方法 showE，并且有一个参数，带有返回，提供一个执行类在执行类中定义一个静态方法，方法参数类型时InterfaceE，并在静态方法调用接口中showE并执行效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提供一个InterfaceE的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceE</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">showE</span><span class="params">(<span class="type">boolean</span> b)</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用匿名内部类的实行使用方法的实现</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> result(<span class="keyword">new</span> <span class="title class_">InterfaceE</span>() </span><br><span class="line">                             &#123;</span><br><span class="line">                                 <span class="meta">@Override</span></span><br><span class="line">                                 <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">showE</span><span class="params">(<span class="type">boolean</span> b)</span> </span><br><span class="line">                                 &#123;</span><br><span class="line">                                     <span class="keyword">return</span> b;</span><br><span class="line">                                 &#125;</span><br><span class="line">                             &#125;,<span class="literal">true</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;匿名内部类实现方法得到的返回值是：&quot;</span>+res);</span><br><span class="line">        <span class="comment">//使用Lambda表达式实现操作</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res2</span> <span class="operator">=</span> result(b -&gt; b, <span class="literal">false</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Lambda表达式实现方法得到的返回值是：&quot;</span>+res2);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供一个静态方法，这个方法参数列表中有InterfaceE这个接口类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">result</span><span class="params">(InterfaceE e,<span class="type">boolean</span> res)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> e.showE(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-局限性-center"><center>局限性</center></h2>
<p>需要注意Lambda表达式不是万能的，Lambda表达式不能替代所有的匿名内部类的操作，Java8中提供的这个新的特性Lambda表达式存在一个实现弊端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceF</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//添加两个抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showF</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showFF</span><span class="params">(<span class="type">int</span> f)</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用匿名内部类实现InterfaceF接口</span></span><br><span class="line">        <span class="type">InterfaceF</span> <span class="variable">interfaceF</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceF</span>() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showF</span><span class="params">()</span> </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类实现InterfaceF接口&quot;</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showFF</span><span class="params">(<span class="type">int</span> f)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类实现InterfaceF接口&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//使用Lambda表达式实现InterfaceF接口</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            IDEA中提供错误提示</span></span><br><span class="line"><span class="comment">            Multiple non-overriding abstract methods found in interface</span></span><br><span class="line"><span class="comment">            com.qfedu.lambda.InterfaceF</span></span><br><span class="line"><span class="comment">            这个就是Lambda表达式的局限性，Lambda表达式只能实现接口中只存在一个抽象方法</span></span><br><span class="line"><span class="comment">            Lambda表达式实现接口中，提供抽象方法有且仅能有一个</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/* InterfaceF interfaceF1 = () -&gt;&#123;</span></span><br><span class="line"><span class="comment">        	System.out.println(&quot;&quot;);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>    Lambda表达式实现接口是有一个要求，接口中只能提供一个抽象方法，这样接口才适合Lambda做简便实现，无法实现接口中同时拥有多个抽象方法，这就是Lambda的弊端</p>
<p>    Java为了保证Lambda表达式可以正确实现接口方法，Java对接口提供一个注解约束，约束接口中只能用一个抽象方法，我们称这样接口叫做函数式接口【专门提供给Lambda表达式实现】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加这样一个注解在接口上方，他会检查接口中是否提供多个抽象方法，如果提供多个抽象方法就会报错</span></span><br><span class="line"><span class="comment">//提供这样注解的接口就是专门对于Lambda提供实现操作的</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceF</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//添加两个抽象方法 --》 这个接口中提供两个抽象方法就会出现错误</span></span><br><span class="line">    <span class="comment">/* void showF();</span></span><br><span class="line"><span class="comment">        void showFF(int f)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showF</span><span class="params">()</span>; <span class="comment">//仅提供一个抽象方法就不会报错了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解@FunctionalInterface就是为了满足Lambda可以正确实现接口而提供，如果你在定义接口时，此时接口可以使用Lambda表达式实现建议在接口上方法添加这个注解</p>
<p>PS：注解只限制接口中抽象方法的个数，不限制default和static方法的个数</p>
]]></content>
      <categories>
        <category>Java语言</category>
      </categories>
      <tags>
        <tag>Java语言</tag>
      </tags>
  </entry>
  <entry>
    <title>0.MySQL数据准备</title>
    <url>/post/68ec1b16.html</url>
    <content><![CDATA[<p><strong>mydb2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建数据库</span><br><span class="line">create database if not exists mydb2;</span><br><span class="line">use mydb2;</span><br><span class="line">-- 创建商品表：</span><br><span class="line">create table product(</span><br><span class="line"> pid int primary key auto_increment, -- 商品编号</span><br><span class="line"> pname varchar(20) not null , -- 商品名字</span><br><span class="line"> price double,  -- 商品价格</span><br><span class="line"> category_id varchar(20) -- 商品所属分类</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into product values(null,&#x27;海尔洗衣机&#x27;,5000,&#x27;c001&#x27;);</span><br><span class="line">insert into product values(null,&#x27;美的冰箱&#x27;,3000,&#x27;c001&#x27;);</span><br><span class="line">insert into product values(null,&#x27;格力空调&#x27;,5000,&#x27;c001&#x27;);</span><br><span class="line">insert into product values(null,&#x27;九阳电饭煲&#x27;,200,&#x27;c001&#x27;);</span><br><span class="line">insert into product values(null,&#x27;啄木鸟衬衣&#x27;,300,&#x27;c002&#x27;);</span><br><span class="line">insert into product values(null,&#x27;恒源祥西裤&#x27;,800,&#x27;c002&#x27;);</span><br><span class="line">insert into product values(null,&#x27;花花公子夹克&#x27;,440,&#x27;c002&#x27;);</span><br><span class="line">insert into product values(null,&#x27;劲霸休闲裤&#x27;,266,&#x27;c002&#x27;);</span><br><span class="line">insert into product values(null,&#x27;海澜之家卫衣&#x27;,180,&#x27;c002&#x27;);</span><br><span class="line">insert into product values(null,&#x27;杰克琼斯运动裤&#x27;,430,&#x27;c002&#x27;);</span><br><span class="line">insert into product values(null,&#x27;兰蔻面霜&#x27;,300,&#x27;c003&#x27;);</span><br><span class="line">insert into product values(null,&#x27;雅诗兰黛精华水&#x27;,200,&#x27;c003&#x27;);</span><br><span class="line">insert into product values(null,&#x27;香奈儿香水&#x27;,350,&#x27;c003&#x27;);</span><br><span class="line">insert into product values(null,&#x27;SK-II神仙水&#x27;,350,&#x27;c003&#x27;);</span><br><span class="line">insert into product values(null,&#x27;资生堂粉底液&#x27;,180,&#x27;c003&#x27;);</span><br><span class="line">insert into product values(null,&#x27;老北京方便面&#x27;,56,&#x27;c004&#x27;);</span><br><span class="line">insert into product values(null,&#x27;良品铺子海带丝&#x27;,17,&#x27;c004&#x27;);</span><br><span class="line">insert into product values(null,&#x27;三只松鼠坚果&#x27;,88,null);</span><br></pre></td></tr></table></figure>
<p><strong>mydb3</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use mydb3;</span><br><span class="line"></span><br><span class="line">-- 创建部门表</span><br><span class="line">create table if not exists dept3(</span><br><span class="line">  deptno varchar(20) primary key ,  -- 部门号</span><br><span class="line">  name varchar(20) -- 部门名字</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">-- 创建员工表</span><br><span class="line">create table if not exists emp3(</span><br><span class="line">  eid varchar(20) primary key , -- 员工编号</span><br><span class="line">  ename varchar(20), -- 员工名字</span><br><span class="line">  age int,  -- 员工年龄</span><br><span class="line">  dept_id varchar(20)  -- 员工所属部门</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 给dept3表添加数据</span><br><span class="line">insert into dept3 values(&#x27;1001&#x27;,&#x27;研发部&#x27;);</span><br><span class="line">insert into dept3 values(&#x27;1002&#x27;,&#x27;销售部&#x27;);</span><br><span class="line">insert into dept3 values(&#x27;1003&#x27;,&#x27;财务部&#x27;);</span><br><span class="line">insert into dept3 values(&#x27;1004&#x27;,&#x27;人事部&#x27;);</span><br><span class="line"> </span><br><span class="line">-- 给emp表添加数据</span><br><span class="line">insert into emp3 values(&#x27;1&#x27;,&#x27;乔峰&#x27;,20, &#x27;1001&#x27;);</span><br><span class="line">insert into emp3 values(&#x27;2&#x27;,&#x27;段誉&#x27;,21, &#x27;1001&#x27;);</span><br><span class="line">insert into emp3 values(&#x27;3&#x27;,&#x27;虚竹&#x27;,23, &#x27;1001&#x27;);</span><br><span class="line">insert into emp3 values(&#x27;4&#x27;,&#x27;阿紫&#x27;,18, &#x27;1001&#x27;);</span><br><span class="line">insert into emp3 values(&#x27;5&#x27;,&#x27;扫地僧&#x27;,85, &#x27;1002&#x27;);</span><br><span class="line">insert into emp3 values(&#x27;6&#x27;,&#x27;李秋水&#x27;,33, &#x27;1002&#x27;);</span><br><span class="line">insert into emp3 values(&#x27;7&#x27;,&#x27;鸠摩智&#x27;,50, &#x27;1002&#x27;); </span><br><span class="line">insert into emp3 values(&#x27;8&#x27;,&#x27;天山童姥&#x27;,60, &#x27;1003&#x27;);</span><br><span class="line">insert into emp3 values(&#x27;9&#x27;,&#x27;慕容博&#x27;,58, &#x27;1003&#x27;);</span><br><span class="line">insert into emp3 values(&#x27;10&#x27;,&#x27;丁春秋&#x27;,71, &#x27;1005&#x27;);</span><br></pre></td></tr></table></figure>
<p><strong>mydb4</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table emp(</span><br><span class="line">    emp_id int primary key auto_increment comment &#x27;编号&#x27;,</span><br><span class="line">    emp_name char(20) not null default &#x27;&#x27; comment &#x27;姓名&#x27;,</span><br><span class="line">    salary decimal(10,2) not null default 0 comment &#x27;工资&#x27;,</span><br><span class="line">    department char(20) not null default &#x27;&#x27; comment &#x27;部门&#x27;</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">insert into emp(emp_name,salary,department) </span><br><span class="line">values(&#x27;张晶晶&#x27;,5000,&#x27;财务部&#x27;),(&#x27;王飞飞&#x27;,5800,&#x27;财务部&#x27;),(&#x27;赵刚&#x27;,6200,&#x27;财务部&#x27;),(&#x27;刘小贝&#x27;,5700,&#x27;人事部&#x27;),</span><br><span class="line">(&#x27;王大鹏&#x27;,6700,&#x27;人事部&#x27;),(&#x27;张小斐&#x27;,5200,&#x27;人事部&#x27;),(&#x27;刘云云&#x27;,7500,&#x27;销售部&#x27;),(&#x27;刘云鹏&#x27;,7200,&#x27;销售部&#x27;),</span><br><span class="line">(&#x27;刘云鹏&#x27;,7800,&#x27;销售部&#x27;);</span><br></pre></td></tr></table></figure>
<p><strong>mydb6_view</strong>、<strong>mydb7_procedure</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 视图</span><br><span class="line">create table dept(</span><br><span class="line">    deptno int primary key,</span><br><span class="line">    dname varchar(20),</span><br><span class="line">    loc varchar(20)</span><br><span class="line">);</span><br><span class="line">insert into dept values(10, &#x27;教研部&#x27;,&#x27;北京&#x27;),</span><br><span class="line">(20, &#x27;学工部&#x27;,&#x27;上海&#x27;),</span><br><span class="line">(30, &#x27;销售部&#x27;,&#x27;广州&#x27;),</span><br><span class="line">(40, &#x27;财务部&#x27;,&#x27;武汉&#x27;);</span><br><span class="line"></span><br><span class="line">create table emp(</span><br><span class="line">    empno int primary key,</span><br><span class="line">    ename varchar(20),</span><br><span class="line">    job varchar(20),</span><br><span class="line">    mgr int,</span><br><span class="line">    hiredate date,</span><br><span class="line">    sal numeric(8,2),</span><br><span class="line">    comm numeric(8, 2),</span><br><span class="line">    deptno int,</span><br><span class="line">    -- FOREIGN KEY (mgr) REFERENCES emp(empno),</span><br><span class="line">    FOREIGN KEY (deptno) REFERENCES dept(deptno) ON DELETE SET NULL ON UPDATE CASCADE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into emp values</span><br><span class="line">(1001, &#x27;甘宁&#x27;, &#x27;文员&#x27;, 1013, &#x27;2000-12-17&#x27;, 8000.00, null, 20),</span><br><span class="line">(1002, &#x27;黛绮丝&#x27;, &#x27;销售员&#x27;, 1006, &#x27;2001-02-20&#x27;, 16000.00, 3000.00, 30),</span><br><span class="line">(1003, &#x27;殷天正&#x27;, &#x27;销售员&#x27;, 1006, &#x27;2001-02-22&#x27;, 12500.00, 5000.00, 30),</span><br><span class="line">(1004, &#x27;刘备&#x27;, &#x27;经理&#x27;, 1009, &#x27;2001-4-02&#x27;, 29750.00, null, 20),</span><br><span class="line">(1005, &#x27;谢逊&#x27;, &#x27;销售员&#x27;, 1006, &#x27;2001-9-28&#x27;, 12500.00, 14000.00, 30),</span><br><span class="line">(1006, &#x27;关羽&#x27;, &#x27;经理&#x27;, 1009, &#x27;2001-05-01&#x27;, 28500.00, null, 30),</span><br><span class="line">(1007, &#x27;张飞&#x27;, &#x27;经理&#x27;, 1009, &#x27;2001-09-01&#x27;, 24500.00, null, 10),</span><br><span class="line">(1008, &#x27;诸葛亮&#x27;, &#x27;分析师&#x27;, 1004, &#x27;2007-04-19&#x27;, 30000.00, null, 20),</span><br><span class="line">(1009, &#x27;曾阿牛&#x27;, &#x27;董事长&#x27;, null, &#x27;2001-11-17&#x27;, 50000.00, null, 10),</span><br><span class="line">(1010, &#x27;韦一笑&#x27;, &#x27;销售员&#x27;, 1006, &#x27;2001-09-08&#x27;, 15000.00, 0.00, 30),</span><br><span class="line">(1011, &#x27;周泰&#x27;, &#x27;文员&#x27;, 1008, &#x27;2007-05-23&#x27;, 11000.00, null, 20),</span><br><span class="line">(1012, &#x27;程普&#x27;, &#x27;文员&#x27;, 1006, &#x27;2001-12-03&#x27;, 9500.00, null, 30),</span><br><span class="line">(1013, &#x27;庞统&#x27;, &#x27;分析师&#x27;, 1004, &#x27;2001-12-03&#x27;, 30000.00, null, 20),</span><br><span class="line">(1014, &#x27;黄盖&#x27;, &#x27;文员&#x27;, 1007, &#x27;2002-01-23&#x27;, 13000.00, null, 10);</span><br><span class="line"></span><br><span class="line">create table salgrade(</span><br><span class="line">    grade int primary key,</span><br><span class="line">    losal int,</span><br><span class="line">    hisal int</span><br><span class="line">);</span><br><span class="line">insert into salgrade values</span><br><span class="line">(1, 7000, 12000),</span><br><span class="line">(2, 12010, 14000),</span><br><span class="line">(3, 14010, 20000),</span><br><span class="line">(4, 20010, 30000),</span><br><span class="line">(5, 30010, 99990);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>23.IO流</title>
    <url>/post/3e1167ea.html</url>
    <content><![CDATA[<h1><center>知识点一：概念</center></h1>
<p><strong>PS：IO很简单主要记忆的就是IO中进行文件读写操作</strong></p>
<p>Java中IO流的作用：IO流在Java中作用就是将内存中数据写入到磁盘进行保存，程序运行时将磁盘中的数据读取到内存中进行处理</p>
<p>在Java中在没有学习到IO流之前，在程序中所有处理数据都是在内存中进行存储的【栈和堆】，在内存中存储的好处在于【执行效率高】坏处【数据无法持久存储】</p>
<p>内存中存储体现在于【DVD操作系统】：所有数据使用集合存储之后依旧是在内存中进行存储，每次执行程序时，都会在内存从新初始化集合中数据，这样就造成无论你如何修改集合中数据，只要程序重新运行数据使用保持原始状态</p>
<p>所以需要将内存中数据保存到磁盘中进行持久保存【将内存中数据写成文件中内容进行保存操作】，如果将内存中数据写到磁盘中，就需要使用到IO流【使用输出流】，数据存存储在磁盘文件之后，程序运行时需要加载磁盘中文件数据【将磁盘文件中内容读取到内存中进行处理】，如果需要将磁盘中文件内读取到内存中，就需要使用到IO流【使用输入流】</p>
<p>什么是IO流？</p>
<p>I —》 顾名思义 —》IN(读取、输入、读入) --》将磁盘中文件内容读取到内存中</p>
<p>O—》 顾名思义 --》OUT(输出、写出、写入) —》将内存中数据写入到磁盘文件中</p>
<p><strong>IO流就是内存与磁盘【存储设备】之间数据传输通道</strong></p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011942738.WebP" alt="传输过程" style="zoom:33%;">
<p>在程序中所有的数据都是以流的方式进行传输与保存，程序需要数据时使用输入流读取数据，当程序需要保存数据时使用输出流保存数据</p>
<p>除了对数据保存之外，实际在网页中的文件上传与下载操作就是IO流完成</p>
<p><strong>PS：IO操作属于“长连接”，需要管理这个连接操作，如果不管理这个连接操作，会造成IO流操作会持续在内存中存在，会造成内存浪费，所以在不使用IO操作下，一定要关闭IO流</strong></p>
<h1><center>知识点二：Java中提供常用IO流</center></h1>
<p>IO流其实就是建立起内存与硬盘【存设备】之间数据传输通道，通过这个通道可以将数据进行读取与写入操作，这个就是IO流本质</p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011943586.WebP" alt="输入输出关系" style="zoom:50%;">
<p>可以根据IO流进行简单的分类</p>
<p>根据流的流向：</p>
<p>    输入流： 把存储在磁盘中数据读取到内存中</p>
<p>    输出流 : 把内存中数据写入到磁盘中</p>
<p>根据流中数据：</p>
<p>    字节流： 无论是输入还是输出流中数据都是byte类型</p>
<p>    字符流： 无论是输入还是输出流中数据都是char类型</p>
<h1><center>知识点三：字节输入输出流</center></h1>
<p>这个流中数据类型就是byte，这个流既可以进行输入操作【读取】，也可以进行输出操作【写出】</p>
<h2 id="center-1-inputstream-字节输入流-center"><center>1、InputStream【字节输入流】</center></h2>
<p>InputStream流是所有字节输入流的父类，所有字节输入流都要直接或间接继承InputStream</p>
<p>这个流是一个抽象类不能直接创建对象，所以需要使用到这个流的子类来完成对字节输入流操作</p>
<p>在API文档中提供创建语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InputStream</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span></span><br></pre></td></tr></table></figure>
<p>在API文档中已知实现之类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AudioInputStream, ByteArrayInputStream,<span class="string">&quot;FileInputStream&quot;</span>, FilterInputStream, InputStream,</span><br><span class="line">ObjectInputStream, PipedInputStream,SequenceInputStream, StringBufferInputStream</span><br></pre></td></tr></table></figure>
<p>这里多子类中，使用那个之类来操作呢？学习流目的在于什么？–》将内存数据写出到磁盘中【持久保存】，程序需要使用时将磁盘中文件存储内容读取到内存中，整个操作过程中都需要使用磁盘文件，所以就需要操作一个处理文件的流来进行操作 --》需要使用其之类FileInputStream</p>
<h2 id="center-2-fileinputsteam-文件字节输入流-center"><center>2、FileInputSteam【文件字节输入流】</center></h2>
<p>FileInputStream是InputStream字节入的子类，这个流主要提供是对文件读取操作，这个文件是泛指【指代的是：所有文档二进制文件（文本文件、音频、视频、压缩包、图片等等）】，都可以通过</p>
<p>FileInputStream进行读取操作，FileInputSteam是字节输入流所以流中数据是【<strong>byte类型</strong>】</p>
<p>在API文档中提供创建定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span></span><br></pre></td></tr></table></figure>
<p>PS：Java中提供原生流【系统API中定义好流】只能对文本文件中内容进行操作即【txt】文件，无法对Office文件记性操作，如果需要对这些文件进行操作需要导入【第三方jar包（别人封装好实现）】</p>
<h3 id="1-核心构造方法">（1）核心构造方法</h3>
<table>
<thead>
<tr>
<th style="text-align:center">构造方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FileInputStream(File file) 通过一个File对象创建FileInputStream字节输入流对象</td>
</tr>
<tr>
<td style="text-align:center">FileInputStream(String name) 通过一个String对象(文件的路径)创建FileInputStream字节输入流对象</td>
</tr>
</tbody>
</table>
<p>PS：这两个构造方法创建出对象方式是一样的，只是参数不一样，个人选取</p>
<h3 id="2-核心api方法">（2）核心API方法</h3>
<table>
<thead>
<tr>
<th style="text-align:center">返回值类型</th>
<th style="text-align:center">方法说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">read() 一次读取一个字节的数据</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">read(byte[] bs) 一次读取参数字节数组长度的数据并存储在字节数组中[常用]</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">read(byte[] bs, int off, int len) 一次读取字节数组长度的数据,根据len读取实际内容长度,并从off位置开始入写到字节数组中</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">close() IO流式一个长连接,所以需要需要关闭流对象【常用】</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamAPIDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//文件字节输入流操作</span></span><br><span class="line">        <span class="comment">//1.提供文件字节输入流对象创建</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这个构造方法中一共提供两种参数</span></span><br><span class="line"><span class="comment">            第一种传入File --&gt;FileInputStream fis = new FileInputStream(new File(&quot;绝对或相对文件路径&quot;));</span></span><br><span class="line"><span class="comment">            第二种传入String类型参数 --》 String类型赋值时一个路径</span></span><br><span class="line"><span class="comment">            	FileInputStream fis = new FileInputStream(&quot;绝对或相对文件路径&quot;);</span></span><br><span class="line"><span class="comment">            在创建文件字节输入流对象同时需要处理创建对象时提供 编译时异常</span></span><br><span class="line"><span class="comment">                         	Unhandled exception:java.io.FileNotFoundException</span></span><br><span class="line"><span class="comment">            今天---》使用try-catch进行处理 ---》 特殊用途</span></span><br><span class="line"><span class="comment">            明天---》 throws处理 --》 开发通用</span></span><br><span class="line"><span class="comment">            后续流开发如果出现异常行，自行选择处理方式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//先声明流资源对象赋值为null值</span></span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//IO流的链接是长链接，所以在不使用IO流前提下要进行关闭操作</span></span><br><span class="line">            <span class="comment">//在try代码块进行流对象具体赋值操作</span></span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/file1.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//读取文件中数据的read方法都有编译时异常Unhandled exception: java.io.IOException</span></span><br><span class="line">            <span class="comment">//1. 一次读取一个字节的内容--》几乎与不使用</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> fis.read();    <span class="comment">//返回文件内容中对应的ASCII，所以要看到读取内容效果需要强制类型转换</span></span><br><span class="line">            System.out.println(<span class="string">&quot;一次读取一个字节的内容是:&quot;</span>+ ((<span class="type">char</span>)read));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//2. 一次读取参数中字节数组长度内容，并且将内容存存储到字节数组中 --》【常用】</span></span><br><span class="line">            <span class="comment">//2.1 需要提供一个字节数组</span></span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="comment">//2.2通过字节输入流对象调用read方法参数是字节数组</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                千万不要理解为:通过fis流对象读取字节数组bs中内容【错误理解】</span></span><br><span class="line"><span class="comment">                真正含义:通过fis流对象读取文件中内容，读取文件中内容是参数bs数组长度，并且将读取到内容存储到bs数组中</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            fis.read(bs);</span><br><span class="line">            <span class="comment">//因为byte类型数组，存储都是整数，所以存储都是文件内容中字符对应十进制形式</span></span><br><span class="line">            System.out.println(Arrays.toString(bs)); <span class="comment">//相当于查看字节数内容，但是不是具体文件中内容</span></span><br><span class="line">            <span class="comment">//利用String这个类构造方法将字节数组转换成字符串查看内容</span></span><br><span class="line">            System.out.println(<span class="string">&quot;读取文件中内容是：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(bs));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//3.一次读取参数中字节数组长度内容并且存储在字节数组中，根据off参数指定下标为开始写入数据，</span></span><br><span class="line">            <span class="comment">// 再根据len参数为基础进行实际读取内容长度作为写入数组中内容长度</span></span><br><span class="line">            <span class="comment">//3.1提供一个byte类型数组</span></span><br><span class="line">            <span class="type">byte</span>[] bs2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line">            <span class="comment">//3.2在通过文件字节输入流对象调用read方法进行读取</span></span><br><span class="line">            fis.read(bs2,<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">            System.out.println(Arrays.toString(bs2));</span><br><span class="line">            System.out.println(<span class="string">&quot;读取文件中内容是:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(bs2));</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (Exception e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//无论try代码块是否出现异常，finally语句代码块都会执行，多用于资源释放 ---》 管理流就是资源释放</span></span><br><span class="line">            <span class="comment">//因为是在try外界创建对象赋值为null，如果赋值成功会存在堆中地址，这样才有关闭价值</span></span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(fis))    <span class="comment">//判断数据是否为null</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//释放流资源--》关闭流 --&gt;close方法也有一个编译时异常Unhandled exception: java.io.IOException</span></span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题：如果使用FileInputStream文件字节输入流读取一个文件，这个文件大小未知（文件存储内容不确定），使用刚刚讲解API中 read(byte[]bs) 进行文件内容读取，此时提供byte数组应该多大？，如何获取到文件中所有内容？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamLoopReadFile</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供文件字节输入流对象【因为InputStream是</span></span><br><span class="line">        FileInputStream父类，所以可以利用多态创建】</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/FileInputStreamAPIDemo.java&quot;</span>));</span><br><span class="line">            <span class="comment">//提供字节数组 ---》 1024 --&gt;给读取文件数组中大小即 1024</span></span><br><span class="line">            <span class="comment">//在开发中如果使用流进行操作，提供byte类型数组或char类型数组使用初始化大小默认给1024</span></span><br><span class="line">            <span class="comment">//如果1024并不能满足你读取文件内容需求，建议倍数递增</span></span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//因为给定初始容量1024，但是不能完全读取文件中所有内容</span></span><br><span class="line">            <span class="comment">//is.read(bs);</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                只需要让读取文件中内容操作重复执行就行--》提供循环让is.read可以去重复去读文件内容</span></span><br><span class="line"><span class="comment">                提供死循环确实可以让读取操作重复执行，但是需要提供读取文件停止方式，不然话程序执行是不合理</span></span><br><span class="line"><span class="comment">                只需要知道是否读取到文件的末尾，就可以停止循环操作了，如何得到读取到文件末尾的操作？</span></span><br><span class="line"><span class="comment">                read 方法在读取文件数据时，如果读取到文件的末尾返回-1作为提示</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">                //提供一个变量len 存储read读取到长度</span></span><br><span class="line"><span class="comment">                int len = 0;</span></span><br><span class="line"><span class="comment">                while(true)</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    len = is.read(bs);</span></span><br><span class="line"><span class="comment">                    if(len == -1)</span></span><br><span class="line"><span class="comment">                    &#123;</span></span><br><span class="line"><span class="comment">                        break;</span></span><br><span class="line"><span class="comment">                    &#125; </span></span><br><span class="line"><span class="comment">                    System.out.println(new String(bs));</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                通过文件字节读取到数据之后进行打印，发现输出内容末尾的位置多出了一些内容，但是在源文件中是不存在</span></span><br><span class="line"><span class="comment">                当调用read方法读取文件中内容时，是按照bs数组的长度进行读取，然后写入到bs数组中，这是一次读取</span></span><br><span class="line"><span class="comment">                下一次循环读取时，也会按照bs数组的长度进行读取，然后是覆盖写入到bs数组中，即不会清除原有数组中存的内容</span></span><br><span class="line"><span class="comment">                而是直接覆盖进新读取到文件内容到数组</span></span><br><span class="line"><span class="comment">                例如：现在读取文件大小是 4063字节 存储数据数组的大小1024字节</span></span><br><span class="line"><span class="comment">                第一次读取时 4063-1024 --》剩余字节 3039 但是读取到 1024字节内容</span></span><br><span class="line"><span class="comment">                第二次读取时 3039-1024 --》剩余字节 2015 但是读取到 1024字节内容</span></span><br><span class="line"><span class="comment">                第二次读取时 2015-1024 --》剩余字节 991 但是读取到 1024字节内容</span></span><br><span class="line"><span class="comment">                第四次读取时 读取字节是991 并没有填充满1024 --》 实际读取991个字节</span></span><br><span class="line"><span class="comment">                991个字节覆盖到byte数组中之后 会剩余33个字节没有进行覆盖内容</span></span><br><span class="line"><span class="comment">                所以通过new String方式打印数组内容时，就会将33个没有覆盖内容数据打印出来</span></span><br><span class="line"><span class="comment">                read(byte[] bs)这个方法的返回值不仅可以返回读取到文件末尾-1值</span></span><br><span class="line"><span class="comment">                                而且这个方法还可以返回读取到实际文件内容长度的实际值</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//提供流循环读取文件内容的while循环书写方式</span></span><br><span class="line">            <span class="comment">//需要提供一个存储实际读取文件内容长度变量【包括文件末尾值】</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(bs))!=-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//循环内部对数组中存储内容进行操作</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    第一个参数是存储数据数组</span></span><br><span class="line"><span class="comment">                    第二个参数是从数组中什么位置开始获取数据【默认值是0(使用是下标值)】</span></span><br><span class="line"><span class="comment">                    第三个参数 实际读取文件内容长度，因为可以避免输出书中没有被覆盖掉内容</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bs,<span class="number">0</span>,len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (Exception e) </span><br><span class="line">        &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(is))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-3-outputstream字节输出流-center"><center>3、OutputStream字节输出流</center></h2>
<p>OutputStream字节输出流是所有字节输出的父类，所有字节输入出流都是直接或间接继承OutputStream类</p>
<p>根据API文档中提供类创建方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OutputStream</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span>, Flushable</span><br></pre></td></tr></table></figure>
<p>OutputStream是抽象类无法直接创建对象使用，所以需要提供子类来完成对流操作</p>
<p>根据API文档中提供子类有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteArrayOutputStream, *FileOutputStream*,</span><br><span class="line">FilterOutputStream, ObjectOutputStream, OutputStream, PipedOutputStream</span><br></pre></td></tr></table></figure>
<p>根据现在操作数据原则，将数据从磁盘文件读取到内容，将内存中数据写出到磁盘文件中，始终要处理是File文件，所以使用<strong>子类是FileOutputStream文件字节输出流</strong></p>
<h2 id="center-4-fileoutputstream文件字节输出流-center"><center>4、FileOutputStream文件字节输出流</center></h2>
<p>FileOutputStream文件字节输出流类是OutputStream的子类，这个类主要用用于将内存中存储数据写入到磁盘文件中进行保存操作，这里的文件是泛指【<strong>指代是二进制文件（文本文件、音频、视频、图片、压缩包等等）</strong>】都可以使用FileOutputStream这个流对象将数据写入到磁盘中</p>
<p>根据API文档中说明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStream</span> <span class="keyword">extends</span> <span class="title class_">OutputStream</span></span><br></pre></td></tr></table></figure>
<p><strong>核心构造方法</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">构造方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FileOutputStream(File file) 通过一个File对象(封装的文件路径)创建文件字节输出流对象</td>
</tr>
<tr>
<td style="text-align:center">FileOutputStream(File file, boolean append)通过一个File对象(封装的文件路径)创建文件字节输出流对象,并根据第二个参数的值决定是否是对文件进行追加写入数据 true是追加 false 不追加</td>
</tr>
<tr>
<td style="text-align:center">FileOutputStream(String name) 通过一个String对象(封装的文件路径)创建文件字节输出流对象</td>
</tr>
<tr>
<td style="text-align:center">FileOutputStream(String name, boolean append)通过一个String对象(封装的文件路径)创建文件字节输出流对象,并根据第二个参数的值决定是否是对文件进行追加写入数据 true是追加 false不追加</td>
</tr>
</tbody>
</table>
<h3 id="1-核心api方法">（1）核心API方法</h3>
<table>
<thead>
<tr>
<th style="text-align:center">void</th>
<th style="text-align:center"><strong>close() 关闭此文件输出流并释放与此流有关的所有系统资源 【常用】</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">write(byte[] b) 将以字节数组长度的内容写入到磁盘文件中</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center"><strong>write(byte[] b, int off, int len) 将实际len长度的内容****从数组b中off位置开始写入到磁盘文件中【常用】</strong></td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">write(int b) 一次写一个字节的内容写入到磁盘文件中</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center"><strong>flush() 加快流的流速,强制清空缓冲区中数据</strong>【加快输出效果（在使用网络流的时候一定要添加）】</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStreamAPIDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建文件字节输出流对象【一个参数的版本】</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            一个参数的版本参数可以传递两种方式</span></span><br><span class="line"><span class="comment">            第一种：传入File对象 --》fos = new FileOutputStream(new File(&quot;绝对或相对路径文件&quot;));</span></span><br><span class="line"><span class="comment">            第二种：传入String类型对象(代表的是文件的路径)</span></span><br><span class="line"><span class="comment">                                fos = new FileOutputStream(&quot;绝对或相对路径文件&quot;);</span></span><br><span class="line"><span class="comment">            在创建文件字节输出流对象时，需要处理编译时异常 Unhandled exception: java.io.FileNotFoundException</span></span><br><span class="line"><span class="comment">            处理方式 要么 try-catch 要么 throws</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                创建文件字节输出流对象【两个参数的版本】</span></span><br><span class="line"><span class="comment">                第一个参数可以是File对象或String类型对象，只要提供文件绝对或相对路径</span></span><br><span class="line"><span class="comment">                第二个参数需要注意是一个boolean类型参数，传入true时会开启追加写入操作</span></span><br><span class="line"><span class="comment">                    new FileOutputStream(&quot;绝对或相对路径文件&quot;,true);</span></span><br><span class="line"><span class="comment">                或者</span></span><br><span class="line"><span class="comment">                    new FileOutputStream(new File(&quot;绝对或相对路径文件&quot;),true);</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//写出数据到磁盘中时，磁盘中可以不存在这个文件，在写数据时会自动创建这个文件</span></span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;dir/file2.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//常用写出方法中都存在一个编译时异常Unhandledexception: java.io.IOException</span></span><br><span class="line">            <span class="comment">//1.一次向文件中写入一个字节的数据</span></span><br><span class="line">            <span class="comment">//fos.write(65);     //参数是int类型对应ASCII值的字符</span></span><br><span class="line">            <span class="comment">//不是“连续”向文件中写入内容，而是再次向file2.txt内容时，覆盖写入</span></span><br><span class="line">            <span class="comment">//2.向文件中一次性写过字节数组中的所有内容</span></span><br><span class="line">            <span class="comment">//getBytes()--&gt;将字符串转换为字节数组</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                如果是分批写入数据，为了防止文件中内容被后一次书写数据进行覆盖，</span></span><br><span class="line"><span class="comment">                可以使用FileOutputStream中构造方法【两个参数版本】，开启追加写入</span></span><br><span class="line"><span class="comment">                一般追加写入的作用都是生成日志文件，记录用户写入一些数据到文件中，一般不追加的比较常用</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            fos.write(<span class="string">&quot;BCDEFGHIJKLMN&quot;</span>.getBytes());    <span class="comment">//getBytes()将字符串转换成字节数组</span></span><br><span class="line">            <span class="comment">//3.从字节数组中将内容写入到文件中，从off参数提供的位置读取数据开始写，写len提供长度内容</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                第一个参数是存储数据字节数组</span></span><br><span class="line"><span class="comment">                第二个参数是从字节数组什么位置开始读取和写出数据【默认0（下标）】</span></span><br><span class="line"><span class="comment">                第三个参数实际写出内容长度（一般会配合输入流中read方法获取实际长度进行写出）</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            fos.write(<span class="string">&quot;BCDEFGHIJKLMN&quot;</span>.getBytes(),<span class="number">6</span>,<span class="string">&quot;HIJKMLN&quot;</span>.length());</span><br><span class="line">            <span class="comment">//执行刷新操作</span></span><br><span class="line">            fos.flush();</span><br><span class="line">            System.out.println(<span class="string">&quot;老子写完了！！！&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (FileNotFoundException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(fos))    <span class="comment">//也可以是 fos != null</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//存在一个编译时异常要处理</span></span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-5-图片拷贝案例-center"><center>5、图片拷贝案例</center></h2>
<p>利用文件字节输入输出流完成图片拷贝操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.InputStreamAndOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCopy</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供文件字节输入输出流对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/1_io.WebP&quot;</span>));</span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/1_io.WebP&quot;</span>));</span><br><span class="line">            <span class="comment">//2.一定明确在使用是什么流【字节或字符】-》提供对应数组进行数据存储与接收</span></span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];    <span class="comment">//提供存储读取数据的字节数组</span></span><br><span class="line">            <span class="comment">//3. 提供一个变量存储读取文件实际内容长度【存储读取到文件末尾-1的值】</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//4.提供流的循环读写操作【读和写都是有编译时异常的要处理】</span></span><br><span class="line">            <span class="keyword">while</span>((len = is.read(bs))!=-<span class="number">1</span>)    <span class="comment">//循环读取数据并存储在bs数组中</span></span><br><span class="line">            &#123; </span><br><span class="line">                <span class="comment">//将存储在bs数组中数据写出到磁盘文件中</span></span><br><span class="line">                os.write(bs,<span class="number">0</span>,len);</span><br><span class="line">            &#125; </span><br><span class="line">            os.flush();    <span class="comment">//刷新</span></span><br><span class="line">            System.out.println(<span class="string">&quot;老子写完了！！！&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (FileNotFoundException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//谁先创建谁最后关闭</span></span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(os))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(is))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-6-利用字节流将文件中的内容进行拷贝赋值操作-center"><center>6、利用字节流将文件中的内容进行拷贝赋值操作</center></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.InputStreamAndOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCopy2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供字节输入输出流对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/1.txt&quot;</span>));</span><br><span class="line">            ois = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/1.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//2.明确使用是字节流还是字符流</span></span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//3.提供循环读写操作【处理编译时异常】</span></span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read(bs))!=-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// ois.write(bs,0,len);</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bs,<span class="number">0</span>,len));</span><br><span class="line">            &#125; </span><br><span class="line">            ois.flush();</span><br><span class="line">            System.out.println(<span class="string">&quot;老子写完了！！！&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (FileNotFoundException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(ois))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    ois.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(fis))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结:字节输入输出流在文件进行操作，因为字节流中使用数据类型byte类型主要针对是二进制的文件，所以<strong>字节流主要对的是【图片、音频、视频、压缩包】这类的二进制文件</strong>，在读取和写出文本文件时，会在处理文件时出现一些乱码问题�，所以字节流主要是处理二进制文件而使用，如果处理文件文件的数据就不太建议使用字节流来完成操作，就是因为容易出现乱码问题�</p>
<h1><center>知识点四：字符输入输出流</center></h1>
<p>字符输入输出流是专门用于对文本文件进行操作流，用于弥补字节流对文本文件操作时容易出现乱码的为题，所以用字符输入输出流对文本文件进行处理操作</p>
<h2 id="center-1-reader字符输入流-center"><center>1、Reader字符输入流</center></h2>
<p>Reader是字符输入的父类，所有字符输入流都要直接或间接继承与Reader类，因为这个流是字符流，所以流中数据是char，要提供数组也是char类型数组</p>
<p>根据API文档中描述可以发现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Reader</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Readable</span>, Closeable</span><br></pre></td></tr></table></figure>
<p>提供已知的之类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader, CharArrayReader, FilterReader, InputStreamReader, PipedReader, StringReader</span><br></pre></td></tr></table></figure>
<p>操作文件FileReader这个类并不是Reader的直接子类，而是间接子类，操作文件FileReader类是继承与InputStreamReader这个类，InputStreamReader这个类是Reader直接子类，可以利用FileReader进行文件操作</p>
<h2 id="center-2-filereader文件字符输入流-center"><center>2、FileReader文件字符输入流</center></h2>
<p>FileReader是Reader的间接子类，FileReader的直接父类是InputStreamReader，InputStreamReader这个类提供文件编码集和缓冲区操作，API文档中也说明【此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的】</p>
<p>通过流操作文本文件时，文本文件是存在编码集的，在使用FileReader类操作是使用就是默认编码集，这个默认编码集是根据系统进行获取，编码集的目的【提供文件的编码让文件可以达到统一性Unicode(UTF-8)】</p>
<p>在使用字节流时，API文档中是没有描述字节流具备缓冲区，但是在使用字符流的时，API文档提供缓冲区的概念，当使用流写出数据时，有一个方法<strong>flush方法</strong>，这个方法就是专门针对缓冲区进行设计，提供缓冲这个概念可以大大提高，流的使用效率</p>
<p>在API文档中提供FileReader中定义描述</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReader</span> <span class="keyword">extends</span> <span class="title class_">InputStreamReader</span></span><br></pre></td></tr></table></figure>
<p><strong>常用构造方法</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">构造方法摘要</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FileReader(File file) 通过一个File对象(封装着文件路径)创建一个FileReader对象进行数据读取</td>
</tr>
<tr>
<td style="text-align:center">FileReader(String fileName) 通过一个String对象(封装着文件路径)创建一个FileReader对象进行数据读取</td>
</tr>
</tbody>
</table>
<h3 id="1-常用api方法">（1）常用API方法</h3>
<table>
<thead>
<tr>
<th style="text-align:center">方法摘要</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center"><strong>close() 关闭该流并释放与之关联的所有资源</strong></td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">read() 读取单个字符</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center"><strong>read(char[] cbuf) 读取字符数组长度的内容(常用)</strong></td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">read(char[] cbuf, int off, int len) 将读取len的长度内容写入到cbuf数组中并且从off的位置开始在数组中写入</td>
</tr>
</tbody>
</table>
<p>PS:直接参考FileInputStream即可，只要将byte数组换char数组就可以了</p>
<h2 id="center-3-writer字符输出流-center"><center>3、Writer字符输出流</center></h2>
<p>Writer字符输入流是所有字符输入流父类，所有字符输入流都要直接或间接继承与Writer，因为这个流是字符流，所以流中数据是char类型，需要提供char类型数组</p>
<p>根据API文档中描述</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Writer</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, Closeable, Flushable</span><br></pre></td></tr></table></figure>
<p>它是一个抽象类不能直接创建流对象进行操作，所以需要使用到其子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedWriter, CharArrayWriter, FilterWriter, OutputStreamWriter, PipedWriter, PrintWriter, StringWriter</span><br></pre></td></tr></table></figure>
<p>操作文件的FileWriter这个类不是Writer的直接子类，而是间接子类，但是FileWriter可以完成对文件写出操作</p>
<h2 id="center-4-filewriter文件字符输出流-center"><center>4、FileWriter文件字符输出流</center></h2>
<p>FileWriter是Writer的间接子类，FileWriter的直接父类是OutputStreamWriter，OutputStreamWriter个类提供文件编码集和缓冲区操作，API文档中也说明【此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的】</p>
<p>通过流操作文本文件时，文本文件时存在编码集的，在使用FileWriter类操作时使用就是默认编码集，这个默认编码集是根据系统进行获取，编码集的目的【提供文件的编码让文件可以达到统一性Unicode(UTF-8)】</p>
<p>在使用字节流时，API文档中是没有描述字节流具备缓冲区，但是在使用字符流的时，API文档提供缓冲区的概念，当使用流写出数据时，有一个方法flush方法，这个方法就是专门针对缓冲区进行设计，提供缓冲这个概念可以大大提高，流的使用效率</p>
<h3 id="1-常用构造方法">（1）常用构造方法</h3>
<table>
<thead>
<tr>
<th style="text-align:center">常用构造方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FileWriter(File file) 构建了一个文件对象FileWriter对象</td>
</tr>
<tr>
<td style="text-align:center">FileWriter(File file, boolean append) 构建了一个文件对象FileWriter对象</td>
</tr>
<tr>
<td style="text-align:center">FileWriter(String fileName) 构造给定文件名的FileWriter对象</td>
</tr>
<tr>
<td style="text-align:center">FileWriter(String fileName, boolean append) 构造FileWriter对象给出一个文件名与一个布尔值，指示是否附加写入的数据</td>
</tr>
</tbody>
</table>
<p>PS:构建方法中多了一个第二参数，是boolean参数值作用就是提供文件追加写入操作，当设置参数为true时，当前写入文件中数据操作就是追加写入【主要适合：记录日志的工作】，如果是连续写出数据，可以不开启这个操作</p>
<h3 id="2-常用api方法">（2）常用API方法</h3>
<table>
<thead>
<tr>
<th style="text-align:center">void</th>
<th style="text-align:center">close() 关闭此流，但要先刷新它</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">flush() 刷新该流的缓冲</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">write(char[] cbuf) 写入字符数组</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">write(char[] cbuf, int off, int len) 从cbuf数组读取数据并写入到文件中,len是实际写出数据长度,off是从cbuf数组中什么位置开始写出 (使用字符数组时核心方法)</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">write(int c) 写入单个字符</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">write(String str) 写入字符串(非常有用的核心方法)</td>
</tr>
</tbody>
</table>
<p>PS: 在写出数据到文件中时，只有字符流中会提供一个参数为String类型write方法，这个方法可以帮我们便捷将数据写出到文件中，这个方法极其重要</p>
<p>FileWriter操作可以完全参考FileOutputStream这个类，基本上是一模一样，只不过将byte类型转换char类型即可</p>
<h2 id="center-5-使用字符输入输出流进行文本文件的拷贝操作-center"><center>5、使用字符输入输出流进行文本文件的拷贝操作</center></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.ReaderAndWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderAndFileWriterCopyFile</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供字符输入输出流对象创建</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//在创建对象时要处理编译时异常Unhandled exception: java.io.FileNotFoundException 处理方法和字节流一样</span></span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/1.txt&quot;</span>));</span><br><span class="line">            writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/2.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//2.一定要明确使用是什么流--》字符流</span></span><br><span class="line">            <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//3. 提供循环读写操作</span></span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = reader.read(buf))!=-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf,<span class="number">0</span>,len));</span><br><span class="line">                <span class="comment">//writer.write(buf,0,len);</span></span><br><span class="line">            &#125; </span><br><span class="line">            writer.flush();</span><br><span class="line">            System.out.println(<span class="string">&quot;老子写完了！！！！&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(writer))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(reader))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-6-使用字符输入输出流进行图片的拷贝操作-center"><center>6、使用字符输入输出流进行图片的拷贝操作</center></h2>
<p>打开拷贝之后图片，观察拷贝之后图片与原来图片的大小</p>
<p>使用字符流进行图片复制拷贝操作是不可以完成，图片出现问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.ReaderAndWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderAndFileWriterCopyFile2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供字符输入输出流对象创建</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//在创建对象时要处理编译时异常Unhandled exception: java.io.FileNotFoundException</span></span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/1_io.WebP&quot;</span>));</span><br><span class="line">            writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/2_io.WebP&quot;</span>));</span><br><span class="line">            <span class="comment">//2.一定要明确使用是什么流--》字符流</span></span><br><span class="line">            <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//3. 提供循环读写操作</span></span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = reader.read(buf))!=-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                writer.write(buf,<span class="number">0</span>,len);</span><br><span class="line">            &#125; </span><br><span class="line">            writer.flush();</span><br><span class="line">            System.out.println(<span class="string">&quot;老子写完了！！！！&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(writer))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(reader))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点五：字节流和字符流之间区别</center></h1>
<p>字节流和字符流是有本质上区别：</p>
<ol>
<li>流中数据是不同，字节流流中的数据是byte而字符流流中数据是char</li>
<li>根据流中不同数据类型所以字节流主要处理是二进制文件【图片、音频、视频、压缩包的等等】也可以处理【文本文件】但是容易出现乱码，而字符流主要是处理文本文件提供流，它是无处理二进制文件的</li>
<li>字节流和字符流之间还有一个很大区别</li>
</ol>
<p>    字节流在操作流的过程中是【没有使用缓冲区】，直接对文件本身进行操作</p>
<p>    字符流在操作流的过程中是【使用了缓冲区】，通过缓冲区进行进行对文件操作</p>
<p><strong>什么是缓冲区？</strong></p>
<p>    缓冲区可以理解为一段特殊区域，某些情况下，如果一个程序频繁的操作一个资源（如文件或数据库），则会出现性能下降的问题，此时为了提升性能，就可以将内存中部分数据读取到一个内存区域中，以后直接从这个区域进行数据去读，这样化就可以提升系统的性能，那么这个提供区域就是“缓冲区”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span></span><br><span class="line">Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在同等条件下进行操作</span></span><br><span class="line"><span class="comment">            创建文件字节输出流和文件字符输出流对象，将数据通过流写入到文件中</span></span><br><span class="line"><span class="comment">            创建了字节和字符文件输出流对象，进行数据书写到文件中并关闭了流资源，此时外界文件中是可以存在数据</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            OutputStream os = new FileOutputStream(new File(&quot;desc/字节流文件.txt&quot;));</span></span><br><span class="line"><span class="comment">            os.write(&quot;Hello World&quot;.getBytes());</span></span><br><span class="line"><span class="comment">            os.close();</span></span><br><span class="line"><span class="comment">            Writer writer = new FileWriter(new File(&quot;desc/字符流文件.txt&quot;));</span></span><br><span class="line"><span class="comment">            //自有字符流中提供可以将字符串写入到文件中方法</span></span><br><span class="line"><span class="comment">            writer.write(&quot;Hello world&quot;);</span></span><br><span class="line"><span class="comment">            writer.close();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//-------------------------------------------------------------------------------------</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在同等条件下进行操作            创建文件字节输出流和文件字符输出流对象，将数据通过流写入到文件中，但是不添加close方法</span></span><br><span class="line"><span class="comment">            字节流可以将数据直接写出到磁盘文件中，在没有使用close方法前提下程序正常结束也可以将流中数据写入到文件中</span></span><br><span class="line"><span class="comment">            字符流在没有使用close方法的前提下，程序正常结束是没有办法将数据写入到文件中的</span></span><br><span class="line"><span class="comment">            就是因为 字符流使用 缓冲区技术即使用“缓冲区”</span></span><br><span class="line"><span class="comment">            在字符流操作过程中，所有字符都是在“内存中形成”的，在输出前会将“所有的暂时保存在内存中内容”输出到文件中</span></span><br><span class="line"><span class="comment">            使用close这个方法在在关闭流资源自后会将缓冲区中数据输出文件中(有flush功能)，所以字符流就要更加要关闭流资源</span></span><br><span class="line"><span class="comment">            但是为了防止忘记书写close方法，并且共缓冲区的利用率，Java对所有输出流都提供了一个方法flush</span></span><br><span class="line"><span class="comment">            flush这个方法可以强制的刷新出缓冲区中数据，所以就算没有关闭流资源可以将字符流中数据写出到文件中</span></span><br><span class="line"><span class="comment">            所以建议在所有写出数据操作中添加flush这个方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/字节流文件.txt&quot;</span>));</span><br><span class="line">        os.write(<span class="string">&quot;Hello World&quot;</span>.getBytes());</span><br><span class="line">        <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/字符流文件.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//自有字符流中提供可以将字符串写入到文件中方法</span></span><br><span class="line">        writer.write(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用字符流还是使用字节流？</p>
<p>    区分场景而言文本文件使用字符流，二进制文件使用字节流，但是字节流处理场景明显要比字符流多，所以建议优先使用字节流处理数据，如果数据是文本文件在考虑转换流操作</p>
<h1><center>知识点六：字符编码</center></h1>
<p>阶段1:</p>
<p>    所以规定使用的字节的最高位是0.每一个字节都是以【0~127之间的数字来表示】,比如A对应65,a对应97.这就是美国标准信息交换码【ASCII】.</p>
<p>‘A’~‘Z’ ‘a’~‘z’ ‘0’~‘9’</p>
<p><strong>阶段2:</strong></p>
<p>    随着计算机在全球的普及,很多国家和地区都把自己的字符引入了计算机,比如汉字.</p>
<p>    此时发现一个字节能表示数字范围太小,不能包含所有的中文汉字那么就规定使用两个字节来表示一个汉字.</p>
<p>    规定:原有的ASCII字符的编码保持不变,仍然使用一个字节表示,为了区别一个中文字符和ASCII码字符中文字符的每个字节最高位规定为1(中文的二进制是负数).这个规范就是【GB2312】编码,后来在GB2312的基础上增加了更多的中文字符,比如汉字,也就出现了【GBK】.</p>
<p>阶段3:</p>
<p>    新的问题,在中国是认识汉字的,但是如果把汉字传递给其他国家,该国家的码表中没有收录汉字,其实就显示另一个符号或者乱码为了解决各个国家因为本地化字符编码带来的影响,咱们就把全世界所有的符号统一进行编码-【Unicode万国码】编码.此时某一个字符在全世界任何地方都是固定的,比如【哥】,在任何地方都是以十六进制的【54E5】来表示.Unicode的编码字符都占有【2个字节大小】</p>
<p>常用字符编码集</p>
<p>    ASCII码： 占一个字节，只能包含128个符号，不能表示汉字</p>
<p>    ISO-8859-1【latin-1】占一个字节，收录的是西欧语言，不能表示汉字 —》properties</p>
<p>    ANSI【GB2312】占两个字节，在简体中文操作系统中ANSI就是值的GB2312(淘汰了)</p>
<p>    GB18030/GBK 占两个字节，支持中文</p>
<p>    UTF-8：是一种针对Unicode的可变长字符编码，又称万国码，UTF-8是Unicode的实现方式之一，这个编码兼容ASCII码 UTF-8表示汉字’\u0000’~’\uffff’</p>
<p>ps：在UTF家族中提供了其他编码 UTF-8E ，UTF-16 ,UTF-32， 这里有一个特殊编码集千万不要使用，这个编码集是MS公司搞出来UTF-8 BOM，默认3个字节一个汉字【不要使用】</p>
<h1><center>知识点七：InputStreamReader 字节字符转换输入流</center></h1>
<p>字节字符转换输入流的作用：<strong>将字节流转换为字符流，并且可以设置文件编码集</strong></p>
<p>“特别说明：<strong>InputStreamReader的父类是Reader类，所以这个流中数据是char类型</strong>”</p>
<p>    “<strong>InputStreamReader是FileReader的直接父类</strong>”</p>
<h2 id="center-1-核心构造方法-center"><center>1、核心构造方法</center></h2>
<table>
<thead>
<tr>
<th style="text-align:center">常用构造方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">InputStreamReader(InputStream in) 通过参数InputStream流的对象构建InputStreamReader流对象并使用的是默认编码集</td>
</tr>
<tr>
<td style="text-align:center">InputStreamReader(InputStream in, Charset cs) 通过参数</td>
</tr>
<tr>
<td style="text-align:center">InputStream流的对象构建InputStreamReader流对象并用过Charset设置读取文件编码集</td>
</tr>
<tr>
<td style="text-align:center">InputStreamReader(InputStream in, String charsetName)通过参数InputStream流的对象构建InputStreamReader流并用过字符串设置读取文件编码集</td>
</tr>
</tbody>
</table>
<p>PS： 转换输入流，所以构建InputStreamReader对象时，需要提供一个字节输入流作为转换对象</p>
<p>通过InputStreamReader可以设置编码集，设置编码集方式是通过InputStreamReader构造方法中第二参数进行设置，这里设置有两种方式</p>
<p>    第一种方式：使用Charset类型进行设置 —》 Charset.forName(“编码集名字”)</p>
<p>    第二种方式：使用String类型进行设置 —》 “编码集名字”</p>
<h2 id="center-2-核心api方法-center"><center>2、核心API方法</center></h2>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">常用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">close() 关闭流并释放与它相关联的任何系统资源</td>
</tr>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:center">getEncoding() 返回此流使用的字符编码的名称。(在读取文件的同时读取文件编码集)</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">read() 读取单个字符</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">read(char[] cbuf, int offset, int length) 将字符读入一个数组的一部分</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">read(char[] cbuf) 将读取的数据存储到字符数组中</td>
</tr>
</tbody>
</table>
<h1><center>知识点八：OutputStreamWriter 字节字符转换输出流</center></h1>
<p>字节字符转换输出流作用:将字符流转换为字节流输出，并可以设置编码集</p>
<p>特别注意:&quot;<strong>OutputStreamWriter的父类是Writer,所以这个流中数据是char类型</strong></p>
<p>        “<strong>OutputStreamWriter是FileWriter的父类</strong>”</p>
<h2 id="center-1-核心构造方法-center"><center>1、核心构造方法</center></h2>
<table>
<thead>
<tr>
<th style="text-align:center">常用构造方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">OutputStreamWriter(OutputStream out) 通过OutputStream对象创建OutputStreamWriter对象并使用默认编码集写出数据</td>
</tr>
<tr>
<td style="text-align:center">OutputStreamWriter(OutputStream out, Charset cs) 通过OutputStream对象创建OutputStreamWriter对象并使用Charset设置写出文件编码集</td>
</tr>
<tr>
<td style="text-align:center">OutputStreamWriter(OutputStream out, StringcharsetName) 通过OutputStream对象创建OutputStreamWriter对象并使用String类型设置写出文件编码集</td>
</tr>
</tbody>
</table>
<p>PS： 转换输出流，所以构建OutputStreamWriter对象时，需要提供一个字节输出流作为转换对象</p>
<p>通过OutputStreamWriter可以设置编码集，设置编码集方式是通过OutputStreamWriter构造方法中第二参数进行设置，这里设置有两种方式</p>
<p>    第一种方式：使用Charset类型进行设置 —》 Charset.forName(“编码集名字”)</p>
<p>    第二种方式：使用String类型进行设置 —》 “编码集名字”</p>
<h2 id="center-2-核心的api方法-center"><center>2、核心的API方法</center></h2>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">常用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">close() 关闭流，冲洗它</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">flush() 冲流</td>
</tr>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:center">getEncoding() 返回此流使用的字符编码的名称</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">write(char[] cbuf, int off, int len) 写入一个字符数组的一部分</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">write(int c) 写一个字符</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">write(String str, int off, int len) 写入字符串的一部分</td>
</tr>
</tbody>
</table>
<p>PS： 因为OutputStreamWriter是父类Writer方法，所以也会继承到Writer方法中参数为String类方法，所以提供直接输出字符串的方法</p>
<p><strong>这两流的操作可以完全操作FileRader和FileWriter进行操作</strong></p>
<p>需求：使用转换流在设置编码集的前提下进行文件的赋值与粘贴</p>
<ol>
<li>读取文件使用UTF-8编码集进行，输出文件时将文件编码集修改为GBK</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.BufferedInputStreamAndBufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileEncodingCopyDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用转换流进行文件的编码集设置操作</span></span><br><span class="line">        <span class="comment">//1.提供创建字节字符转换输入输出流对象</span></span><br><span class="line">        <span class="comment">//在创建转换流对象时，是存在一个编译时异常 UnsupportedEncodingException【不支持设置编码集】</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/1.txt&quot;</span>)),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">//只有读对了才可以写对</span></span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/1.txt&quot;</span>)),</span><br><span class="line">        Charset.forName(<span class="string">&quot;GBK&quot;</span>));</span><br><span class="line">        <span class="comment">//2.这两个转换流是父类都是字符类型，所以流中的数据都是char类型</span></span><br><span class="line">        <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//提供一个变量存储实际读取到文件长度【包括文件末尾-1的返回值】</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//3.循环读取数据并将当前数据输出</span></span><br><span class="line">        <span class="keyword">while</span>((len = isr.read(buf))!=-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            osw.write(buf,<span class="number">0</span>,len);</span><br><span class="line">        &#125; </span><br><span class="line">        osw.flush();</span><br><span class="line">        osw.close();</span><br><span class="line">        isr.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;老子写完了！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需求：仿照上面代码提供一个通用方法可以设置文件编码集并且使用转换流进行拷贝与粘贴操作</p>
<ol>
<li>读取文件使用UTF-8编码集进行，输出文件时将文件编码集修改为GBK</li>
<li>读取文件使用GBK编码集进行，输出文件时将文件编码集修改为UTF-8</li>
<li>使用GBK编码集读取一个UTF-8文件，输出文件时使用UTF-8编码集输出</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.BufferedInputStreamAndBufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileEncodingCopyDemo2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. 读取文件是UTF-8，写出文件GBK</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            copyFile(new File(&quot;dir/1.txt&quot;),&quot;UTF-8&quot;,new File(&quot;desc/1.txt&quot;),&quot;GBK&quot;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//2. 读取文件是GBK ，写出文件是UTF-8编码</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            copyFile(new File(&quot;desc/1.txt&quot;),&quot;GBK&quot;, new File(&quot;dir/UFT-8文件.txt&quot;),&quot;UTF-8&quot;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 3. 读取一个UTF-8的编码文件使用GBK编码，写出文件是使用UTF-8写出</span></span><br><span class="line">        copyFile(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/UFT-8文件.txt&quot;</span>),<span class="string">&quot;GBK&quot;</span>, <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/将UFT-8文件设置为GBK之后修</span></span><br><span class="line"><span class="string">                                                                                改为UTF-8.txt&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 设置文件编码集进行赋值粘贴的方法</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> srcFile 源文件</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> srcCharset 源文件编码集</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> descFile 目标文件</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> descCharset 目标文件编码集</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> Exception 代表方法所有要抛出的编译时异常</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(File srcFile,String srcCharset,File descFile,String descCharset)</span><span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供字节字符转换输入输出流对象</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile),srcCharset);</span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(descFile),descCharset);</span><br><span class="line">        <span class="comment">//2.使用的是什么流，流中数据是什么 --》 他们都是字符流</span></span><br><span class="line">        <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = isr.read(buf))!=-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            osw.write(buf,<span class="number">0</span>,len);</span><br><span class="line">        &#125; </span><br><span class="line">        osw.flush();</span><br><span class="line">        osw.close();</span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>转换流的总结：</strong></p>
<p>    <strong>转换流的目的在于提供了字节与字符流之间的一种转换效果，我们可以通过转换流将字符流和字节流进行转化，除此之外还可以设置文件的编码集进行文件的读取和写出操作</strong>，这样可以完成文件的编码集转换操作【文件编码集的转换操作原则是：只有读取文件时编码集设置正确，才可在写出文件时将编码集设置正确】</p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012007515.WebP" alt="字符流转字节流" style="zoom: 67%;">
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012008623.WebP" alt="字节流转字符流" style="zoom:67%;">
<h1><center>知识点九：缓冲流</center></h1>
<p>有了缓冲流之后，不建议使用原始流进行操作，缓冲流效率是远远高于原始流，缓冲流提供缓冲区让流可以进行操作</p>
<p>原始流指的是：InputStream和OutputStream 或者 Reader和Writer不使用缓冲区的流</p>
<p>PS：需要注意的是 字符流 默认使用了缓冲区，所以和缓冲流的效果差不多</p>
<h2 id="center-1-字节缓冲流-center"><center>1、字节缓冲流</center></h2>
<p>字节缓冲流是针对原始字节流而提供一种流，这个中流可以更加高效处理流中操作</p>
<p><strong>BufferedInputStream字节缓冲输入流 和 BufferedOutputStrem 字节缓冲输出流</strong></p>
<p>BufferedInputStream字节缓冲输入流是InputStream字节输入流的子类，这个流提供一个缓冲区，这个缓冲区可以帮组流进行数据缓冲与操作，<strong>这个缓冲区的大小默认是8192K</strong>,提供BufferedInputStream这个流可以包装一个普通字节输入流进行缓冲操作，这个缓冲区大小是可以用过BufferedInputStream构造方法进行设置，但是<strong>这个缓冲区的设置不要低于8192，设置时按照1024倍数设置即可</strong></p>
<h3 id="1-bufferedinputstream常用构造方法">（1）BufferedInputStream常用构造方法</h3>
<table>
<thead>
<tr>
<th style="text-align:center">常用构造方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">BufferedInputStream(InputStream in) 创建一个BufferedInputStream 和保存它的参数，输入流 in ，供以后使用</td>
</tr>
<tr>
<td style="text-align:center">BufferedInputStream(InputStream in, int size) 创建一个具有指定的缓冲区大小 BufferedInputStream ，并保存它的参数，输入流 in ，供以后使用</td>
</tr>
</tbody>
</table>
<p>PS：缓冲流的使用其实就是对原始流进行二次“包装”，让原始就具备一个缓冲区可以快速进行流操作，所以构建字节缓冲输入流对象时，<strong>需要提供一个“InputStream字节输入流对象”</strong>，不仅如此还可以设置缓冲区的默认大小，<strong>不要低于8192这个数据，设置时按照1024倍数设置即可</strong>，缓冲流输入流是唯一支持字节输入流父类中提供mark和reset方法【但是没有任何效果】</p>
<h3 id="2-bufferedinputstream常用api方法">（2）BufferedInputStream常用API方法</h3>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">常用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">close() <strong>关闭此输入流并释放与流关联的任何系统资源</strong></td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">read() 看到的 InputStream 的 read 方法一般合同</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">read(byte[] b) <strong>读取文件存储到数组中</strong>【常用】</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">read(byte[] b, int off, int len) 从这个字节的输入流读取到指定的字节数组中的字节，从给定的偏移量开始</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">markSupported() 如果输入流的支持 mark 和reset 方法【无用】</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">mark(int readlimit) 看到的 InputStream 的mark 方法一般合同【无用】</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">reset() 看到的 InputStream 的 reset 方法一般合同【无用】</td>
</tr>
</tbody>
</table>
<p>    BufferedOutputStream字节缓冲输出流是OutputStream字节输出流子类，这个流提供一个缓冲区，这个缓冲区可以帮组流进行数据缓冲与操作，<strong>这个缓冲区的大小默认是8192K</strong>,提供BufferedOutputStream这个流可以包装一个普通字节输出流进行缓冲操作，这个缓冲区大小是可以用过BufferedOutputStream构造方法进行设置，<strong>但是这个缓冲区的设置不要低于8192，设置时按照1024倍数设置即可</strong></p>
<h3 id="3-bufferedoutputstream常用构造方法">（3）BufferedOutputStream常用构造方法</h3>
<table>
<thead>
<tr>
<th style="text-align:center">常用构造方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">BufferedOutputStream(OutputStream out) 创建一个新的缓冲输出流，将数据写入到指定的基本输出流中</td>
</tr>
<tr>
<td style="text-align:center">BufferedOutputStream(OutputStream out, int size) 创建一个新的缓冲输出流，用指定的缓冲区大小写数据到指定的基本输出流中</td>
</tr>
</tbody>
</table>
<p>PS：缓冲流的使用其实就是对原始流进行二次“包装”，让原始就具备一个缓冲区可以快速进行流操作，所以构建字节缓冲输出流对象时，<strong>需要提供一个“OutputStream字节输出流对象”</strong>，不仅如此还可以设置缓冲区的默认大小，<strong>不要低于8192这个数据，设置时按照1024倍数设置即可</strong></p>
<h3 id="4-bufferedoutputstream常用api方法">（4）BufferedOutputStream常用API方法</h3>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">常用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">flush() 刷新缓冲输出流</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">write(byte[] b, int off, int len) 写 len 字节指定字节数组中的起始偏移 off 这个缓冲输出流</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">write(int b) 将指定的字节写入该缓冲输出流中</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">close() 关闭此输出流并释放与此流关联的任何系统资源</td>
</tr>
</tbody>
</table>
<p>PS:字节缓冲输入输出流没有任何特殊方法，这个操作可以完全参考FileInputStream 和FileOutputStream</p>
<p>字节缓冲输入输出流就是提供缓冲区提高操作效率而已</p>
<p>性能对比： 使用缓冲字节流和普通字节流进行 大于2GB文件拷贝操作计算时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span></span><br><span class="line">com.qfedu.BufferedInputStreamAndBufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCopyTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span></span><br><span class="line">Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供一个开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//先提供字节输入输出流拷贝操作</span></span><br><span class="line">     <span class="comment">//copyFileToByte(new File(&quot;C:\\Users\\jkmaster\\Desktop\\23_IO流1.zip&quot;),new File(&quot;C:\\abc\\23_IO流1.zip&quot;));</span></span><br><span class="line">        <span class="comment">//在提供缓冲字节输入输出流拷贝操作</span></span><br><span class="line">        copyFileToBufferedByte(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\jkmaster\\Desktop\\23_IO流1.zip&quot;</span>),</span><br><span class="line">                                                                        <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\abc\\23_IO流1.zip&quot;</span>));</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//System.out.println(&quot;缓冲字节输入输出流拷贝文件的时间</span></span><br><span class="line">                                                    <span class="comment">//是：&quot;+(endTime-beginTime)+&quot;毫秒&quot;);5869毫秒 --》约等于 6秒</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;普通字节输入输出流拷贝文件的时间</span></span><br><span class="line">                                                   <span class="comment">//是：&quot;+(endTime-beginTime)+&quot;毫秒&quot;);21387毫秒 --》约等于 21秒</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 普通字节输入输出流拷贝文件操作</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> srcFile 源文件</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> descFile 目标文件</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception 抛出所有编译时异常信息    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileToByte</span><span class="params">(File srcFile, File descFile)</span><span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供字节输入输出对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(descFile);</span><br><span class="line">        <span class="comment">//2.提供byte类型数组</span></span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//3.提供一个变量存储读取实际文件长度【读取文件末尾-1值】</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(bs))!=-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            os.write(bs,<span class="number">0</span>,len);</span><br><span class="line">        &#125; </span><br><span class="line">        os.flush();</span><br><span class="line">        os.close();</span><br><span class="line">        is.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;字节输入输出流拷贝文件结束！&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 提供缓冲字节输入输出流拷贝文件操作</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> srcFile 源文件</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> descFile 目标文件</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception 抛出所有编译时异常信息    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileToBufferedByte</span><span class="params">(File srcFile, File descFile)</span><span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供缓冲字节输入输出对象</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile));</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(descFile));</span><br><span class="line">        <span class="comment">//2.提供byte类型数组</span></span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//3.提供一个变量存储读取实际文件长度【读取文件末尾-1值】</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(bs))!=-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            bos.write(bs,<span class="number">0</span>,len);</span><br><span class="line">        &#125; </span><br><span class="line">        bos.flush();</span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲字节输入输出流拷贝文件结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//PS：能用缓冲流就用缓冲流，不要使用普通字节流</span></span><br></pre></td></tr></table></figure>
<h2 id="center-2-字符缓冲流-center"><center>2、字符缓冲流</center></h2>
<p>PS：这个流才是我们真记忆，他符合内容数据写入到磁盘，在从磁盘将数据读取到内容使用流</p>
<p>字符缓冲流对于将内存中数据写入到磁盘中和将磁盘中数据读取到内容中有非常好支持，所以只要是这样数据操作就一定使用这个流</p>
<p>字符缓冲流也是缓冲流，所有字符缓冲输入输出流都具备缓冲区，默认大小也是8192K，如果要修改缓冲区大小需要比8192K大，并且是提供1024倍数进行修改</p>
<p>BufferedReader缓冲字符输入流是Reader字节输入的子类，提供8192K缓冲区，可以包装一个普通的字符输入流提高操作效率</p>
<h3 id="1-bufferedreader常用构造方法">（1）BufferedReader常用构造方法</h3>
<table>
<thead>
<tr>
<th style="text-align:center">构造方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">BufferedReader(Reader in) 创建一个使用默认大小输入缓冲区的缓冲字符输入流</td>
</tr>
<tr>
<td style="text-align:center">BufferedReader(Reader in, int sz) 创建一个使用指定大小的输入缓冲区的缓冲字符输入流</td>
</tr>
</tbody>
</table>
<p>PS：BuffereReader是缓冲字符输入流，所以需要提供一个字符输入流作为对象传入到缓冲字符输入流中进行对象创建，除此之外提供修改默认缓冲区大小</p>
<h3 id="2-bufferedreader常用api方法">（2）BufferedReader常用API方法</h3>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">常用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">string</td>
<td style="text-align:center">readLine() 读一行文本【强烈推荐】</td>
</tr>
</tbody>
</table>
<p>说明：</p>
<ol>
<li>BufferedReader是一个流，所以也需要调用close方法</li>
<li>BufferedReader读取数据方式一共有两种：</li>
</ol>
<p>    2.1 使用原始字符输入流的方式进行数据读取 --》 提供char数组，使用read方法读取数据【不推荐】</p>
<p>    2.2 使用BufferedReader中独有的方法进行数据读取 —》 readLine方法【强烈推荐】</p>
<p>        readLine这个方法是返回读取一次文本中内一行内容，这个方法的返回值是String</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.BufferedReaderAndBufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReaderDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建字符缓冲输入流BufferedReader对象</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/UFT-8文件.txt&quot;</span>)));</span><br><span class="line">        <span class="comment">//2.提供两种读取数据的方式</span></span><br><span class="line">        <span class="comment">//2.1 使用char数组的方式进行读取</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            char[] buf = new char[1024];</span></span><br><span class="line"><span class="comment">            int len;</span></span><br><span class="line"><span class="comment">            while((len = br.read(buf))!=-1)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(new String(buf,0,len));</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//2.1 使用 readLine进行数据读取，一次读取文件中一行内容</span></span><br><span class="line">        <span class="comment">//2.1.1 提供一个String类型变量接收读取到数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            readLine方法读取文件中每一个行内容时，一共有两种数据返回形态</span></span><br><span class="line"><span class="comment">            读取到数据就返回String类型字符串读，取到文件末尾就返回null值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">while</span>((content = br.readLine()) != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//可以在这个循环中对content得到String字符串数据即文件中读取到内容进行操作</span></span><br><span class="line">            System.out.println(content);</span><br><span class="line">        &#125; </span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-bufferedwriter缓冲字符输出流">（3）BufferedWriter缓冲字符输出流</h3>
<p>BufferedWritrer缓冲字符输出流是Writer字符输出流子类，并且提供一个默认缓冲区大小为8192K，提供给包装普通字符输出流对象使用对字符输出流操作</p>
<h4 id="常用构造方法">常用构造方法</h4>
<table>
<thead>
<tr>
<th style="text-align:center">常用构造方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">BufferedWriter(Writer out) 创建一个使用默认大小输出缓冲区的缓冲字符输出流</td>
</tr>
<tr>
<td style="text-align:center">BufferedWriter(Writer out, int sz) 创建一个新的缓冲字符输出流，该流使用给定大小的输出缓冲区</td>
</tr>
</tbody>
</table>
<p>PS：BufferedWriter缓冲字符输出流是包装一个字符输出流对象，所以参数需要一个字符出流对象进行传入创建，并且可以设置默认缓冲区的大小，不建议低于8192K大小，提供设置默认值时要是1024的倍数</p>
<h4 id="常用api方法">常用API方法</h4>
<table>
<thead>
<tr>
<th style="text-align:center">void</th>
<th style="text-align:center">write(String str) 写一个字符串【这个方法是专门应对readLine方法写出的】</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">newLine() 写行分隔符</td>
</tr>
</tbody>
</table>
<p>说明：</p>
<ol>
<li>BufferedWriter提供字符缓冲输出流操作，所以支持flush和close方法</li>
<li>BufferedWriter提供数据写出操作，提供两种方式应对BufferedReader的操作</li>
</ol>
<p>        2.1 如果BufferedReader使用是char类型数组进行数据读取操作BufferedWriter就提 ·writer(char[] buf,int off,int len)将数据写出</p>
<p>        2.2 如果BufferedReader使用是readLine这个方法进行数据读取操作者BufferedWriter就提供 write(String str) 将数据写出</p>
<p><strong>PS: 使用write(String str) 将数据写出时需要配合使用newLine()这个方法以保证写出文件正确格式</strong></p>
<p>需求： 使用缓冲字符输入输出流对象进行数据拷贝操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyFileDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span></span><br><span class="line">Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供缓冲字符输入输出流对象</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/UFT-8文件.txt&quot;</span>)));</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;desc/file文件.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//1.提供char数组方式进行写入写出操作</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            char[] buf = new char[1024];</span></span><br><span class="line"><span class="comment">            int len;</span></span><br><span class="line"><span class="comment">            while((len = br.read(buf))!=-1)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                bw.write(buf,0,len);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//2.使用newLine来进行数据写入写出操作</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((str = br.readLine()) != <span class="literal">null</span>)    <span class="comment">//readLine这个方式不读取换行操作，不读取回车&quot;\n&quot;</span></span><br><span class="line">        &#123;</span><br><span class="line">        </span><br><span class="line">            bw.write(str);</span><br><span class="line">            <span class="comment">//所以为了保证写出数据的格式完整性</span></span><br><span class="line">            bw.newLine(); <span class="comment">//添加换行操作即添加&quot;\n&quot;</span></span><br><span class="line">        &#125; </span><br><span class="line">        bw.flush();</span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结:</p>
<p>    Java中提供缓冲流的效率是远远高于普通（原始）流，因为缓冲流提供缓冲区操作，<strong>缓冲字节输入输出流针对是二进制文件【视频、音频、图片、压缩包】等等，缓冲字符输入输出流针对的是文本文件，主要完成就是将内存中数据写入到文件中，将文件中数据在读取会内容，提供这个操作</strong></p>
<p>案例：使用字符输入流从控台读取数据【不用Scanner】，写入到文件中【默认记录聊天数据】，写出数据时使用</p>
<p>System.out打印到文件中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.BufferedReaderAndBufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadScannerToFile</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//不使用Scanner进行数据操作</span></span><br><span class="line">        <span class="comment">//可以提供字符缓冲输入流进行控制台数据读取</span></span><br><span class="line">        <span class="comment">//之所以可以在控制台获取到数据主要是因为使用标准字节输入流--》System.in</span></span><br><span class="line">        <span class="comment">//如果使用这种方法获取数据方式很单一只有readLine</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用System这个类中 setOut方法改变打印数据流向--》标准输出流重定向</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//需要提供一个字节打印流对象，提供流输出数据位置</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;desc/聊天记录.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//修改打印流的流向</span></span><br><span class="line">        System.setOut(ps);</span><br><span class="line">        <span class="comment">//提供循环进行数据获取</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供一个Date对象获取当前时间</span></span><br><span class="line">            <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">            <span class="comment">//读取控制台数据</span></span><br><span class="line">            content = br.readLine();</span><br><span class="line">            <span class="comment">//约定如果输入886结束程序</span></span><br><span class="line">            <span class="keyword">if</span>(content.equals(<span class="string">&quot;886&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//就将数据写入到文件中</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> sdf.format(date);</span><br><span class="line">            <span class="comment">//System.out.println(time);</span></span><br><span class="line">            System.out.println(content);</span><br><span class="line">        &#125; </span><br><span class="line">        br.close();</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//ps:已经将System.out的输出指定到文件中，如果需要将输出在指定会控制台打印如何做？</span></span><br></pre></td></tr></table></figure>
<h2 id="center-3-资源文件properties-center"><center>3、资源文件Properties</center></h2>
<p>Properties文件是继承与Hashtable，Properties文件中存储数据方式就是以【key-value键值对】进行，对这个文件操作是将需要使用数据存储在value中，提供key可以访问外界访问到key获取到需要value值</p>
<p>Properties文件是可以通过代码进行创建，也可以在外界直接创建这个文件但是文件后缀名必须【.properties】这个文件被称之为资源文件，可以向这个文件中提供一些常用的配置信息【JDBC链接信息，Spring的配置信息、SpringBoot配置信息】等等，这个文件默认编码集是ISO-8859-1，所以不支持使用代码的形式创建文件中出现中文，如果出现中文是以Unicode码进行展示的。直接创建文件是支持写入中文但是要以注释形式存在</p>
<p><strong>案例：使用流方式来创建Properties文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesFileDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在控制台上获取一些数据，存储在properties文件中</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="comment">//文件后缀名字必须是.properties</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;dir/config.properties&quot;</span>));</span><br><span class="line">        <span class="comment">//1.提供Properties对象的创建</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//循环获取到控制台输入的数据</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入key值：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">            <span class="comment">//当key值获取到over的时候停止循环操作</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;over&quot;</span>.equals(key))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            System.out.println(<span class="string">&quot;请输入value值：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">            <span class="comment">//调用Properties中方法将key-value键值对存储到 Properties对象中</span></span><br><span class="line">            p.setProperty(key,value);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//将存储在Properties对象中数据写入到文件中，properties文件中 #号是注释的意思</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            store方法需要传递输出流对象【字符或字节都可以】</span></span><br><span class="line"><span class="comment">            第二个参数是 注释--》通过代码写出文件中文是无法正确展示的，所以建议使用英文</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        p.store(bw,<span class="string">&quot;我是注释!!!&quot;</span>);</span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>案例：使用流读取Properties文件【常用】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="comment">//读取资源文件的工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesUtil</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.提供一个私有静态Properties对象获取文件中数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties properties;</span><br><span class="line">    <span class="comment">//2.加载文件操作一般都会提前加载，而不是当用户使用到时候在加载</span></span><br><span class="line">    <span class="keyword">static</span>    <span class="comment">//使用静态代码块进行资源加载，只会执行一次不会出现重复加载问题</span></span><br><span class="line">    &#123; </span><br><span class="line">        </span><br><span class="line">        properties = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            调用load方法加载资源文件，将资源文件中内容读取到properties对象中</span></span><br><span class="line"><span class="comment">            这个方法参数既可以是字节流也可以是字符流</span></span><br><span class="line"><span class="comment">            这个操作会存在编译时异常，static静态代码块中是不能throws，只能try-catch</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dir/config.properties&quot;</span>));</span><br><span class="line">        &#125; </span><br><span class="line">            <span class="keyword">catch</span> (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;资源文件加载失败，无法加载：&quot;</span>+e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        提供一个方法可以获取Properties资源文件中值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getValue</span><span class="params">(String key)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过key值获取到vlaue值        </span></span><br><span class="line">        <span class="keyword">return</span> properties.getProperty(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取用户名字请输入username:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> input.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> PropertiesUtil.getValue(username);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名：&quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结Properties核心方法：</p>
<ol>
<li>创建对象—》new Properties();</li>
<li>存储key和value键值对 —》setProperty(key,value)</li>
<li>创建Properties文件 —》 store(字节或字符输出流对象，“文件内容注释”)</li>
<li>读取Properties文件 —》 load(字节或字符输入流对象)</li>
<li>获取value值 —》 getProperty(key)</li>
</ol>
<h2 id="center-4-序列化和反序列化-对象流-center"><center>4、序列化和反序列化【对象流】</center></h2>
<p>序列化和反序列化？</p>
<p>    <strong>对象序列化</strong> : <strong>把一个【对象转换二进制数据】这种方式称之为序列化</strong>，序列化之后对象可以方便实现对象【<strong>存储与传输</strong>】</p>
<p><strong>    对象反序列化</strong>：<strong>把一个【二进制数据转换成对象】这种方式称之为反序列化</strong>,通过反序列化操作就可以得到存储在文件中对象内的数据了</p>
<p><strong>Serializable接口</strong></p>
<p>    如果需要将某个对象进行序列化操作，那么这个对象描述类就需要实现<strong>Serializable接口</strong>，这样才可以允许对当前对象进行序列化和反序列化</p>
<p>    API文档中对Serializable接口的说明： 类通过实现java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段，仅用于标识可序列化的语义</p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012018417.WebP" alt="兼容问题" style="zoom:50%;">
<h3 id="1-对象字节输入输出流">（1）对象字节输入输出流</h3>
<p>使用对象字节输入流读取文件称之为【反序列化】，从磁盘文件中将对象读取到内存使用是【ObjectInputStream】</p>
<p>使用对象字节输出流写出文件称之为【序列化】，从内存将对象写入到文件中使用是【ObjectOutputStream】</p>
<p><strong>ObjectOutputStream常用构造方法和常用方法</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">常用构造方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">ObjectOutputStream(OutputStream out)创建一个对象写入到指定的输出流，参数需要是一个字节输出流对象</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">常用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">writeObject(Object obj) 将对象写入到对象流中【对象的序列化】</td>
</tr>
</tbody>
</table>
<p>因为需要将对象序列化到文件中所以构造方法中需要提供字节输出流对象，配套使用是FileOutputStream，核心方法就是序列化对象，所以使用writeObject方法，还支持很多其他的写入方法，但是使用较少，支持关闭和刷新流</p>
<p><strong>ObjectInputStream常用的构造方法和常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">常用构造方法</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectInputStream</span><span class="params">(InputStream in)</span></span><br><span class="line">创建一个对象输入流读取从指定的输入流，参数需要一个字节输入流对象</span><br><span class="line">常用方法</span><br><span class="line">Object <span class="title function_">readObject</span><span class="params">()</span> 从对象输入流读取对象【反序列化】 </span><br><span class="line">读取的是文件中内容，所以参数需要一个字节输入流对象，匹配使用是FileInputStream，核心方法就是反序列化对象，</span><br><span class="line">所以使用readObject这个方法，特别注意返回值类型时Object，这个流也需要关闭</span><br></pre></td></tr></table></figure>
<p>案例：单个对象序列和反序列化操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//java.io.NotSerializableException: com.qfedu.serializable.Student</span></span><br><span class="line">        <span class="comment">//出现这个异常原因是因为没有实现：Serializable接口</span></span><br><span class="line">        <span class="comment">// Student student = new Student(&quot;成龙&quot;,68);</span></span><br><span class="line">        <span class="comment">// serializableObject(student);</span></span><br><span class="line">        deSerializableObject();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        对象序列化操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serializableObject</span><span class="params">(Student student)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建序列化对象的流对象</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;dir/序列化单个对象的文件&quot;</span>));</span><br><span class="line">        <span class="comment">//2.代用writeObject方法进行序列化操作</span></span><br><span class="line">        oos.writeObject(student);</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化成功！&quot;</span>);</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        对象反序列化操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deSerializableObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供反序列化流对象</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dir/序列化单个对象的文件&quot;</span>));</span><br><span class="line">        <span class="comment">//2.调用readObject方法反序列化操作</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> ois.readObject();    <span class="comment">//这个方法返回值是Boject类型，如果需要对数据进行具体化操作需要对象向下转型</span></span><br><span class="line">        System.out.println(<span class="string">&quot;验证o对象是否是Student类型：&quot;</span>+(o <span class="keyword">instanceof</span> Student));</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>案例：多个对象序列化和反序列化【创建5个Student对象进行序列化和反序列化操作要求在同一个文件中（一个文件5个对象）】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">//多个对象序列化与反序列化操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三1&quot;</span>,<span class="number">19</span>),<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三2&quot;</span>,<span class="number">20</span>), <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三3&quot;</span>,<span class="number">21</span>),</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三4&quot;</span>,<span class="number">22</span>), <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三5&quot;</span>,<span class="number">23</span>),<span class="literal">null</span>);<span class="comment">//追加null就是结尾证明没有数据了</span></span><br><span class="line">        <span class="comment">//serializableMoreObject(list);</span></span><br><span class="line">        <span class="comment">//deSerializableMoreObject();</span></span><br><span class="line">        <span class="comment">// --------------------------------------------------</span></span><br><span class="line">        <span class="comment">//serializableMoreObject2(list);</span></span><br><span class="line">        deSerializableMoreObject2();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供第一个处理方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serializableMoreObject</span><span class="params">(List&lt;Student&gt; list)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;dir/多个对象序列化文件&quot;</span>));</span><br><span class="line">        <span class="comment">//此时要序列化操作，但是现在所有的对象都是存在List集合中，所以直接序列化集合即可</span></span><br><span class="line">        <span class="comment">//这个操作只是取巧，不是多个对象序列化， 只是序列化了一个List集合对象</span></span><br><span class="line">        oos.writeObject(list);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deSerializableMoreObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dir/多个对象序列化文件&quot;</span>));</span><br><span class="line">        <span class="comment">//readObject这个方法的返回值是Object类型，所以需要操作数据时需要向下转型</span></span><br><span class="line">        List&lt;Student&gt; stus = ((List&lt;Student&gt;)ois.readObject());</span><br><span class="line">        <span class="keyword">for</span> (Student student : stus) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//----------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//第二种序列化和反序列化方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serializableMoreObject2</span><span class="params">(List&lt;Student&gt; list)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;dir/多个对象序列化文件2&quot;</span>));</span><br><span class="line">        <span class="comment">//此时要序列化操作，但是现在所有的对象都是存在List集合中，需要从集合中获取所有对象</span></span><br><span class="line">        <span class="keyword">for</span> (Student student : list) </span><br><span class="line">        &#123;</span><br><span class="line">            oos.writeObject(student); <span class="comment">//这样才是5对象序列化</span></span><br><span class="line">        &#125; </span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deSerializableMoreObject2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dir/多个对象序列化文件2&quot;</span>));</span><br><span class="line">        <span class="comment">//提供一个集合存储读取对象数据</span></span><br><span class="line">        List&lt;Student&gt; stus = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            readObject这个方法的返回值是Object类型，所以需要操作数据时需要向下转型</span></span><br><span class="line"><span class="comment">            因为文件中存储的5个对象，如果对象么有值使用什么代表--》null值</span></span><br><span class="line"><span class="comment">            利用这个原则进行数据读取操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用这种读取方式readObject提示一个EOFException含义</span></span><br><span class="line"><span class="comment">            此异常主要被数据输入流用来表明到达流的末尾</span></span><br><span class="line"><span class="comment">            证明是争取读取到文件中每一个数据并且读取到文件末尾，才会出现这个异常</span></span><br><span class="line"><span class="comment">            在while循环中提供判断是无法生效，它是无法获取到文件末尾的null，即没有这个null</span></span><br><span class="line"><span class="comment">            只能以异常形式停止，所以如何处理这个问题，会在集合存储的最后一个位置添加一个null作为结尾</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">while</span>((obj = ois.readObject())!=<span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stus.add(((Student)obj));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            while(true)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                try </span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    obj = ois.readObject();</span></span><br><span class="line"><span class="comment">                    stus.add(((Student)obj));</span></span><br><span class="line"><span class="comment">                &#125; </span></span><br><span class="line"><span class="comment">                catch (EOFException e) </span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    break;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ois.close();</span><br><span class="line">        stus.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java语言</category>
      </categories>
      <tags>
        <tag>Java语言</tag>
      </tags>
  </entry>
  <entry>
    <title>6.异常、File类和递归</title>
    <url>/post/a24af109.html</url>
    <content><![CDATA[<h1>异常</h1>
<p>程序在运行的过程出现的错误，称之为异常</p>
<p>如果异常不处理，那么就会终止java虚拟机的运行。意味着出现异常后面的代码就不会再执行了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//程序出现异常，但是没有处理</span></span><br><span class="line">System.out.println(<span class="number">10</span>/<span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;处理了么&quot;</span>);     <span class="comment">//不会运行</span></span><br></pre></td></tr></table></figure>
<h2 id="center-异常分类-center"><center>异常分类</center></h2>
<ul>
<li>Throwable (异常的父类)
<ul>
<li>Error(错误) 内存溢出、硬件等等(程序员无法通过程序解决)</li>
<li><strong>Exception</strong>(异常)：需要程序处理
<ul>
<li><strong>运行期</strong>异常(未检查)：程序运行期间出现的异常（<strong>RuntimeException</strong>）</li>
<li><strong>不是必须处理</strong>
<ul>
<li>举例：空指针异常、类转换异常、数组下标越界异常、输入异常、下标越界异常等</li>
</ul>
</li>
<li><strong>编译期</strong>异常 (受检)：程序在编译期间出现的异常（<strong>Exception</strong>）</li>
<li><strong>必须处理</strong>
<ul>
<li>举例：ParseException InterruptedException等</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="center-捕获异常-主动处理-center"><center>捕获异常(主动处理)</center></h2>
<p>运行期异常：一般不需要处理，可以利用逻辑判断解决(避免)</p>
<p>编译期异常：必须要解决 现在如果代码出现异常(现阶段直接try、catch)</p>
<p>try、catch、finally</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//可能会出现异常的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(要捕获的异常类型<span class="number">1</span> 变量名)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果出现对应异常所执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(要捕获的异常类型<span class="number">2</span> 变量名 )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果出现对应异常所执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//无论try、catch结构是否报错都会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>catch需要注意的点</p>
<ul>
<li>catch中捕获的异常类型必须要与出现异常的类型要一致(大于等于)，否则相当于没有处理异常</li>
<li>catch中的异常类型可以捕获多个,注意：捕获异常的顺序是从小到大</li>
<li>捕获异常的时候，可以捕获最大的异常Exception</li>
</ul>
<p>finally的特点</p>
<ul>
<li>无论代码是否出现异常，都会执行finally中的代码</li>
<li>一般在finally写释放资源的代码</li>
<li>如果方法中出现return关键字，finally依旧会执行（但是如果调用System.exit(0); 那么finally不会再执行）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果要对不同异常要做不同处理，则用这种形式</span></span><br><span class="line"><span class="comment">//        try</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            //try中放可能会出现错误的代码</span></span><br><span class="line"><span class="comment">//            String[] names = &#123;&quot;jack&quot;,&quot;rose&quot;&#125;;</span></span><br><span class="line"><span class="comment">//            System.out.println(names[3]);</span></span><br><span class="line"><span class="comment">//            String s = null;</span></span><br><span class="line"><span class="comment">//            System.out.println(s.length());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        catch (NullPointerException e)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            //一定一定记住!!!     无论如何要把错误信息打印出来</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();    //打印异常信息</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;当出现空指针异常的时候会执行这里代码&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        catch (ArrayIndexOutOfBoundsException e)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;出现数组下标越界异常的时候会执行这里代码&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;这里代码会执行么？？？&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不需要分别处理不同异常，则用这种形式</span></span><br><span class="line"><span class="comment">//        try</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            //try中放可能会出现错误的代码</span></span><br><span class="line"><span class="comment">//            String[] names = &#123;&quot;jack&quot;,&quot;rose&quot;&#125;;</span></span><br><span class="line"><span class="comment">//            System.out.println(names[3]);</span></span><br><span class="line"><span class="comment">//            String s = null;</span></span><br><span class="line"><span class="comment">//            System.out.println(s.length());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        //Exception:无论啥异常，都可以捕获那个最大异常</span></span><br><span class="line"><span class="comment">//        catch (Exception e)  //写异常时要从小异常写到大异常</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            //一定一定记住!!!     无论如何要把错误信息打印出来</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();    //打印异常信息</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;当出现异常的时候会执行这里代码&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;这里代码会执行么？？？&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//try中放可能会出现错误的代码</span></span><br><span class="line">            String[] names = &#123;<span class="string">&quot;jack&quot;</span>,<span class="string">&quot;rose&quot;</span>&#125;;</span><br><span class="line">            System.out.println(names[<span class="number">1</span>]);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            System.out.println(s.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//一定一定记住!!!     无论如何要把错误信息打印出来</span></span><br><span class="line">            e.printStackTrace();    <span class="comment">//打印异常信息</span></span><br><span class="line">            System.out.println(<span class="string">&quot;当出现异常的时候会执行这里代码&quot;</span>);</span><br><span class="line">            <span class="comment">//return; //finally执行</span></span><br><span class="line">            System.exit(<span class="number">0</span>); <span class="comment">//jvm结束，finally不会执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>     <span class="comment">//无论try、catch结构是否报错都会执行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//一般用于写释放资源的代码</span></span><br><span class="line">            System.out.println(<span class="string">&quot;这是finally中的代码&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;这里代码会执行么？？？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-抛出异常-被动处理-center"><center>抛出异常(被动处理)</center></h2>
<h3 id="方法上声明-throws">方法上声明 throws</h3>
<ul>
<li>当前无法对异常进行处理的时候，可以把异常抛给方法的调用者</li>
<li>如果异常声明在了main方法上，实际上就是给jvm处理(那就是没有处理)</li>
<li>声明异常可以声明多个</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> <span class="keyword">throws</span> 异常的类型<span class="number">1</span>,异常的类型<span class="number">2</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法内部抛出-throw">方法内部抛出 throw</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> 异常对象;</span><br></pre></td></tr></table></figure>
<p>特点:</p>
<ul>
<li>如果抛出运行期异常，那么直接抛出即可</li>
<li>如果抛出编译期异常，那么需要在方法上声明抛出</li>
</ul>
<p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用者需要处理这个异常</span></span><br><span class="line"><span class="comment">//        m1();   //如果调用者继续抛出，则这个异常没有处理</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;这个代码会执行么？？&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用者</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            m2(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;进入到首页&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;返回到登陆页面&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不知道怎么处理异常时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> <span class="keyword">throws</span> ParseException   <span class="comment">//抛出异常</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="comment">//快捷方式：alt+enter</span></span><br><span class="line">        sdf.parse(<span class="string">&quot;2022/03/29&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一些大型框架都是抛出，让调用者解决异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">(String username,String passward)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!username.equals(<span class="string">&quot;admin&quot;</span>) || !passward.equals(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//主动抛出异常</span></span><br><span class="line">            <span class="comment">//语法：throw 异常对象</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;用户或密码错误&quot;</span>); <span class="comment">//编译期异常</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-自定义异常-center"><center>自定义异常</center></h2>
<p>一般在系统的异常无法满足自己公司需求的时候会自定义异常</p>
<p>自定义异常一般和throw抛出一起配合使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsernameAndPasswardException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> <span class="comment">//编译期异常</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//构造一个无参和一个参数的函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UsernameAndPasswardException</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>();    <span class="comment">//调用父类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UsernameAndPasswardException</span><span class="params">(String message)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用者</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            m2(<span class="string">&quot;adm&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;进入到首页&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;返回到登陆页面&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">(String username,String passward)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!username.equals(<span class="string">&quot;admin&quot;</span>) || !passward.equals(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//主动抛出异常</span></span><br><span class="line">            <span class="comment">//语法：throw 异常对象</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameAndPasswardException</span>(<span class="string">&quot;用户或密码错误&quot;</span>); <span class="comment">//编译期异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承中方法的重写</p>
<p>    子类重写父类的方法，不能抛出比父类更大、更多的编译器异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> ParseException</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子类不能抛出父类更多更大的编译期异常</span></span><br><span class="line"><span class="comment">     * 子类抛出的异常不能比父类的大，且抛出异常的个数不能超过父类抛出异常的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> ParseException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyy-MM-dd&quot;</span>);</span><br><span class="line">        sdf.parse(<span class="string">&quot;2022-03-23&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>File类</center></h1>
<p>表示操作系统磁盘上的文件或者是文件夹</p>
<p>路径：</p>
<p>    相对路径 （相对于当前工程的跟路径）</p>
<p>    绝对路径 (在磁盘上的完整路径)</p>
<h2 id="对象的创建">对象的创建</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建File对象</span></span><br><span class="line">        <span class="comment">//参数：文件或文件夹路径(绝对路径)，第一种构建方式</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\a.txt&quot;</span>); <span class="comment">//表示的是一个文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\zz&quot;</span>);    <span class="comment">//表示的是文件夹</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种构建方式</span></span><br><span class="line">        <span class="comment">//参数1：父目录的路径(字符串) 参数2：子目录的路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span>,<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三种构建方式</span></span><br><span class="line">        <span class="comment">//参数1：父目录(file对象) 参数2：子目录路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file2,<span class="string">&quot;c.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//参数:文件或者文件夹(相对路径:相对于当前工程)</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常见方法">常见方法</h2>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">createNewFile()</td>
<td style="text-align:center">创建一个新文件</td>
</tr>
<tr>
<td style="text-align:center">mkdir()</td>
<td style="text-align:center">创建一个新目录。如果父目录不存在，则无法创建</td>
</tr>
<tr>
<td style="text-align:center">mkdirs()</td>
<td style="text-align:center">创建一个新目录。如果父目录不存在，则一起创建</td>
</tr>
<tr>
<td style="text-align:center">delete()</td>
<td style="text-align:center">删除文件或空目录</td>
</tr>
<tr>
<td style="text-align:center">exists()</td>
<td style="text-align:center">判断File对象所对象所代表的对象是否存在</td>
</tr>
<tr>
<td style="text-align:center">length()</td>
<td style="text-align:center">获取文件(夹)的大小(字节)</td>
</tr>
<tr>
<td style="text-align:center">getAbsolutePath()</td>
<td style="text-align:center">获取文件的绝对路径</td>
</tr>
<tr>
<td style="text-align:center">getAbsoluteFile()</td>
<td style="text-align:center">获取文件(夹)的绝对路径:（返回File）</td>
</tr>
<tr>
<td style="text-align:center">getName()</td>
<td style="text-align:center">获取当前file对象的文件名或者是文件夹名</td>
</tr>
<tr>
<td style="text-align:center">getParent()</td>
<td style="text-align:center">获取当前file对象的父目录（返回String）</td>
</tr>
<tr>
<td style="text-align:center">isDirectory()</td>
<td style="text-align:center">是否是目录</td>
</tr>
<tr>
<td style="text-align:center">isFile()</td>
<td style="text-align:center">是否是文件</td>
</tr>
<tr>
<td style="text-align:center">getPath()</td>
<td style="text-align:center">获取文件(夹)的相对路径:（返回String）</td>
</tr>
<tr>
<td style="text-align:center">listFiles()</td>
<td style="text-align:center">列出目录中的所有内容</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建文件</span></span><br><span class="line"><span class="comment">//        File file = new File(&quot;a.txt&quot;);</span></span><br><span class="line"><span class="comment">//        try</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            //创建文件</span></span><br><span class="line"><span class="comment">//            file.createNewFile();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        catch (IOException e)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建文件夹</span></span><br><span class="line">        <span class="comment">//mkdirs(); 如果父目录不存在连同父目录一起创建</span></span><br><span class="line">        <span class="comment">//mkdir();  如果父目录不存在则创建不成功</span></span><br><span class="line"><span class="comment">//        File file = new File(&quot;d:\\zz&quot;);</span></span><br><span class="line"><span class="comment">//        file.mkdirs();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//在创建文件或者文件夹的时候，先判断文件或者文件夹是否存在</span></span><br><span class="line"><span class="comment">//        File file = new File(&quot;d:\\zz\\aa&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(file.exists());</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        File file = new File(&quot;d:\\z\\aa&quot;);  //文件</span></span><br><span class="line"><span class="comment">//        //判断是否是文件</span></span><br><span class="line"><span class="comment">//        System.out.println(file.isFile());</span></span><br><span class="line"><span class="comment">//        //判断是否是文件夹</span></span><br><span class="line"><span class="comment">//        System.out.println(file.isDirectory());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//File file = new File(&quot;a.txt&quot;);</span></span><br><span class="line">        <span class="comment">//获取文件的绝对路径</span></span><br><span class="line"><span class="comment">//        System.out.println(file.getAbsolutePath()); //返回类型：String</span></span><br><span class="line"><span class="comment">//        System.out.println(file.getAbsoluteFile()); //返回类型：File</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取文件的父目录  如果写的是相对路径，则会按照相对路径去找父目录</span></span><br><span class="line"><span class="comment">//        System.out.println(file.getParent());</span></span><br><span class="line"><span class="comment">//        System.out.println(file.getParentFile());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除文件</span></span><br><span class="line">        <span class="comment">//如果file对象是一个文件则可以删除</span></span><br><span class="line">        <span class="comment">//如果file对象是一个空文件夹则可以删除，但是如果文件夹中有内容则无法删除</span></span><br><span class="line">        <span class="comment">//System.out.println(file.delete());  //成功返回true，失败返回false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取文件或文件夹的名称</span></span><br><span class="line">        <span class="comment">//System.out.println(file.getName());</span></span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\zz&quot;</span>);</span><br><span class="line">        <span class="comment">//获取当前文件夹下所有的文件或者文件夹名称</span></span><br><span class="line">        String[] a = file.list();</span><br><span class="line">        <span class="keyword">for</span> (String s : a)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java语言</category>
      </categories>
      <tags>
        <tag>Java语言</tag>
      </tags>
  </entry>
  <entry>
    <title>4.常用工具类</title>
    <url>/post/a920af81.html</url>
    <content><![CDATA[<h1><center>String类</center></h1>
<h3 id="center-string的创建-center"><center>String的创建</center></h3>
<h3 id="直接赋值">直接赋值</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">System.out.println(s1);</span><br></pre></td></tr></table></figure>
<h3 id="通过构造方法">通过构造方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//String s2 = new String();   //相当于String s2 = &quot;&quot;;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;123&quot;</span>);  <span class="comment">//相当于String s2 = &quot;123&quot;;</span></span><br><span class="line">System.out.println(s2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.将一个byte类型数组作为数据参数传递到字符串中进行存储</span></span><br><span class="line"><span class="comment">//ps:将byte数组中数据转换成对应ASCII码---》如果ASCII码范围就会转换为Unicode【万国码】</span></span><br><span class="line"><span class="comment">//Unicode对应中国文字编码 ---》 UTF-8</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;str2 = &quot;</span>+str2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.将一个char类型数组作为数据参数传递到字符串中进行存储</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;str3 = &quot;</span>+str3)</span><br></pre></td></tr></table></figure>
<h3 id="通过字节数组创建对象">通过字节数组创建对象</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> b [] = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b,<span class="number">0</span>,<span class="number">3</span>);  <span class="comment">//括号里的参数 第一个数组名 第二个从数组中的起始位置 第三个获取的长度</span></span><br><span class="line">System.out.println(s3);</span><br></pre></td></tr></table></figure>
<h3 id="通过字符数组创建对象">通过字符数组创建对象</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c [] = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">System.out.println(s4);</span><br></pre></td></tr></table></figure>
<h2 id="center-string类常用方法-center"><center>String类常用方法</center></h2>
<h3 id="获取方法">获取方法</h3>
<h4 id="获取字符">获取字符</h4>
<p>获取字符串中指定下标对应的字符，返回值为char类型<br>
语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名.charAt(下标);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">sh</span> <span class="operator">=</span> str.charAt(<span class="number">1</span>);</span><br><span class="line">System.out.println(sh);</span><br></pre></td></tr></table></figure>
<h4 id="获取下标">获取下标</h4>
<p>获取字符串中指定字符串对应的下标，返回值为int类型</p>
<p>如果有相同的字符串，那么返回值是第一个字符串对应的下标</p>
<p>如果没有指定字符串，那么返回-1</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组名.indexOf(<span class="string">&quot;要指定的字符串&quot;</span>);		从前往后找指定的字符串</span><br><span class="line">数组名.lastIndexOf(<span class="string">&quot;要指定的字符串&quot;</span>);	从后往前找指定的字符串</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取下标</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;asdfrgx&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> str1.indexOf(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"><span class="comment">//如果没有指定字符则返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> str1.indexOf(<span class="string">&quot;re&quot;</span>);</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br><span class="line"><span class="comment">//如果有相同的，取出最后面一个下标</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;abc,Java,de,Java,ga&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> str2.lastIndexOf(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">System.out.println(c);</span><br><span class="line"><span class="comment">//提供一个重载方法，在指定下标位置开始向后查找 ，包含指定位置</span></span><br><span class="line"><span class="comment">//只会返回第一次遇到该字符的位置 ，如果找不到就负数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> str5.indexOf(<span class="string">&#x27;f&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(f);</span><br></pre></td></tr></table></figure>
<h4 id="获取字符串长度">获取字符串长度</h4>
<p>返回值为int类型</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组名.length();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取字符串长度</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> str3.length();</span><br><span class="line"><span class="comment">//System.out.println(str3.length());</span></span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></table></figure>
<h3 id="判断的方法">判断的方法</h3>
<p>返回值都是boolean类型</p>
<p>判断两个字符串是否相等（<strong>区分大小写</strong>）</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组名<span class="number">1.</span>equals(数组名<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>判断两个字符串是否相等（<strong>不区分大小写</strong>）</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组名<span class="number">1.</span>equalsIgnoreCase(数组名<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断两个字符串是否相等</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Abc&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">a</span> <span class="operator">=</span> str1.equals(str2);  <span class="comment">//区分大小写</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> str1.equalsIgnoreCase(str2); <span class="comment">//不区分大小写</span></span><br><span class="line"><span class="comment">//System.out.println(str1.equals(str2));</span></span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure>
<h4 id="比较字符串大小">比较字符串大小</h4>
<p>逐一对比两个字符串中对应位置的字符，并进行差值计算得到结果就是一个整数</p>
<p>    结果 &gt; 0 当前字符串就大于传入字符串</p>
<p>    结果 == 0 当前字符串就等于传入字符串</p>
<p>    结果 &lt; 0 当前字符串就小于传入字符串</p>
<p>调用方法字符串是 当前字符串 参数赋值字符串是 传入字符</p>
<p>只要有任何一对字符比较结果出现 &gt;0 或 &lt;0 的时候就返回结果值，否则就继续比较所有字符，直到一个字符为止</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str1_1</span> <span class="operator">=</span> <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> str1.compareTo(str1_1);</span><br><span class="line">System.out.println(i);    <span class="comment">//结果是32大于0 就证明str1 大于str1_1</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">String str2 = &quot;你&quot;;</span></span><br><span class="line"><span class="comment">String str2_1 = &quot;您&quot;;</span></span><br><span class="line"><span class="comment">int i1 = str2.compareTo(str2_1);</span></span><br><span class="line"><span class="comment">System.out.println(i1);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="判断字符串是否以指定的字符串开头或结尾">判断字符串是否以指定的字符串开头或结尾</h4>
<p>开头</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组名.startsWith(<span class="string">&quot;指定的字符串&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;18660416463&quot;</span>;</span><br><span class="line">System.out.println(str.startsWith(<span class="string">&quot;186&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>结尾</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组名.endsWith(<span class="string">&quot;指定的字符串&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;hello.java&quot;</span>;</span><br><span class="line">System.out.println(str3.endsWith(<span class="string">&quot;.java&quot;</span>));</span><br></pre></td></tr></table></figure>
<h4 id="判断字符串中是否包含指定的字符串">判断字符串中是否包含指定的字符串</h4>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组名.contains(<span class="string">&quot;指定的字符串&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断字符串中是否包含指定的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;java,WC&quot;</span>;</span><br><span class="line">System.out.println(str4.contains(<span class="string">&quot;WC&quot;</span>));</span><br></pre></td></tr></table></figure>
<h4 id="判断字符串是否为空">判断字符串是否为空</h4>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组名.isEmpty();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断字符串是否为空，长度是否为零</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot; &quot;</span>;  <span class="comment">//里面有空格，不为空</span></span><br><span class="line">System.out.println(str5.isEmpty());</span><br></pre></td></tr></table></figure>
<h3 id="拼接方法">拼接方法</h3>
<h4 id="字符串拼接方法">字符串拼接方法</h4>
<p>使用 + 进行拼接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;hello &quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3_1</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="comment">//得到一个全新的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> str3 + str3_1;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>
<p>concat 方法参数是要字符串,返回一个全新字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因为方法返回的是一个全新字符串对象，所以可以继续的进行调用拼接</span></span><br><span class="line"><span class="type">String</span> <span class="variable">concat</span> <span class="operator">=</span> str3.concat(str3_1).concat(<span class="string">&quot;Java is &quot;</span>).concat(<span class="string">&quot;NO.1&quot;</span>);</span><br><span class="line">System.out.println(concat);</span><br></pre></td></tr></table></figure>
<h4 id="自定义拼接字符串">自定义拼接字符串</h4>
<p>自定义拼接字符串方式【格式化字符串】 —》 静态方法</p>
<p>String.format</p>
<p>第一个参数是格式控制符 --》 %d 代表整数 %f 代表小数 %s代表字符串 %c代表字符</p>
<p>第二个参数是与格式化控制符与之对应的数据【一一对应】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> String.format(<span class="string">&quot;%f%s%c&quot;</span>, <span class="number">12.345</span>, <span class="string">&quot;字符串&quot;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">System.out.println(format);</span><br><span class="line"><span class="comment">//Java中如何让小数保留小数点后几位 --》 使用使用%f 进行 %.几f ---》.几就是保留几位</span></span><br><span class="line"><span class="comment">//保留小数点后两位【支持四舍五入】</span></span><br><span class="line"><span class="type">String</span> <span class="variable">format1</span> <span class="operator">=</span> String.format(<span class="string">&quot;%.2f&quot;</span>, <span class="number">12.345</span>);</span><br><span class="line">System.out.println(format1);</span><br><span class="line"><span class="comment">//打印整数时候进行补位操作 ---》使用%d 进行 %0几d --》 不足几位就补几个0</span></span><br><span class="line"><span class="comment">//不足2位补0</span></span><br><span class="line"><span class="type">String</span> <span class="variable">format2</span> <span class="operator">=</span> String.format(<span class="string">&quot;%02d&quot;</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(format2);</span><br></pre></td></tr></table></figure>
<h3 id="其他方法">其他方法</h3>
<h4 id="字符串变成字节数组">字符串变成字节数组</h4>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组名.getBytes();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将字符串变成字节数组</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">byte</span> a [] = str.getBytes();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符串变成字符数组">字符串变成字符数组</h4>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组名.toCharArray();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> ch [] = str1.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ch.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(ch[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="取出指定的字符串">取出指定的字符串</h4>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组名.substring(起始下标,结束下标);</span><br></pre></td></tr></table></figure>
<p>注意：String是一个字符串常量，一旦定义不能改变，一定要重新赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取出指定的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;hello,java!!!&quot;</span>;</span><br><span class="line"><span class="comment">//参数1：起始下标 参数2：结束下标</span></span><br><span class="line">str2 = str2.substring(<span class="number">6</span>,<span class="number">10</span>);  <span class="comment">//在Java中区范围都是 左边闭区间，右边开区间</span></span><br><span class="line">System.out.println(str2);</span><br></pre></td></tr></table></figure>
<h4 id="字符串中指定的部分字符串改成指定的字符串">字符串中指定的部分字符串改成指定的字符串</h4>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组名.replace(<span class="string">&quot;原数组中指定的要更改的字符串&quot;</span>,<span class="string">&quot;新的字符串&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>注意：String是一个字符串常量，一旦定义不能改变，一定要重新赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将指定的字符串改成指定的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;hello,SB&quot;</span>;</span><br><span class="line">str3 = str3.replace(<span class="string">&quot;SB&quot;</span>,<span class="string">&quot;**&quot;</span>);</span><br><span class="line">System.out.println(str3);</span><br></pre></td></tr></table></figure>
<h4 id="按指定格式将字符串切割">按指定格式将字符串切割</h4>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组名.split(<span class="string">&quot;切割的格式&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;jack lin lida hdnpi&quot;</span>;</span><br><span class="line">String s [] = str4.split(<span class="string">&quot; &quot;</span>); <span class="comment">//按空格进行切割，切割完是一个字符串数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(s[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="将字符串中的字母变成大写">将字符串中的字母变成大写</h4>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组名.toUpperCase();</span><br></pre></td></tr></table></figure>
<p>返回值为String类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str6</span> <span class="operator">=</span> <span class="string">&quot;ABC好&quot;</span>;</span><br><span class="line">System.out.println(str6.toLowerCase());</span><br></pre></td></tr></table></figure>
<h4 id="去除字符串中前后的空格">去除字符串中前后的空格</h4>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组名.trim();</span><br></pre></td></tr></table></figure>
<p>注意：String是一个字符串常量，一旦定义不能改变，一定要重新赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str7</span> <span class="operator">=</span> <span class="string">&quot;hello java&quot;</span>;</span><br><span class="line">str7 = str7.trim();    <span class="comment">//str7指向了新的地址</span></span><br><span class="line">System.out.println(str7);</span><br></pre></td></tr></table></figure>
<h4 id="将其他类型数据转换成string类型数据">将其他类型数据转换成String类型数据</h4>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String.valueOf(变量名);</span><br></pre></td></tr></table></figure>
<p>返回值为String类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str8</span> <span class="operator">=</span> String.valueOf(d);</span><br><span class="line">System.out.println(str8);</span><br></pre></td></tr></table></figure>
<p>方式二</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str9</span> <span class="operator">=</span> c + <span class="string">&quot;&quot;</span>;    <span class="comment">//自动转化成String类型</span></span><br><span class="line">System.out.println(str9);</span><br></pre></td></tr></table></figure>
<h2 id="center-正则表达式-center"><center>正则表达式</center></h2>
<p>    正则表达式是一个特殊字符串，可以根据正则表达式的语法规则构建一个字符串，利用这个字符串就可以验证其他字符串是否合法</p>
<p>    正则表达式其实就是提供字符串中内容约束，通过正则表达式就可以验证输入字符串是否满足指定需求。</p>
<p>例如： 注册页面—》用户名验证、密码验证、邮箱验证、手机号码验证等等</p>
<p>需求：在控制台上输入一个QQ 号码需要对QQ号码进行如下验证</p>
<p>    QQ号码必须满足5~15之间、而且必须全部是数字、首位数字不可以是0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QQMatches</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        需求:在控制台上输入一个QQ 号码需要对QQ号码进行如下验证</span></span><br><span class="line"><span class="comment">            QQ号码必须满足5~15之间、而且必须全部是数字、首位数字不可以是0</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//1.在控制台上获取字符串</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//2.提供获取控制台数据操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入QQ号码：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">qq</span> <span class="operator">=</span> input.nextLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;您输入的QQ是否合法?（true【合法】/false【不合法】）&quot;</span>+checkQQ(qq));</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkQQ</span><span class="params">(String qq)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.需要QQ号是5~15位之间【只要不在5~15之间就是不合法的】</span></span><br><span class="line">        <span class="keyword">if</span>(qq.length() &lt; <span class="number">5</span> || qq.length() &gt; <span class="number">15</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//2.需要QQ号码是全数字【只要输入有不是数字的就不合法】</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span> ; i&lt;qq.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(qq.charAt(i) &lt; <span class="string">&#x27;0&#x27;</span> || qq.charAt(i) &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//3.首位不可以是数字0</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> qq.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//证明通过验证</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在验证QQ号码时需要提供复杂的逻辑判断，但是如果使用正则表达式就可以简化这个操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkQQ2</span><span class="params">(String qq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1。根据需求提供验证输入QQ号码的正则表达式</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;[1-9]\\d&#123;4,14&#125;&quot;</span>;<span class="comment">// --》正则表达式</span></span><br><span class="line">    <span class="keyword">return</span> qq.matches(regex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>    正则表达式就是一个以特殊符号组合而成一个字符串，用这个字符串可以验证其他字符串是否合法【满足规则】即正则表达式其实就是一个匹配规则，用来替代验证字符串复杂的if结构判断</p>
<p><strong>    在String类中提供一个方法matches，这个方法是用于接收一个正则表达式的字符串，验证调用方法的字符串是否满足正则表达式的条件，如果满足条件则返回true，否则返回false</strong></p>
<h3 id="正则表达式的基本使用">正则表达式的基本使用</h3>
<p>    提供一个语法规则： 使用[]中括号 匹配单个字符 --》在中括号中可以使用 【^ 取反 和 - 范围】就可以组合成如下效果：</p>
<p>    <strong>1. [abc]代表a、或者b、或者c字符中任何一个</strong></p>
<p><strong>    2. [ ^abc] 代表除a、b、c以为任意字符</strong></p>
<p><strong>    3. [a-z] 代表a-z之间所有的小写字符中任意一个</strong></p>
<p>    <strong>4. [A-Z] 代表A-Z之间所有的大写字符中任意一个</strong></p>
<p><strong>    5.[0-9] 代表0-9之间所有数字中任意一个</strong></p>
<p>    <strong>6.[a-zA-Z0-9] 代表a~z之间、A~Z之间、0-9之间任意一个字符</strong></p>
<p>    <strong>自定义范围[a-dm-p]代表 a~d之间 m~p之间的任意一个字符</strong></p>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexDemo1</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="comment">//不可以这样验证，这样是错误</span></span><br><span class="line">        System.out.println(str.matches(<span class="string">&quot;[abc]&quot;</span>));<span class="comment">//false判断某一个不是所有</span></span><br><span class="line">        <span class="comment">//这样操作是对的</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        System.out.println(str1.matches(<span class="string">&quot;[abc]&quot;</span>));<span class="comment">//true判断的是某一个字符</span></span><br><span class="line">        <span class="comment">//1.验证某个字符串是否以h开头，以d结尾。中间是[a、e、i、o、u]中的某个字符</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ead&quot;</span>.matches(<span class="string">&quot;h[aeiou]d&quot;</span>));<span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hed&quot;</span>.matches(<span class="string">&quot;h[aeiou]d&quot;</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;head&quot;</span>.matches(<span class="string">&quot;h[aeiou]d&quot;</span>));<span class="comment">//false</span></span><br><span class="line">        <span class="comment">//2.验证某个字符串是否以a-z的任何一个小写字母开头，后缀ad</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Aad&quot;</span>.matches(<span class="string">&quot;[a-z]ad&quot;</span>)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;aad&quot;</span>.matches(<span class="string">&quot;[a-z]ad&quot;</span>));<span class="comment">// true</span></span><br><span class="line">        <span class="comment">//3.验证某个字符串是否以a-d或者m-p之间某个字符靠头，后缀ad</span></span><br><span class="line">        System.out.println(<span class="string">&quot;nad&quot;</span>.matches(<span class="string">&quot;[a-dm-p]ad&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Mad&quot;</span>.matches(<span class="string">&quot;[a-dm-p]ad&quot;</span>));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式之逻辑运算符">正则表达式之逻辑运算符</h3>
<p>可以在上面语法中增加逻辑运算符 ，正则表达式中逻辑运算符有【&amp;&amp;并且 、 | 或者】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexDemo2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//需求：判断某个字符串是小写辅音字母开头，后跟ab，剩余字母除aeiou之外，其他辅音字母</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>.matches(<span class="string">&quot;[aeiou]ab[^aeiou]&quot;</span>));</span><br><span class="line">        <span class="comment">//需求：开头字母必须是a-z之间小写字母并且不在aeiou中</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>.matches(<span class="string">&quot;[a-z&amp;&amp;[^aeiou]]&quot;</span>));</span><br><span class="line">        <span class="comment">//[]这个语法是存在或者含义 ---》[abc] --》得到结果是a或b或c中一个</span></span><br><span class="line">        <span class="comment">//需求：要求字符串首字母必须是aeiou中任意一个，后面ad</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>.matches(<span class="string">&quot;[aeiou]ad&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>.matches(<span class="string">&quot;[a|e|i|o|u]ad&quot;</span>)); <span class="comment">//能表明含义</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正在表达式之预定义字符-需要记住">正在表达式之预定义字符【需要记住】</h3>
<table>
<thead>
<tr>
<th style="text-align:center">“\d” 任何数字[0-9]的简写</th>
<th style="text-align:center">\s 任意空白字符[\t\n\x)B\f\r]简写</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">“\w单词字符[a-zA-Z0-9]简写”</td>
<td style="text-align:center">“\D” 任何非数字[ ^0-9]的简写</td>
</tr>
<tr>
<td style="text-align:center">\S 非空白字符 [ ^\s]简写</td>
<td style="text-align:center">“\W 非单词字符[\w]简写”</td>
</tr>
</tbody>
</table>
<p>特殊说明</p>
<ol>
<li>Java中单个 【\】代表的是转移字符 即 本身字母d是没有任何含义 配合使用 【\】就代表数字了，我们不能直接在字符串中使用 \d的形式 需要将\体现出来让 \d成为一个整体 而不是使用 \ 去转义d —》就需要使用到【\】 --》 即需使用【\d】</li>
<li>“.” 点在正则表达式中代表任意字符，如果必要表示一个字符点，那么需要使用【\.】</li>
</ol>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexDemo3</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;判断9是否是数字：&quot;</span>+(<span class="string">&quot;9&quot;</span>.matches(<span class="string">&quot;[0-9]&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;判断9是否是数字：&quot;</span>+(<span class="string">&quot;9&quot;</span>.matches(<span class="string">&quot;\\d&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;判断258是否是数字：&quot;</span>+(<span class="string">&quot;258&quot;</span>.matches(<span class="string">&quot;[0-9][0-9][0-9]&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;判断258是否是数字：&quot;</span>+(<span class="string">&quot;258&quot;</span>.matches(<span class="string">&quot;\\d\\d\\d&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;判断字符串是否满足内容需求【h.d】&quot;</span>+ (<span class="string">&quot;h.d&quot;</span>.matches(<span class="string">&quot;h\\.d&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;判断字符串是以h开头中间任意字符并且以d结尾&quot;</span>+ (<span class="string">&quot;h%d&quot;</span>.matches(<span class="string">&quot;h.d&quot;</span>)));</span><br><span class="line">        <span class="comment">//需求：--》 验证输入手机号是合法</span></span><br><span class="line">        <span class="comment">//手机号一般是由11位组成 ---》可以提供一个简单版本正则表达式---》提供 11个\\d</span></span><br><span class="line">        <span class="comment">//手机号第一位是1组成，第二位是由一定范围变换，除此之外剩余就是简单数字</span></span><br><span class="line">        System.out.println(<span class="string">&quot;13888888888&quot;</span>.matches(<span class="string">&quot;1[3|4|5|6|7|8|9]\\d\\d\\d\\d\\d\\d\\d\\d\\d&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式之数量词">正则表达式之数量词</h3>
<p>    正则表达式中的数量词其实就是指定正则表达式出现的次数 --》X【代表单个正则表达式的条件</p>
<p>或者 可以代表组】</p>
<p>    <strong>X?：0次或1次 —》 \d? --》代表当前数字可以出现0次或1次</strong></p>
<p><strong>    X*：0次或多次 --》 \d* --》 代表当前数字可以出现0次或多次</strong></p>
<p><strong>    X+：1次或多次 --》\d+ --》 代表当前数字可以出现1次或多次</strong></p>
<p>    <strong>X{n}：正好n次–》\d{9} --》 代表当前数字可以出现9次</strong></p>
<p><strong>    X{n,}：至少n次(包含n) --》 \d{9,} --》 代表当前数字至少出现9次或多次</strong></p>
<p>    <strong>X{n，m}：至少n次~m次(n和m都是包含) --》 \d{4,14} --》代表当前数字出现4~14次</strong></p>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexDemo4</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;258&quot;</span>;</span><br><span class="line">        <span class="comment">//验证str是否满足3位数字</span></span><br><span class="line">        System.out.println(str.matches(<span class="string">&quot;[0-9]&#123;3&#125;&quot;</span>));</span><br><span class="line">        System.out.println(str.matches(<span class="string">&quot;\\d&#123;3&#125;&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;a58&quot;</span>.matches(<span class="string">&quot;\\d&#123;3&#125;&quot;</span>));<span class="comment">//false</span></span><br><span class="line">        System.out.println(str.matches(<span class="string">&quot;\\d+&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(str.matches(<span class="string">&quot;\\d?&quot;</span>)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(str.matches(<span class="string">&quot;\\d*&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(str.matches(<span class="string">&quot;\\d&#123;3,&#125;&quot;</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(str.matches(<span class="string">&quot;\\d&#123;3,13&#125;&quot;</span>));<span class="comment">//true</span></span><br><span class="line">        <span class="comment">//需求：--》 验证输入手机号是合法</span></span><br><span class="line">        <span class="comment">//手机号一般是由11位组成 ---》可以提供一个简单版本正则表达式---》提供 11个\\d</span></span><br><span class="line">        <span class="comment">//手机号第一位是1组成，第二位是由一定范围变换，除此之外剩余就是简单数字</span></span><br><span class="line">        System.out.println(<span class="string">&quot;13888888888&quot;</span>.matches(<span class="string">&quot;1[3|4|5|6|7|8|9]\\d\\d\\d\\d\\d\\d\\d\\d\\d&quot;</span>));</span><br><span class="line">        <span class="comment">//修改</span></span><br><span class="line">        System.out.println(<span class="string">&quot;13888888888&quot;</span>.matches(<span class="string">&quot;1[3|4|5|6|7|8|9]\\d&#123;9&#125;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式值组">正则表达式值组</h3>
<p><strong>组的出现可以将条件统一化，将多个条件捆绑到一起 —》 小括号()</strong></p>
<p>需求：提供一个字符串写出对应的正则表达式 --》“d0a3911a-a8e9-4e5e-b9e7-c2c53324d50d”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexDemo5</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">//String str = &quot;d0a3911a-a8e9-4e5e-b9e7-c2c53324d50d&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;[a-z0-9]&#123;8&#125;-[a-z0-9]&#123;4&#125;-[a-z0-9]&#123;4&#125;-[a-z0-9]&#123;4&#125;-[a-z0-9]&#123;12&#125;&quot;</span>;</span><br><span class="line">        <span class="comment">//可以将上述正则表达式进行组的划分</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regex2</span> <span class="operator">=</span> <span class="string">&quot;([a-z0-9]&#123;8&#125;)(-[a-z0-9]&#123;4&#125;)&#123;3&#125;(-[a-z0-9]&#123;12&#125;)&quot;</span>;</span><br><span class="line">        System.out.println(str.matches(regex2));</span><br><span class="line">        <span class="comment">//呵呵嘿嘿哈哈--》提供正则表达式与之匹配 ---》 点【.】可以匹配任意字符</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;呵呵嘿嘿哈哈&quot;</span>;</span><br><span class="line">        System.out.println(str2.matches(<span class="string">&quot;(.)&#123;2&#125;(.)&#123;2&#125;(.)&#123;2&#125;&quot;</span>));</span><br><span class="line">        System.out.println(str2.matches(<span class="string">&quot;((.)&#123;2&#125;)&#123;3&#125;&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;呵呵&quot;</span>;</span><br><span class="line">        System.out.println(str3.matches(<span class="string">&quot;(.)&#123;2&#125;&quot;</span>));</span><br><span class="line">        <span class="comment">//(.)代表第一组【一组条件】 \\1表示第一组在出现一次(.)\\1--》(.)(.)</span></span><br><span class="line">        System.out.println(str3.matches(<span class="string">&quot;(.)\\1&quot;</span>));</span><br><span class="line">        <span class="comment">//如何修改(.)\\2第二组的(.)在出现一次 (.)\\3第三组的(.)在出现一次</span></span><br><span class="line">        System.out.println(str2.matches(<span class="string">&quot;(.)\\1(.)\\2(.)\\3&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;高兴高兴&quot;</span>.matches(<span class="string">&quot;(..)\\1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271928546.WebP" alt="转义符"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271929293.WebP" alt="数量表示"></p>
<p>String类中匹配正则表达式作为参数方法一共有三个【常用】</p>
<p>    matches()方法：根据方法的参数进行对字符串匹配操作，满足条件范围true，不满足返回false</p>
<p>    split()方法:【拆分、切分、分割】字符串，根据参数中指定条件进行字符串拆分操作</p>
<p>    replaceAll()方法: 根据方法中第一个参数的正则表达式条件，替换字符串中指定内容【替换的内容是第二个参数】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexDemo6</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//验证字符串是否合法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">phoneNumber</span> <span class="operator">=</span> <span class="string">&quot;13112345678&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;1[3|4|5|6|7|8|9]\\d&#123;9&#125;&quot;</span>;</span><br><span class="line">        System.out.println(phoneNumber.matches(regex));</span><br><span class="line">        <span class="comment">//根据条件进行字符串拆分，将拆分结果存储到一个String类型数组中并返回</span></span><br><span class="line">        <span class="comment">//这个方法比较常用，但是拆分不一定非要是正则表达式，只要满足拆条情况都是可以</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> <span class="string">&quot;20:39:49&quot;</span>;</span><br><span class="line">        <span class="comment">//获取时间中 小时、分钟和秒</span></span><br><span class="line">        String[] split = time.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String t : split)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//这个方法主要是用于批量字符串替换，它是需要第一个参数提供正则条件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;43eh5hj34l4h23jh4233h42oru3ohfh3rihf3hf3hgf4568632485rewh34&quot;</span>;</span><br><span class="line">        <span class="comment">//需求：将字符串中所有的数字都替换成*</span></span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i= <span class="number">0</span>; i&lt;chars.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(chars[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                chars[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> str.replaceAll(<span class="string">&quot;\\d+&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-string的内存分配-center"><center>String的内存分配</center></h2>
<p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271929031.WebP" alt="String的内存分配"></p>
<p>PS：字符串是引用类型，所以比较时候依旧使用equals进行比较内容，不要因为有池机制在就是用 == 进行比较，受众面比较小</p>
<h2 id="center-stringbuffer-stringbuilder类-center"><center>StringBuffer、StringBuilder类</center></h2>
<p>    String这个字符串是一个不可变字符串，不可以修改String中存储的内容，所以当我们调用大部分String方法的时候都会得到一个新String字符串</p>
<p>    Java中提供两个可变的字符串StringBuffer和StringBuilder，这两字符串创建之后，任何的修改都会对字符串内容提供修改操作即直接修改字符串内容</p>
<p>    PS：StringBuffer和StringBuilder本质上并不是字符串，它属于一个字符串“构建器”，允许将String中内容存储到这个“构建器”，进行修改从而得到修改之后的效果</p>
<p>    StringBuffer和StringBuilder都可以提供对字符串操作，并且两个类API是完全相同的，</p>
<p>    StringBuffer是线程安全【在多线程操作前提下可以保证字符串操作的正确性】但是效率低，</p>
<p>    StringBuilder是线程不安全【在多线程操作前提下不可以保证字符串操作正确】但是效率高，大多数的情况下都是使用【单线程】在进行编程，所以建议优先使用StringBuilder，如果遇到多线程操作字符串时在修改为StringBuffer使用即可</p>
<p>StringBuffer的对象创建及常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderAPIDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.StringBuffer和StringBuilder本身并不是字符串，所以不可以使用String直接赋值方式进行创建</span></span><br><span class="line">        <span class="comment">//StringBuilder bs = &quot;abc&quot;;</span></span><br><span class="line">        <span class="comment">//2.需要使用StringBuilder的构造方法来创建StringBuilder对象进行字符串操作者处理</span></span><br><span class="line">        <span class="comment">//2.1 创建一个空的StringBuilder对象【没有存储任何字符串内容】</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            通过观察可以发现在调用StringBuilder无参构造创建StringBuilder对象是 会调用父类有参</span></span><br><span class="line"><span class="comment">            构造方法</span></span><br><span class="line"><span class="comment">            执行 value = new char[capacity];构建一个字符数组作为存储数据的依据</span></span><br><span class="line"><span class="comment">            capacity的值是 --》默认值为 16</span></span><br><span class="line"><span class="comment">            ---》在创建空的StringBuilder对象时，创建一个初始容量为16的字符数组进行数据存储操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">bs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            面试问题：在创建StringBuilder对象是默认会初始化一个大小为16的字节数组作为存储数据的方式</span></span><br><span class="line"><span class="comment">            那么如果存储数据超过16时，是否可以正常的存储数据值，还是截取多余数据值仅保留16个字符？</span></span><br><span class="line"><span class="comment">            答案：StringBuilder是可以正常存储数据的，为什么可以存储？</span></span><br><span class="line"><span class="comment">            就是因为StringBuilder的底层存储过程中会对value这个数组进行“动态扩容操作”，</span></span><br><span class="line"><span class="comment">            当到某个临街值的时候</span></span><br><span class="line"><span class="comment">            执行Arrays.copyOf这个方法将原来value中数据赋值到新创建的数组中，并且将新数据引用赋值给value</span></span><br><span class="line"><span class="comment">            这样一来给外界开发人员造成的感觉就是我们使用在操作同一个字符串</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        bs.append(<span class="string">&quot;12345678901234567890&quot;</span>);</span><br><span class="line">        System.out.println(bs);</span><br><span class="line">        <span class="comment">//2.2创建StringBuilder对象同时向StringBuilder中存String字符串</span></span><br><span class="line">        <span class="comment">//StringBuilder如果使用字符串进行初始化创建，会使用参数字符串的长度+16这个默认值作为初始容量value字符数组的大小</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">bs2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="comment">//2.3PS：这个构建方式是以前开发时常用的一种方式</span></span><br><span class="line">        <span class="comment">//自定义初始化数组容量【要创建一个空的StringBuilder对象必然使用这个方法】</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">bs3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">80</span>);</span><br><span class="line">        <span class="comment">//常用API</span></span><br><span class="line">        <span class="comment">//1.最常用的方法 append 追加---》向StringBuilder中追加存储内容</span></span><br><span class="line">        <span class="comment">// 没出使用append方法时都是向原有字符串末尾添加数据 --》这个方法十分强大基本上减容各种数据类型进行存储</span></span><br><span class="line">        bs2.append(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        bs2.append(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">        <span class="comment">//append这个方法的特殊点在于，这个方法的中内部使用使用this关键字作为方法参数传递</span></span><br><span class="line">        <span class="comment">//因为这个方法返回的是调用方法的对象，所以可以使用多次[.]点的方式连续追加</span></span><br><span class="line">        <span class="comment">//Java管这种编程方式叫做“链式编程”--》他是StreamAPI【简称流式编程前身】</span></span><br><span class="line">        bs2.append(<span class="string">&quot;f&quot;</span>).append(<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">        System.out.println(bs2);</span><br><span class="line">        <span class="comment">//2.获取字符串长度</span></span><br><span class="line">        System.out.println(bs2.length());</span><br><span class="line">        <span class="comment">//3.删除字符串中指定位置字符串 ---&gt; 根据两个参数决定删除范围【下标】</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一个参数 是从什么位置开始删除（包含）</span></span><br><span class="line"><span class="comment">            第二个参数 到什么位置结束（不包含）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        bs2.delete(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(bs2);</span><br><span class="line">        <span class="comment">//4.删除指定位置的字符【下标】</span></span><br><span class="line">        bs2.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">        System.out.println(bs2);</span><br><span class="line">        <span class="comment">//5.在指定位置插入字符串【不能超出下标范围】，插入内容不受长度限制</span></span><br><span class="line">        bs2.insert(<span class="number">1</span>,<span class="string">&quot;漫威&quot;</span>);</span><br><span class="line">        System.out.println(bs2);</span><br><span class="line">        <span class="comment">//6.替换指定位置的字符串</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一个参数 从什么位置开始替换（包括）</span></span><br><span class="line"><span class="comment">            第二个参数 到什么位置结束（不包括）</span></span><br><span class="line"><span class="comment">            第三个参数 替换的字符串</span></span><br><span class="line"><span class="comment">            PS：替换的字符串长度不受替换位置大小限制的</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        bs2.replace(<span class="number">1</span>,<span class="number">3</span>,<span class="string">&quot;复仇者联盟5&quot;</span>);</span><br><span class="line">        System.out.println(bs2);</span><br><span class="line">        <span class="comment">//7.反转字符串</span></span><br><span class="line">        bs2.reverse();</span><br><span class="line">        System.out.println(bs2);</span><br><span class="line">        <span class="comment">//8.修改执行位置的字符</span></span><br><span class="line">        bs2.setCharAt(bs2.length()-<span class="number">1</span>,<span class="string">&#x27;♂&#x27;</span>);</span><br><span class="line">        System.out.println(bs2);</span><br><span class="line">        <span class="comment">//9.StringBuilder和String之间互相转换</span></span><br><span class="line">        <span class="comment">//将StringBuilder变成String</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> bs2.toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">string2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bs2);</span><br><span class="line">        <span class="comment">//将String变成StringBuilder</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">bs4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;ancd&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StringBuffer操作与上面同理，只需要将Builder变换为Buffer就可以了</p>
<h2 id="center-string-stringbuffer-stringbuilder区别-center"><center>String、StringBuffer、StringBuilder区别</center></h2>
<p>这三个类都可以用于表示字符串</p>
<p>    1）String类是字符串常量类，一旦定义不能改变</p>
<p>    2）StringBuffer、StringBuilder是可变的字符串,自带有缓冲区。默认缓冲区大小16个字符</p>
<p>    3）StringBuffer是线程安全的，所以效率低 StringBuilder是线程不安全的，所以效率高</p>
<p>总结：实际开发中更常用的是String类型，但在大量的字符串拼接的时候，使用 StringBuffer、StringBuilder。而不考虑线程安全的时候，选择StringBuilder，否则选择StringBuffer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//需求：做100000次字符串拼接//获取当前系统时间的毫秒数 4918</span></span><br><span class="line">        <span class="comment">//记录一个开始时间</span></span><br><span class="line">        <span class="comment">//long start = System.currentTimeMillis();</span></span><br><span class="line">        <span class="comment">//String str = &quot;&quot;;</span></span><br><span class="line">        <span class="comment">//for (int i = 0; i &lt; 100000; i++)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    str = str + &quot;a&quot;;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//记录一个结束时间</span></span><br><span class="line">        <span class="comment">//long end = System.currentTimeMillis();</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;耗时&quot;+(end -start));</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//long start = System.currentTimeMillis();</span></span><br><span class="line">        <span class="comment">//StringBuffer sb = new StringBuffer();</span></span><br><span class="line">        <span class="comment">//for (int i = 0; i &lt; 10000000; i++)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    sb.append(&quot;a&quot;);</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//long end = System.currentTimeMillis();</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;耗时&quot;+(end -start));   //239</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时&quot;</span>+(end -start));    <span class="comment">//90</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-string和stringbuilder作为方法参数问题-center"><center>String和StringBuilder作为方法参数问题</center></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringMethodDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;没有修改str字符串之前的内容是：&quot;</span>+str);</span><br><span class="line">        changeString(str);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改之后str字符串中内容是：&quot;</span>+str);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------处理修改方式--------------------------&quot;</span>);</span><br><span class="line">        str = changeString2(str);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------处理修改方式2--------------------------&quot;</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(str);</span><br><span class="line">        changeString3(builder);</span><br><span class="line">        System.out.println(builder);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            String是引用类型没有问题，但是是一个特殊的引用类型，平时在外界进行的修改是可以操作</span></span><br><span class="line"><span class="comment">            但是如果将String类型作为方法的参数，此时是无法通过方法内部对String类型参数进行修改影响到</span></span><br><span class="line"><span class="comment">传递参数</span></span><br><span class="line"><span class="comment">            主要是跟字符串的存储机制有关，一个值字符串字符串池机制和底层存储机制【private final char[] value】</span></span><br><span class="line"><span class="comment">            对String字符串进行操作时都等于重新创建一个新的String对象</span></span><br><span class="line"><span class="comment">            下面方法发生执行过程</span></span><br><span class="line"><span class="comment">            首先：通过外界main方法中调用changeString(str) 将 str赋值给方法参数str</span></span><br><span class="line"><span class="comment">            即执行 方法参数赋值过程 String str = str ---》 String str = &quot;abc&quot;</span></span><br><span class="line"><span class="comment">            参数str会得到字符串&quot;abc&quot;的引用地址</span></span><br><span class="line"><span class="comment">            然后：在方法的【内部对方法参数str进行了修改】将str修改为一个新的引用执行 &quot;bcd&quot;</span></span><br><span class="line"><span class="comment">            所有的修改过程都是对 方法参数空间引用str进行操作，是不会影响到外界str的</span></span><br><span class="line"><span class="comment">            这样就造成如果使用String类型作为方法参数时，是无法修改外界传递字符串数据</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changeString</span><span class="params">(String str)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            str = <span class="string">&quot;bcd&quot;</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//可以进行修改操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        第一种： 提供返回值，将方法内部修改之后地址赋值给外界字符串</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">changeString2</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        str = <span class="string">&quot;bcd&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            第</span></span><br><span class="line"><span class="comment">二种： 存储在自定义类、数组或集合</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// private static void changeString3(这里的参数需要是存储String类型数据的【自定义类、数组或集合】) </span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">// 方法内部通过这个存储方式进行字符串修改操作</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第三种：提供StringBuffer和StringBuilder作为方法参数</span></span><br><span class="line"><span class="comment">            StringBuilder是引用类型而且是一个可变字符串，底层存储【char[] value】,所以是一个可变操作</span></span><br><span class="line"><span class="comment">            对StringBuilder做到任何修改都是影响到其内部存储内容</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changeString3</span><span class="params">(StringBuilder builder)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            builder.replace(<span class="number">0</span>,builder.length(),<span class="string">&quot;bcd&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>Object类</center></h1>
<h2 id="center-含义-center"><center>含义</center></h2>
<p>在Java继承树上最顶层的父类，所有的类都是直接或者间接的继承自Object，都有Object类提供的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;&#125; --》此时是默认继承Object这个类</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Object</span>&#123;&#125; --》显式继承与Object这个类，这样两种创建方式都是一样，就是语法区别</span><br></pre></td></tr></table></figure>
<p>PS：在API中Object类一共提供11个方法，这11方法中只有clone这个方法在开发中几乎与不使用</p>
<h2 id="center-常用方法-center"><center>常用方法</center></h2>
<h3 id="getclass">getClass()</h3>
<p>    返回该对象的真实类型(运行期类型)</p>
<p>ObjectDemo类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="comment">//获取对象的真是类型（类对象）</span></span><br><span class="line">        System.out.println(student.getClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断str和tea是否同一个类型</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">tea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">        System.out.println(str.getClass() == tea.getClass());</span><br><span class="line">        <span class="comment">//以前方法</span></span><br><span class="line">        <span class="keyword">if</span> (str <span class="keyword">instanceof</span> Student &amp;&amp; tea <span class="keyword">instanceof</span> Student</span><br><span class="line">            || str <span class="keyword">instanceof</span> Teacher &amp;&amp; tea <span class="keyword">instanceof</span> Teacher)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;同一个类型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不同一个类型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Person类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Student类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Teacher类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tostring">toString</h3>
<p>    全限定名+@+十六进制的hash值(地址)如果直接输出一个对象，那么默认会调用这个对象的toString方法，而toString方法是Object类提供的，返回的是“对象的地址”。但是我们一般输出对象希望输出的是对象的属性信息，所以可以重写父类的toString方法</p>
<p>ObjectDemo2类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectDemo2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Student stu = new Student();</span></span><br><span class="line">        <span class="comment">//com.qf.object.Student@1b6d3586 对象的内存地址</span></span><br><span class="line">        <span class="comment">//如果直接输出一个对象，实际上是调用了这个对象的toString方法，输出的是这个对象的地址</span></span><br><span class="line">        <span class="comment">//System.out.println(stu);</span></span><br><span class="line">        <span class="comment">//但是通常情况下，我们输出对象就希望输出对象的属性信息，所以通常我们会重写Object的toString方法</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(stu);    <span class="comment">//隐式调用toString方法,stu.toString()显式调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Person类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Student类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当进行toString方法重写的时候IDEA会默认提供一个toString实现的方式</span></span><br><span class="line"><span class="comment">    * 这个方式的实现就是 打印Person类型中所提供属性值</span></span><br><span class="line"><span class="comment">    * 在开发中可以根据个人的需求进行定制，无需使用IDEA提供默认实现，自行实现即可</span></span><br><span class="line"><span class="comment">    * 只要能得到一个字符串就可以</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hashcode">hashCode</h3>
<p>区分对象</p>
<ul>
<li>返回该对象的十进制的哈希吗值</li>
<li>hash值是由hash算法通过对象的地址、对象中的字符串、数字等，计算出来的</li>
<li>相同的对象应当返回相同的哈希吗值，不同的对象尽量返回不同的哈希码值</li>
</ul>
<p>不同的对象有可能会出现hash冲突</p>
<p>ObjectDemo03类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectDemo03</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(stu1.hashCode());</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(stu2.hashCode());</span><br><span class="line">        <span class="comment">//hash冲突</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;通话&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;重地&quot;</span>;</span><br><span class="line">        System.out.println(s1.hashCode());</span><br><span class="line">        System.out.println(s2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Student类和Person类与ObjectDemo2相同</p>
<h3 id="equals">equals</h3>
<p>    Object类的equals方法的作用是比较两个对象是否相等。默认比较的是内存地址。其底层代码的是==如果不想比较内存地址，那么需要重写equals方法。系统默认重写过后的equals方法，只要属性一致，那么结构返回true</p>
<p>    String类就重写父类equals，从而比较的是内容，所以String类中只要两个字符串内容相等，那么equals就返回true。</p>
<p>快捷方法：alt+INS ==&gt;equals()and hashCode() ==&gt;第一个界面需要打勾的 打勾第一个 ==&gt;剩下全部下一步</p>
<p>PS：如果遇到自定义类中所创建对象需要比较相等，那么就需要在这个自定义类中提供equals方法的重新操作，才可以进行比较。</p>
<p>重写equals的同时重写hashcode方法的原因</p>
<p>    因为在Java中协定，只要两个对象使用equals比较相等，那么两个对象的hahsi值也必须相等</p>
<p>在HashSet等集合的底层去重原理? ( 如何比较两个对象是否相等? )</p>
<p>    在java中会优先比较两个对象的hash值，如果hash值不一致，那么两个对象就不相同。</p>
<p>    如果hash值一致，进而再比较equals，如果equals 方法也相等，那么这两个对象就等同。</p>
<p>训练提示</p>
<p>    （1）提供一个公民类，属性有【姓名和ID】</p>
<p>    （2）提供一个数据存储工具类，工具类中存储一下数据信息，提供一个方法可以获取到这些数据信息</p>
<p>        姓名 ID</p>
<p>        张学友, 9999</p>
<p>        刘德华, 8888</p>
<p>        郭富城, 7777</p>
<p>        吴奇隆，6666</p>
<p>    （3） 设计一个机场安检系统类，提供控制台输入姓名和ID的操作存储到公民对象中，提供操作完成公民信息与数据类中提供数据信息比较操作，如果信息一致则提示机场想起了警报，来了一群便衣将XXX带走了，否则祝XXX旅途愉快！</p>
<p>公民类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Citizen</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> ID;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Citizen</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Citizen</span><span class="params">(String name, <span class="type">int</span> ID)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.ID = ID;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getID</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ID;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setID</span><span class="params">(<span class="type">int</span> ID)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.ID = ID;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供一个toString重写打印公民类中的属性信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Citizen&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, ID=&quot;</span> + ID +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>公民信息存储工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CitizenDB</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.工具类是不会提供对象创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CitizenDB</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">//2.工具类中提供方法和属性都是静态的</span></span><br><span class="line">    <span class="comment">//2.1提供一个静态数组存储公民信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Citizen[] db = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Citizen</span>(<span class="string">&quot;张学友&quot;</span>,<span class="number">9999</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Citizen</span>(<span class="string">&quot;刘德华&quot;</span>,<span class="number">8888</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Citizen</span>(<span class="string">&quot;郭富城&quot;</span>,<span class="number">7777</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Citizen</span>(<span class="string">&quot;吴奇隆&quot;</span>,<span class="number">6666</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//2.2 提供一个共有静态方法可以访问到这个数据数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Citizen[] getCitizenDB()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> db;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>机场安检系统</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AirPortSystem</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------欢迎进入机场安检系统-------------------------&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入您的姓名：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> input.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入您的ID：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ID</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            注意: 要比较信息数据是存储在公民数组中，公民数组中存储都是一个一个公民对象，每个公民对</span></span><br><span class="line"><span class="comment">象中存储就是具体数据信息</span></span><br><span class="line"><span class="comment">            所以需要将name和ID信息封装一个公民信息对象中，与公民数组中存储对象进行比较</span></span><br><span class="line"><span class="comment">            此时就需要使用到Object类中所提供equals方法进行对象的比较操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Citizen</span> <span class="variable">citizen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Citizen</span>(name,ID);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------请稍等，系统正在比对您的信息-------------------------&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">//为了让系统有一个卡顿的效果【模拟查找数据库】</span></span><br><span class="line">        <span class="keyword">if</span> (checkCitizenInfo(citizen))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;机场想起了警报，来了一群便衣将：&quot;</span>+citizen+<span class="string">&quot;带走了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;祝:&quot;</span>+citizen+<span class="string">&quot;旅途愉快！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 检查公民信息的方法</span></span><br><span class="line"><span class="comment">    * 公民信息对象</span></span><br><span class="line"><span class="comment">    * 证明是要逮捕的人 false 证明就不是要逮捕人</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkCitizenInfo</span><span class="params">(Citizen citizen)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (Citizen citizen1 : CitizenDB.getCitizenDB())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//利用数据中每一个公民对象与传递进来公民对象进行比较操作</span></span><br><span class="line">            <span class="keyword">if</span> (citizen1.equals(citizen))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>    通过上面代码执行我们可以发现Objcet类提供equals方法无法满足子类比较的需求，所以需要重新equals方法进行对象比较的操作</p>
<p>    如果认为两个引用类型“相等“即equals比较值为true，认为只要引用类型中存储的数据内容是一致的就认为这个两个引用类型相等，即equals比较结果为true，否则equals比较结果为false</p>
<p>    针对自定义类中创建对象使用equals进行比较时，重写equals方法中提供方式是即当前类中定义属性，根据需求，要么全部都相等 或者 部分相等</p>
<p>在公民类（Citizen）中重写equals方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公民类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Citizen</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> ID;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Citizen</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Citizen</span><span class="params">(String name, <span class="type">int</span> ID)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.ID = ID;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getID</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ID;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setID</span><span class="params">(<span class="type">int</span> ID)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.ID = ID;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供一个toString重写打印公民类中的属性信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Citizen&#123;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">    <span class="string">&quot;, ID=&quot;</span> + ID +</span><br><span class="line">    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供equals方法的重写</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        观察这个方法时可以发现，方法的参数类型是Object类型，使用是父类类型作为方法的参数</span></span><br><span class="line"><span class="comment">        这样可以达到方法的最大通用性，任何类重写equals方法的时候可以满足类的需求---》这就是多态的</span></span><br><span class="line"><span class="comment">好处</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在这个类中提供比较原则，使用this代表当前对象， other传入对象</span></span><br><span class="line"><span class="comment">            外界调用这个方法就是this，当做方法参数传递的就是other对象</span></span><br><span class="line"><span class="comment">            这个编程需求是需要比较类中所有全部相等，所以需要提供属性操作，又因为使用是父类Object类</span></span><br><span class="line"><span class="comment">                型作为方法参数【为了达到最通用性】</span></span><br><span class="line"><span class="comment">            但是传入到这个方法中对象会被执行【对象的向上转型】提升为Object类型，此时是无法调用子类</span></span><br><span class="line"><span class="comment">属性和方法</span></span><br><span class="line"><span class="comment">            需要将这个提升之后对象转换为原有的数据类型</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Citizen</span> <span class="variable">other</span> <span class="operator">=</span> (Citizen)o;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            类中属性的操作方式：如果类中属性是系统引用类型，直接调用equals方法即可【因为系统引用类</span></span><br><span class="line"><span class="comment">            型基本上都重写了Object类中equals方法】</span></span><br><span class="line"><span class="comment">            如果类中属性是基本数据类型，直接使用 == 比较即可</span></span><br><span class="line"><span class="comment">            name属性是String类型所以可以直接使用String类提供equals方法重写比较</span></span><br><span class="line"><span class="comment">            ID属性是int类型所以可以直接使用 == 进行比较操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name.equals(other.name) &amp;&amp; <span class="built_in">this</span>.ID == other.ID;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：== 和 equals的区别</p>
<p>    两个东西都是用于比较的</p>
<p>    == 可以用于基本类型和引用类型==在基本类型的比较中，比较的值是否相等，如果相等返回true，否则返回false</p>
<p>    ==在引用类型的比较中，比较的地址是否相等，如果相等返回true，否则返回false</p>
<p>    equals只能用于引用类型的比较equals方法是Object类提供的方法，其底层实现是==比较，所以在没有重写父类的equals方法时。比较的也是地址。如果希望两个对象的属性一样，就认为两个对象是相同的对象，那么需要重写equals方法，但是重写了equals的同时也需要重写hashcode方法，因为java中约定两个对象相等，那么两个对象的hash值也应该相等</p>
<h3 id="finalize">finalize</h3>
<p>当垃圾回收器回收垃圾对象的时候，自动调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test5</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">//手动将对象标记为垃圾对象</span></span><br><span class="line">        p = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//触发垃圾回收器，回收垃圾对象</span></span><br><span class="line">        System.gc();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();<span class="comment">//不要删除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;finalize方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>包装类</center></h1>
<h2 id="center-概念-center"><center>概念</center></h2>
<p>什么是包装类？</p>
<p>    包装类就是【基本数据类型对应引用数据类型版本】，基本数据类型在网络数据传输时，效率是极低的，就是因为基本数据类型没有执行序列化接口，所以提供对应引用类型版本进行替换操作，提高基本数据类型在网络中传递效率</p>
<p>    在后学习中我们会接触到一个更加便利的数据存储形式—》集合，集合中存储数据只能是引用类型，所以基本数据类型无法存储到集合中，所以就需要使用包装类即基本数据类型对应引用类型版本</p>
<p>    基本数据类型只提供基础数据存储与定义操作，并没有提供任何对存储数据的操作方法,包装类就提供常用数据方法，字符串转换为整数，int类型就无法完成，就需要使用包装类Integer</p>
<p>PS：包装类是类，即引用类型【但是需要注意是一个“特殊”的引用类型】</p>
<h2 id="center-包装类的类型及定义-center"><center>包装类的类型及定义</center></h2>
<table>
<thead>
<tr>
<th style="text-align:center">基本类型</th>
<th style="text-align:center">作为属性默认值</th>
<th style="text-align:center">包装类型</th>
<th style="text-align:center">作为属性默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">0</td>
<td style="text-align:center">Byte</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">0</td>
<td style="text-align:center">Short</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">0</td>
<td style="text-align:center">Integer</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">0</td>
<td style="text-align:center">Long</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">0.0</td>
<td style="text-align:center">Float</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">0.0</td>
<td style="text-align:center">Double</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">不可见空字符</td>
<td style="text-align:center">Character</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">false</td>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">null</td>
</tr>
</tbody>
</table>
<p>PS：基本数据类型中除了int和char类型之外，所有对应保证类都是首字母大写，而int对应包装类Integer，char对应包装类Character</p>
<p>以下操作者都已Integer类为主要操作，其余包装类与之操作是一样，就是改变类名而已</p>
<h2 id="center-拆箱和装箱-center"><center>拆箱和装箱</center></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//以Integer为例讲解包装类 拆箱与装箱操作</span></span><br><span class="line">        <span class="comment">//什么是装箱？</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            装箱操作其实就是在形容: 将基本数据类型转换为对应包装类类型</span></span><br><span class="line"><span class="comment">            这个过程我们形容为【装箱操作】 ---》 装箱操作分为自动装箱和手动装箱</span></span><br><span class="line"><span class="comment">            手动装箱是Java5以前提供--》需要将基本数据类型转换为对应包装类类型</span></span><br><span class="line"><span class="comment">            包装类类型 对象名 = new 包装类类型(对象包装类的基本数据类型值)</span></span><br><span class="line"><span class="comment">            自动装箱是Java5以后提供 --》将基本数据类型转换为对应包装类类型是</span></span><br><span class="line"><span class="comment">            无需在使用new创建包装类对象，而是直接对包装类赋值即可</span></span><br><span class="line"><span class="comment">            包装类类型 对象名 = 对象包装类的基本数据类型值;</span></span><br><span class="line"><span class="comment">            Java5以后是支持自动和手动装箱操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//手动装箱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">19</span>;</span><br><span class="line">        <span class="comment">//将int类型age变量转换为对应Integer类型进行存储</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(age);</span><br><span class="line">        <span class="comment">//自动装箱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age2</span> <span class="operator">=</span> <span class="number">19</span>;</span><br><span class="line">        <span class="comment">//将int类型age2变量转换为对应Integer类型进行存储</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> age2;</span><br><span class="line">        <span class="comment">//这种两种方式创建的Integer对象存储的空间是不一样的，所以不要使用 == 比较</span></span><br><span class="line">        <span class="comment">//引用类型不要使用 == 比较比较是内存地址，要使用equals进行比较操作</span></span><br><span class="line">        System.out.println(integer == integer1);</span><br><span class="line">        System.out.println(integer.equals(integer1));</span><br><span class="line">        <span class="comment">//什么是拆箱操作？</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            拆箱操作其实就是在形容: 将包装类中存储的数据转换为对应基本数据类型进行存储</span></span><br><span class="line"><span class="comment">            这个过程我们形容为【拆箱操作】 ---》 拆箱操作分为自动拆箱和手动拆箱</span></span><br><span class="line"><span class="comment">            手动拆箱是Java5以前提供--》需要包装类类型对象调用包装类中提供XXXValue()方法，转换为对应基本数类型</span></span><br><span class="line"><span class="comment">            这个的XXX是包装类对象对应基本数据类型---》例如 Integer包装类 对应的就是 int类型 所以XX就是int</span></span><br><span class="line"><span class="comment">            对应转换包装类的基本数据类型 变量 = 包装类对象.XXXValue();</span></span><br><span class="line"><span class="comment">            自动拆箱是Java5以后提供 --》无需调用繁琐XXXValue()方法，只需要将包装类对象赋值给对应基本数据类型变量即可</span></span><br><span class="line"><span class="comment">            对应转换包装类的基本数据类型 变量 = 包装类对象;</span></span><br><span class="line"><span class="comment">            Java5以后是支持自动和手动拆箱操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//手动拆箱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> integer.intValue();</span><br><span class="line">        System.out.println(<span class="string">&quot;拆箱之后的int类型数：&quot;</span>+i);</span><br><span class="line">        <span class="comment">//自动拆箱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> integer1;</span><br><span class="line">        System.out.println(<span class="string">&quot;拆箱之后的int类型数：&quot;</span>+i2);</span><br><span class="line">        <span class="comment">//现在的开发使用包装类计算或在计算时自动拆箱</span></span><br><span class="line">        System.out.println(<span class="string">&quot;求存储在包装类对象integer和integer1中年龄和:&quot;</span>+</span><br><span class="line">(integer+integer1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-number类-center"><center>Number类</center></h2>
<p>Number是Byte、Short、Integer、Long、Float、Double的父类</p>
<p>Number提供一组方法用于将其中某一种类型转换成其他类型</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">xxxValue()方法</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> a.byteValue();</span><br><span class="line"><span class="type">Short</span> <span class="variable">c</span> <span class="operator">=</span> a.shortValue();</span><br><span class="line"><span class="type">Long</span> <span class="variable">d</span> <span class="operator">=</span> a.longValue();</span><br><span class="line"><span class="type">Float</span> <span class="variable">e</span> <span class="operator">=</span> a.floatValue();</span><br><span class="line"><span class="type">Double</span> <span class="variable">f</span> <span class="operator">=</span> a.doubleValue();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">g</span> <span class="operator">=</span> a.intValue();</span><br></pre></td></tr></table></figure>
<h2 id="center-常用包装类-center"><center>常用包装类</center></h2>
<p>开发中用的最多：Integer 、Double</p>
<p>定义方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Integer、Double的定义方式</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">ii1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">ii1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">dd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">100.2</span>);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="type">Double</span> <span class="variable">dd1</span> <span class="operator">=</span> <span class="number">100.2</span>;</span><br></pre></td></tr></table></figure>
<h3 id="常用属性">常用属性</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Integer.MAX_VALUE);</span><br><span class="line">System.out.println(Integer.MIN_VALUE);</span><br><span class="line">System.out.println(Double.MAX_VALUE);</span><br><span class="line">System.out.println(Double.MIN_VALUE);</span><br></pre></td></tr></table></figure>
<h3 id="常用方法">常用方法</h3>
<p>前端传入后端的数据一般是字符串类型</p>
<p>所以需要将字符串类型的数值转换成int或者是double类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"><span class="comment">//字符串转Integer</span></span><br><span class="line"><span class="comment">//第一种方法（常用）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;23&quot;</span>);</span><br><span class="line">System.out.println(number);</span><br><span class="line"><span class="comment">//第二种方法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number1</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;234&quot;</span>);</span><br><span class="line">System.out.println(number1);</span><br><span class="line"><span class="comment">//字符串转Double</span></span><br><span class="line"><span class="comment">//第一种方法(常用)</span></span><br><span class="line"><span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> Double.parseDouble(<span class="string">&quot;23.4&quot;</span>);</span><br><span class="line">System.out.println(price);</span><br><span class="line"><span class="comment">//第二种方法</span></span><br><span class="line"><span class="type">double</span> <span class="variable">price1</span> <span class="operator">=</span> Double.valueOf(<span class="string">&quot;23.45&quot;</span>);</span><br><span class="line">System.out.println(price1);</span><br></pre></td></tr></table></figure>
<h2 id="center-integer缓冲区-center"><center>Integer缓冲区</center></h2>
<p>整数型的包装类定义缓冲区(-128~127)，如果定义的数在这个范围你之内，那么直接从缓存数组中获取，不需要new</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">/*** 面试题：整数型包装类缓冲区</span></span><br><span class="line"><span class="comment">        * 整数型的包装类定义缓冲区(-128~127)，如果定义的数在这个范围你之内，那么直接从缓存数组中获取，</span></span><br><span class="line"><span class="comment">        * 否则，重新new新的对象</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line">        System.out.println(i1 == i2); <span class="comment">//false</span></span><br><span class="line">        System.out.println(i1.equals(i2));<span class="comment">//true</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">1000</span>; <span class="comment">//Integer i3 = new Integer(1000);</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">1000</span>; <span class="comment">//Integer i3 = new Integer(1000);</span></span><br><span class="line">        System.out.println(i3 == i4); <span class="comment">//false</span></span><br><span class="line">        System.out.println(i3.equals(i4));<span class="comment">//true</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i5</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">//IntegerCache.cache[i + (-IntegerCache.low)]</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i6</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">//IntegerCache.cache[i + (-IntegerCache.low)]</span></span><br><span class="line">        System.out.println(i5 == i6);<span class="comment">//true</span></span><br><span class="line">        System.out.println(i5.equals(i6));<span class="comment">//true&#125;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>    Integer类内部实现的原则 —》【享元原则】它是Java中设计的一种优化，外部使用自动装箱进行Integer创建时，设计了一个范围 【-128~127】只要是这个范围内创建出来Integer对象，他们都会得到堆中相同地址，相当于Integer中出现一个缓存数据 Integer cache[] = {-128，… ,127} ,只要存储这个范围内的值就直接返回存储好地址，这样一来就说明了存储123时通过 == 比较得到结果是true ，存储300时 == 比较得到结果是false，因为300超出了Integer缓存范围，机会触发valueOf方法 new Integer，得到就是堆地址</p>
<h2 id="center-包装类作为方法参数类型-center"><center>包装类作为方法参数类型</center></h2>
<p>    需求：提供给一个测试类，在main方法中提供一个Integer类型包装类对象存储数据1000【形式不限】，然后再测试类中提供static方法，将Integer设置为当前方法参数类型，并在方法内部将外界传递Integer数据【1000】，修改为99999，然后再mian方法中调用方法执行，打印修改之后的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//包装类作为方法参数类型时问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackageClassMethod</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//包装类就是引用类型,但是是一个“特殊”引用类型</span></span><br><span class="line">        <span class="comment">//Integer i1 = null;</span></span><br><span class="line">        <span class="comment">//提供一个Integer类型的对象存储数据1000</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">//toHexString 将十进制转换为十六进制 toBinaryString 将十进制转换为二进制</span></span><br><span class="line">        <span class="comment">//toOctalString 将十进制转换为八进制</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main方法中integer对象的内存地址是：&quot;</span>+Integer.toHexString(integer.hashCode()));</span><br><span class="line">        changeIntegerValue(integer);</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法调用changeIntegerValue方法之后integer对象的内存地</span></span><br><span class="line"><span class="string">            址是：&quot;</span>+Integer.toHexString(integer.hashCode()));</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changeIntegerValue</span><span class="params">(Integer integer)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法中将integer对象存储的地址赋值给changeIntegerValue</span></span><br><span class="line"><span class="string">        方法参数integer的地址：&quot;</span>+Integer.toHexString(integer.hashCode()));</span><br><span class="line">        integer = <span class="number">99999</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;changeIntegerValue方法将Integer对象中存储数据修改之后的地</span></span><br><span class="line"><span class="string">            址是：&quot;</span>+Integer.toHexString(integer.hashCode()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包装类是一个特殊的引用类型，将包装类作为方法参数之后，在方法内部提供数据修改之后无法</p>
<p>得到修改之后的结果，原因在于其内部存储</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原码中Integer存储数据时做的操作</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    value就是Integer类型存储数据时的成员“变量（常量）”</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    调用构造方法创建Integer对象提供存储数据都是存储在value这个成员“变量”</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Integer</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>    综上所属：包装类其实是一个特殊的引用类型，当在方法体进行操作时，相当于是“重新”创建了一个地址，所以的修改都不是在原有地址上执行，而是在这个新的地址执行，这样一来就造成了无法修改的问题，除此之外在原码中可以发现，存储数据是使用【 private final int value】，value是final修饰，所以每次对Integer赋值操作时，都是得到一个新的地址。</p>
<p>提供可以正常修改方案：</p>
<p>    第一种方式：对方法添加返回值类型，利用return关键字将修改之后地址，返回出来，并让外界原来对象，存储这个新的地址，间接的修改了</p>
<p>    第二种方式：使用自定义类，将Integer作为类的属性类型存在，修改Integer时，传递自定义类作为参数类型，在方法内部通过get和set进行修改，这样也可以改变</p>
<p>    第三种方式：存储到数据结构中 —》数组或集合</p>
<p>包装类与包装类之间关系</p>
<p>    基本数据类型除了boolean类型之外，都可以参与到数据类型转换过程中。但是包装类彼此之间</p>
<p>    是互相独立，非要找一些关联化，数值类型【Byte、short、Integer、Long、Float和Double】</p>
<p>    他们有一个共同父类是Number，除此之外包装类是存在在java.lang包中</p>
<h1><center>Dete类</center></h1>
<p>表示日期</p>
<h2 id="center-创建-center"><center>创建</center></h2>
<p>创建java.util.Date对象</p>
<p>获取系统当前时间：Date date = new Date();</p>
<p>自己定义时间：Date date = new Date(定义年 - 1900,定义月-1,定义日);</p>
<p>获取时间戳：先new Date	形式：变量名.getTime();</p>
<p>需要定义变量保存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">dateDemo01</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建java.util.Date对象</span></span><br><span class="line">        <span class="comment">//获取系统当前时间</span></span><br><span class="line">        <span class="comment">//Date date = new Date();</span></span><br><span class="line">        <span class="comment">//System.out.println(date);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * year：默认从1900年开始</span></span><br><span class="line"><span class="comment">         * moth：0-11</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//使用Date类表示指定时间</span></span><br><span class="line">        <span class="comment">//Date date = new Date(2020-1900,10-1,29);</span></span><br><span class="line">        <span class="comment">//System.out.println(date);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前Date对应时间的毫秒数（时间戳）</span></span><br><span class="line">        <span class="comment">//获取到的时间戳是从1970年开始计算</span></span><br><span class="line"><span class="comment">//        Date date = new Date();</span></span><br><span class="line"><span class="comment">//        long time = date.getTime();</span></span><br><span class="line"><span class="comment">//        System.out.println(time);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算活了多少天</span></span><br><span class="line">        <span class="comment">//1、获取当前系统时间</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="comment">//2、获取出生时间</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2000</span>-<span class="number">1900</span>,<span class="number">6</span>-<span class="number">1</span>,<span class="number">29</span>);</span><br><span class="line">        <span class="comment">//3、获取两个时间对应的时间戳相减</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> date.getTime() - date1.getTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;我活了&quot;</span>+ time/<span class="number">1000</span>/<span class="number">60</span>/<span class="number">60</span>/<span class="number">24</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>SimpleDateFormat类</center></h1>
<p>用于日期格式化</p>
<h2 id="center-作用-center"><center>作用</center></h2>
<p>1）将Date类转换成字符串类型</p>
<p>2）将字符串类型转换成Date类型</p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271929805.WebP" alt="时间表达" style="zoom:67%;">
<p>提供对应字符中常用主要有【y（年）、M（月）、d（日）、H（小时）、m（分钟）、s（秒）】</p>
<p>SimpleDateFormat常用方法</p>
<p>    public String format(Date date): 根据提供日期格式将Date对象格式化成String对象</p>
<p>    public Date parse(String source): 根据提供日期格式将String对象解析为Date对象</p>
<p>    public void applyPattern(String pattern): 可以通过参数String类型字符串设置日期格式</p>
<p>ps：这个方法主要应对的是使用SimpleDateFormat无参的构造方法所创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDateFormatDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将Date转换字符串</span></span><br><span class="line">        <span class="comment">//创建一个Date对象</span></span><br><span class="line"><span class="comment">//         Date date = new Date();</span></span><br><span class="line"><span class="comment">//         //创建日期格式化对象 2021年03月12日 14:15:30</span></span><br><span class="line"><span class="comment">//         SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);</span></span><br><span class="line"><span class="comment">//        String time = sdf.format(date);</span></span><br><span class="line"><span class="comment">//        System.out.println(time);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将字符串类型转换成Date类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> <span class="string">&quot;2022-04-13 20:32:29&quot;</span>;</span><br><span class="line">        <span class="comment">//此时的格式必须要与字符串中的日期格式一致</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="comment">//转换</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf.parse(time);</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-calender日历类-center"><center>Calender日历类</center></h2>
<p>    Calender类是有Java提供用来代替Date类使用的一个日历类【PS：但是设计者脑残了，这个类存在一个缺陷】，这类所存在的包时java.util中，它是一个抽象类，不能创建对象，所以需要使用到它的子类GregorianCalendar类来完成，这个子类无需直接创建对象，只需要使用Calender类中getInstance()静态方法获取到子类对象即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalendarDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供Calendar对象创建</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="comment">//不能像打印Date一样打印Calendar对象，因为Calendar对象中存储的是日历信息</span></span><br><span class="line">        System.out.println(c);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            java.util.GregorianCalendar[time=1637913526755,areFieldsSet=true,</span></span><br><span class="line"><span class="comment">            areAllFieldsSet=true,lenient=true,</span></span><br><span class="line"><span class="comment">            zone=sun.util.calendar.ZoneInfo[id=&quot;Asia/Irkutsk&quot;,</span></span><br><span class="line"><span class="comment">            offset=28800000,dstSavings=0,useDaylight=false,</span></span><br><span class="line"><span class="comment">            transitions=67,lastRule=null],firstDayOfWeek=1,</span></span><br><span class="line"><span class="comment">            minimalDaysInFirstWeek=1,ERA=1,YEAR=2021,MONTH=10,</span></span><br><span class="line"><span class="comment">            WEEK_OF_YEAR=48,WEEK_OF_MONTH=4,DAY_OF_MONTH=26,</span></span><br><span class="line"><span class="comment">            DAY_OF_YEAR=330,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MONTH=4,</span></span><br><span class="line"><span class="comment">            \AM_PM=1,HOUR=3,HOUR_OF_DAY=15,MINUTE=58,SECOND=46,</span></span><br><span class="line"><span class="comment">            MILLISECOND=755,ZONE_OFFSET=28800000,DST_OFFSET=0]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//这个日历类中操作时一定要注意月份问题，月份的基础范围【0~11】代表【1~12月】</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Calendar中打印存储的是日历信息，所以利用Calendar中提供一个方法</span></span><br><span class="line"><span class="comment">        public int get(int Field) --》参数是Calendar类中字段---》通过参数传入的字段获取</span></span><br><span class="line"><span class="comment">        当前日历类中数据</span></span><br><span class="line"><span class="comment">        提供一些常用字段：</span></span><br><span class="line"><span class="comment">            Calendar.YEAR : 年</span></span><br><span class="line"><span class="comment">            Calendar.MONTH ：月</span></span><br><span class="line"><span class="comment">            Calendar.DAY_OF_MONTH：月中的日期 --》还有一个字段可以获取 Calendar.DATE 月中的日期</span></span><br><span class="line"><span class="comment">            Calendar.HOUR：小时</span></span><br><span class="line"><span class="comment">            Calendar.MINUTE：分钟</span></span><br><span class="line"><span class="comment">            Calendar.SECOND：秒</span></span><br><span class="line"><span class="comment">            Calendar.DAY_OF_WEEK：星期</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(c.get(Calendar.YEAR)+<span class="string">&quot;年&quot;</span></span><br><span class="line">				+(c.get(Calendar.MONTH)+<span class="number">1</span>)+<span class="string">&quot;月&quot;</span></span><br><span class="line">        		+c.get(Calendar.DATE)+<span class="string">&quot;日&quot;</span></span><br><span class="line">				+<span class="string">&quot; &quot;</span>+c.get(Calendar.HOUR)+<span class="string">&quot;时&quot;</span></span><br><span class="line">        		+c.get(Calendar.MINUTE)+<span class="string">&quot;分&quot;</span></span><br><span class="line">				+c.get(Calendar.SECOND)+<span class="string">&quot;秒&quot;</span>);</span><br><span class="line">        <span class="comment">//将Calendar对象转换为Date对象</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> c.getTime();</span><br><span class="line">        <span class="comment">//可以通过Calendar中提供set方法进行指定的时间设置</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">c1</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="comment">//可以通过这样方式进行时间设置，参数第一个是对应时间字段，第二个是对应的时间数据</span></span><br><span class="line">        <span class="comment">// c1.set(Calendar.YEAR,2021);</span></span><br><span class="line">        <span class="comment">//建议使用下面这个方法完成 ,上面执行操作太繁琐</span></span><br><span class="line">        <span class="comment">//设置月份的时候一定要-1操作【范围是0~11】</span></span><br><span class="line">        c1.set(<span class="number">2021</span>,<span class="number">10</span>,<span class="number">26</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;这是这一年的第：&quot;</span>+c1.get(Calendar.DAY_OF_YEAR)+<span class="string">&quot;天&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;这是这一年的第：&quot;</span>+c1.get(Calendar.WEEK_OF_YEAR)+<span class="string">&quot;周&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;这是这个月的第：&quot;</span>+c1.get(Calendar.DAY_OF_MONTH)+<span class="string">&quot;天&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日历类中存在的一些小问题：</p>
<ol>
<li>中国人的第一个天是星期一， 外国人第一天是星期日</li>
<li>日历类中的月份是从【0~11】结束</li>
</ol>
<h1><center>System类</center></h1>
<p>系统类</p>
<h2 id="center-作用-center"><center>作用</center></h2>
<p>1）返回当前系统时间的毫秒数 从1970年开始计算</p>
<p>    System.currentTimeMillis();</p>
<p>系统当前时间纳秒值</p>
<p>    System.nanoTime();</p>
<p>2）终止Java虚拟机的运行 参数表示终止的状态 0表示正常退出，负数异常终止</p>
<p>    System.exit(0);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemDemo01</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取当前时间的毫秒数    1970年开始</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(time);   <span class="comment">//时间戳</span></span><br><span class="line">        <span class="comment">//日期格式化类可以对long类型的毫秒数进行格式化</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(sdf.format(time));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//终止虚拟机运行  0表示正常退出 非0非正常关机</span></span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;会执行么&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//并不会直接使用垃圾回收器回收垃圾，只会将不用的对象主动添加到垃圾队列</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//数组复制</span></span><br><span class="line">        <span class="type">int</span>[] src = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] des = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一个参数 是原数组即被要复制的数据</span></span><br><span class="line"><span class="comment">            第二个参数 从原数组中那个位置开始复制【下标】</span></span><br><span class="line"><span class="comment">            第三个参数 是目标数组即复制内容到那个数组中</span></span><br><span class="line"><span class="comment">            第四个参数 是目标数组的位置【下标】，从目标数组中什么位置开始写入数据</span></span><br><span class="line"><span class="comment">            第五个参数 被复制的长度</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.arraycopy(src,<span class="number">2</span>,des,<span class="number">5</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(Arrays.toString(des));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>Math类</center></h1>
<h2 id="center-含义-center"><center>含义</center></h2>
<p>数学计算的工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//求a的b次方法 参数1：底数 参数2：幂数</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">num1</span> <span class="operator">=</span> Math.pow(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(num1);</span><br><span class="line">        <span class="comment">//求a平方根 参数1：要开方的数</span></span><br><span class="line">        System.out.println(Math.sqrt(<span class="number">100</span>));</span><br><span class="line">        <span class="comment">//求a立方根 参数1：要开立方的数</span></span><br><span class="line">        System.out.println(Math.cbrt(<span class="number">27</span>));</span><br><span class="line">        <span class="comment">//向上取整  10.1    11</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">10.2</span>));</span><br><span class="line">        <span class="comment">//向下取整  10.6    10</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">10.9</span>));</span><br><span class="line">        <span class="comment">//四舍五入</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">10.5</span>));</span><br><span class="line">        <span class="comment">//随机数 默认的范围[0,1)</span></span><br><span class="line">        System.out.println(Math.random());</span><br><span class="line">        <span class="comment">//需求：随机一个两位数 [0,1)*90   [0,90) + 10</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num8</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random()*<span class="number">90</span>+<span class="number">10</span>);</span><br><span class="line">        System.out.println(num8);</span><br><span class="line">        <span class="comment">//1.8API中提供新的方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MAX_VALUE;<span class="comment">//获取int类型最大值存储到max中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        System.out.println(max+i);<span class="comment">//最大值进行+1之后的到溢出结果不会报错，这样可能影响计算结果</span></span><br><span class="line">        <span class="comment">//正确计算整数之间求和 ---》 一旦超过了最大值范围就会抛出异常提示 --&gt; ArithmeticException: integer overflow</span></span><br><span class="line">        <span class="comment">//System.out.println(Math.addExact(max,i));</span></span><br><span class="line">        System.out.println(max);</span><br><span class="line">        <span class="comment">//安全的递减操作 ---》让数值-1 ，如果超过最小值范围 抛出异常提示</span></span><br><span class="line">        System.out.println(Math.decrementExact(max));</span><br><span class="line">        <span class="comment">//安全的递增操作 ---》 让数值+1，如果超过最大值范围 抛出异常提示</span></span><br><span class="line">        <span class="comment">// System.out.println(Math.incrementExact(max));</span></span><br><span class="line">        <span class="comment">//提供除法操作【都是安全】</span></span><br><span class="line">        System.out.println(Math.floorDiv(<span class="number">6</span>,<span class="number">3</span>));</span><br><span class="line">        <span class="comment">//提供取余操作【都是安全】</span></span><br><span class="line">        System.out.println(Math.floorMod(<span class="number">6</span>,<span class="number">3</span>));</span><br><span class="line">        <span class="comment">//提供一个安全乘法计算.如果超过范围 抛出异常提示</span></span><br><span class="line">        System.out.println(Math.multiplyExact(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line">        <span class="comment">//提供一个安全相减操作.如果超过范围 抛出异常提示</span></span><br><span class="line">        System.out.println(Math.subtractExact(<span class="number">10</span>,<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>Random类</center></h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Random是Java中提供随机数类，可以得到随机数</span></span><br><span class="line"><span class="comment">            但是这个随机数类是一个“伪随机数” --》Random如果使用相同“种子”创建对象，随机出来数据</span></span><br><span class="line"><span class="comment">就是相同</span></span><br><span class="line"><span class="comment">            Random中一共两个构造方法 --》 无参 和 有参</span></span><br><span class="line"><span class="comment">            开发时多数使用无参--》使用系统随机种子</span></span><br><span class="line"><span class="comment">            有参可以运行出伪随机效果 ---》 参数是一个种子值，但是不是随机范围</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//标准使用方式</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="comment">//他们可以随机正数 --&gt; 参数是范围</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> random.nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//伪随机效果</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">10</span>);</span><br><span class="line">        System.out.println(r1.nextBoolean());</span><br><span class="line">        System.out.println(r1.nextDouble());</span><br><span class="line">        System.out.println(r1.nextInt());</span><br><span class="line">        System.out.println(r1.nextInt(<span class="number">100</span>));</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">10</span>);</span><br><span class="line">        System.out.println(r2.nextBoolean());</span><br><span class="line">        System.out.println(r2.nextDouble());</span><br><span class="line">        System.out.println(r2.nextInt());</span><br><span class="line">        System.out.println(r2.nextInt(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建Random对象</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="comment">//随机一个[0,100)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> random.nextInt(<span class="number">50</span>);</span><br><span class="line">        System.out.println(num);</span><br><span class="line"></span><br><span class="line">        System.out.println(randomCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//需求随机生成一个思维的验证码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">randomCode</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">        <span class="comment">//将字符串转换成char数组</span></span><br><span class="line">        <span class="type">char</span> ch [] = str.toCharArray();</span><br><span class="line">        <span class="comment">//2、产生4个随机数</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> random.nextInt(str.length());</span><br><span class="line">            a.append(ch[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>BigDecimal类</center></h1>
<h2 id="center-为什么使用bigdecimal-center"><center>为什么使用BigDecimal?</center></h2>
<p>以下的代码的错误原因是0.9在计算中中的二进制是一个无限循环的</p>
<p>double保存时近似值，所以计算的结果不精确</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Java中已经提供浮点（小数）数据类型 --》 float和double但是他们在日常计算中还是可以使用</span></span><br><span class="line"><span class="comment">    但对于数据的精度有要求操作时float和double就不可以的【金融、电信、电力完全禁用float和double】</span></span><br><span class="line"><span class="comment">    Java提供了一个超精度的小数BigDecimal，可以适用于【金融、电信、电力】，日常也可以使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showBigDecimal</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//为什么double 和float被称之为不精准计算</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        计算出这个结果其实是一个“超精确的结果” 数学中提供一个悖论 1/3 = 0.33333333333</span></span><br><span class="line"><span class="comment">        数学中一个理论 0.333333*3 = 0.9999999 不等于1</span></span><br><span class="line"><span class="comment">        0.99999无限接近于1的所以 约等于</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    System.out.println(<span class="string">&quot;0.09+0.01=&quot;</span>+(<span class="number">0.09</span>+<span class="number">0.01</span>));<span class="comment">//0.1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;1.0-0.33=&quot;</span>+(<span class="number">1.0</span>-<span class="number">0.33</span>));<span class="comment">//0.67</span></span><br><span class="line">    System.out.println(<span class="string">&quot;4.015*1000=&quot;</span>+(<span class="number">4.015</span>*<span class="number">1000</span>));<span class="comment">//4015</span></span><br><span class="line">    System.out.println(<span class="string">&quot;12.3/100=&quot;</span>+(<span class="number">12.3</span>/<span class="number">100</span>));<span class="comment">//0.123</span></span><br><span class="line">    <span class="comment">//建议使用 BigDecimal进行 计算操作</span></span><br><span class="line">    <span class="comment">// BigDecimal bigDecimal1 = new BigDecimal(0.09);</span></span><br><span class="line">    <span class="comment">// BigDecimal bigDecimal2 = new BigDecimal(0.01);</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        BigDecimal创建出来的是对象，所以不能使用算数运算符进行计算，不可能对象+对象</span></span><br><span class="line"><span class="comment">        BigDecimal提供一套计算方法</span></span><br><span class="line"><span class="comment">        使用BigDecimal计算之后数据得到</span></span><br><span class="line"><span class="comment">        0.1799999999999999933386618522490607574582099914550781250</span></span><br><span class="line"><span class="comment">        这个值比double计算更加离谱，这个不是离谱，这个叫做“超级精度”</span></span><br><span class="line"><span class="comment">        BigDecimal在计算时或精确计算小数点后128位置</span></span><br><span class="line"><span class="comment">        通过观察JavaAPI文件发现 ---》BigDecimal中调用参数double类型构造方法时，有一个明确</span></span><br><span class="line"><span class="comment">的说明</span></span><br><span class="line"><span class="comment">        此构造方法的结果有一定的不可预知性,如果向BigDecimal中存储0.1这个double类型的数据</span></span><br><span class="line"><span class="comment">        传入到构造方法的值不会正好等于 0.1（虽然表面上等于该值），原因在与Java中是无法精确表</span></span><br><span class="line"><span class="comment">示0.1这个值</span></span><br><span class="line"><span class="comment">        所以存储到BigDecimal中得到结果等于</span></span><br><span class="line"><span class="comment">        0.1000000000000000055511151231257827021181583404541015625</span></span><br><span class="line"><span class="comment">        所以计算时就会得到一个BigDecimal的精确计算，所以不能调用参数为double类型</span></span><br><span class="line"><span class="comment">        BigDecimal构造方法来创建</span></span><br><span class="line"><span class="comment">BigDecimal对象</span></span><br><span class="line"><span class="comment">        建议在创建BigDecimal对象是，如果需要将数据存储到BigDecimal中建议使用，参数为</span></span><br><span class="line"><span class="comment">String类型构造方法</span></span><br><span class="line"><span class="comment">        因为&quot;0.1&quot;字符串它是一个常量，并且可以精准表示这个数据</span></span><br><span class="line"><span class="comment">        写入 new BigDecimal(&quot;0.1&quot;) 将创建一个 BigDecimal，它正好 等于预期的 0.1</span></span><br><span class="line"><span class="comment">        开发中，官方的一个建议，优先使用包装类中Double.toString(double类型数据)，将数据转</span></span><br><span class="line"><span class="comment">换为String类型</span></span><br><span class="line"><span class="comment">        然后调用BigDecimal中String类型参数构造方法创建对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0.09</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> Double.toString(d);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">bigDecimal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(string);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">bigDecimal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.01&quot;</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        add --&gt; 求和 subtract --&gt; 减法 multiply --&gt; 乘法 divide --&gt;除法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    System.out.println(bigDecimal1.add(bigDecimal2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-基本用法-center"><center>基本用法</center></h2>
<p>位置：java.math包中</p>
<p>作用：精确计算浮点数</p>
<p>创建方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal bd=<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(“<span class="number">1.0</span>”);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">要运算的数变量名1.add(要运算的数变量名2)</td>
<td style="text-align:center">加</td>
</tr>
<tr>
<td style="text-align:center">要运算的数变量名1.subtract(要运算的数变量名2)</td>
<td style="text-align:center">减</td>
</tr>
<tr>
<td style="text-align:center">要运算的数变量名1.multiply(要运算的数变量名2)</td>
<td style="text-align:center">乘</td>
</tr>
<tr>
<td style="text-align:center">要运算的数变量名1.divide(要运算的数变量名2)</td>
<td style="text-align:center">除</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimalDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//演示情况</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="number">0.9</span>;</span><br><span class="line">        System.out.println(d1-d2);  <span class="comment">//0.09999999999999998</span></span><br><span class="line">        <span class="comment">//因为：java中的浮点型在保存小数的时候是近似存储，所以计算的结果不准确</span></span><br><span class="line">        <span class="comment">//1、创建BigDecimal对象</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">        System.out.println(b1.subtract(b2));    <span class="comment">//减</span></span><br><span class="line">        System.out.println(b1.add(b2)); <span class="comment">//加</span></span><br><span class="line">        System.out.println(b1.multiply(b2)); <span class="comment">//乘</span></span><br><span class="line">        <span class="comment">//除法运算：要设置保留位数和模式</span></span><br><span class="line">        <span class="comment">//ArithmeticException 算术异常</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 参数说明：</span></span><br><span class="line"><span class="comment">        * 参数1：被除数</span></span><br><span class="line"><span class="comment">        * 参数2：保留小数位数</span></span><br><span class="line"><span class="comment">        * 参数3：舍入模式</span></span><br><span class="line"><span class="comment">        *     ROUND_CEILING 向上取整</span></span><br><span class="line"><span class="comment">        *     ROUND_FLOOR 向下取整</span></span><br><span class="line"><span class="comment">        *     ROUND_HALF_UP 四舍五入</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(b1.divide(b2,<span class="number">2</span>,BigDecimal.ROUND_HALF_UP));<span class="comment">//除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>BigInteger类</center></h1>
<p>主要应用场景在于当我们遇到long类型都无法存储整数数据时，可以使用这个类型来进行存储计算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showBigInteger</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//参数类型要使用Sting类型</span></span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">	<span class="title class_">BigInteger</span>(<span class="string">&quot;7777777777777777777777777777777777777&quot;</span> +</span><br><span class="line">        <span class="string">&quot;7777777777777777777777777777777777777777777777777777777777777777777777&quot;</span> +</span><br><span class="line">        <span class="string">&quot;777777777777777777777777777777777777777777777777777777777777&quot;</span>);</span><br><span class="line">    <span class="comment">//可以调用BigInteger中提方法进行计算</span></span><br><span class="line">    <span class="comment">//mod这个方法是求余数</span></span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">mod</span> <span class="operator">=</span> integer.mod(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;7&quot;</span>));</span><br><span class="line">    System.out.println(mod);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> integer.intValue();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>Runtime类</center></h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    每个Java 应用程序都有一个 Runtime 类实例，</span></span><br><span class="line"><span class="comment">    使应用程序能够与其运行的环境相连接。可以通过 getRuntime 方法获取当前运行时。</span></span><br><span class="line"><span class="comment">    Runtime这个实例就相当于是虚拟机</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showRuntime</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.获取正在运行虚拟机对象</span></span><br><span class="line">    <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">    System.out.println(<span class="string">&quot;JVM的核心数量：&quot;</span>+runtime.availableProcessors());</span><br><span class="line">    System.out.println(<span class="string">&quot;JVM的总内存大小：&quot;</span>+(runtime.totalMemory()/<span class="number">1024</span>/<span class="number">1024</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;JVM的空闲内存大小：&quot;</span>+(runtime.freeMemory()/<span class="number">1024</span>/<span class="number">1024</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;JVM的最大内存大小：&quot;</span>+(runtime.maxMemory()/<span class="number">1024</span>/<span class="number">1024</span>));</span><br><span class="line">    <span class="comment">//2.通过runtime这个对象加快GC的回收</span></span><br><span class="line">    runtime.gc(); <span class="comment">//只能是加快，但是不是立即</span></span><br><span class="line">    <span class="comment">//3.终止虚拟机 如果是负数就是异常终止 如果正数就是正常终止</span></span><br><span class="line">    <span class="comment">//这个效果只有虚拟机中有，外界无法查看</span></span><br><span class="line">    runtime.exit(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;如果没有关闭我必然执行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java语言</category>
      </categories>
      <tags>
        <tag>Java语言</tag>
      </tags>
  </entry>
  <entry>
    <title>2.MySQL进阶</title>
    <url>/post/4e3021ff.html</url>
    <content><![CDATA[<h1>视图</h1>
<p>一个虚拟表，非真实存在，其本质是根据SQL语句获取动态的数据集，并为其命名，用户使用时只需使用视图名称即可获取结果集，并可以将其当作表来使用</p>
<p>数据库中只存放了视图的定义，而并没有存放视图中的数据。这些数据存放在原来的表中，表中的数据发生改变，显示在视图中的数据也会发生改变</p>
<p>作用：</p>
<ul>
<li>把重复使用的查询封装成视图重复使用，同时可以使复杂的查询易于理解和使用</li>
<li>安全原因，如果一张表中有很多数据，很多信息不希望让所有人看到，此时可以使用视图视</li>
</ul>
<h2 id="创建视图">创建视图</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create [or replace] [algorithm = &#123;undefined | merge | temptable&#125;]</span><br><span class="line">view view_name [(column_list)]</span><br><span class="line">as select_statement</span><br><span class="line">[with [cascaded | local] check option]</span><br><span class="line"></span><br><span class="line">/*参数说明：</span><br><span class="line">	algorithm：可选项，表示视图选择的算法</span><br><span class="line">	view_name ：表示要创建的视图名称</span><br><span class="line">	column_list：可选项，指定视图中各个属性的名词，默认情况下与SELECT语句中的查询的属性相同</span><br><span class="line">	select_statement：表示一个完整的查询语句，将查询记录导入视图中</span><br><span class="line">	[with [cascaded | local] check option]：可选项，表示更新视图时要保证在该视图的权限范围之内	*/</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建视图</span><br><span class="line">create or replace view view1_emp</span><br><span class="line">as</span><br><span class="line">select ename,job from emp;</span><br><span class="line"></span><br><span class="line">-- 查看表和视图</span><br><span class="line">show full tables;</span><br><span class="line"></span><br><span class="line">-- 使用视图</span><br><span class="line">select * from view1_emp;</span><br></pre></td></tr></table></figure>
<h2 id="修改视图">修改视图</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter view 视图名 as select语句;</span><br><span class="line"></span><br><span class="line">alter view view1_emp</span><br><span class="line">as</span><br><span class="line">select a.deptno,a.dname,a.loc,b.ename,b.sal</span><br><span class="line">from dept a,emp b where a.deptno = b.deptno;</span><br></pre></td></tr></table></figure>
<h2 id="更新视图">更新视图</h2>
<p>在update(修改)、delete(删除) 或 insert(插入) 等语句中更新视图(实际修改是原表的数据)</p>
<p>视图中虽然可以更新数据，但是有很多的限制。一般情况下，最好将视图作为查询数据的虚拟表，而不要通过视图更新数据。因为，使用视图更新数据时，如果没有全面考虑在视图中更新数据的限制，就可能会造成数据更新失败</p>
<p>不可更新的情况：</p>
<ul>
<li>聚合函数（sum(), min(), max(), count()等）</li>
<li>distinct</li>
<li>group by</li>
<li>having</li>
<li>union或union all</li>
<li>位于选择列表中的子查询</li>
<li>join</li>
<li>FROM子句中的不可更新视图</li>
<li>where子句中的子查询，引用from子句中的表。</li>
<li>仅引用文字值（在该情况下，没有要更新的基本表）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update view1_emp set ename = &#x27;周瑜&#x27; where ename = &#x27;刘备&#x27;;</span><br><span class="line"></span><br><span class="line">-- 由于原表还有其它列，但视图没法看到添加只有两列其它列没添加，则添加不成功</span><br><span class="line">insert into view1_emp values(&#x27;孙权&#x27;,&#x27;文员&#x27;);</span><br></pre></td></tr></table></figure>
<h2 id="重命名视图">重命名视图</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- rename table 视图名 to 新视图名; </span><br><span class="line">rename table view1_emp to my_view1</span><br></pre></td></tr></table></figure>
<h2 id="删除视图">删除视图</h2>
<p>删除视图时，只能删除视图的定义，不会删除数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- drop view 视图名[,视图名…];</span><br><span class="line">drop view if exists view_student;</span><br></pre></td></tr></table></figure>
<h1>存储过程</h1>
<p>SQL 语言层面的代码封装与重用，可以实现一些比较复杂的逻辑功能，类似于JAVA语言中的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delimiter 自定义结束符号</span><br><span class="line">create procedure 储存名([ in ,out ,inout ] 参数名 数据类形...)</span><br><span class="line">begin</span><br><span class="line">  sql语句</span><br><span class="line">end 自定义的结束符合</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">-- 自定义结束符</span><br><span class="line">delimiter $$</span><br><span class="line">-- 创建</span><br><span class="line">create procedure proc01()</span><br><span class="line">begin</span><br><span class="line"> select empno,ename from emp;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">-- 调用</span><br><span class="line">call proc01;</span><br></pre></td></tr></table></figure>
<h2 id="变量定义">变量定义</h2>
<h3 id="局部变量">局部变量</h3>
<p>用户自定义，在 begin/end 块中有效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 语法(声明变量)： </span><br><span class="line">declare 变量名 变量类型及范围 [default var_value]; </span><br><span class="line"></span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc02()</span><br><span class="line">begin</span><br><span class="line">	declare var_name01 varchar(20) default &#x27;aaa&#x27;;	-- 定义局部变量</span><br><span class="line">	set var_name01 = &#x27;张三&#x27;;	-- 给变量赋值</span><br><span class="line">	select var_name01;	-- 输出变量的值</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line">-- 调用存储过程</span><br><span class="line">call proc02();</span><br><span class="line"></span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc02()</span><br><span class="line">begin</span><br><span class="line">	-- 定义局部变量</span><br><span class="line">	declare var_name01 decimal(7,2);	-- 长度7，小数2</span><br><span class="line">	set var_name01 = 12.2;	-- 给变量赋值</span><br><span class="line">	select var_name01;	-- 输出变量的值</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">call proc02();</span><br></pre></td></tr></table></figure>
<p>还可以使用 <strong>SELECT…INTO</strong> 语句为变量赋值</p>
<p>当将查询结果赋值给变量时，返回结果只能是单行单列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select col_name [...] into var_name[,...] </span><br><span class="line">from table_name wehre condition </span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">col_name：查询字段名称</span><br><span class="line">var_name：变量名称</span><br><span class="line">table_name：表的名称</span><br><span class="line">condition：查询条件	*/</span><br><span class="line"></span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc03()</span><br><span class="line">begin</span><br><span class="line">	declare my_ename varchar(20);</span><br><span class="line">	-- 从emp表中查询empno为1001的ename赋值给变量my_ename</span><br><span class="line">	select ename into my_ename from emp where empno=1001;</span><br><span class="line">	-- 输出变量的值</span><br><span class="line">	select my_ename;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line">-- 调用存储过程</span><br><span class="line">call proc03();</span><br></pre></td></tr></table></figure>
<h3 id="用户变量">用户变量</h3>
<p>用户自定义，当前会话(连接)有效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 语法(不需要提前声明，使用即声明)： </span><br><span class="line">@var_name</span><br><span class="line"></span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc04()</span><br><span class="line">begin</span><br><span class="line">	set @var_name01 = &#x27;ZS&#x27;;</span><br><span class="line">	select @var_name01;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line">call proc04();</span><br><span class="line"></span><br><span class="line">-- 外部也可以访问用户变量</span><br><span class="line">select @var_name01;</span><br></pre></td></tr></table></figure>
<h3 id="系统变量">系统变量</h3>
<p>对全局变量的修改会影响到整个服务器，但是对会话变量的修改，只会影响到当前的会话（也就是当前的数据库连接）</p>
<h4 id="全局变量">全局变量</h4>
<p>由服务器自动将它们初始化为默认值，可以通过更改 <code>my.ini</code> 这个文件来更改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 语法：</span><br><span class="line">@@global.var_name</span><br><span class="line"></span><br><span class="line">-- 查看全局变量</span><br><span class="line">show global variables;</span><br><span class="line"></span><br><span class="line">-- 查看某全局变量</span><br><span class="line">select @@global.auto_increment_increment;</span><br><span class="line"></span><br><span class="line">-- 修改全局变量的值</span><br><span class="line">set global sort_buffer_size = 40000;</span><br><span class="line">set @@global.sort_buffer_size = 33000;</span><br></pre></td></tr></table></figure>
<h4 id="会话变量">会话变量</h4>
<p>每次建立一个新的连接的时候，MYSQL会将当前所有全局变量的值复制一份，来做为会话变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 语法：</span><br><span class="line">@@session.var_name</span><br><span class="line"></span><br><span class="line">-- 查看会话变量</span><br><span class="line">show session variables;</span><br><span class="line"></span><br><span class="line">-- 查看某会话变量 </span><br><span class="line">select @@session.auto_increment_increment;</span><br><span class="line"></span><br><span class="line">-- 修改会话变量的值</span><br><span class="line">set session sort_buffer_size = 50000; </span><br><span class="line">set @@session.sort_buffer_size = 50000 ;</span><br></pre></td></tr></table></figure>
<h2 id="参数传递">参数传递</h2>
<h3 id="in">in</h3>
<p>传入的参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 传入员工编号，查找员工信息</span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc06(in empno01 int)</span><br><span class="line">begin</span><br><span class="line">	select * from emp where empno = empno01;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">call proc06(1001);</span><br><span class="line"></span><br><span class="line">-- 封装有参数的存储过程，可以通过传入部门名和薪资，查询指定部门，并且薪资大于指定值的员工信息</span><br><span class="line">delimiter $$</span><br><span class="line">create procedure dec_param0x(in dname varchar(50), in sal decimal(7,2))</span><br><span class="line">begin</span><br><span class="line">        select * from dept a, emp b where b.sal &gt; sal and a.dname = dname;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">call dec_param0x(&#x27;学工部&#x27;,20000);</span><br></pre></td></tr></table></figure>
<h3 id="out">out</h3>
<p>从存储过程内部传值给调用者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">create procedure proc08(in in_empno int, out out_ename varchar(50))</span><br><span class="line">begin</span><br><span class="line">	-- 查询emp表中empno与传进来的参数in_empno一致的ename并且赋值给out_ename返回</span><br><span class="line">	select ename into out_ename from emp where empno = in_empno;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">call proc08(1001,@o_ename);</span><br><span class="line">select @o_ename;</span><br><span class="line"></span><br><span class="line">-- 封装有参数的存储过程，传入员工编号，返回员工名字和薪资</span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc09(in empno int , out out_ename varchar(50) , out out_sal decimal(7,2))</span><br><span class="line">begin</span><br><span class="line">  select ename,sal into out_ename,out_sal from emp where emp.empno = empno;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"> </span><br><span class="line">call proc09(1001, @o_dname,@o_sal);</span><br><span class="line">select @o_dname;</span><br><span class="line">select @o_sal;</span><br></pre></td></tr></table></figure>
<h3 id="inout">inout</h3>
<p>从外部传入的参数经过修改后返回的变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">create procedure proc10(inout num int)</span><br><span class="line">begin</span><br><span class="line">	set num = num * 10;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">set @inout_num = 3;</span><br><span class="line">call proc10(@inout_num);</span><br><span class="line">select @inout_num;</span><br><span class="line"></span><br><span class="line">-- 传入员工名，拼接部门号，传入薪资，求出年薪</span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc10(inout inout_ename varchar(50), inout inout_sal int)</span><br><span class="line">begin</span><br><span class="line">  select  concat(deptno,&quot;_&quot;,inout_ename) into inout_ename from emp where ename = inout_ename;</span><br><span class="line">  set inout_sal = inout_sal * 12;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">set @inout_ename = &#x27;关羽&#x27;;</span><br><span class="line">set @inout_sal = 3000;</span><br><span class="line">call proc10(@inout_ename, @inout_sal) ;</span><br><span class="line">select @inout_ename ;</span><br><span class="line">select @inout_sal ;</span><br></pre></td></tr></table></figure>
<h2 id="流程控制">流程控制</h2>
<h3 id="分支语句">分支语句</h3>
<h4 id="if">if</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 语法</span><br><span class="line">if search_condition_1 then statement_list_1</span><br><span class="line">    [elseif search_condition_2 then statement_list_2] ...</span><br><span class="line">    [else statement_list_n]</span><br><span class="line">end if</span><br><span class="line"></span><br><span class="line">-- 输入学生的成绩，来判断成绩的级别：</span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc_12_if(in score int)</span><br><span class="line">begin</span><br><span class="line">	if score &lt; 60</span><br><span class="line">		then</span><br><span class="line">			select &#x27;不及格&#x27;;</span><br><span class="line">	elseif score &lt; 80</span><br><span class="line">		then</span><br><span class="line">			select &#x27;及格&#x27;;</span><br><span class="line">	elseif score &gt;= 80 and score &lt; 90</span><br><span class="line">		then</span><br><span class="line">			select &#x27;良好&#x27;;</span><br><span class="line">	elseif score &gt;= 90 and socre &lt;= 100</span><br><span class="line">		then</span><br><span class="line">			select &#x27;优秀&#x27;;</span><br><span class="line">	end if;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">call proc_12_if(88);</span><br><span class="line"></span><br><span class="line">-- 输入员工的名字，判断工资的情况。</span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc12_if(in in_ename varchar(50))</span><br><span class="line">begin</span><br><span class="line">    declare result varchar(20);</span><br><span class="line">    declare var_sal decimal(7,2);</span><br><span class="line">        select sal into  var_sal from emp where ename = in_ename;</span><br><span class="line">    if var_sal &lt; 10000 </span><br><span class="line">        then set result = &#x27;试用薪资&#x27;;</span><br><span class="line">    elseif var_sal &lt; 30000</span><br><span class="line">        then set result = &#x27;转正薪资&#x27;;</span><br><span class="line">    else </span><br><span class="line">        set result = &#x27;元老薪资&#x27;;</span><br><span class="line">    end if;</span><br><span class="line">    select result;</span><br><span class="line">end$$</span><br><span class="line">delimiter ;</span><br><span class="line">call proc12_if(&#x27;庞统&#x27;);</span><br></pre></td></tr></table></figure>
<h4 id="case">case</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 语法一（类比java的switch）：</span><br><span class="line">case case_value</span><br><span class="line">    when when_value then statement_list</span><br><span class="line">    [when when_value then statement_list] ...</span><br><span class="line">    [else statement_list]</span><br><span class="line">end case</span><br><span class="line"></span><br><span class="line">-- 语法二：</span><br><span class="line">case</span><br><span class="line">    when search_condition then statement_list</span><br><span class="line">    [when search_condition then statement_list] ...</span><br><span class="line">    [else statement_list]</span><br><span class="line">end case</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">create procedure pro14_case(in pay_type int)</span><br><span class="line">begin</span><br><span class="line">	case pay_type</span><br><span class="line">		when 1 then select &#x27;微信支付&#x27;;</span><br><span class="line">		when 2 then select &#x27;支付宝支付&#x27;;</span><br><span class="line">		when 3 then select &#x27;银行卡支付&#x27;;</span><br><span class="line">		else select &#x27;其它支付&#x27;;</span><br><span class="line">	end case;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">call pro14_case(2);</span><br><span class="line"></span><br><span class="line">-- 语法二</span><br><span class="line">delimiter  $$</span><br><span class="line">create procedure proc_15_case(in score int)</span><br><span class="line">begin</span><br><span class="line">	case</span><br><span class="line">		when score &lt; 60 </span><br><span class="line">		then</span><br><span class="line">			select &#x27;不及格&#x27;;</span><br><span class="line">		when  score &lt; 80</span><br><span class="line">		then</span><br><span class="line">			select &#x27;及格&#x27; ;</span><br><span class="line">		when score &gt;= 80 and score &lt; 90</span><br><span class="line">		then </span><br><span class="line">			select &#x27;良好&#x27;;</span><br><span class="line">		when score &gt;= 90 and score &lt;= 100</span><br><span class="line">		then</span><br><span class="line">			select &#x27;优秀&#x27;;</span><br><span class="line">		else</span><br><span class="line">			select &#x27;成绩错误&#x27;;</span><br><span class="line">	end case;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">call proc_15_case(88);</span><br></pre></td></tr></table></figure>
<h3 id="循环语句">循环语句</h3>
<p>leave：类似于 break，跳出，结束当前所在的循环</p>
<p>iterate：类似于 continue，继续，结束本次循环，继续下一次</p>
<h4 id="while">while</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【标签:】while 循环条件 do</span><br><span class="line">    循环体;</span><br><span class="line">end while【标签】;</span><br><span class="line"></span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc16_while(in insertCount int)</span><br><span class="line">begin</span><br><span class="line">	declare i int default 1;</span><br><span class="line">	while i &lt;= insertCount do</span><br><span class="line">		insert into user(uid,username,password) values(i,concat(&#x27;user-&#x27;,i),&#x27;123456&#x27;);</span><br><span class="line">		set i = i +1;</span><br><span class="line">	end while;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">call proc16_while(10);</span><br></pre></td></tr></table></figure>
<p>leave：跳出整个循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 只插入前五条数据</span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc17_leave(in insertCount int)</span><br><span class="line">begin</span><br><span class="line">	declare i int default 1;</span><br><span class="line">	label:while i &lt;= insertCount do</span><br><span class="line">		insert into user(uid,username,password) values(i,concat(&#x27;user-&#x27;,i),&#x27;123456&#x27;);</span><br><span class="line">		if i = 5 then</span><br><span class="line">			leave label;</span><br><span class="line">		end if;</span><br><span class="line">		set i = i +1;</span><br><span class="line">	end while label;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">call proc17_leave(10);</span><br></pre></td></tr></table></figure>
<p>iterate：跳出本次循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">create procedure proc18_iterate(in insertCount int)</span><br><span class="line">begin</span><br><span class="line">	declare i int default 0;</span><br><span class="line">	label:while i &lt; insertCount do</span><br><span class="line">		set i = i +1;</span><br><span class="line">		if i = 5 then</span><br><span class="line">			iterate label;</span><br><span class="line">		end if;</span><br><span class="line">		insert into user(uid,username,password) values(i,concat(&#x27;user-&#x27;,i),&#x27;123456&#x27;);</span><br><span class="line">	end while label;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">call proc18_iterate(10);</span><br></pre></td></tr></table></figure>
<h4 id="repeat">repeat</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 条件表达式为真时跳出循环</span><br><span class="line">[标签:]repeat </span><br><span class="line"> 循环体;</span><br><span class="line">until 条件表达式</span><br><span class="line">end repeat [标签];</span><br><span class="line"></span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc18_repeat(in insertCount int)</span><br><span class="line">begin</span><br><span class="line">	declare i int default 1;</span><br><span class="line">	repeat</span><br><span class="line">		insert into user(uid,username,password) values(i,concat(&#x27;user-&#x27;,i),&#x27;123456&#x27;);</span><br><span class="line">		set i = i +1;</span><br><span class="line">		until i &gt; insertCount</span><br><span class="line">	end repeat;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">call proc18_repeat(10);</span><br></pre></td></tr></table></figure>
<h4 id="loop">loop</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标签: loop</span><br><span class="line">  循环体;</span><br><span class="line">  if 条件表达式 then </span><br><span class="line">     leave 标签; </span><br><span class="line">  end if;</span><br><span class="line">end loop;</span><br><span class="line"></span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc19_loop(in insertCount int)</span><br><span class="line">begin</span><br><span class="line">	declare i int default 1;</span><br><span class="line">	label: loop</span><br><span class="line">		insert into user(uid,username,`password`) values(i,concat(&#x27;user-&#x27;,i),&#x27;123456&#x27;);</span><br><span class="line">		set i = i+1;</span><br><span class="line">		if i &gt; insertCount</span><br><span class="line">			then</span><br><span class="line">				leave label;</span><br><span class="line">		end if;</span><br><span class="line">	end loop label;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">call proc19_loop(20);</span><br></pre></td></tr></table></figure>
<h2 id="游标">游标</h2>
<p>用来存储查询结果集的数据类型, 在存储过程和函数中可以使用光标对结果集进行循环的处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 声明语法</span><br><span class="line">declare 游标名 cursor for 结果集;</span><br><span class="line"></span><br><span class="line">-- 打开语法</span><br><span class="line">open 游标名;</span><br><span class="line"></span><br><span class="line">-- 取值语法，需要定义变量来保存结果集每一列</span><br><span class="line">fetch 游标名 into 变量名 [, 变量名1] ...;</span><br><span class="line"></span><br><span class="line">-- 关闭语法</span><br><span class="line">close 游标名;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">create procedure proc19_cursor(in in_dname varchar(50))</span><br><span class="line">begin</span><br><span class="line">	-- 定义局部变量</span><br><span class="line">	declare var_empno int;</span><br><span class="line">	declare var_ename varchar(50);</span><br><span class="line">	declare var_sal decimal(7,2);</span><br><span class="line"></span><br><span class="line">	-- 声明游标</span><br><span class="line">	declare my_cursor cursor for</span><br><span class="line">		select empno,ename,sal</span><br><span class="line">		from dept a,emp b</span><br><span class="line">		where a.deptno = b.deptno and a.dname = in_dname;</span><br><span class="line">	-- 打开语法</span><br><span class="line">	open my_cursor;</span><br><span class="line">	-- 取值语法</span><br><span class="line">	label: loop</span><br><span class="line">		fetch my_cursor into var_empno, var_ename, var_sal;</span><br><span class="line">		select var_empno, var_ename, var_sal;</span><br><span class="line">	end loop label;	-- 后续需要用句柄来结束循环</span><br><span class="line">	-- 关闭语法</span><br><span class="line">	close my_cursor;</span><br><span class="line">end $$;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">call proc19_cursor(&#x27;销售部&#x27;);</span><br></pre></td></tr></table></figure>
<h2 id="异常处理">异常处理</h2>
<p>存储过程提供了对异常处理的功能：通过定义HANDLER来完成异常声明的实现</p>
<p>在语法中，变量声明、游标声明、handler声明是必须按照先后顺序书写的，否则创建存储过程出错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare handler_action handler</span><br><span class="line">    FOR condition_value [, condition_value] ...</span><br><span class="line">    statement</span><br><span class="line"></span><br><span class="line">/* handler_action：CONTINUE(继续向下执行)、 EXIT(退出程序)、UNDO</span><br><span class="line">condition_value：</span><br><span class="line">	mysql_error_code(错误码)</span><br><span class="line">	condition_name(错误条件的名称)</span><br><span class="line">	SQLWARNING(警告条件)</span><br><span class="line">	NOT FOUND(没有找到数据)</span><br><span class="line">	SQLEXCEPTION(异常条件)</span><br><span class="line">statement：异常触发之后执行什么</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use mysql7_procedure;</span><br><span class="line">drop procedure if exists proc21_cursor_handler;</span><br><span class="line">-- 需求：输入一个部门名，查询该部门员工的编号、名字、薪资 ，将查询的结果集添加游标</span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc20_cursor(in in_dname varchar(50))</span><br><span class="line">begin</span><br><span class="line">  -- 定义局部变量</span><br><span class="line">    declare var_empno int;</span><br><span class="line">    declare var_ename varchar(50);</span><br><span class="line">    declare var_sal decimal(7,2);</span><br><span class="line"></span><br><span class="line">    declare flag int default 1; -- ---------------------</span><br><span class="line"></span><br><span class="line">    -- 声明游标</span><br><span class="line">    declare my_cursor cursor for</span><br><span class="line">        select empno,ename,sal</span><br><span class="line">        from dept a, emp b</span><br><span class="line">        where a.deptno = b.deptno and a.dname = in_dname;</span><br><span class="line"></span><br><span class="line">    -- 定义句柄，当数据未发现时将标记位设置为0</span><br><span class="line">    declare continue handler for not found set flag = 0;   </span><br><span class="line">    -- 打开游标</span><br><span class="line">    open my_cursor;</span><br><span class="line">    -- 通过游标获取值</span><br><span class="line">    label:loop</span><br><span class="line">        fetch my_cursor into var_empno, var_ename,var_sal;</span><br><span class="line">        -- 判断标志位</span><br><span class="line">        if flag = 1 then</span><br><span class="line">            select var_empno, var_ename,var_sal;</span><br><span class="line">        else</span><br><span class="line">            leave label;</span><br><span class="line">        end if;</span><br><span class="line">    end loop label;</span><br><span class="line"></span><br><span class="line">    -- 关闭游标</span><br><span class="line">    close my_cursor;</span><br><span class="line">end $$;</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br><span class="line">call proc21_cursor_handler(&#x27;销售部&#x27;);</span><br></pre></td></tr></table></figure>
<p>综合：每天一张表，存当天的统计数据，就要求提前生产这些表——每月月底创建下一个月每天的表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 使用数据库mysql7_procedure</span><br><span class="line">use mysql7_procedure;</span><br><span class="line"></span><br><span class="line">-- 如果存在同名的存储过程，则删除它</span><br><span class="line">drop procedure if exists proc22_demo;</span><br><span class="line"></span><br><span class="line">-- 更改默认的语句结束符，以便在存储过程中可以使用分号</span><br><span class="line">delimiter $$</span><br><span class="line"></span><br><span class="line">-- 创建存储过程proc22_demo</span><br><span class="line">create procedure proc22_demo()</span><br><span class="line">begin</span><br><span class="line">  -- 声明整型变量用于存储年份、月份和月份中的天数</span><br><span class="line">  declare next_year int;</span><br><span class="line">  declare next_month int;</span><br><span class="line">  declare next_month_day int;</span><br><span class="line">  </span><br><span class="line">  -- 声明字符型变量用于存储格式化的月份和天数</span><br><span class="line">  declare next_month_str char(2);</span><br><span class="line">  declare next_month_day_str char(2);</span><br><span class="line">  </span><br><span class="line">  -- 声明字符型变量用于存储表名</span><br><span class="line">  declare table_name_str char(10);</span><br><span class="line">  </span><br><span class="line">  -- 声明整型变量作为循环索引，并初始化为1</span><br><span class="line">  declare t_index int default 1;</span><br><span class="line"></span><br><span class="line">  -- 获取下个月的年份</span><br><span class="line">  set next_year = year(date_add(now(), INTERVAL 1 month));</span><br><span class="line"></span><br><span class="line">  -- 获取下个月是几月</span><br><span class="line">  set next_month = month(date_add(now(), INTERVAL 1 month));</span><br><span class="line"></span><br><span class="line">  -- 获取下个月最后一天是几号</span><br><span class="line">  set next_month_day = dayofmonth(LAST_DAY(date_add(now(), INTERVAL 1 month)));</span><br><span class="line"></span><br><span class="line">  -- 如果月份小于10，则在前面补零</span><br><span class="line">  if next_month &lt; 10 then</span><br><span class="line">    set next_month_str = concat(&#x27;0&#x27;, next_month);</span><br><span class="line">  else</span><br><span class="line">    set next_month_str = concat(&#x27;&#x27;, next_month);</span><br><span class="line">  end if;</span><br><span class="line"></span><br><span class="line">  -- 循环直到下个月的最后一天</span><br><span class="line">  while t_index &lt;= next_month_day do</span><br><span class="line">    -- 如果天数小于10，则在前面补零</span><br><span class="line">    if t_index &lt; 10 then</span><br><span class="line">      set next_month_day_str = concat(&#x27;0&#x27;, t_index);</span><br><span class="line">    else</span><br><span class="line">      set next_month_day_str = concat(&#x27;&#x27;, t_index);</span><br><span class="line">    end if;</span><br><span class="line"></span><br><span class="line">    -- 构建表名，格式为：user_YYYY_MM_DD</span><br><span class="line">    set table_name_str = concat(next_year, &#x27;_&#x27;, next_month_str, &#x27;_&#x27;, next_month_day_str);</span><br><span class="line"></span><br><span class="line">    -- 拼接创建表的SQL语句</span><br><span class="line">    set @create_table_sql = concat(</span><br><span class="line">      &#x27;create table user_&#x27;,</span><br><span class="line">      table_name_str,</span><br><span class="line">      &#x27;(`uid` INT, `ename` varchar(50), `information` varchar(50)) COLLATE=\&#x27;utf8_general_ci\&#x27; ENGINE=InnoDB&#x27;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    -- 准备并执行动态SQL语句</span><br><span class="line">    prepare create_table_stmt FROM @create_table_sql;</span><br><span class="line">    execute create_table_stmt;</span><br><span class="line">    -- 释放预编译语句</span><br><span class="line">    DEALLOCATE prepare create_table_stmt;</span><br><span class="line"></span><br><span class="line">    -- 更新循环索引</span><br><span class="line">    set t_index = t_index + 1;</span><br><span class="line">  end while;</span><br><span class="line">end $$</span><br><span class="line">-- 将语句结束符改回分号</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">-- 调用存储过程proc22_demo</span><br><span class="line">call proc22_demo();</span><br></pre></td></tr></table></figure>
<h1>存储函数(自定义函数)</h1>
<p>一般用于计算和返回一个值，可以将经常需要使用的计算或功能写成一个函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create function func_name ([param_name type[,...]])</span><br><span class="line">returns type</span><br><span class="line">[characteristic ...] </span><br><span class="line">begin</span><br><span class="line">    routine_body</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">参数说明：</span><br><span class="line">    func_name ：存储函数的名称</span><br><span class="line">    param_name type：可选项，指定存储函数的参数</span><br><span class="line">    type参数用于指定存储函数的参数类型，该类型可以是MySQL数据库中所有支持的类型</span><br><span class="line">    RETURNS type：指定返回值的类型</span><br><span class="line">    characteristic：可选项，指定存储函数的特性</span><br><span class="line">    routine_body：SQL代码内容	*/</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 允许创建函数权限</span><br><span class="line">set global log_bin_trust_function_creators = true;</span><br><span class="line">-- 创建存储函数-没有输输入参数</span><br><span class="line">delimiter $$</span><br><span class="line">create function myfunc1_emp() returns int</span><br><span class="line">begin</span><br><span class="line">	-- 定义局部变量</span><br><span class="line">	declare cnt int default 0;</span><br><span class="line">	select count(*) into cnt from emp;</span><br><span class="line">	return cnt;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">-- 调用存储函数</span><br><span class="line">select myfunc1_emp();</span><br><span class="line"></span><br><span class="line">-- 创建存储过程-有输入参数</span><br><span class="line">-- 传入一个员工编号，返回员工名字</span><br><span class="line">delimiter $$</span><br><span class="line">create function myfun2_emp(in_empno int) returns varchar(50)</span><br><span class="line">begin</span><br><span class="line">	declare out_ename varchar(50);</span><br><span class="line">	select ename into out_ename from emp where empno = in_empno;</span><br><span class="line">	return out_ename;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">-- 调用存储函数</span><br><span class="line">select myfun2_emp(1008);</span><br></pre></td></tr></table></figure>
<h1>触发器</h1>
<h1>索引</h1>
<h1>事务</h1>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>24.多线程</title>
    <url>/post/fbc0ae86.html</url>
    <content><![CDATA[<h1><center>知识点一：Thread线程基础</center></h1>
<p>有一个场景：在一个程序中即可以玩游戏又可以播放音乐？</p>
<p>以现在编程手段而言 —》 提供编程结构【顺序、分支、循环】</p>
<p>代码是要遵守顺序执行，代码需要遵守从上至下逐行执行，利用分支和循环修改循环执行一些操作，选择性执行某代码或者是让某些代码重复执行，无论如何操作代码依旧要顺序执行，没有办法让两段代交替执行</p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012202919.WebP" alt="线程流程" style="zoom: 50%;">
<p>此时Java为了解决这样的问题，提供一个操作，这个操作就叫做<strong>线程</strong>，可以在代码中使用多线程形式来完成这个操作</p>
<p>PS:现在电脑基本上都是多核CPU，所以每个人电脑上运行线程程序结果可能都不一样，这是一个非常正常现象，多线程运行时是一个不可预知状态，程序猿可以通过代码干预线程运行，以达到我们运行效果</p>
<h1><center>知识点二：并行和并发</center></h1>
<p>这两个概念在宏观的角度而言他们是一样(相似)的，但是在微观的角度而言他们是有区别</p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012203194.WebP" alt="并行和并发" style="zoom:50%;">
<p><strong>并行就是同时执行，并发就是在交替执行</strong></p>
<p>    在操作系统中，安装了很多程序，并发指的是在一段时间内宏观上多个程序同时执行，这个在单个CPU系统中，每一个时刻只有一个程序执行，即微观上这些程序是分时交替的执行，只不过给人感觉是在同时运行，因为分时交替运行时间非常短暂</p>
<p>    现在而言都是多核CPU，则这些并发执行程序可以分配到不同的处理器上（CPU），实现多个任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序就可以同时执行了，你的电脑CPU核心越多你电脑的性能就相对更加强悍</p>
<p>PS:单核处理的计算机肯定是不能并行处理多个任务，只能是多个任务在单个CPU上并发需要运行，同理线程也是一样的从宏观的角度而言线程并行运行从微观角度看就是串行运行，即线程是一个一个去执行的，当系统只有一个CPU是，线程会以某种顺序执行多个线程，这个情况称之线程调度【线程提供CPU时间争抢】</p>
<h1><center>知识点三：线程和进程</center></h1>
<p><strong>进程</strong></p>
<p>    进程是程序的一次执行过程，是系统运行程序的基本单元，系统运行一个程序即在运行一个进程【从创建、运行、消亡的一个过程】，每一个进程都有自己一个独立的空间【内存空间】，一个应用程序(进程)可以同时运行多个线程</p>
<p>特点：</p>
<ol>
<li>进程是一个独立程序单元并且拥有自己独立空间</li>
<li>一个进程中可以同时运行多个线程</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012204035.WebP" alt="进程" style="zoom:50%;">
<p>进程是可以完成多个任务交替执行的，可以开发一个音乐软件（QQ音乐、网易云音乐、酷狗音乐），也可以开发一个打游戏软件（L0L、吃鸡战场、Dota2），只要运行这两个进程程序就可以完成一边听音乐，一边打游戏，这样做开发成本高，进行是独立的进程与进程之间是无法进行“<strong>通信</strong>”的</p>
<p><strong>线程</strong></p>
<p>    线程是进程中一个内部执行单元，负责当前进程中的程序执行，一个进程中至少有一个线程，一个进程可以有多个线程，这些线程在进程中被称之为“多线程”，进程就可以利用这些多线程，去完成不同操作</p>
<p>特点:</p>
<ol>
<li>线程是在进程的内部执行，并且可以存在多个，彼此之间共享进程的内存区域</li>
<li>线程与线程之间彼此独立，但是可以进行“通信”</li>
</ol>
<p>可以利用这个轻量级的开发完成一个进程内部程序交替执行效果（线程并发执行）</p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012205517.WebP" alt="线程" style="zoom:50%;">
<p>总结进程与线程的区别：</p>
<p>    进程： 有独立的内存空间，进程中数据存放的空间是独立的并且至少有一个线程</p>
<p>    线程：堆空间是共享的，栈空间是独立的，线程消耗的资源要比进程小，并且可以多个线程存在同一个进程中</p>
<p>PS:需要知道了解的知识点：</p>
<ol>
<li>因为一个程序中有多个线程并发运行，那么从微观的角度而言是有先后顺序的，那么线程执行的顺序是取决于CPU的调度【线程争抢CPU时间片】，程序猿只能进行干涉，在不加干涉前提下线程执行就会出现很多随机性</li>
<li>Java程序进程中最少包含两个线程，一个是主线程就是main()方法【它在执行方法是或者执行程序时它的优先级永远最高】，另外一个垃圾回收机制线程(GC)【守护线程】，每当Java执行一个类的时候，实际上都会启动一个JVM，每一个JVM实际上就是在操作系统中启动了一个线程，Java本身就被垃圾回收机制所守护，所Java运行时至少启动了两个线程</li>
<li>由于创建一个线程开销远比创建一个进程开销要小很多，那么我们在开发多任务运行时，通常会优先考虑创建多线程，而不是多进程</li>
<li>所有的线程轮流使用CPU，每一个线程都会得到CPU分配的时间片，这个分配“尽量”平均分配CPU资源，但是这个效果不一定能达到，所以同优先级的线程对CPU时间的争抢是存在随机性的，可以对线程进行优先级设置来概念获取CPU时间片的几率，优先级越高几率越大，优先级越低几率越小</li>
</ol>
<h1><center>知识点四：Java程序中实现线程的方式</center></h1>
<p>在Java中主要创建线程方式有四种：</p>
<ol>
<li>继承Thread类，此时子类就是线程类</li>
<li>实现Runnable接口，此时实现类不是线程类，使用Thread类才可成为线程</li>
</ol>
<p><strong>无论是上述两种方式中那种方式都需必须重写run方法实现线程逻辑</strong></p>
<ol start="3">
<li>实现Callable接口， 此实现方方式并不是线程类，主要针对的是线程池提供</li>
<li>线程池可以帮组我们创建线程并进行管理操作</li>
</ol>
<p>如果实现线程需要继承Thread或实现Runnable接口，但是无论是那种都需要实现一个必要核心方法</p>
<p><strong>这个run方法是提供线程实现的核心逻辑，需要线程什么样需求代码，就将将代码写入到这个线程中</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">void</th>
<th style="text-align:center">run() 使用实现接口 Runnable 的对象创建一个线程时，启动该线程将导致在独立执行的线程中调用对象的 run方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><strong>PS：通过观察可以发现这个run方法是没有参数和返回值类型，所以这个run不能通过方法接收参数和返回数据值</strong></td>
</tr>
</tbody>
</table>
<h2 id="center-1-线程创建方式之继承thread类-center"><center>1、线程创建方式之继承Thread类</center></h2>
<p>步骤：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 定义一个普通类继承与`java.lang.Thread`类</span><br><span class="line"><span class="number">2.</span> 在子类中重新给父类Thread中run方法并提供线程实现逻辑</span><br><span class="line"><span class="number">3.</span> 在测试类中main方法中，通过线程子类或Thread这个父类创建线程对象并执行线程启动完成调用run方法中逻辑执行</span><br></pre></td></tr></table></figure>
<p>PS：因为Thread本身就是线程类，所以继承Thread类子类也是线程类，具备父类中Thread所提供的所有操作者线程方法</p>
<p>需求：使用继承Thread类方法是完成边打游戏和边听音乐</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为了演示效果方便观察写在同一个文件中</span></span><br><span class="line"><span class="comment">//此时GameThread继承与Thread类所以GameThread就是线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//必须重写Thread父类中的run方法，提供这个线程需要的执行逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span> ; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;打游戏：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//此时MusicThread继承与Thread类所以GameThread就是线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MusicThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//必须重写Thread父类中的run方法，提供这个线程需要的执行逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span> ; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;听音乐：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//提供一个测试类完成线程创建与调用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//main方法本身一个线程，主线线程优先级最高</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如何创建线程对象</span></span><br><span class="line">        <span class="comment">//下面两种创建线程方式并没有指定线程优先级，所以都是默认优先级athread和bthread的优先级相同</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1. 使用多态的效果【Thread是子线程类父类，所以可以使用Thread方式创建】</span></span><br><span class="line"><span class="comment">                Thread 线程对象的名字 = new 子线程类();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GameThread</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            2. 直接使用继承线程子类创建对象</span></span><br><span class="line"><span class="comment">                子线程类 线程对象的名字 = new 子线程类();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">MusicThread</span> <span class="variable">bthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicThread</span>();</span><br><span class="line">        <span class="comment">//启动线程执行 ---》调用 Thread类中提供 start方法 ，而不是调用run方法</span></span><br><span class="line">        athread.start();</span><br><span class="line">        bthread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-2-线程创建方式之实现runnable接口-center"><center>2、线程创建方式之实现Runnable接口</center></h2>
<p>PS：<strong>实现Runnable接口的类并不是线程类，只是实现Runnable接口并提供run方法的重写，需要配合使用Thread类创建线程对象，此时线程才可以操作</strong>。因为Runnable接口中提供run方法的实现【实现Runnable接口的类】，传入到Thread类中时，就会覆盖Thread类中run方法，所以Thread提供创建线程对象就会执行重写Runnable接口中run方法，就会得到线程的效果</p>
<p>步骤:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 定义一个普通类实现Runnable接口</span><br><span class="line"><span class="number">2.</span> 实现Runnable接口的类必须重写run方法提供线程需要执行的逻辑</span><br><span class="line"><span class="number">3.</span> 在测试类中main方法中，使用Thread创建线程对象完成线程操作</span><br></pre></td></tr></table></figure>
<p>需求：使用继承Thread类方法是完成边打游戏和边听音乐</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Runnable;</span><br><span class="line"><span class="comment">//为了演示效果方便观察写在同一个文件中</span></span><br><span class="line"><span class="comment">//此类就是实现Runnable接口并提供run方法实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameRunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">1</span>; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;打游戏：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MusicRunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">1</span>; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;听音乐：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建Runnable接口实现类作为Thread线程对象操作</span></span><br><span class="line">        <span class="comment">//需要将Runnable接口的对象传递到Thread这个类中</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1. 先创建Runnable接口实现类的对象，然后再传递到Thread类中进行线程对象创建</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">GameRunnableImpl</span> <span class="variable">gri</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GameRunnableImpl</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(gri);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            2.使用匿名对象的方式进行Thread构造方法Runnable参数传递</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MusicRunnableImpl</span>());</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-3-thread类创建线程和runnable接口创建线程-center"><center>3、Thread类创建线程和Runnable接口创建线程</center></h2>
<p>    两种方式皆可，因为都要实现run方法，但是从类的扩展角度而言，建议使用实现Runnable接口方式来完成作，因为Java中类是单一继承，所以如果继承Thread类就无法在继承其他类，所以就会影响类的扩展，但是如果实现接口方式完成，不仅可以继承一个类还可以实现多个接口所以就比较推荐实现Runnable接口</p>
<p>继承效果：</p>
<p>    class A extends Thread{} //没有办法让A在继承</p>
<p>    class B extends XXXX implements Runnable{} // 不仅可以作为线程类操作而且还可以进行继承其他类</p>
<h2 id="center-4-start方法和run方法-center"><center>4、start方法和run方法</center></h2>
<p>PS：<strong>创建完毕线程对象之后，线程执行需要调用的是start方法而不是run方法</strong></p>
<p>start方法： 用start方法来启动线程，真正的实现了线程运行，通过Thread类中给提供start来启动一个线程，此时线程会进入到“<strong>准备就绪</strong>”状态，但是真正运行，一旦线程获取到CPU时间片，此时线程才会真正的执行，执行调用提供run方法完成线程逻辑</p>
<p>run方法：run方法只是一个普通方法，只是在run方法中实现线程执行逻辑，如果外界直接调用run方法，线程是没有启动，只不过是在main方法调用了run方法执行，执行出run方法提供操作，和线程一点关系都没有</p>
<h2 id="center-5-使用匿名内部类或lambda表达式便捷的创建线程对象并执行-了解-center"><center>5、使用匿名内部类或Lambda表达式便捷的创建线程对象并执行（了解）</center></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousAndLambdaThread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这种方式，线程是现创建现使用，只会使用一次即可</span></span><br><span class="line">        <span class="comment">//1.针对Thread类提供匿名内部类创建【只支持匿名内部类】</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">50</span>;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;听音乐：&quot;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();     <span class="comment">// 在最外侧的大括号中调用start方法</span></span><br><span class="line">        <span class="comment">//2.针对Runnable接口提供匿名内部类和Lambda表达式实现</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">50</span>;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;打游戏：&quot;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start(); <span class="comment">// 在最外侧的大括号中调用start方法</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">50</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;吃饭：&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start(); <span class="comment">// 在最外侧的大括号中调用start方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点五：线程常用方法</center></h1>
<h2 id="center-1-线程状态getstate-center"><center>1、线程状态getState</center></h2>
<p>这个方法可以返回线程运行状态</p>
<p>PS：API有一个静态属性 State【API中给返回类型时错误的，它不是静态类，他是一个枚举】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetStateDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用run方法进行求和操作【GetStateDemo 是 Thread子类</span></span><br><span class="line">        所以会得到所有方法】</span><br><span class="line">        System.out.println(<span class="string">&quot;进入run方法是当前线程状态：&quot;</span> + <span class="built_in">this</span>.getState());</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;=<span class="number">100</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;sum = &quot;</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetStateDemo</span>();</span><br><span class="line">        <span class="comment">//在启动线程之前</span></span><br><span class="line">        System.out.println(<span class="string">&quot;start方法之前线程状态：&quot;</span>+thread.getState());</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;start方法之后线程状态：&quot;</span>+thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以表示线程状态说明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 出生、新生</span></span><br><span class="line"><span class="comment">* 至今尚未启动的线程就是这种状态</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">NEW,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 准备就绪和执行</span></span><br><span class="line"><span class="comment">*PS：Java中提供Thread类并没有提供准备就绪的状态描述，所以RUNNABLE就有两个概念</span></span><br><span class="line"><span class="comment">* 调用start方法时是 ---&gt; 准备就绪</span></span><br><span class="line"><span class="comment">* 执行run方法时是 ---&gt; 执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">RUNNABLE,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 阻塞或睡眠 ---》 sleep方法</span></span><br><span class="line"><span class="comment">* 当线程出现【阻塞状态】，当前线程就会出现让出CPU时间片的操作等待后续执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">BLOCKED,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 等待 ---》 wait</span></span><br><span class="line"><span class="comment">* 等待是无限期等待只有进行唤醒之后等待效果才会消失【等待不是阻塞状态】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">WAITING,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 时间等待</span></span><br><span class="line"><span class="comment">* 在设置等待状态时设置一个时间，只要在时间范围内都是等待状</span></span><br><span class="line"><span class="comment">态，如果到了并且在等待时期并没有进行唤 </span></span><br><span class="line"><span class="comment">* 醒从操作，等待线程会自动唤醒</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">TIMED_WAITING,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 消亡，死亡</span></span><br><span class="line"><span class="comment">* 线程都执行完毕不会在执行就出现这个状态【线程结束】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">TERMINATED;</span><br></pre></td></tr></table></figure>
<h2 id="center-2-线程优先级setpriority-center"><center>2、线程优先级setPriority</center></h2>
<p>理论上线程优先级越高，获取CPU时间片的几率越大，反之获取几率越小</p>
<p>PS：但是优先级只是相当于给CPU一个暗示【先由我开始】，但是CPU是否会决定将时间片给当前线程，是CPU决定</p>
<p>所有在没有修改优先级之前的线程默认优先级都是相同，在Java中使用1~10之间数字表示线程优先级，数值越大优先级越高，所有在没有</p>
<p>修改优先级之前默认优先级是【5】API中提供三个静态常量方便对优先级的定义</p>
<table>
<thead>
<tr>
<th style="text-align:center">static int</th>
<th style="text-align:center">MAX_PRIORITY 线程可以具有的最高优先级【等级10】</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">static int</td>
<td style="text-align:center">MIN_PRIORITY 线程可以具有的最低优先级【等级1】</td>
</tr>
<tr>
<td style="text-align:center">static int</td>
<td style="text-align:center">NORM_PRIORITY 分配给线程的默认优先级【等级5】</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetPriorityDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span> ;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//getName()获取线程名字</span></span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;：i的数值：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//利用线程创建两个线程对象使用默认优先级</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SetPriorityDemo</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">bthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SetPriorityDemo</span>();</span><br><span class="line">        <span class="comment">//可能会出现Thread-0先执行 或 Thread-1先执行</span></span><br><span class="line">        <span class="comment">// athread.start(); // Thread-0</span></span><br><span class="line">        <span class="comment">// bthread.start(); // Thread-1</span></span><br><span class="line">        <span class="comment">//修改优先级</span></span><br><span class="line">        <span class="comment">// 【只要优先级的差别较大就可以的得到先执行和后执行效果】</span></span><br><span class="line">        <span class="comment">// 【只要优先级等级差别不是很大(比较接近)，执行效果就不是很明显了】</span></span><br><span class="line">        athread.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        bthread.setPriority(<span class="number">6</span>);</span><br><span class="line">        athread.start();     <span class="comment">// Thread-0</span></span><br><span class="line">        bthread.start();     <span class="comment">// Thread-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-3-更改和获取线程的名字-center"><center>3、更改和获取线程的名字</center></h2>
<p>线程是有默认名字组成方式 —》 使用到一个关键字“Thread” + “-” +“数字”，数字的从0开始，随着线程创建而逐渐增多，随着线程的减少而逐渐减少 —》 默认名字 【Thread-数字】</p>
<p>在编写线程程序时可以通过<strong>getName方法获取线程名字</strong>，但是如果创建线程过多使用默认名字看到效果就不是很明显</p>
<p>Java中提供线程名字修改方式有三种：</p>
<ol>
<li>在创建出线程对象之后调用setName(“线程新的名字&quot;)</li>
<li>使用类实现Runnable接口并使用Thread类创建线程对象，调用两个参数版本构造方法进行名字设置</li>
</ol>
<p>    Thread(Runnable接口实现类的对象，“线程名字”);</p>
<ol start="3">
<li>使用类继承与Thread类，子类中提供一个仿照父类生成构造方法，这个方法参数是String name，子类只	需要实现这个构造方法即可，在创建线程对象时只需要调用有参构造方法就可以指定线程名字</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetNameDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//方式一</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AThread</span>();</span><br><span class="line">        athread.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        System.out.println(athread.getName());</span><br><span class="line">        <span class="comment">//方式二</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">bthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">BThread</span>(),<span class="string">&quot;线程B&quot;</span>);</span><br><span class="line">        System.out.println(bthread.getName());</span><br><span class="line">        <span class="comment">//方式三</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">cthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CThread</span>(<span class="string">&quot;线程C&quot;</span>);    <span class="comment">//多态</span></span><br><span class="line">        System.out.println(cthread.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//实现Runnable接口不是线程类，所以不能在实现Runnable接口类中调用Thread类中方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;线程的名字：&quot;+getName());</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 如何在实现Runnable接口的类中获取当前线程</span></span><br><span class="line"><span class="comment">        * Thread类中提供一个静态方法currentThread() 可以获取当前线程对象</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;通过静态访获取到线程对象：&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//子类只要仿照生成一个带有String类型参数方法即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CThread</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-4-线程休眠sleep-使用几率极高-center"><center>4、线程休眠sleep【使用几率极高】</center></h2>
<p>sleep这个方法是静态方法，它可以让线程进入到【阻塞状态】即让线程进行到休眠时间，<strong>进入休眠之后线程会让出CPU时间片，给其他的线程进行争抢，当休眠时间到了之后恢复之后线程会继续和其线程进行CPU时间片的争抢</strong></p>
<p>sleep方法的参数是毫秒值 —》 1000毫秒 等于 1秒</p>
<p>线程如果触发sleep方法会有两种方式可以醒来：</p>
<ol>
<li>自然醒来【睡眠时间到了，自动醒来】</li>
<li>中断醒来【会通过Thread类中添加中断标记，强行让sleep醒来】</li>
</ol>
<p>所以sleep方法在调用时候会有一个编译时异常【InterruptedException(中断异常)】</p>
<p><strong>特别注意：如果sleep方法被调用在【同步锁、对象锁、同步监听器、同步代码块】中，sleep方法休眠之后是不会让出当前系统时间片【虽然会睡眠时间片也会释放，但是外界线程是无法获取】</strong></p>
<p>需求：通过sleep方法来实现以下交替执行效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">100</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">5</span> == <span class="number">0</span>)    <span class="comment">//只要i值可以对5整除</span></span><br><span class="line">            &#123; </span><br><span class="line">                System.out.println(<span class="string">&quot;当前线程:&quot;</span>+getName()+<span class="string">&quot;~~~~~~~~~&quot;</span>+i);</span><br><span class="line">                <span class="comment">//在run方法中调用sleep方法是不可以throws异常，只能try-catch抓取</span></span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SleepDemo</span>();</span><br><span class="line">        athread.setName(<span class="string">&quot;子线程&quot;</span>);</span><br><span class="line">        athread.start();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Java程序会默认提供两个线程一个是GC 和 一个是main方法【主线程作为线程操作】</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//在主线程中提供和SleepDemo类中一样的操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i&lt;=<span class="number">100</span> ;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">5</span> ==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前线程：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;~~~~~~~~~&quot;</span>+i);</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sleep方法确实可以让线程进入到休眠状态，并且释放出CPU时间片，但是时间无法正确把控就会造成无法使用sleep方法进行代码的交替执行</p>
<h2 id="center-5-线程礼让yield-了解-center"><center>5、线程礼让yield（了解）</center></h2>
<p>礼让线程的作用就是在调用yield方法的线程中，让出CPU时间片【相当于通知CPU不急着执行】，让出之后CPU会不会回收CPU时间片取决于CPU，礼让原则是：线程优先级越高礼让效果就是会明显一些</p>
<p>yield和sleep方法是有一定区别的，sleep是立即让出CPU时间片，在睡眠时间内是不会争抢CPU时间片，yield方法执行之后，礼让线程会进入“准备就绪”，礼让线程可能会再次持有CPU时间片</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YieldDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程的名字：&quot;</span>+getName()+<span class="string">&quot;~~~~~~~~&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.<span class="keyword">yield</span>(); <span class="comment">//让线程礼让</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建两个线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YieldDemo</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">bthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YieldDemo</span>();</span><br><span class="line">        athread.setName(<span class="string">&quot;a线程&quot;</span>);</span><br><span class="line">        bthread.setName(<span class="string">&quot;b线程&quot;</span>);</span><br><span class="line">        athread.start();</span><br><span class="line">        bthread.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        bthread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-6-线程合并join-center"><center>6、线程合并join</center></h2>
<p>合并线程是一个效果非常明显操作，合并线程是一个线程正处于运行阶段，此时这个线程达到某个条件时，可以让其他线程合并到这个执行线程中，只要使用join合并，合并线程<strong>必然</strong>会得到CPU时间片，被合并的线程需要等待合并线程执行完毕之后才会继续运行</p>
<p>需求：妹子在看葫芦娃【50级】，当看到【10级】汉子要看喜洋洋</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Meizi</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Meizi</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;妹子正在看精钢葫芦娃大战蛇精：&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//启动另外一个线程进行合并操作</span></span><br><span class="line">                <span class="type">Hanzi</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hanzi</span>();</span><br><span class="line">                <span class="comment">//合并之前必要前提：要合并线程必须进入准备就绪状态，即调用start方法</span></span><br><span class="line">                thread.start();</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    thread.join();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hanzi</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;汉子正在看喜羊羊与灰太狼：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程合并必然是让出CPU时间片，CPU时间片会join的线程，线程必须是启动状态【调用start】</p>
<h2 id="center-7-线程中断-标记-center"><center>7、线程中断(标记)</center></h2>
<p>在Thread这个类中提供让线程停止方法 stop方法，但是这个方法被Java进行过时处理，所以就不建议在线程中进行使用了，所以Java就提供一个替代 stop方法的方法 —》interrupt方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptThreadDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">20</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;线程中执行i值是:&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//停止线程 --&gt;过时的stop方法</span></span><br><span class="line">                <span class="comment">// stop();</span></span><br><span class="line">                <span class="comment">//中断线程</span></span><br><span class="line">                interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InterruptThreadDemo</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这个线程中断标记方法向线程中添加【中断标记】，只有被含有中断异常方法检测到这个标记就会终止方法的执行效果【sleep明显 和join不明显】，<strong>直接在线程调用这个方法是无用的</strong>，只是添加标记不会停止线程，配合API中所提供的一个方法来使用【<strong>interrupted</strong>】，作用检查线程中是否存在中断标记，如果存在着返回true，不存在则返回false</p>
<p><strong>正确使用方式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptThreadDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">20</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;线程中执行i值是:&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//使用替代stop方法中断线程时，当遇到某个条件要终止线程时，检查中断标记</span></span><br><span class="line">                <span class="keyword">if</span>(Thread.interrupted())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//停止线程</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">InterruptThreadDemo</span> <span class="variable">interruptThreadDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterruptThreadDemo</span>();</span><br><span class="line">        interruptThreadDemo.start();</span><br><span class="line">        <span class="comment">//向线程中添加中断标记</span></span><br><span class="line">        interruptThreadDemo.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>强行终止睡眠</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.ThreadMethod;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptThreadDemo2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入线程&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;没有被中断正常睡眠苏醒&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;中断睡眠苏醒&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">InterruptThreadDemo2</span> <span class="variable">interruptThreadDemo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterruptThreadDemo2</span>();</span><br><span class="line">        interruptThreadDemo2.start();</span><br><span class="line">        <span class="comment">//为了效果让主线程休眠2秒之后在触发中断标记</span></span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        interruptThreadDemo2.interrupt();  <span class="comment">//如果检查到中断标记就会强行终止睡眠</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点六：火车售票问题</center></h1>
<p>需求：火车站买票，一共有且仅有【100】张票，4个窗口同时贩卖临界资源就是这个票，多个线程访问保证票有且仅有100张，开4个线程同时买100张票</p>
<p>    其实这个卖票案例就是多线程下同时操作一个资源(临界资源),如何保证线程操作资源安全不出现以下情况</p>
<p>    买票不会出现重票 --&gt; 线程1 卖出第99张票 线程2 卖出99张票</p>
<p>    错误票 —&gt; 线程1 卖出第75张票. 线程2 卖出76张票 —&gt; 这个是对</p>
<p>    但是 线程2 卖出49张票</p>
<p>    负数票 —&gt; 某个线程买完最后一张票的时候 剩余线程就不能在卖票0 -1 -2…票</p>
<p>    1秒卖一张 —&gt; 有且仅有100张 —&gt;不要卖出400张票数</p>
<p><strong>问题1：如何将票固定在100张，而不是每个线程都卖出100张票</strong></p>
<p>    如何做到所有的线程都共享这一个资源？</p>
<ol>
<li>将票作为成员变量，作为成员变量之后，需要保证这个提供票的类在外界创建对象必须是唯一的，如果不唯一的，就会出现你创建票的对象每个对象都会唯一，一个成员变量，4个对象就是4个成员变量，此时相当于400张票【单例设计模式】</li>
</ol>
<p>PS：单例设计模式的原则：保证外界无论如何获取对象都是唯一的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//v1基础版本</span></span><br><span class="line"><span class="keyword">package</span> com.qfedu.Thread.SellTicket1;</span><br><span class="line"><span class="comment">//v1版本</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    不要让类继承与Thread，继承Thread必然要提供四个线程对象</span></span><br><span class="line"><span class="comment">    这样就会出现无法控制票100张</span></span><br><span class="line"><span class="comment">    建议实现Runnable，以Runnable实现类方式创建线程处理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供成成员变量存储票的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑</span></span><br><span class="line">            <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)    <span class="comment">//证明还票可以出售</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//买票</span></span><br><span class="line">                System.out.println(<span class="string">&quot;当前售票员[&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;]第&quot;</span>+<span class="string">&quot;[&quot;</span>+(tickets--)+<span class="string">&quot;]票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果提供的是成员变量【保证存储成员变量的这个类所得到对象是必须唯一】</span></span><br><span class="line">        <span class="comment">//出现400张票问题[在构建线程对象时，提供四个Runnable接口实现类对象创建]</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            Thread thread1 = new Thread(new SellTicket1(),&quot;刘德华&quot;);</span></span><br><span class="line"><span class="comment">            Thread thread2 = new Thread(new SellTicket1(),&quot;张学友&quot;);</span></span><br><span class="line"><span class="comment">            Thread thread3 = new Thread(new SellTicket1(),&quot;郭富城&quot;);</span></span><br><span class="line"><span class="comment">            Thread thread4 = new Thread(new SellTicket1(),&quot;吴奇隆&quot;);</span></span><br><span class="line"><span class="comment">            thread1.start();</span></span><br><span class="line"><span class="comment">            thread2.start();</span></span><br><span class="line"><span class="comment">            thread3.start();</span></span><br><span class="line"><span class="comment">            thread4.start();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//在外界只创建一个Runnable接口实现类对象，保证对象是唯一的</span></span><br><span class="line">        <span class="type">SellTicket1</span> <span class="variable">sellTicket1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket1</span>(); <span class="comment">//只会维护一份的票对象【100】张</span></span><br><span class="line">        <span class="comment">//利用这个对象初始化创建4个线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket1,<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket1,<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket1,<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket1,<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-getinstance-center"><center>GetInstance</center></h2>
<p>在主函数开始时调用，返回一个实例化对象，此对象是static的，在内存中保留着它的引用，即内存中有一块区域专门用来存放静态方法和变量，可以直接使用，调用多次返回同一个对象</p>
<p>GetInstance与new区别</p>
<p>    如Object object = new Object()，这时候，就必须要知道有第二个Object的存在，而第二个Object也常常是在当前的应用程序域中的，可以被直接调用的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.Demo03.test;</span><br><span class="line"><span class="comment">//提供了成员变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SellTicket2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供成员变量，变量是存储票信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    单设计模式的原则--》保证在外界获取对象时都是同一个对象【地址也是相同的】</span></span><br><span class="line"><span class="comment">    1.私有化构造方法</span></span><br><span class="line"><span class="comment">    2.提供一个私有化静态变量并对静态变量进行赋值【类型是本类类型提供对象创建】</span></span><br><span class="line"><span class="comment">    3.提供一个静态共有方法可以获取本类对象的唯一途径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SellTicket2</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">//使用本类类型创建对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SellTicket2</span> <span class="variable">sellTicket2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket2</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SellTicket2 <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> sellTicket2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑</span></span><br><span class="line">            <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)    <span class="comment">//证明还票可以出售</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//买票</span></span><br><span class="line">                System.out.println(<span class="string">&quot;当前售票员[&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;]第&quot;</span>+<span class="string">&quot;[&quot;</span>+(tickets--)+<span class="string">&quot;]票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提供了静态变量，这个类的创建对象方式就无所谓</span></span><br><span class="line">        <span class="type">SellTicket2</span> <span class="variable">sellTicket2</span> <span class="operator">=</span> SellTicket2.getInstance();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>定义一个变量保证所有对象共享，无论外界如何创建线程对象【实现Runnable还是继承Thread类】，这里都可以保证所有兑现共享这个变量，可以提供一个static修饰变量即静态变量</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.SellTicket1;</span><br><span class="line"><span class="comment">//v1.1版本 ---&gt; 提供了静态变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供静态成员变量存储票的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑</span></span><br><span class="line">            <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)    <span class="comment">//证明还票可以出售</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//买票</span></span><br><span class="line">                System.out.println(<span class="string">&quot;当前售票员[&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;]第&quot;</span>+<span class="string">&quot;[&quot;</span>+(tickets--)+<span class="string">&quot;]票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提供了静态变量，这个类的创建对象方式就无所谓</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket2</span>(),<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket2</span>(),<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket2</span>(),<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket2</span>(),<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题2：在买票的时候会出现、重票、错票、排序顺序的混乱的问题</p>
<p>    这个问题产生就是多线程并发争抢&quot;临界资源&quot;出现里临界资源不安全问题</p>
<h2 id="center-1-如何解决多线程并发访问临界资源-保证资源安全问题-center"><center>1、如何解决多线程并发访问临界资源，保证资源安全问题</center></h2>
<p>此时Java为了保证多线程并发访问临界资源线程安全问题，提供了一个处理机制，可以在处理临界资源代码中添加（同步锁/对象锁/同步代码块/同步监听器），这里四个名称都是指的是同一个操作，可以添加“锁机制”，保证在同一个时刻的只有一个线程操作临界资源，保证临界资源安全</p>
<h2 id="center-2-synchronized关键字-center"><center>2、synchronized关键字</center></h2>
<p>synchronized翻译意思：同步</p>
<p>使用synchronized关键字进行同步操作，使用synchronized组成同步操作叫做【同步锁/对象锁/同步代码块】</p>
<p>语法 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(资源锁对象)</span><br><span class="line">&#123;</span><br><span class="line">    提供操作临界资源的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行原理： 利用了同一时间内【只能有一个线程对象持有当前资源锁对象】，只要线程不释放这个所资源对象，外界线程是无法执行线程逻辑资源代码，在同步代码块中执行线程进行休眠是不会释放CPU时间片到外界给其他线程，因为sleep方法是不会释放锁资源</p>
<p>需要注意还需要保证【<strong>资源锁对象必须是唯一的</strong>】，不唯一锁对象数无法进行同步操作</p>
<p>如果保证资源锁对象是唯一的？</p>
<p>个人建议：十分不推荐使用 this 作为锁资源对象，this可能锁不了，this代表的是当前对象，那么就意味着这个提供临界支援类必须是创建唯一的对象才可以，这样才可以保证this是唯一的</p>
<p>替代方案一：</p>
<p>    在静态资源处理线程类中提供一个全局静态常量“锁资源”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">synchronized</span>(obj)</span><br><span class="line">&#123;</span><br><span class="line">    提供操作临界资源的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>替代方案二【推荐】</p>
<p>    天生对象就是唯一的，Java中这个对象无论你如何操作，就可以保证他是唯一的地址都是同一个，String字符串类，直接使用字符串对象即可----&gt;【使用 “” (双引号)创建】</p>
<p>提供字符串空串处理 —&gt; 即 提供字符串空串对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    提供操作临界资源的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用同步代码块修改买票的案例的</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.SynchronizedSellTicket1;</span><br><span class="line"><span class="comment">//v2版本 ---&gt; 提供了静态变量 和 同步代码块执行买票操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供静态成员变量存储票的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) <span class="comment">//同步代码块</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) <span class="comment">//证明还票可以出售</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">//买票</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;当前售票员[&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;]第&quot;</span></span><br><span class="line">                                                    + <span class="string">&quot;[&quot;</span> + (tickets--) + <span class="string">&quot;]票&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提供了静态变量，这个类的创建对象方式就无所谓</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket</span>(),<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket</span>(),<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket</span>(),<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket</span>(),<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-3-同步方法-对象同步方法-成员同步方法-center"><center>3、同步方法/对象同步方法/成员同步方法</center></h2>
<p>使用synchronized关键字进行成员方法的修饰，这个方法就会成为<strong>同步方法</strong>将操作资源代码写入到这个方法中就可以进行同步操作了</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问权限修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    方法体；</span><br><span class="line">    <span class="keyword">return</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>特别注意：使用是同步方法，所以这个方法使用锁资源对象是【this】，提供同步方法的这个类所创建对象必须是唯一的才可以锁住资源</strong></p>
<p>PS：到目前位置 方法定义中其他修饰符就已经全部介绍完毕</p>
<p>    类中方法可以使用：【static、final、abstract、synchronized】</p>
<p>    接口中方法可以使用：【abstract、static、default】</p>
<p><strong>修饰同步方法是该买票案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.SynchronizedSellTicket1;</span><br><span class="line"><span class="comment">//v2.1版本 ---&gt; 提供了静态变量 和 同步方法进行买票</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供静态成员变量存储票的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑 ---》调用同步方法即可</span></span><br><span class="line">            seller();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同步方法 --&gt; 这个锁资源对象是this</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">seller</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供就是线程处理临界资源操作</span></span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) <span class="comment">//证明还票可以出售</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//买票</span></span><br><span class="line">            System.out.println(<span class="string">&quot;当前售票员[&quot;</span> +</span><br><span class="line">            Thread.currentThread().getName() + <span class="string">&quot;]第&quot;</span></span><br><span class="line">            + <span class="string">&quot;[&quot;</span> + (tickets--) + <span class="string">&quot;]票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提供了静态变量，这个类的创建对象方式就无所谓</span></span><br><span class="line">        <span class="comment">//同步方法提供类如果是线程类，需要保证线程类对象是唯一的</span></span><br><span class="line">        <span class="type">SellTicket2</span> <span class="variable">sellTicket2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket2</span>();   <span class="comment">//这是保证线程类对象唯一</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-4-类锁-类同步代码块-类同步方法-静态同步方法-center"><center>4、类锁/类同步代码块/类同步方法/静态同步方法</center></h2>
<p>如果使用是同步代码块的语法，就是将资源锁对象，从当前对象替换成类对象，通过类的方式获取对象【通反射获取】，静态同步方法就是使用static和synchronized同时修饰方法</p>
<p><strong>类锁/类同步代码块</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(类名.class)    <span class="comment">// 类锁对象</span></span><br><span class="line">&#123;</span><br><span class="line">    操作临界资源代码即可</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>类同步方法/静态同步方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问权限修饰符 <span class="keyword">static</span> <span class="keyword">synchronized</span> 返回值类型 方法名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    方法代码</span><br><span class="line">    <span class="keyword">return</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//v2.2版本 ---&gt; 提供了静态变量 和 静态同步操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket3</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供静态成员变量存储票的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑 ---》调用同步方法即可</span></span><br><span class="line">            <span class="comment">//seller();</span></span><br><span class="line">            <span class="keyword">synchronized</span> (String.class)    <span class="comment">// 类锁</span></span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) <span class="comment">//证明还票可以出售</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">//买票</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;当前售票员[&quot;</span> +</span><br><span class="line">                    Thread.currentThread().getName() + <span class="string">&quot;]第&quot;</span></span><br><span class="line">                    + <span class="string">&quot;[&quot;</span> + (tickets--) + <span class="string">&quot;]票&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态同步方法 --&gt; 这个锁资源就是当前类的对象【是唯一的】，通过类获取即 类.class</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">seller</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供就是线程处理临界资源操操作</span></span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) <span class="comment">//证明还票可以出售</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//休眠1秒再买票</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//卖票</span></span><br><span class="line">            System.out.println(<span class="string">&quot;当前售票员[&quot;</span> +Thread.currentThread().getName() + <span class="string">&quot;]第&quot;</span> </span><br><span class="line">                                                        + <span class="string">&quot;[&quot;</span> + (tickets--) + <span class="string">&quot;]票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提供了静态变量，这个类的创建对象方式就无所谓</span></span><br><span class="line">        <span class="comment">//同步方法提供类如果是线程类，需要保证线程类对象是唯一的</span></span><br><span class="line">        <span class="type">SellTicket3</span> <span class="variable">sellTicket2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket3</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized总结：</p>
<ol>
<li>在开发中常用肯定是对象锁【同步代码块】但是这个代码块的范围不要太大，不然的话会影响执行效率</li>
</ol>
<p>    PS: 在什么位置对资源操作就在什么位置添加 同步代码块</p>
<ol start="2">
<li>使用synchronized关键字之后线程就会变成安全，间接就将并行线程修改为串行线程，使用锁机制将线程变	成 【一个一个站排执行效果】</li>
</ol>
<h1><center>知识点七：线程通信</center></h1>
<p>到现目前位置线程与线程之间依旧是彼此独立，就算使用同步代码块，也是让线程执行有一定顺序，但是还是没有进行通信操作，如果需要遇到某个线程执行完毕之后需要通知另外一个线程继续执行，此时就需要使用到线程通信，可以在一个进程中开发多个线程，每个线程之间可以进行通信操作，从而协调性的完成某个进程中需要执行逻辑</p>
<p><strong>线程通信有一个标准的通信模型【生产者与消费者模式】</strong></p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012227153.WebP" alt="线程通信" style="zoom:50%;">
<h2 id="center-1-完成生产者和消费者通信模型v1版本-center"><center>1、完成生产者和消费者通信模型v1版本</center></h2>
<p>Bank(银行类) —》 提供数据维护与使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基础的第一个版本 ---》 提供临界资源并提供操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;    <span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一单例设计模式的实现：</span></span><br><span class="line"><span class="comment">        1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        money = m+money;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span>+m+<span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        money = money-m;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取了&quot;</span>+m+<span class="string">&quot;余额是：&quot;</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生产者【是一个线程提供数据存储操作】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供银行属性</span></span><br><span class="line">    <span class="keyword">private</span> Bank bank;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Bank bank)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.bank = bank;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供线程存储钱的操作 存储十次 每次1000元</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            bank.pushMoney(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者【是一个线程提供数据获取操作】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供银行属性</span></span><br><span class="line">    <span class="keyword">private</span> Bank bank;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Bank bank)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.bank = bank;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供线程存获取的操作 获取十次 每次1000元</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            bank.popMoney(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提供一个测试类Test进行测试操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.waitAndnotfiny;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过单例获取银行对象</span></span><br><span class="line">        <span class="type">Bank</span> <span class="variable">bank1</span> <span class="operator">=</span> Bank.getInstance();</span><br><span class="line">        <span class="comment">//2.创建线程对象并启动操作</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(bank1),<span class="string">&quot;花花&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(bank1),<span class="string">&quot;菲菲&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题1：现在执行速度太快了，看不到交替执行效果，让线程休眠1秒操作</p>
<p>问题2：虽然让线程休眠之后，出现了一个执行错乱的问题，因为多线程并发访问临界资源money，出现线程挣抢的问题，所以出现临界资源部不安全问题，添加同步代码块</p>
<p>Bank银行类需要修改为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.waitAndnotfiny;</span><br><span class="line"><span class="comment">//基础的第一个版本 ---》 提供临界资源并提供操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;<span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一</span></span><br><span class="line"><span class="comment">        单例设计模式的实现：</span></span><br><span class="line"><span class="comment">        1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = m + money;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = money - m;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-2-完成生产者和消费者通信模型v2版本-center"><center>2、完成生产者和消费者通信模型v2版本</center></h2>
<p>使用了同步代码块+sleep方法，虽然让程序执行有序了也保证线程中操作临界资源过程也安全了，但是还是无法保证线程可以做到交替执行的效果【<strong>即生产者生产完数据之后通知消费者可以进行消费，消费者消费完数据之后通知生产者可以生产</strong>】，所以如何完成这个通信操作呢？</p>
<p>此时就需要使用Java中Object类中提供三个方法了</p>
<table>
<thead>
<tr>
<th style="text-align:center">线程通信方法</th>
<th style="text-align:center">方法说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">wait()</td>
<td style="text-align:center">执行该方法的线程对象会释放【同步锁资源】，JVM会把当前线程放到等待池中，等待其他线程唤醒操作</td>
</tr>
<tr>
<td style="text-align:center">notify()</td>
<td style="text-align:center">执行该方法的线程对象会在等待池【随机唤醒】一个等待的线程，把线程转移到锁池中等待，再次获取资源</td>
</tr>
<tr>
<td style="text-align:center">notifyAll()</td>
<td style="text-align:center">执行该方法的线程对象会在等地池中【唤醒所有的线程】，把线程转移到锁池中等待，再次获取资源</td>
</tr>
</tbody>
</table>
<p>    就可以利用这三个方法进行线程通信操作了，<strong>特别注意调用通信方法必须是锁资源对象，否则会出现异常提示信息【在哪里调用等待方法就在位置被唤醒】</strong></p>
<p>线程通信执行流程：</p>
<p>    假设<strong>A线程</strong>和<strong>B线程</strong>共同操作一个<strong>X锁对象</strong>，A、B线程可以通过X锁对象调用wait和notify方法进行如下线程通信操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当A线程执行到X锁对象时，A线程持有X锁对象，B线程是没有执行机会的，B线程在X对象的等待锁池中</span><br><span class="line">A线程在同步代码块种执行到X.wait方法时，A线程会释放X对象所资源，A线程会进入到X对象的等待锁池中</span><br><span class="line">B线程就会在等待锁池中得到A线程释放的X资源锁对象，B线程就开始执行操作</span><br><span class="line">B线程在同步代码块中执行到X.notify方法时，JVM把A线程从X对象等待池中，移动到等待X对象锁资源中得到锁资源</span><br><span class="line">B线程执行完毕之后释放锁资源，A线程就有机会获取到锁，继续执行同步方法</span><br></pre></td></tr></table></figure>
<p>修改Bank类提供线程通信操作者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.waitAndnotfiny.V2;</span><br><span class="line"><span class="comment">//通信的版本 ---》 提供临界资源并提供操作[添加线程通信和同步代码块+sleep方法]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;    <span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一</span></span><br><span class="line"><span class="comment">        单例设计模式的实现：</span></span><br><span class="line"><span class="comment">            1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">            2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">            3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在外界创建生产者与消费者线程对象中都是可以获取到CPU资源</span></span><br><span class="line"><span class="comment">        但是问题在于，如果消费者先获取到资源，但是没有数据不能消费</span></span><br><span class="line"><span class="comment">        所以就提供一个变量来存储状态的，通过对这个状态的判断决定执行哪个线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//添加线程通信操作</span></span><br><span class="line">                <span class="keyword">if</span>(isEmpty)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果条件为true值，就证明现在有数据，无需生产</span></span><br><span class="line">                    <span class="comment">//生产这个就进入到等待状态</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//因为if没有执行就证明，没有数据可以生产</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = m + money;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//生产数据完毕之后需要修改状态信息</span></span><br><span class="line">                isEmpty = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//执行唤醒操作</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notify();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 增加线程通信操作</span></span><br><span class="line">                <span class="comment">//isEmpty状态值 false代表没有数据 true代表有属性</span></span><br><span class="line">                <span class="keyword">if</span>(!isEmpty)    <span class="comment">//没有数据的时候不能执行消费，等待生产</span></span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        没有数据isEmpty值是false，取非操作 !false --》 true if就执行等待</span></span><br><span class="line"><span class="comment">                        有数据isEmpty值是true ，取非操作 !true --》false if就不执行等待，进行消费</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//if分支语句不执行就证明有数据，进行消费操作</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = money - m;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//修改状态数据</span></span><br><span class="line">                isEmpty = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//进行唤醒操作</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notify();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-3-分析执行流程-center"><center>3、分析执行流程</center></h2>
<ol>
<li>现有的两个线程生产者【花花】和消费者【菲菲】默认初始isEmpty状态都是false</li>
<li>消费者【菲菲】先获取到CPU时间片，持有所资源，判断if分支条件为!false,消费者【菲菲】就会释放锁资源并且进入到等待池中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等待池</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    生产者【花花】</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>等待池中生产者【花花】就会或得到执行CPU时间片，并且获取到锁资源，判断if分支条件false，证明没有数据，生产数据并且唤醒等待池中【菲菲】修改isEmpty值true，生产者线程就执行完毕了</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等待池</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    消费者【菲菲】</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>此时生产者【花花】和消费者【菲菲】就会再次同时争抢CPU时间片和锁资源对象，假如生产者【花花】再次获取哦到CPU时间片和锁资源对象，执行线程逻辑，判断if分支条件为true，此时花花就会释放资源进入到等待池中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等待池</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    生产者【花花】</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>消费者【菲菲】必然获取到CPU时间片，执行操作逻辑判断条件!true 得到是false，就执行消费，并且修改状态为false，唤醒等待池中生产者，这样就完成交替执行效果</li>
</ol>
<p><strong>PS：以上这些操作就是典型的一对一生产者与消费者模型</strong></p>
<h1><center>知识点八：多对多通信模型</center></h1>
<p>提供线程对象创建操作， 这里从原有一对一的模式，变成多对多的模式，原来的一个生产者对应一个消费者，修改为了多个生产者对应多个消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过单例获取银行对象</span></span><br><span class="line">        <span class="type">Bank</span> <span class="variable">bank1</span> <span class="operator">=</span> Bank.getInstance();</span><br><span class="line">        <span class="comment">//2.创建线程对象并启动操作</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(bank1),<span class="string">&quot;花花1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(bank1),<span class="string">&quot;菲菲2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(bank1),<span class="string">&quot;花花3&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(bank1),<span class="string">&quot;菲菲4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当将线程对象增多之后，执行多线程同时操作就出现两个问题“<strong>负数问题和死等待问题</strong>”</p>
<h2 id="center-1-负数问题-center"><center>1、负数问题</center></h2>
<p>现有线程【花花1（存)、菲菲2（取）、花花3（存）、菲菲4（取）】，模拟一个执行流程</p>
<ol>
<li>菲菲2先抢到线程，不能取，所以进入到等待队列中，释放CPU时间片和释放锁资源</li>
<li>菲菲4抢到线程资源，不能取，所以进入到等待列中，释放CPU时间片和释放锁资源</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等待队列 菲菲2、菲菲4</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>花花1抢到线程，存储了数据，修改标记为true值，并唤醒等待队列中的线程的线程对象，现在使用唤醒机制notify方法【随机唤醒一个等待队列汇总线程对象】，假设唤醒了菲菲4</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等待队列中 菲菲2</span></span><br><span class="line"><span class="comment">//外部争抢CPU操作的时间片 花花1、花花3、菲菲4</span></span><br><span class="line"><span class="comment">//临界资源中存储数据是 ---》 1000</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>菲菲4抢到了线程，在哪里等待就在哪里被唤醒，而且if分支语句特点，只会执行一次判断即if分支条件判断完成之后【不添加循环前提】，只会执行一次判断，菲菲4正好是在if分支语句中进行等待操作，醒来之后机会继续向后执行【它是不会在判断if分支语句】，菲菲4进行正常消费，修改标记为false，需要执行notify，唤醒等待队列菲菲2【菲菲2这个线程是通过wait进入到等待状态，它已经执行了if判断】</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等待队列中 空</span></span><br><span class="line"><span class="comment">// 外部增强CPU操作者时间片 花花1、菲菲2【从等待状态恢复而来】、花花3、菲菲4</span></span><br><span class="line"><span class="comment">// 临界资源中存储的数据是 ----》 0 【因为菲菲4消费了】</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>菲菲2抢到了执行权，会在if分支语句继续执行操作，此时虽然标记已经修改为false，正常而言不应该消费的，但是if分支语句已经被执行过，所以不会进行判断继续执行，进行消费，修改标记，执行唤醒</li>
</ol>
<p>但是现在的数据是 0 在执行消费出现数据就是 -1000</p>
<p><strong>为了保证线程通信可以正常执行，建议在开发的时候，不要书写if作为状态判断操作，建议使用while循环语句替代if分支，while循环语句只有条件为false，才不执行，否者就继续执行，这样就可以让等待位置线程在次被唤醒之后可以再次判断状态操作，以防出现错误数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.waitAndnotfiny.V3;</span><br><span class="line"><span class="comment">//通信的版本【多对多】 ---》 提供临界资源并提供操作[添加线程通信和同步代码块+sleep方法]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;<span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一</span></span><br><span class="line"><span class="comment">        单例设计模式的实现：</span></span><br><span class="line"><span class="comment">        1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在外界创建生产者与消费者线程对象中都是可以获取到CPU资源</span></span><br><span class="line"><span class="comment">        但是问题在于，如果消费者先获取到资源，但是没有数据不能消费</span></span><br><span class="line"><span class="comment">        所以就提供一个变量来存储状态的，通过对这个状态的判断决定执行哪个线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//添加线程通信操作</span></span><br><span class="line">                <span class="comment">//只需要将if修改为while即可</span></span><br><span class="line">                <span class="keyword">while</span>(isEmpty)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果条件为true值，就证明现在有数据，无需生产</span></span><br><span class="line">                    <span class="comment">//生产这个就进入到等待状态</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//因为if没有执行就证明，没有数据可以生产</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = m + money;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//生产数据完毕之后需要修改状态信息</span></span><br><span class="line">                isEmpty = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//执行唤醒操作</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notify();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 增加线程通信操作</span></span><br><span class="line">                <span class="comment">//isEmpty状态值 false代表没有数据 true代表有属性</span></span><br><span class="line">                <span class="comment">//只需要将if修改为while即可</span></span><br><span class="line">                <span class="keyword">while</span>(!isEmpty)    <span class="comment">//没有数据的时候不能执行消费，等待生产</span></span><br><span class="line">                &#123; </span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        没有数据isEmpty值是false，取非操作 !false --》 true if就执行等待</span></span><br><span class="line"><span class="comment">                        有数据isEmpty值是true ，取非操作 !true --》false if就不执行等待，进行消费</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//if分支语句不执行就证明有数据，进行消费操作</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = money - m;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//修改状态数据</span></span><br><span class="line">                isEmpty = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//进行唤醒操作</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notify();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-2-死等待问题-center"><center>2、死等待问题</center></h2>
<p>所有线程都进入到等待池中无人唤醒</p>
<p><strong>PS：这个效果是需要特殊情况下才会出现【它属于一个极端情况】</strong></p>
<p><strong>这个原因的产生就是使用notfiy随机唤醒机制</strong></p>
<p>现有线程【花花1（存)、菲菲2（取）、花花3（存）、菲菲4（取）】模拟一个执行流程</p>
<ol>
<li>菲菲2先抢到线程，不能取，所以进入到等待池中，释放锁和CPU时间片</li>
<li>菲菲4抢到线程，不能取，所以进入到等待池中，释放锁和CPU时间片</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等待队列中 菲菲2、菲菲4</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>花花1抢到线程，存储数据，修改标记为true并进行唤醒操作【随机唤醒】</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等待队列中 菲菲2</span></span><br><span class="line"><span class="comment">//争抢CPU资源 花花1、花花3、菲菲4</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>花花1在次获取线程，不能存储，所以要进入到等待队列中，释放锁和CPU时间片</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等待队列中 菲菲2、花花1 //争抢CPU资源 花花3、菲菲4</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>花花3抢到线程，不能存储，所以要进入到等待队列中，释放锁和CPU时间片</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等待队列中 菲菲2、花花1、花花3 //争抢CPU资源 菲菲4</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li>菲菲4抢到线程，取钱消费，修改标记为false，并进入唤醒操作【随机唤醒】 --》 菲菲2唤醒</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等待队列汇总 花花1、花花3 //争抢CPU资源 菲菲4、菲菲2 ，现在状态时false</span></span><br></pre></td></tr></table></figure>
<ol start="7">
<li>生产者都在等待队列中，外部都是消费这个，现在状态时false</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等待队列中 花花1、花花3、菲菲4、菲菲2</span></span><br></pre></td></tr></table></figure>
<p>所有线程都进入到等待队列中，无人唤醒就出现死的等待问题</p>
<p>    之所以会出现死等待原因就因为使用了notify的操作，它是随机唤醒，等待池中两个消费，外界两个生产【生产完毕，状态修改，无法唤醒】，或等待池中两个生产，外界两个消费【消费完毕，状态修改，无法唤醒】，<strong>建议使用notifyAll 替换 notfiy</strong>，进行全部唤醒，然后再进行条件判断执行操作，决定好是否存储与消费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通信的版本 ---》 提供临界资源并提供操作[添加线程通信和同步代码块+sleep方法]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;<span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一</span></span><br><span class="line"><span class="comment">        单例设计模式的实现：</span></span><br><span class="line"><span class="comment">        1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在外界创建生产者与消费者线程对象中都是可以获取到CPU资源</span></span><br><span class="line"><span class="comment">        但是问题在于，如果消费者先获取到资源，但是没有数据不能消费</span></span><br><span class="line"><span class="comment">        所以就提供一个变量来存储状态的，通过对这个状态的判断决定执行哪个线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//添加线程通信操作</span></span><br><span class="line">                <span class="keyword">while</span>(isEmpty)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果条件为true值，就证明现在有数据，无需生产</span></span><br><span class="line">                    <span class="comment">//生产这个就进入到等待状态</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//因为if没有执行就证明，没有数据可以生产</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = m + money;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//生产数据完毕之后需要修改状态信息</span></span><br><span class="line">                isEmpty = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//执行唤醒操作进行全部唤醒操作</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notifyAll();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 增加线程通信操作</span></span><br><span class="line">                <span class="comment">//isEmpty状态值 false代表没有数据 true代表有属性</span></span><br><span class="line">                <span class="keyword">while</span>(!isEmpty)    <span class="comment">//没有数据的时候不能执行消费，等待生产</span></span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    没有数据isEmpty值是false，取非操作 !false --》 true if就执行等待</span></span><br><span class="line"><span class="comment">                    有数据isEmpty值是true ，取非操作 !true --》false if就不执行等待，进行消费</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//if分支语句不执行就证明有数据，进行消费操作</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = money - m;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//修改状态数据</span></span><br><span class="line">                isEmpty = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//进行唤醒操作修改为全部唤醒</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notifyAll();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：如果在日后的开发中出现线程通信操作，建议判断状态标签的位置使用while关键字而不是if，进行唤醒操作建议使用notfiyAll而不是notify</strong></p>
<h2 id="center-3-扩展：lock接口-显示锁-center"><center>3、扩展：Lock接口【显示锁】</center></h2>
<p>Lock接口是Java5中新加入与Synchronized比较操作，它属于显示定义，结构更加灵活，提供了一个更加便捷的操作，相对比synchronized更加简洁易用</p>
<p>PS：这个锁资源Lock虽然语法更加简洁易用，但是它不能定义锁对象，Lock使用锁对象是【this】，<strong>使用Lock时就需要保证this的唯一性了</strong></p>
<p><strong>Lock锁如何操作？</strong></p>
<p>    Lock是一个接口所以需要使用到他实现类进行锁的操作</p>
<p><strong>ReentrantLock</strong>提供两常用操作</p>
<table>
<thead>
<tr>
<th style="text-align:center">Lock锁方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">lock()</td>
<td style="text-align:center">添加锁(对象上锁)</td>
</tr>
<tr>
<td style="text-align:center">unlock()</td>
<td style="text-align:center">释放锁(对象所释放)</td>
</tr>
</tbody>
</table>
<p>    以为Lock是一个显示锁对象，所有不能调用Object类中提供wait、notify、notifyAll方法进行线程通信，所以系统就提供了<strong>一个和Lock锁一起使用线程通信接口Condititon</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">通信方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">await()</td>
<td style="text-align:center">线程等待释放锁资源和CPU时间片</td>
</tr>
<tr>
<td style="text-align:center">signal()</td>
<td style="text-align:center">唤醒等待池中某一个线程对象【随机唤醒】</td>
</tr>
<tr>
<td style="text-align:center">signalAll()</td>
<td style="text-align:center">唤醒等待池中所有线程对象</td>
</tr>
</tbody>
</table>
<p>使用Lock锁替代Synchronized同步代码块进行数据操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="comment">//通信的版本【多对多】 ---》 提供临界资源并提供操作[添加线程Lock锁+sleep方法+线程通信]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankLock</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;<span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一</span></span><br><span class="line"><span class="comment">        单例设计模式的实现：</span></span><br><span class="line"><span class="comment">        1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BankLock</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">BankLock</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BankLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BankLock <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供锁资源对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//提供线程通信资源对象【它是接口不能new，使用lock对象调用newCondition创建】</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在外界创建生产者与消费者线程对象中都是可以获取到CPU资源</span></span><br><span class="line"><span class="comment">        但是问题在于，如果消费者先获取到资源，但是没有数据不能消费</span></span><br><span class="line"><span class="comment">        所以就提供一个变量来存储状态的，通过对这个状态的判断决定执行哪个线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//synchronized (&quot;&quot;) //替换成lock锁资源对象</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//添加线程通信操作</span></span><br><span class="line">                <span class="comment">//只需要将if修改为while即可</span></span><br><span class="line">                <span class="keyword">while</span>(isEmpty)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果条件为true值，就证明现在有数据，无需生产</span></span><br><span class="line">                    <span class="comment">//生产这个就进入到等待状态</span></span><br><span class="line">                    <span class="comment">// &quot;&quot;.wait();</span></span><br><span class="line">                    condition.await();    <span class="comment">//使用通信资源创建对象</span></span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//因为if没有执行就证明，没有数据可以生产</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = m + money;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//生产数据完毕之后需要修改状态信息</span></span><br><span class="line">                isEmpty = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//执行唤醒操作</span></span><br><span class="line">                <span class="comment">//&quot;&quot;.notifyAll();</span></span><br><span class="line">                condition.signalAll();    <span class="comment">//使用通信资源创建对象</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> </span><br><span class="line">            &#123;</span><br><span class="line">                lock.unlock(); <span class="comment">//锁资源释放</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//synchronized (&quot;&quot;) </span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 增加线程通信操作</span></span><br><span class="line">                    <span class="comment">//isEmpty状态值 false代表没有数据 true代表有属性</span></span><br><span class="line">                    <span class="comment">//只需要将if修改为while即可</span></span><br><span class="line">                    <span class="keyword">while</span>(!isEmpty)    <span class="comment">//没有数据的时候不能执行消费，等待生产</span></span><br><span class="line">                    &#123; </span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                            没有数据isEmpty值是false，取非操作 !false --》 true if就执行等待</span></span><br><span class="line"><span class="comment">                            有数据isEmpty值是true ，取非操作 !true --》false if就不执行等待，进行消费</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        <span class="comment">//&quot;&quot;.wait();</span></span><br><span class="line">                        condition.await();</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">//if分支语句不执行就证明有数据，进行消费操作</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    money = money - m;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                    <span class="comment">//修改状态数据</span></span><br><span class="line">                    isEmpty = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">//进行唤醒操作</span></span><br><span class="line">                    <span class="comment">// &quot;&quot;.notifyAll();</span></span><br><span class="line">                    condition.signalAll();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点九：线程声明周期</center></h1>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012240972.WebP" alt="声明周期" style="zoom:50%;">
<p>线程声明周期分为两条线:</p>
<ol>
<li>基础线程声明周期： 新建 —》 准备就绪 —》 运行状态 —》 死亡状态</li>
<li>对线程添加了一些操作造成线程阻塞现象的产生【sleep、join、wait、synchronized等等】</li>
</ol>
<p>新建 —》 准备就绪 —》 运行状态 —》【 阻塞状态 —》 准备就绪 —》 运行状态】 —》 死亡状态</p>
<p>PS：在阻塞状态没有消失之前</p>
<p>准备就绪 —》 运行状态 —》阻塞状态 —》 准备就绪 —》 运行状态 … 【会一直重复执行】</p>
<p>1、新建状态(new):使用new创建一个线程对象,仅仅在堆中分配内存空间,在调用start方法之前.</p>
<p>    新建状态下,线程压根就没有启动,仅仅只是存在一个线程对象而已.</p>
<p>    Thread t = new Thread();//此时t就属于新建状态</p>
<p>    当新建状态下的线程对象调用了start方法,此时从新建状态进入可运行状态</p>
<p>    线程对象的start方法只能调用一次,否则报错:IllegalThreadStateException</p>
<p>2、可运行状态(runnable):分成两种状态，ready和running。分别表示就绪状态和运行状态</p>
<p>    就绪状态:线程对象调用start方法之后,等待JVM的调度(此时该线程并没有运行).</p>
<p>    运行状态:线程对象获得JVM调度,如果存在多个CPU,那么允许多个线程并行运行</p>
<p>3、阻塞状态(blocked):正在运行的线程因为某些原因放弃CPU,暂时停止运行,就会进入阻塞状态.</p>
<p>    此时JVM不会给线程分配CPU,直到线程重新进入就绪状态,才有机会转到运行状态.</p>
<p>    阻塞状态只能先进入就绪状态,不能直接进入运行状态</p>
<p>    阻塞状态的两种情况:</p>
<p>    （1）当A线程处于运行过程时,试图获取同步锁时,却被B线程获取.此时JVM把当前A线程存到对象的锁池中,A线程进入阻塞状态.</p>
<p>    （2）当线程处于运行过程时,发出了IO请求时,此时进入阻塞状态</p>
<p>4、等待状态(waiting)(等待状态只能被其他线程唤醒):此时使用的无参数的wait方法,</p>
<p>    （1）当线程处于运行过程时,调用了wait()方法,此时JVM把当前线程存在对象等待池中</p>
<p>5、计时等待状态(timed waiting)(使用了带参数的wait方法或者sleep方法)</p>
<p>    (1)当线程处于运行过程时,调用了wait(long time)方法,此时JVM把当前线程存在对象等待池中.</p>
<p>    (2)当前线程执行了sleep(long time)方法.</p>
<p>6、终止状态(terminated):通常称为死亡状态，表示线程终止.</p>
<p>    (1)正常执行完run方法而退出(正常死亡).</p>
<p>    (2)遇到异常而退出(出现异常之后,程序就会中断)(意外死亡)</p>
<p>线程一旦终止,就不能再重启启动,否则报错(IllegalThreadStateException).</p>
<p>在Thread类中过时的方法(因为存在线程安全问题,所以弃用了【真心好用，绝对不能用】)</p>
<p>    void suspend() :暂停当前线程</p>
<p>    void resume() :恢复当前线程</p>
<p>    void stop() :结束当前线程</p>
<h1><center>知识点十：拓展</center></h1>
<h2 id="center-1-线程池-重点-center"><center>1、线程池【重点】</center></h2>
<h3 id="1-线程池概念">（1）线程池概念</h3>
<p>如果有非常的多的任务需要多线程来完成，且每个线程执行时间不会太长，这样频繁的创建和销毁线程。</p>
<p>频繁创建和销毁线程会比较耗性能。有了线程池就不要创建更多的线程来完成任务，因为线程可以重用</p>
<p>线程池用维护者一个队列，队列中保存着处于等待（空闲）状态的线程。不用每次都创建新的线程</p>
<h3 id="2-线程池实现原理">（2）线程池实现原理</h3>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012242641.WebP" alt="实现原理" style="zoom:50%;">
<h3 id="3-线程池中常见的类">（3）线程池中常见的类</h3>
<p>常用的线程池接口和类(所在包java.util.concurrent)</p>
<p>Executor：线程池的顶级接口。</p>
<p>ExecutorService：线程池接口，可过submit(Runnable task) 提交任务代码</p>
<p>Executors工厂类：通过此类可以获得一个线程池</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">newFixedThreadPool(int nThreads)</td>
<td style="text-align:center">获取固定数量的线程池。参数：指定线程池中线程的数量</td>
</tr>
<tr>
<td style="text-align:center">newCachedThreadPool()</td>
<td style="text-align:center">获得动态数量的线程池，如不够则创建新的，无上限</td>
</tr>
</tbody>
</table>
<p><strong>创建方法一：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建一个线程池对象   创建了一个固定数量3个的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);   <span class="comment">//返回ExecutorService对象</span></span><br><span class="line">        <span class="comment">//2.通过线程池对象调用sumit方法来提交线程任务</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable1</span>());   <span class="comment">//传入实现runnable接口的类</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable2</span>());</span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable3</span>());</span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable4</span>());</span><br><span class="line">        <span class="comment">//3.结束线程池</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable3</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable4</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">30</span>; i &lt; <span class="number">40</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建方式二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建一个线程池对象   创建一个带缓存的连接池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//2.通过线程池对象，提交线程任务，并启动线程执行任务</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-callable接口">（4）Callable接口</h3>
<p>JDK5加入，与Runnable接口类似，实现之后代表一个线程任务。</p>
<p>Callable具有泛型返回值、可以声明异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt; V &gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不使用返回值和Runnable的作用一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建一个线程对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//2.通过线程池对象提交线程任务，并启动线程执行任务</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.关闭线程对象</span></span><br><span class="line">        es.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>   <span class="comment">//Callable接口的泛型表示call方法返回值的类型</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread1;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建一个线程对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//2.通过线程池对象提交线程任务，并启动线程执行任务</span></span><br><span class="line">        Future&lt;String&gt; future = es.submit(<span class="keyword">new</span> <span class="title class_">MyCallable2</span>());   <span class="comment">//保存线程的返回结果</span></span><br><span class="line">        System.out.println(future.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.关闭线程对象</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable2</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是call方法返回值&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo03</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//需求：线程A 计算1~50 线程B 51~100  最终得到结果</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;Integer&gt; f1 = es.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">51</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Future&lt;Integer&gt; f2 = es.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">51</span>; i &lt; <span class="number">101</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;结果为:&quot;</span> + (f1.get() + f2.get()));</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-future接口">（5）Future接口</h3>
<p>Future接口表示将要执行完任务的结果。</p>
<p>get()以阻塞形式等待Future中的异步处理结果（call()的返回值）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCallable2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Runnable接口和Callable接口的区别？</span></span><br><span class="line"><span class="comment">    * 1、这两个接口都可以当做线程任务提交并执行</span></span><br><span class="line"><span class="comment">    * 2、Callable接口执行完线程任务之后有返回值，而Runnable接口没有返回值</span></span><br><span class="line"><span class="comment">    * 3、Callable接口中的call方法已经抛出了异常，而Runnable接口不能抛出编译异常</span></span><br><span class="line"><span class="comment">    * Future接口：</span></span><br><span class="line"><span class="comment">    * 用于接口Callable线程任务的返回值。</span></span><br><span class="line"><span class="comment">    * get()方法当线程任务执行完成之后才能获取返回值，这个方法是一个阻塞式的方法</span></span><br><span class="line"><span class="comment">    *随堂案例：</span></span><br><span class="line"><span class="comment">    * 使用两个线程，并发计算1-100的和， 一个线程计算1~50,另一个线程计算51~100， 最终汇总结果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,</span><br><span class="line">ExecutionException </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1、创建线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//2、通过线程池提交线程并执行任务</span></span><br><span class="line">        Future&lt;String&gt; future = es.submit(<span class="keyword">new</span> <span class="title class_">MyCallable1</span>());</span><br><span class="line">        <span class="comment">//获取线程任务的返回值</span></span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;哈哈哈哈哈哈&quot;</span>);</span><br><span class="line">        <span class="comment">//3、关闭线程池</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable1</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+i);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是Callable线程任务的返回值&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-读写锁">（6）读写锁</h3>
<p>ReentrantReadWriteLock：</p>
<p>    一种支持一写多读的同步锁，读写分离，可分别分配读锁、写锁。</p>
<p>    支持多次分配读锁，使多个读操作可以并发执行。</p>
<p>互斥规则：</p>
<p>    写-写：互斥，阻塞</p>
<p>    读-写：互斥，读阻塞写、写阻塞读。</p>
<p>    读-读：不互斥、不阻塞。</p>
<p>    在读操作远远高于写操作的环境中，可在保障线程安全的情况下，提高运行效率</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriterLockDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//记录开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//1.创建线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//2.提交8个读操作任务，提交2个写操作任务</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="type">ReadThread</span> <span class="variable">readThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReadThread</span>(user);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            es.submit(readThread);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="type">WriteThread</span> <span class="variable">writeThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WriteThread</span>(user);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            es.submit(writeThread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.结束线程池</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">        <span class="comment">//es.isTerminated();    获取当前线程池的状态，如果线程池钟的任务执行结束，那么返回true，否则返回false</span></span><br><span class="line">        <span class="comment">//System.out.println(es.isTerminated());</span></span><br><span class="line">        <span class="comment">//我们希望以下的代码在线程任务执行结束之后再执行.利用代码空转来判断</span></span><br><span class="line">        <span class="keyword">while</span> (!es.isTerminated())</span><br><span class="line">        &#123;&#125;</span><br><span class="line">        <span class="comment">//记录结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时&quot;</span> + (end-start) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写线程</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">WriteThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    User user;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WriteThread</span><span class="params">(User user)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        user.setName(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    User user;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReadThread</span><span class="params">(User user)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        user.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//读写锁</span></span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">rrwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">//读锁</span></span><br><span class="line">    ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> rrwl.readLock();</span><br><span class="line">    <span class="comment">//写锁</span></span><br><span class="line">    ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> rrwl.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读操作</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读和写都需要花一秒，而读和读是不影响的，读和写的互斥的，写和写是互斥的</span></span><br><span class="line"><span class="comment">//class User</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    private String name;</span></span><br><span class="line"><span class="comment">//    Lock lock = new ReentrantLock();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    //写操作</span></span><br><span class="line"><span class="comment">//    public void setName(String name)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        lock.lock();</span></span><br><span class="line"><span class="comment">//        try</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            Thread.sleep(1000);</span></span><br><span class="line"><span class="comment">//            this.name = name;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        catch (InterruptedException e)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        finally</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            lock.unlock();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    //读操作</span></span><br><span class="line"><span class="comment">//    public String getName()</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        lock.lock();</span></span><br><span class="line"><span class="comment">//        try</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            Thread.sleep(1000);</span></span><br><span class="line"><span class="comment">//            return name;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        catch (InterruptedException e)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        finally</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            lock.unlock();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return null;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="7-重入锁">（7）重入锁</h3>
<p>重入锁:在同步锁中可以继续加入同步锁(锁对象是同一个)</p>
<p>    synchronized和Lock锁都可以实现锁的重入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReentrantLock</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 重入锁:在同步锁中可以继续加入同步锁(锁对象是同一个)</span></span><br><span class="line"><span class="comment">    * synchronized和Lock锁都可以实现锁的重入</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        a();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//当前锁对象为this</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        b();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//当前锁对象为this</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        c();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-公平锁">（8）公平锁</h3>
<p>公平锁和非公平锁</p>
<p>    非公平锁：优先使用上一个线程接着执行下面的线程任务</p>
<p>        synchronized是非公平锁的实现，无法实现公平锁</p>
<p>        lock锁默认是非公平锁，如果想要实现公平锁，那么需要在构造方法设置为true</p>
<p>    公平锁：让每个线程都公平去执行线程任务</p>
<p>        lock锁可以实现公平锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Lock锁实现公平锁 参数为true表示是公平锁，默认是false表示非公平锁</span></span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java语言</category>
      </categories>
      <tags>
        <tag>Java语言</tag>
      </tags>
  </entry>
  <entry>
    <title>云图床</title>
    <url>/post/2ec6e870.html</url>
    <content><![CDATA[<p>图床导航：<a href="http://imgdh.com/">网址</a>，目前在用前三个结合</p>
<h1>sm.ms图床</h1>
<p>普通用户5g内存，一次上传10张，一张最大5M，链接：<a href="https://sm.ms/">网址</a>（主用），博客文章图片用，备用链接：<a href="https://smms.app/">网址</a></p>
<h1>Picgo图床</h1>
<p>没发现啥限制，图片链接只有上传完之后查看，链接：<a href="https://www.picgo.net/">网址</a>，背景图等使用</p>
<h1>postimage图床</h1>
<p>链接：<a href="https://postimages.org/">网址</a>，目前没发现有什么限制，备用</p>
<h1>珊瑚图床</h1>
<p>链接：<a href="https://tg.idc.cloudns.be/">网址</a>，无需登录即可上传，用于不重要的图片链接</p>
<h1>聚合图床</h1>
<p>链接：<a href="https://www.superbed.cn/">网址</a>，只能上传1000张，每小时最多100张，日均访问量1万次，最大一张图片5M，单次上传5张</p>
<h1>薄荷图床</h1>
<p><a href="https://zixiaoyun.com/">网址</a></p>
<h1>风筝图床</h1>
<p><a href="https://www.imgbed.link/">网址</a></p>
<h1>ImgURL图床</h1>
<p><a href="https://www.imgurl.org/vip/manage/upload">网址</a></p>
<h1>Hello图床</h1>
<p><a href="https://www.helloimg.com/">网址</a></p>
]]></content>
      <categories>
        <category>工具分享</category>
      </categories>
      <tags>
        <tag>云图床</tag>
      </tags>
  </entry>
  <entry>
    <title>图片在线工具</title>
    <url>/post/79959306.html</url>
    <content><![CDATA[<h1><center>图片修复</center></h1>
<h3 id="百度ai图片助手">百度AI图片助手</h3>
<p><a href="https://image.baidu.com/search/index?tn=baiduimage&amp;ipn=r&amp;ct=201326592&amp;cl=2&amp;lm=-1&amp;st=-1&amp;fm=detail&amp;fr=baiduimageedit&amp;hs=0&amp;xthttps=111110&amp;sf=1&amp;fmq=1713767239197_R&amp;pv=&amp;ic=0&amp;nc=1&amp;z=&amp;se=&amp;showtab=0&amp;fb=0&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;ie=utf-8&amp;word=bdaitpzs%E7%99%BE%E5%BA%A6AI%E5%9B%BE%E7%89%87%E5%8A%A9%E6%89%8Bbdaitpzs&amp;o">网址</a></p>
<h1>图片压缩</h1>
<h3 id="tinypng">TinyPng</h3>
<p><a href="https://tinypng.com/">地址</a></p>
<h3 id="色彩笔">色彩笔</h3>
<p><a href="https://www.secaibi.com/tools/">地址</a></p>
<h3 id="recompressor">Recompressor</h3>
<p><a href="https://zh.recompressor.com/">地址</a></p>
<h3 id="picdiet">Picdiet</h3>
<p><a href="https://www.picdiet.com/zh-cn?ref=dartools.com#google_vignette">地址</a></p>
<h3 id="squoosh">Squoosh</h3>
<p><a href="https://squoosh.app/">地址</a></p>
<h3 id="imagify">Imagify</h3>
<p><a href="http://webresizer.com/resizer/">地址</a></p>
<h3 id="optimizilla">Optimizilla</h3>
<p><a href="https://imagecompressor.com/zh/">地址</a></p>
]]></content>
      <categories>
        <category>工具分享</category>
      </categories>
      <tags>
        <tag>图片压缩在线工具</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器插件</title>
    <url>/post/def84ee6.html</url>
    <content><![CDATA[<p>如果我们经常使用的浏览器不是edge或者是chrome浏览器时，需要在浏览器安装插件时，无法获取插件以及不知道如何安装插件，本文章教你如何获取以及安装使用。</p>
<h1><center>获取方法</center></h1>
<h2 id="center-第一种方法-推荐-center"><center>第一种方法（推荐）</center></h2>
<p>无需“魔法”，即可访问获取插件的网站：<a href="https://www.crxsoso.com/">链接</a></p>
<p>还有一个浏览器一些黑科技小网站（正规绿色）：<a href="https://www.youxiaohou.com/">链接</a></p>
<h2 id="center-网上搜集下载地址-center"><center>网上搜集下载地址</center></h2>
<p>由于这些都是搬运的插件，若怕插件不安全，请使用第一种方法（本人正在使用），也可自行必应搜<code>浏览器插件下载</code>关键词</p>
<p>扩展坞：<a href="https://extensiondock.com/cn">链接</a></p>
<p>极简插件：<a href="https://chrome.zzzmh.cn/index">链接</a></p>
<p>收藏猫插件：<a href="https://chrome.pictureknow.com/">链接</a></p>
<h1><center>使用方法</center></h1>
<p>一般下载之后，插件文件的后缀名为：crx的单文件</p>
<p>这里以华为浏览器为例，首先打开华为浏览器，在右上角点击三点图标，选择设置，进入设置</p>
<img src="https://s2.loli.net/2024/08/19/XlcF9WSIkEOATfz.png" alt="打开浏览器设置" style="zoom:50%;">
<p>打开在左边的下面，有一个扩展程序，点击进去</p>
<img src="https://s2.loli.net/2024/08/19/8SNeo5OzCAmq9Un.png" alt="打开扩展程序" style="zoom:50%;">
<p>打开开发者模式</p>
<img src="https://s2.loli.net/2024/08/19/kOSZ9jAEy7qP8vR.png" alt="开发者模式" style="zoom: 33%;">
<p>打开之后，如果下载后的插件文件后缀为：<code>crx</code> 的单文件，则直接将文件拖进扩展程序这个页面，即可添加插件</p>
<p>如果是压缩包，解压之后是多文件，则点击左上角的加载已解压的扩展程序，然后选择解压出来的插件文件夹，打开即可。</p>
<p>如果是其他浏览器也是类似操作，也可以进行模仿尝试是否可以导入插件</p>
]]></content>
      <categories>
        <category>工具分享</category>
      </categories>
      <tags>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>CubeIDE与CubeMX软件设置</title>
    <url>/post/32e9e993.html</url>
    <content><![CDATA[<h1><center>stm32cubeMX库文件安装路径自定义设置</center></h1>
<p>打开stm32cubeMX软件，依次点击标题栏【Help】→【Updater Settings】</p>
<img src="https://s2.loli.net/2024/08/19/JLheYWSMProxE9N.png" style="zoom:50%;">
<p>点击图中的【Browser】，选择自己想要存放库文件的文件夹，选择完成后点击【OK】即可设置成功。</p>
<img src="https://s2.loli.net/2024/08/19/vfIDTXqhRkMzLuG.png" style="zoom:50%;">
<p>PS：这里的路径建议选择软件的安装目录</p>
<h1><center>stm32cubeIDE库安装路径自定义设置</center></h1>
<p>首先打开 stm32cubeIDE软件，然后依次点击【Window】→【Preference】</p>
<img src="https://s2.loli.net/2024/08/19/fFpBHGnV5LtIaQr.png" style="zoom:50%;">
<p>依次点击左侧【STM32Cube】→【Firmware Updater】，点击上图中的【Browser】，选择自己想要存放库文件的文件夹，选择完成后点击【Apply and Close】即可设置成功</p>
<img src="https://s2.loli.net/2024/08/19/1CisUhRVynDZS4j.png" style="zoom: 50%;">
<p>PS：stm32cubeIDE与stm32cubeMX的库文件是通用的，也可以直接选择了stm32cubeMX的库文件路径，这样stm32cubeIDE就可以自动识别文件夹中已有的库文件，避免库文件重复下载，节省了内存。</p>
<h1><center>STM32CubeIDE代码字体大小</center></h1>
<p>进入首选项设置</p>
<img src="https://s2.loli.net/2024/08/19/P1QzDuywg6JvdWh.png" alt="进入首选项" style="zoom:50%;">
<p>搜索editor，按照图中标号，进行设置</p>
<img src="https://s2.loli.net/2024/08/19/ZszSKUNbqoRfLhE.png" style="zoom:50%;">
<p>按图中标号进行设置，选择需要的字号，到此设置完成</p>
<img src="https://s2.loli.net/2024/08/19/1Iuhj8c4EOGgbrU.png" alt="选字号" style="zoom:50%;">
]]></content>
      <categories>
        <category>技术积累记录</category>
      </categories>
      <tags>
        <tag>CubeIDE与CubeMX软件设置</tag>
      </tags>
  </entry>
  <entry>
    <title>资源搜索网址</title>
    <url>/post/1f293ccb.html</url>
    <content><![CDATA[<h3 id="猫狸盘搜">猫狸盘搜</h3>
<p><a href="https://www.alipansou.com/">地址</a></p>
<h3 id="千帆搜索">千帆搜索</h3>
<p><a href="https://pan.qianfan.app/">地址</a></p>
<h3 id="懒盘搜索">懒盘搜索</h3>
<p><a href="https://www.lzpanx.com/">地址</a></p>
<h3 id="快盘搜">快盘搜</h3>
<p><a href="https://www.kpanso.com/">地址</a></p>
<h3 id="秒搜">秒搜</h3>
<p><a href="https://miaosou.fun/">地址</a></p>
<h3 id="皮卡搜索">皮卡搜索</h3>
<p><a href="https://www.pikaso.top/">地址</a></p>
<h3 id="磁力狗">磁力狗</h3>
<p><a href="http://clg0.icu/">地址</a></p>
<h3 id="老王磁力">老王磁力</h3>
<p><a href="https://laowangyx.top/">地址</a></p>
<h3 id="搜度盘">搜度盘</h3>
<p><a href="http://www.sodu123.com/index.html">地址</a></p>
<h3 id="小白盘">小白盘</h3>
<p><a href="https://www.xiaobaipan.com/">地址</a></p>
<h3 id="文件搜">文件搜</h3>
<p><a href="https://wjsou.com/">地址</a></p>
<h3 id="soso云盘">SOSO云盘</h3>
<p><a href="https://www.sosoyunpan.com/">地址</a></p>
<h3 id="搜baidu盘">搜BaiDu盘</h3>
<p><a href="https://www.sobaidupan.com/">地址</a></p>
<h3 id="盘友圈">盘友圈</h3>
<p><a href="https://panyq.com/">地址</a></p>
<h3 id="up云搜">UP云搜</h3>
<p><a href="https://www.upyunso.com/">地址</a></p>
<h3 id="学霸盘">学霸盘</h3>
<p><a href="https://www.xuebapan.com/">地址</a></p>
<h3 id="盘他一下">盘他一下</h3>
<p><a href="https://www.panothers.com/">地址</a></p>
<h3 id="云盘分享网">云盘分享网</h3>
<p><a href="https://alypw.cn/">网址</a></p>
<h3 id="好当家">好当家</h3>
<p><a href="https://www.hjdang.com/">网址</a></p>
<h3 id="爱盘搜">爱盘搜</h3>
<p><a href="https://aipanso.com/">网址</a></p>
<h3 id="易搜">易搜</h3>
<p><a href="https://yiso.fun/">网址</a></p>
]]></content>
      <categories>
        <category>工具分享</category>
      </categories>
      <tags>
        <tag>资源搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>Win11相关设置</title>
    <url>/post/f705831.html</url>
    <content><![CDATA[<h1>使用 Win10的文件资源管理器</h1>
<p>在 Windows 11 中恢复旧文件资源管理器 首先打开记事本并粘贴以下文本代码，然后保存，将记事本重命名为：文件名.reg，如：<code>file.reg</code>，然后双击添加注册表即可</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version <span class="number">5</span>.<span class="number">00</span></span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;<span class="number">2</span>aa9162e-c906-<span class="number">4</span>dd9-ad0b-<span class="number">3</span>d24a8eef5a0&#125;]</span><br><span class="line">@=&quot;CLSID_ItemsViewAdapter&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;<span class="number">2</span>aa9162e-c906-<span class="number">4</span>dd9-ad0b-<span class="number">3</span>d24a8eef5a0&#125;\InProcServer32]</span><br><span class="line">@=&quot;C:\\Windows\\System32\\Windows.UI.FileExplorer.dll_&quot;</span><br><span class="line">&quot;ThreadingModel&quot;=&quot;Apartment&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;<span class="number">6480100</span>b-<span class="number">5</span>a83-<span class="number">4</span>d1e-<span class="number">9</span>f69-<span class="number">8</span>ae5a88e9a33&#125;]</span><br><span class="line">@=&quot;File Explorer Xaml Island View Adapter&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;<span class="number">6480100</span>b-<span class="number">5</span>a83-<span class="number">4</span>d1e-<span class="number">9</span>f69-<span class="number">8</span>ae5a88e9a33&#125;\InProcServer32]</span><br><span class="line">@=&quot;C:\\Windows\\System32\\Windows.UI.FileExplorer.dll_&quot;</span><br><span class="line">&quot;ThreadingModel&quot;=&quot;Apartment&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\Toolbar\ShellBrowser]</span><br><span class="line">&quot;ITBar7Layout&quot;=hex:<span class="number">13</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">20</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">10</span>,<span class="number">00</span>,<span class="number">01</span>,<span class="number">00</span>,\</span><br><span class="line">  <span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">01</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">01</span>,<span class="number">07</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">5</span>e,<span class="number">01</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,\</span><br><span class="line">  <span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,\</span><br><span class="line">  <span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,\</span><br><span class="line">  <span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,\</span><br><span class="line">  <span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,\</span><br><span class="line">  <span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,\</span><br><span class="line">  <span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,\</span><br><span class="line">  <span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,\</span><br><span class="line">  <span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,\</span><br><span class="line">  <span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,\</span><br><span class="line">  <span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,\</span><br><span class="line">  <span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,\</span><br><span class="line">  <span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,\</span><br><span class="line">  <span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,\</span><br><span class="line">  <span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,\</span><br><span class="line">  <span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,\</span><br><span class="line">  <span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,\</span><br><span class="line">  <span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,\</span><br><span class="line">  <span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,\</span><br><span class="line">  <span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,\</span><br><span class="line">  <span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,\</span><br><span class="line">  <span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span></span><br></pre></td></tr></table></figure>
<p>关闭 Windows 10 的文件资源管理器，切换回 Windows 11</p>
<p>再次打开记事本，把下面的文本粘贴进去，保存同样的 .reg 文件，双击执行即可</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version <span class="number">5</span>.<span class="number">00</span> </span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;<span class="number">2</span>aa9162e-c906-<span class="number">4</span>dd9-ad0b-<span class="number">3</span>d24a8eef5a0&#125;] </span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;<span class="number">6480100</span>b-<span class="number">5</span>a83-<span class="number">4</span>d1e-<span class="number">9</span>f69-<span class="number">8</span>ae5a88e9a33&#125;]</span><br></pre></td></tr></table></figure>
<h1>Win11右键修改成Win10</h1>
<p><code>win + r</code>以管理员运行命令窗口，输入下列代码，重启电脑或文件管理区</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKCU\Software\Classes\CLSID\&#123;<span class="number">86</span>ca1aa0-<span class="number">34</span>aa-<span class="number">4</span>e8b-a509-<span class="number">50</span>c905bae2a2&#125;\InprocServer32&quot; /f /ve</span><br></pre></td></tr></table></figure>
<h1>家庭版系统增加Hyper-V</h1>
<p>新建txt文件，将下面复制进去，改名为<code>Hyper-V.bat</code>，以管理员身份运行，然后重启电脑</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pushd &quot;%~dp0&quot;</span><br><span class="line"></span><br><span class="line">dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hyper-v.txt</span><br><span class="line"></span><br><span class="line">for /f %%i in (&#x27;findstr /i . hyper-v.txt 2^&gt;nul&#x27;) do dism /online /norestart /add-package:&quot;%SystemRoot%\servicing\Packages\%%i&quot;</span><br><span class="line"></span><br><span class="line">del hyper-v.txt</span><br><span class="line"></span><br><span class="line">Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术积累记录</category>
      </categories>
      <tags>
        <tag>Win11相关设置</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot相关配置</title>
    <url>/post/fd908b52.html</url>
    <content><![CDATA[<h1><center>maven安装与配置</center></h1>
<blockquote>
<p>maven安装：<a href="https://archive.apache.org/dist/maven/maven-3/">网址</a>（这里以3.6.3为例），选择好对应版本后，点击<code>binaries</code></p>
</blockquote>
<img src="https://s2.loli.net/2024/09/30/UcuHV5jgt4Xv2eW.webp" alt="maven安装" style="zoom:40%;">
<blockquote>
<p>配置环境变量(任务栏放大镜搜索)，进入后添加</p>
<p>变量名：<code>MAVEN_HOME</code>，变量值：maven下载后的解压路径(看到bin)</p>
</blockquote>
<img src="https://s2.loli.net/2024/09/30/b5gQYH7TR9OzjSV.webp" alt="配置环境变量" style="zoom:40%;">
<blockquote>
<p>继续配置，双击<code>Path</code>，新建添加<code>%MAVEN_HOME%\bin</code>，然后一层层点确定</p>
</blockquote>
<img src="https://s2.loli.net/2024/09/30/sWBeRwgU5AzpaSN.webp" alt="配置环境变量" style="zoom:45%;">
<blockquote>
<p>测试是否配置完成，cdm命令输入：<code>mvn -v</code></p>
</blockquote>
<img src="https://s2.loli.net/2024/09/30/CiOc5KxDzPrXUS3.webp" alt="成功图" style="zoom:50%;">
<h1><center>修改仓库</center></h1>
<blockquote>
<p>在maven 下载后的解压路径下，新建一个文件夹 文件命名为<code>repository</code></p>
</blockquote>
<img src="https://s2.loli.net/2024/09/30/uHG839XgwcVnxRo.webp" alt="新建文件夹" style="zoom:50%;">
<blockquote>
<p>在解压文件夹中找到<code>conf</code>，打开<code>settings.xml</code></p>
</blockquote>
<img src="https://s2.loli.net/2024/09/30/ixUDlSBP96GY24t.webp" alt="打开文件" style="zoom:50%;">
<h2 id="修改本地仓库">修改本地仓库</h2>
<blockquote>
<p>找到<code>localRepositor</code>标签，可能注释掉了，直接搜索取消注释即可，找到后添加刚才创建文件夹路径</p>
</blockquote>
<img src="https://s2.loli.net/2024/09/30/B7LQhATnlzyPpdq.webp" alt="修改本地仓库位置" style="zoom:40%;">
<h2 id="修改远程仓库">修改远程仓库</h2>
<blockquote>
<p>找到<code>mirrors</code>标签，可能注释掉了，直接搜索取消注释即可，找到后添加以下代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">    &lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">    &lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http:<span class="comment">//maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span></span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2024/09/30/5IHyqTFCuWQPjRf.webp" alt="添加代码" style="zoom:35%;">
<blockquote>
<p>验证maven本地仓库和远程仓库是否配置成功，在命令行界面输入<code>mvn help:system</code>，出现图中标志表示成功</p>
</blockquote>
<img src="https://s2.loli.net/2024/09/30/3Vivd95MEeKkycZ.webp" alt="验证" style="zoom:60%;">
<h1><center>项目打包成jar包</center></h1>
<blockquote>
<p>查看项目中的<code>pom.xml</code>是否有一下插件，如果没有添加，如果按上面配置应该是有</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用Maven命令打包，在项目中的终端或者命令窗口进入到项目文件夹运行命令</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mvn clean <span class="keyword">package</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行jar包，输入以下命令</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar jar包名</span><br><span class="line"><span class="comment">//例：java -jar demoa-0.0.1-SNAPSHOT.jar</span></span><br></pre></td></tr></table></figure>
<h1>idea修改设置默认maven，解决每次新建和导入项目都需要重新配置maven</h1>
<p>配置系统环境变量及Path环境变量</p>
<blockquote>
<p>变量名：<code>MAVEN_HOME</code></p>
<p>变量值:<code>D:\apache-maven-3.6.2</code> (D:\APP\maven_3.6.3)</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/14/yHwBVoTe2IYA76l.webp" alt="配置环境变量1" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>配置Path环境变量，在maven中进入bin目录，复制目录，填进去(D:\APP\maven_3.6.3\bin)</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/10/14/KgWG9bFcOVqATe7.webp" alt="环境变量配置2" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<blockquote>
<p>验证：cmd打开窗口，输入<code>mvn -version</code>，如果出现对应maven的版本号，即成功</p>
</blockquote>
<p>修改默认仓库</p>
<p>进入maven文件夹找到图片的文件打开，然后在maven文件夹下新建一个文件夹名为<code>repository</code></p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/10/14/tADH94LVjkuy7Ro.webp" alt="进入文件" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>进入后，找到图片中的位置增加圈中的代码，中间的路径则为刚才新建的文件夹路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;localRepository&gt;D:\APP\maven_3.6.3\repository&lt;/localRepository&gt;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/10/14/ws2hxZDUvQiSRT6.webp" alt="修改本地仓库" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>顺便将仓库修改为阿里云的，可以快速下载配置文件，往下滑增加图片中的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">  &lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">  &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">  &lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">  &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/14/3qAhPMCN6ZyEFT5.webp" alt="修改仓库" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>修改完成之后，新建工程，进入工程，打开设置，按照图中修改</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/10/14/r9HCFyWsO3NaevR.webp" alt="修改工程中的maven" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>修改新建工程时的maven仓库地址，修改后就完成了</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/10/14/E98bzUKwh3JdeGu.webp" alt="修改新工程的配置" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
]]></content>
      <categories>
        <category>技术积累记录</category>
      </categories>
      <tags>
        <tag>springboot相关配置</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu相关设置</title>
    <url>/post/96c26968.html</url>
    <content><![CDATA[<h1><center>设置Ubuntu中文界面</center></h1>
<p>进入语言设置</p>
<img src="https://s2.loli.net/2024/09/12/CsSj7RbPhx2HGwD.webp" alt="进入语言设置" style="zoom:50%;">
<p>进入语言下载，打勾简体中文，点击应用下载</p>
<img src="https://s2.loli.net/2024/09/12/WTuOsodlyKNDGf3.webp" alt="下载语言包" style="zoom: 67%;">
<p>更换中文语言</p>
<img src="https://s2.loli.net/2024/09/12/SFU2CkZPBqYuKs4.webp" alt="更换中文语言" style="zoom:50%;">
<p>重启更新语言，输入密码重启</p>
<img src="https://s2.loli.net/2024/09/12/PQja9sUpwTcIdyJ.webp" alt="更新语言" style="zoom:50%;">
<p>根据需求选择，推荐保留就的名称</p>
<img src="https://s2.loli.net/2024/09/12/H7DRydPuovct6mT.webp" alt="自行选择对应" style="zoom:60%;">
<h1><center>设置Ubuntu字体大小</center></h1>
<p>打开终端，安装gnome-tweaks</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo apt install gnome-tweaks</span><br></pre></td></tr></table></figure>
<p>安装完成之后，输入</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">gnome-tweaks</span><br></pre></td></tr></table></figure>
<p>根据需求调整字体大小</p>
<img src="https://s2.loli.net/2024/09/12/6AnpSRgylNv3JKT.webp" alt="调整字体大小" style="zoom:50%;">
<h1><center>设置Ubuntu鼠标大小</center></h1>
<p>进入设置，按照图片指示按需修改</p>
<img src="https://s2.loli.net/2024/09/12/CiwO4hgvVLcIHop.webp" alt="修改鼠标大小" style="zoom:50%;">
]]></content>
      <categories>
        <category>技术积累记录</category>
      </categories>
      <tags>
        <tag>ubuntu相关设置</tag>
      </tags>
  </entry>
  <entry>
    <title>1.MySQL基础</title>
    <url>/post/c24675b4.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th style="text-align:center">关键字</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">database</td>
<td style="text-align:center">库</td>
</tr>
<tr>
<td style="text-align:center">table</td>
<td style="text-align:center">表</td>
</tr>
<tr>
<td style="text-align:center">create</td>
<td style="text-align:center">创建</td>
</tr>
<tr>
<td style="text-align:center">drop</td>
<td style="text-align:center">删除(数据库或表)</td>
</tr>
<tr>
<td style="text-align:center">alter</td>
<td style="text-align:center">修改</td>
</tr>
<tr>
<td style="text-align:center">update</td>
<td style="text-align:center">数据修改</td>
</tr>
<tr>
<td style="text-align:center">insert into</td>
<td style="text-align:center">插入</td>
</tr>
<tr>
<td style="text-align:center">where</td>
<td style="text-align:center">筛选</td>
</tr>
<tr>
<td style="text-align:center">delete from</td>
<td style="text-align:center">删除(数据)</td>
</tr>
<tr>
<td style="text-align:center">select</td>
<td style="text-align:center">查询</td>
</tr>
</tbody>
</table>
<h1>查看所有数据库</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查看所有数据库</span><br><span class="line">show databases;</span><br></pre></td></tr></table></figure>
<h1>查看当前数据库所有的表</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure>
<h1>查看指定表的创建语句</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show create table 查看的表名;</span><br><span class="line">show create table student;</span><br></pre></td></tr></table></figure>
<h1>查看表结构</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">desc 表名;</span><br><span class="line">desc student;</span><br></pre></td></tr></table></figure>
<h1>创建数据库</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database 创建数据库名字;</span><br><span class="line">create database mydb1;</span><br><span class="line"></span><br><span class="line">-- if not exists：当数据库mydbq不存在时才创建</span><br><span class="line">create database if not exists 创建数据库名字;</span><br><span class="line">create database if not exists mydbq;</span><br></pre></td></tr></table></figure>
<h1>使用哪个数据库</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use 使用的数据库名;</span><br><span class="line">use mydb1;</span><br></pre></td></tr></table></figure>
<h1>删除数据库</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop database 删除的数据库名;</span><br><span class="line">drop database mydb1;</span><br><span class="line"></span><br><span class="line">-- if exists：当数据库mydb1存在时才删除</span><br><span class="line">drop database if exists 删除的数据库名;</span><br><span class="line">drop database if exists mydb1;</span><br></pre></td></tr></table></figure>
<h1>修改数据库编码（默认utf8）</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter database 修改的数据库名 character set 编码格式;</span><br><span class="line">alter database mydb1 character set utf8;</span><br></pre></td></tr></table></figure>
<h1>创建表</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建表是构建一张空表，指定这个表的名字，这个表有几列，每一列叫什么名字，以及每一列存储的数据类型</span><br><span class="line">-- 字段名：每一列的名字，中括号中的内容可以省略也可以添加</span><br><span class="line">create table [if not exists]表名(</span><br><span class="line">  字段名1 类型[(宽度)] [约束条件] [comment &#x27;字段说明&#x27;],</span><br><span class="line">  字段名2 类型[(宽度)] [约束条件] [comment &#x27;字段说明&#x27;],</span><br><span class="line">  字段名3 类型[(宽度)] [约束条件] [comment &#x27;字段说明&#x27;]</span><br><span class="line">)[表的一些设置];</span><br><span class="line"></span><br><span class="line">create table if not exists student(</span><br><span class="line">    sid int,</span><br><span class="line">    name varchar(20),</span><br><span class="line">    gender varchar(10),</span><br><span class="line">    age int,</span><br><span class="line">    birth date,</span><br><span class="line">    address varchar(20),</span><br><span class="line">    score double</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h1>数据类型</h1>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">描述</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">tinyint</td>
<td style="text-align:center">非常小的整数，带符号的范围是(-128, 127)，无符号的范围是(0, 255)</td>
<td>1 byte</td>
</tr>
<tr>
<td style="text-align:center">smallint</td>
<td style="text-align:center">较小的整数，带符号的范围是(-32,768, 32,767)，无符号的范围是(0, 65,535)</td>
<td>2 byte</td>
</tr>
<tr>
<td style="text-align:center">mediumint</td>
<td style="text-align:center">中等大小的整数，带符号的范围是(-8,388,608, 8,388,607)，无符号的范围是(0, 16,777,215)</td>
<td>3 byte</td>
</tr>
<tr>
<td style="text-align:center">int或integer</td>
<td style="text-align:center">普通大小的整数，带符号的范围是(-2,147,483,648, 2,147,483,647)，无符号的范围是(0, 4,294,967,295)</td>
<td>4 byte</td>
</tr>
<tr>
<td style="text-align:center">bigint</td>
<td style="text-align:center">大整数，带符号的范围是(-9,223,372,036,854,775,808, 9,223,372,036,854,775,807)，无符号的范围是(0, 18,446,744,073,709,551,615)</td>
<td>8 byte</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">单精度浮点数</td>
<td>4 byte</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">双精度浮点数</td>
<td>8 byte</td>
</tr>
<tr>
<td style="text-align:center">decimal</td>
<td style="text-align:center">小数，精度和标度可变</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">varchar</td>
<td style="text-align:center">变长字符串，0-65535</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">date</td>
<td style="text-align:center">日期，格式为YYYY-MM-DD(1000-01-01~9999-12-31)</td>
<td>3</td>
</tr>
<tr>
<td style="text-align:center">datetime</td>
<td style="text-align:center">混合日期和时间值(1000-01-01 00:00:00~9999-12-31 23:59:59)</td>
<td>8</td>
</tr>
<tr>
<td style="text-align:center">timestamp</td>
<td style="text-align:center">混合日期和时间值 时间戳(获取当前时区时间)</td>
<td>4</td>
</tr>
</tbody>
</table>
<h1>删除表</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table 表名;</span><br><span class="line">drop table student;</span><br></pre></td></tr></table></figure>
<h1>修改表结构</h1>
<h2 id="表添加列">表添加列</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 add 列名 类型(长度) [约束];</span><br><span class="line"></span><br><span class="line">-- 为student表添加一个新的字段为：系别 dept 类型为 varchar(20)</span><br><span class="line">alter table student add dept varchar(20);</span><br></pre></td></tr></table></figure>
<h2 id="修改列名和类型">修改列名和类型</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 change 旧列名 新列名 类型(长度) 约束; </span><br><span class="line"></span><br><span class="line">-- 为student表的dept字段更换为department varchar(30)</span><br><span class="line">alter table student change dept department varchar(30);</span><br></pre></td></tr></table></figure>
<h2 id="删除列">删除列</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 drop 列名;</span><br><span class="line"></span><br><span class="line">-- 删除student表中department这列</span><br><span class="line">alter table student drop department;</span><br></pre></td></tr></table></figure>
<h2 id="修改表名">修改表名</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rename table 表名 to 新表名;</span><br><span class="line"></span><br><span class="line">-- 将表student改名成 stu</span><br><span class="line">rename table student to stu;</span><br></pre></td></tr></table></figure>
<h1>表的增删改(DML)</h1>
<h2 id="插入数据">插入数据</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 向某些列插入值</span><br><span class="line">-- 值要与列名的数据类型保持一致</span><br><span class="line">insert into 表 (列名1,列名2,列名3...) values (值1,值2,值3...);</span><br><span class="line">-- 向表中所有列插入值</span><br><span class="line">insert into 表 values (值1,值2,值3...);</span><br><span class="line"></span><br><span class="line">insert into student(sid,name,gender,age,birth,address,score)</span><br><span class="line">	values (1001,&#x27;张三&#x27;,&#x27;男&#x27;,18,&#x27;2001-11-12&#x27;,&#x27;北京&#x27;,13.9),</span><br><span class="line">	(1002,&#x27;李四&#x27;,&#x27;女&#x27;,15,&#x27;2001-11-12&#x27;,&#x27;北京&#x27;,10.9);</span><br><span class="line">	</span><br><span class="line">insert into student values (1003,&#x27;王五&#x27;,&#x27;女&#x27;,34,&#x27;1992-12-01&#x27;,&#x27;深圳&#x27;,23);</span><br></pre></td></tr></table></figure>
<h2 id="数据修改">数据修改</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 将字段名那一列全部行都修改</span><br><span class="line">update 表名 set 字段名=值,字段名=值...;</span><br><span class="line">-- 满足条件的行才修改</span><br><span class="line">update 表名 set 字段名=值,字段名=值... where 条件;</span><br><span class="line"></span><br><span class="line">-- 将所有学生的地址修改为重庆</span><br><span class="line">update student set address=&#x27;重庆&#x27;;</span><br><span class="line">-- id为1002的学生的地址修改为北京</span><br><span class="line">update student set address=&#x27;北京&#x27; where sid = 1002;</span><br><span class="line">-- id为1001的学生的地址修改为上海，成绩修成绩修改为100</span><br><span class="line">update student set address=&#x27;上海&#x27;,score=100 where sid = 1001;</span><br></pre></td></tr></table></figure>
<h2 id="数据删除">数据删除</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from 表名 [where 条件];</span><br><span class="line">-- 整个表删除，然后再创建该表</span><br><span class="line">truncate table 表名; 或者 truncate 表名;</span><br><span class="line"></span><br><span class="line">-- 删除sid为1004的学生数据</span><br><span class="line">delete from student where sid = 1003;</span><br><span class="line">-- 2.删除表所有数据</span><br><span class="line">delete from student;</span><br><span class="line">-- 3.清空表数据</span><br><span class="line">truncate table student;</span><br><span class="line">truncate student;</span><br></pre></td></tr></table></figure>
<h1>约束</h1>
<h2 id="主键约束">主键约束</h2>
<p>主键可以是一个列或者多个列的组合，其值能唯一地标识表中的每一行，方便在RDBMS中尽快的找到某一行</p>
<p><code>不允许重复，不允许空值</code>，每个表最多只允许<code>一个主键</code>，当创建主键的约束时，系统默认会在所在的列和列组合上建立对应的唯一索引</p>
<p>关键字：<code>primary key</code></p>
<h3 id="添加单列主键">添加单列主键</h3>
<p>方式1：在定义字段的同时指定主键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">   ...</span><br><span class="line">   &lt;字段名&gt; &lt;数据类型&gt; primary key</span><br><span class="line">   ...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp1(</span><br><span class="line">    -- 将eid添加主键约束</span><br><span class="line">	eid int primary key,</span><br><span class="line">	name varchar(20),</span><br><span class="line">	deptId int,</span><br><span class="line">	salary double</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>方式2：在定义字段之后再指定主键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">   ...</span><br><span class="line">    -- []里面可以省略</span><br><span class="line">   [constraint &lt;约束名&gt;] primary key [字段名]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp2(</span><br><span class="line">	eid int,</span><br><span class="line">	name varchar(20),</span><br><span class="line">	deptId int,</span><br><span class="line">	salary double,</span><br><span class="line">    -- constraint pk1可以省略</span><br><span class="line">	constraint pk1 primary key(eid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="添加多列联合主键">添加多列联合主键</h3>
<ul>
<li>主键由一张表中多个字段组成，只要主键的字段不完全相同即可但任何一个都不能为空</li>
<li>当主键是由多个字段组成时，不能直接在字段名后面声明主键约束</li>
<li>一张表只能有一个主键，联合主键也是一个主键</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">   ...</span><br><span class="line">   primary key (字段1，字段2，…,字段n)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp3(</span><br><span class="line">	eid int,</span><br><span class="line">	name varchar(20),</span><br><span class="line">	deptId int,</span><br><span class="line">	salary double,</span><br><span class="line">	constraint pk2 primary key (eid,deptId)</span><br><span class="line">);</span><br><span class="line">insert into emp3 values(1001,&#x27;李四&#x27;,2001,23);</span><br><span class="line">-- eid 和 deptId两个都相同添加不了</span><br><span class="line">-- insert into emp3 values(1001,&#x27;李四&#x27;,2001,23);</span><br><span class="line">-- 只要两个有一个不同即可添加，但是两个任何一个都不能为空</span><br><span class="line">insert into emp3 values(1001,&#x27;李四&#x27;,2002,23);</span><br></pre></td></tr></table></figure>
<h3 id="修改表结构添加主键">修改表结构添加主键</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">   ...</span><br><span class="line">);</span><br><span class="line">alter table &lt;表名&gt; add primary key（字段列表);</span><br><span class="line"></span><br><span class="line">create table emp4(</span><br><span class="line">	eid int,</span><br><span class="line">	name varchar(20),</span><br><span class="line">	deptId int,</span><br><span class="line">	salary double</span><br><span class="line">);</span><br><span class="line">-- 添加单列主键</span><br><span class="line">alter table emp4 add primary key(eid);</span><br><span class="line"></span><br><span class="line">create table emp5(</span><br><span class="line">	eid int,</span><br><span class="line">	name varchar(20),</span><br><span class="line">	deptId int,</span><br><span class="line">	salary double</span><br><span class="line">);</span><br><span class="line">-- 添加联合主键</span><br><span class="line">alter table emp5 add primary key(name,eid);</span><br></pre></td></tr></table></figure>
<h3 id="删除主键">删除主键</h3>
<p>修改表结构实现删除主键，删除主键不分单列主键或多列联合主键，删除全删</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table &lt;数据表名&gt; drop primary key;</span><br><span class="line"></span><br><span class="line">-- 删除单列主键</span><br><span class="line">alter table emp1 drop primary key;</span><br><span class="line">-- 删除多列联合主键</span><br><span class="line">alter table emp5 drop primary key;</span><br></pre></td></tr></table></figure>
<h2 id="自增长约束">自增长约束</h2>
<p>当主键定义为自增长后，这个主键的值就不再需要用户输入数据了，而由数据库系统根据定义自动赋值。每增加一条记录，主键会自动以相同的步长进行增长</p>
<blockquote>
<p>给字段添加 <code>auto_increment</code> 属性来实现主键自增长</p>
<ul>
<li>初始值是 1，每新增一条记录，字段值自动加 1</li>
<li>一个表中只能有一个字段使用 auto_increment约束，且该字段必须有唯一索引，以避免序号重复（即为主键或主键的一部分）</li>
<li>字段必须具备 NOT NULL 属性</li>
<li>字段只能是整数类型(TINYINT、SMALLINT、INT、BIGINT )</li>
<li>增长的最大值为该字段数据类型的最大值</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字段名 数据类型 primary key auto_increment</span><br><span class="line"></span><br><span class="line">-- 添加自增站约束</span><br><span class="line">create table t_user1(</span><br><span class="line">	id int primary key auto_increment,</span><br><span class="line">	name varchar(20)</span><br><span class="line">);</span><br><span class="line">-- 从1开始自增长，每次加1</span><br><span class="line">insert into t_user1 values(NULL,&#x27;张三&#x27;);</span><br><span class="line">insert into t_user1(name) values(&#x27;李四&#x27;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>指定自增字段初始值</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 方式一：创建表时指定</span><br><span class="line">create table t_user2(</span><br><span class="line">	id int primary key auto_increment,</span><br><span class="line">	name varchar(20)</span><br><span class="line">)auto_increment=100;</span><br><span class="line"></span><br><span class="line">-- 方式二：创建表之后指定</span><br><span class="line">create table t_user3(</span><br><span class="line">	id int primary key auto_increment,</span><br><span class="line">	name varchar(20)</span><br><span class="line">);</span><br><span class="line">-- 通过修改表结构来指定初始值</span><br><span class="line">alter table t_user3 auto_increment = 200;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong><code>delete</code> 和 <code>truncate</code> 在删除后自增列的变化</strong></p>
</blockquote>
<ul>
<li>delete 数据之后自动增长从断点开始</li>
<li>truncate 数据之后自动增长从默认起始值开始</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- delete删除数据之后，自增长还是在最后一个值基础上加1</span><br><span class="line">delete from t_user2;</span><br><span class="line">-- 如最后一个id值为100，则删除重新添加数据之后从101开始</span><br><span class="line">insert into t_user2(name) values(&#x27;李四&#x27;);</span><br><span class="line"></span><br><span class="line">-- truncate删除之后，自增长从1开始</span><br><span class="line">truncate t_user3;</span><br><span class="line">insert into t_user3(name) values(&#x27;李四&#x27;);</span><br></pre></td></tr></table></figure>
<h2 id="非空约束">非空约束</h2>
<p>使用了非空约束的字段，如果用户在添加数据时没有指定值，数据库系统就会报错</p>
<blockquote>
<p>添加</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 方式一：创建表时指定</span><br><span class="line">字段名 数据类型 not null;</span><br><span class="line">create table t_user6(</span><br><span class="line">	id int,</span><br><span class="line">	name varchar(20) not null,	-- 指定非空约束</span><br><span class="line">	address varchar(20) not null</span><br><span class="line">);</span><br><span class="line">-- insert into t_user6(id) values(1001);	name、address为空报错</span><br><span class="line">-- 控制字符串可以</span><br><span class="line">insert into t_user6(id,name,address) values(1001,&#x27;&#x27;,&#x27;&#x27;);</span><br><span class="line">-- 字符串为NULL</span><br><span class="line">insert into t_user6(id,name,address) values(1001,&#x27;NULL&#x27;,&#x27;NULL&#x27;);</span><br><span class="line"></span><br><span class="line">-- 方式二：创建表之后通过修改表结构指定</span><br><span class="line">alter table 表名 modify 字段 类型 not null;</span><br><span class="line">create table t_user7(</span><br><span class="line">	id int,</span><br><span class="line">	name varchar(20),</span><br><span class="line">	address varchar(20)</span><br><span class="line">);</span><br><span class="line">alter table t_user7 modify name varchar(20) not null;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table t_user7 modify name varchar(20);</span><br></pre></td></tr></table></figure>
<h2 id="唯一约束">唯一约束</h2>
<p>一个表可以有多个唯一约束，可以包含NULL值</p>
<blockquote>
<p>添加</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 方式一：创建表时指定</span><br><span class="line">&lt;字段名&gt; &lt;数据类型&gt; unique</span><br><span class="line">create table t_user8(</span><br><span class="line">	id int,</span><br><span class="line">	name varchar(20),</span><br><span class="line">	phone_number varchar(20) unique</span><br><span class="line">);</span><br><span class="line">insert into t_user8 values(1001,&#x27;张三&#x27;,138);</span><br><span class="line">-- phone_number不能重复</span><br><span class="line">-- insert into t_user8 values(1001,&#x27;张三&#x27;,138);</span><br><span class="line">-- 在mysql中NULL和任何值都不相同，甚至和自己都不相同</span><br><span class="line">insert into t_user8 values(1002,&#x27;张1&#x27;,NULL);</span><br><span class="line">insert into t_user8 values(1003,&#x27;张2&#x27;,NULL);</span><br><span class="line"></span><br><span class="line">-- 方式二：创建表之后通过修改表结构指定</span><br><span class="line">alter table 表名 add constraint 约束名 unique(列);</span><br><span class="line">create table t_user9(</span><br><span class="line">	id int,</span><br><span class="line">	name varchar(20),</span><br><span class="line">	phone_number varchar(20)</span><br><span class="line">);</span><br><span class="line">alter table t_user9 add constraint unique_pn unique(phone_number);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table &lt;表名&gt; drop index &lt;唯一约束名&gt;;</span><br><span class="line"></span><br><span class="line">-- 使用第二种创建的约束删除</span><br><span class="line">alter table t_user9 drop index unique_pn;</span><br><span class="line">-- 使用第一种创建的约束删除，约束名为约束那一列的列名</span><br><span class="line">alter table t_user8 drop index phone_number;</span><br></pre></td></tr></table></figure>
<h2 id="默认约束">默认约束</h2>
<p>默认值约束用来指定某列的默认值</p>
<blockquote>
<p>创建</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 方式一：创建表时指定</span><br><span class="line">&lt;字段名&gt; &lt;数据类型&gt; default &lt;默认值&gt;;</span><br><span class="line">create table t_user10(</span><br><span class="line">	id INT,</span><br><span class="line">	name varchar(20),</span><br><span class="line">	address varchar(20) default &#x27;北京&#x27;</span><br><span class="line">);</span><br><span class="line">-- address没给定值，默认为北京</span><br><span class="line">insert into t_user10(id,name) values(1001,&#x27;李四&#x27;);</span><br><span class="line"></span><br><span class="line">-- 方式二：创建表之后通过修改表结构指定</span><br><span class="line">alter table 表名 modify 列名 类型 default 默认值;</span><br><span class="line">create table t_user11(</span><br><span class="line">	id INT,</span><br><span class="line">	name varchar(20),</span><br><span class="line">	address varchar(20)</span><br><span class="line">);</span><br><span class="line">alter table t_user11 modify address varchar(20) default &#x27;深圳&#x27;;</span><br><span class="line">insert into t_user11(id,name) values(1001,&#x27;李四&#x27;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table &lt;表名&gt; modify column &lt;字段名&gt; &lt;类型&gt; default null;</span><br><span class="line"></span><br><span class="line">alter table t_user11 modify address varchar(20) default null;</span><br></pre></td></tr></table></figure>
<h2 id="零填充约束">零填充约束</h2>
<p>插入数据时，当该字段的值的长度小于定义的长度时，会在该值的前面补上相应的0</p>
<blockquote>
<p>创建</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table t_user12(</span><br><span class="line">	id int zerofill,</span><br><span class="line">	name varchar(20)</span><br><span class="line">);</span><br><span class="line">insert into t_user12 values(20,&#x27;李四&#x27;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table t_user12 modify id int;</span><br></pre></td></tr></table></figure>
<h1>基本查询</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">  [all | distinct]</span><br><span class="line">  &lt;目标列的表达式1&gt; [别名],</span><br><span class="line">  &lt;目标列的表达式2&gt; [别名]...</span><br><span class="line">from &lt;表名或视图名&gt; [别名],&lt;表名或视图名&gt; [别名]...</span><br><span class="line">[where&lt;条件表达式&gt;]</span><br><span class="line">[group by &lt;列名&gt; </span><br><span class="line">[having &lt;条件表达式&gt;]]</span><br><span class="line">[order by &lt;列名&gt; [asc|desc]]</span><br><span class="line">[limit &lt;数字或者列表&gt;];</span><br><span class="line"></span><br><span class="line">-- 简化版</span><br><span class="line">select *|列名 from 表 where 条件</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询所有商品</span><br><span class="line">select pid,pname,price,category_id from product;</span><br><span class="line">-- *：代表所有列</span><br><span class="line">select * from product;</span><br><span class="line"></span><br><span class="line">-- 查询商品名和商品价格</span><br><span class="line">select 列名1,列名2 from product;</span><br><span class="line">select pname,price from product;</span><br><span class="line"></span><br><span class="line">-- 别名查询.使用的关键字是as（as可以省略的）</span><br><span class="line">select * from product 别名;</span><br><span class="line">-- 别名在多表查询有作用，表别名</span><br><span class="line">select * from product as p;</span><br><span class="line">select * from product p;</span><br><span class="line"></span><br><span class="line">-- 列别名</span><br><span class="line">select pname as 别名,price 别名 from product;</span><br><span class="line">select pname as &#x27;商品名&#x27;,price &#x27;商品价格&#x27; from product;</span><br><span class="line"></span><br><span class="line">-- 去掉重复值</span><br><span class="line">select distinct 列名 from product;</span><br><span class="line">select distinct price from product;</span><br><span class="line">select distinct * from product;</span><br><span class="line"></span><br><span class="line">-- 查询结果是表达式（运算查询）：将所有商品的价格+10元进行显示</span><br><span class="line">select pname, price+10 别名 from product;</span><br><span class="line">select pname, price+10 new_price from product;</span><br></pre></td></tr></table></figure>
<h2 id="运算符">运算符</h2>
<table>
<thead>
<tr>
<th style="text-align:center">算术运算符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>+</strong></td>
<td style="text-align:center">加法运算</td>
</tr>
<tr>
<td style="text-align:center"><strong>-</strong></td>
<td style="text-align:center">减法运算</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">乘法运算</td>
</tr>
<tr>
<td style="text-align:center"><strong>/</strong> 或 <strong>DIV</strong></td>
<td style="text-align:center">除法运算，返回商</td>
</tr>
<tr>
<td style="text-align:center"><strong>%</strong> 或 <strong>MOD</strong></td>
<td style="text-align:center">求余运算，返回余数</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 将每件商品的价格加10</span><br><span class="line">select pname,price +10 as new_price from product;</span><br><span class="line">-- 将所有商品的价格上调10%</span><br><span class="line">select pname,price *1.1 as new_price from product;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">比较运算符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>=</strong></td>
<td style="text-align:center">等于</td>
</tr>
<tr>
<td style="text-align:center"><strong>&lt;</strong>  <strong>和</strong>  <strong>&lt;=</strong></td>
<td style="text-align:center">小于和小于等于</td>
</tr>
<tr>
<td style="text-align:center"><strong>&gt;</strong>  <strong>和</strong>  <strong>&gt;=</strong></td>
<td style="text-align:center">大于和大于等于</td>
</tr>
<tr>
<td style="text-align:center"><strong>&lt;=&gt;</strong></td>
<td style="text-align:center">完全等于，两个操作码均为NULL时，其所得值为1；而当一个操作码为NULL时，其所得值为0</td>
</tr>
<tr>
<td style="text-align:center"><strong>&lt;&gt;</strong> <strong>或!=</strong></td>
<td style="text-align:center">不等于</td>
</tr>
<tr>
<td style="text-align:center"><strong>IS NULL</strong> <strong>或</strong> <strong>ISNULL</strong></td>
<td style="text-align:center">判断一个值是否为  NULL</td>
</tr>
<tr>
<td style="text-align:center"><strong>IS NOT NULL</strong></td>
<td style="text-align:center">判断一个值是否不为  NULL</td>
</tr>
<tr>
<td style="text-align:center"><strong>least</strong></td>
<td style="text-align:center">当有两个或多个参数时，返回最小值</td>
</tr>
<tr>
<td style="text-align:center"><strong>greatest</strong></td>
<td style="text-align:center">当有两个或多个参数时，返回最大值</td>
</tr>
<tr>
<td style="text-align:center"><strong>between and</strong></td>
<td style="text-align:center">判断一个值是否落在两个值之间</td>
</tr>
<tr>
<td style="text-align:center"><strong>in</strong></td>
<td style="text-align:center">判断一个值是IN列表中的任意一个值</td>
</tr>
<tr>
<td style="text-align:center"><strong>NOT IN</strong></td>
<td style="text-align:center">判断一个值不是IN列表中的任意一个值</td>
</tr>
<tr>
<td style="text-align:center"><strong>like</strong></td>
<td style="text-align:center">通配符匹配</td>
</tr>
<tr>
<td style="text-align:center"><strong>regexp</strong></td>
<td style="text-align:center">正则表达式匹配</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>逻辑运算符</strong></th>
<th style="text-align:center"><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>NOT</strong> 或 <strong>!</strong></td>
<td style="text-align:center">逻辑非</td>
</tr>
<tr>
<td style="text-align:center"><strong>AND</strong> 或 <strong>&amp;&amp;</strong></td>
<td style="text-align:center">逻辑与</td>
</tr>
<tr>
<td style="text-align:center"><strong>OR</strong> 或 <strong>||</strong></td>
<td style="text-align:center">逻辑或</td>
</tr>
<tr>
<td style="text-align:center"><strong>XOR</strong></td>
<td style="text-align:center">逻辑异或</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>位运算符</strong></th>
<th style="text-align:center"><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>|</strong></td>
<td style="text-align:center">按位或</td>
</tr>
<tr>
<td style="text-align:center"><strong>&amp;</strong></td>
<td style="text-align:center">按位与</td>
</tr>
<tr>
<td style="text-align:center"><strong>^</strong></td>
<td style="text-align:center">按位异或</td>
</tr>
<tr>
<td style="text-align:center"><strong>&lt;&lt;</strong></td>
<td style="text-align:center">按位左移</td>
</tr>
<tr>
<td style="text-align:center"><strong>&gt;&gt;</strong></td>
<td style="text-align:center">按位右移</td>
</tr>
<tr>
<td style="text-align:center"><strong>~</strong></td>
<td style="text-align:center">按位取反，反转所有比特</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询商品名称为“海尔洗衣机”的商品所有信息：</span><br><span class="line">select * from product where pname = &#x27;海尔洗衣机&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询价格为800商品</span><br><span class="line">select * from product where price = 800;</span><br><span class="line"></span><br><span class="line">-- 查询价格不是800的所有商品</span><br><span class="line">select * from product where price != 800;</span><br><span class="line">select * from product where price &lt;&gt; 800;</span><br><span class="line">select * from product where not (price = 800);</span><br><span class="line"></span><br><span class="line">-- 查询商品价格大于60元的所有商品信息</span><br><span class="line">select * from product where price &gt; 60;</span><br><span class="line"></span><br><span class="line">-- 查询商品价格在200到1000之间所有商品</span><br><span class="line">select * from product where price between 200 and 1000;</span><br><span class="line">select * from product where price &gt;= 200 and price &lt;= 1000;</span><br><span class="line">select * from product where price &gt;= 200 &amp;&amp; price &lt;= 1000;</span><br><span class="line"></span><br><span class="line">-- 查询商品价格是200或800的所有商品</span><br><span class="line">select * from product where price in (200,800);</span><br><span class="line">select * from product where price = 200 or price = 800;</span><br><span class="line">select * from product where price = 200 || price = 800;</span><br><span class="line"></span><br><span class="line">-- 查询含有‘裤&#x27;字的所有商品</span><br><span class="line">-- %：用来匹配任意字符</span><br><span class="line">select * from product where pname like &#x27;%裤&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询以&#x27;海&#x27;开头的所有商品</span><br><span class="line">select * from product where pname like &#x27;海%&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询第二个字为&#x27;蔻&#x27;的所有商品</span><br><span class="line">-- _：匹配单个字符</span><br><span class="line">select * from product where pname like &#x27;_蔻%&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询category_id为null的商品</span><br><span class="line">select * from product where category_id is null;</span><br><span class="line"></span><br><span class="line">-- 查询category_id不为null分类的商品</span><br><span class="line">select * from product where category_id is not null;</span><br><span class="line"></span><br><span class="line">-- 使用least求最小值</span><br><span class="line">select least(10,5,20) as small_number;</span><br><span class="line">-- 如果最小或最大值，有为null，则不会比较，结果直接为null</span><br><span class="line">select least(10,null,20) as small_number; -- null</span><br><span class="line"></span><br><span class="line">-- 使用greatest求最大值</span><br><span class="line">select greatest(10,5,20) as small_number;</span><br><span class="line">select least(10,null,20) as small_number; -- null</span><br></pre></td></tr></table></figure>
<h2 id="排序查询">排序查询</h2>
<blockquote>
<p>对读取的数据进行排序使用 <code>order by</code> 子句来设定你想按哪个字段哪种方式来进行排序，再返回搜索结果</p>
<p>asc代表升序，desc代表降序，如果不写默认升序</p>
<p>放在查询语句的最后面，LIMIT子句除外</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line"> 字段名1，字段名2，……</span><br><span class="line">from 表名</span><br><span class="line">order by 字段名1 [asc|desc]，字段名2[asc|desc]……</span><br><span class="line"></span><br><span class="line">-- 使用价格排序(降序)</span><br><span class="line">select * from product order by price desc;</span><br><span class="line"></span><br><span class="line">-- 在价格排序(降序)的基础上，以分类排序(降序)</span><br><span class="line">select * from product order by price desc, category_id desc;</span><br><span class="line"></span><br><span class="line">-- 显示商品的价格(去重复)，并排序(降序)</span><br><span class="line">select distinct price from product order by price desc;</span><br></pre></td></tr></table></figure>
<h2 id="聚合查询">聚合查询</h2>
<p>纵向查询，对一列的值进行计算，返回一个单一的值，会忽略空值</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>聚合函数</strong></th>
<th style="text-align:center"><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>count()</strong></td>
<td style="text-align:center">统计指定列不为NULL的记录行数</td>
</tr>
<tr>
<td style="text-align:center"><strong>sum()</strong></td>
<td style="text-align:center">计算指定列的数值和，如果指定列类型不是数值类型，计算结果为0</td>
</tr>
<tr>
<td style="text-align:center"><strong>max()</strong></td>
<td style="text-align:center">计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算</td>
</tr>
<tr>
<td style="text-align:center"><strong>min()</strong></td>
<td style="text-align:center">计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算</td>
</tr>
<tr>
<td style="text-align:center"><strong>avg()</strong></td>
<td style="text-align:center">计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询商品的总条数</span><br><span class="line">select count(pid) from product;</span><br><span class="line">select count(*) from product;</span><br><span class="line"></span><br><span class="line">-- 查询价格大于200商品的总条数</span><br><span class="line">select count(pid) from product where price &gt; 200;</span><br><span class="line"></span><br><span class="line">-- 查询分类为&#x27;c001&#x27;的所有商品的总和</span><br><span class="line">select sum(price) from product where category_id = &#x27;c001&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询商品的最大价格</span><br><span class="line">select max(price) from	product;</span><br><span class="line"></span><br><span class="line">-- 查询商品的最小价格</span><br><span class="line">select min(price) from product;</span><br><span class="line"></span><br><span class="line">select max(price) max_price,min(price) min_price from product;</span><br><span class="line"></span><br><span class="line">-- 查询分类为&#x27;c002&#x27;所有商品的平均价格</span><br><span class="line">select avg(price) from product where category_id = &#x27;c003&#x27;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>NULL值的处理</p>
</blockquote>
<p>count函数：参数为星号（*），则统计所有记录的个数，参数为某字段，不统计含null值的记录个数</p>
<p>sum和avg函数：忽略null值的存在</p>
<p>max和min函数：忽略null值的存在</p>
<h2 id="分组查询">分组查询</h2>
<p>使用<code>group by</code>字句对查询信息进行分组</p>
<blockquote>
<p>SELECT子句之后，只能出现分组的字段和统计函数，其他的字段不能出现</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 按照分组字段进行分组，每个分组字段相同的变成一张临时表</span><br><span class="line">-- 再按照字段的规则进行查询</span><br><span class="line">select 字段1,字段2… from 表名 group by 分组字段1,... having 分组条件;</span><br><span class="line"></span><br><span class="line">--  统计各个分类商品的个数</span><br><span class="line">select category_id,count(pid) from product group by category_id;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>分组之后条件筛选 - <code>having</code></p>
</blockquote>
<blockquote>
<p>[!CAUTION]</p>
<p><code>where</code>子句：筛选 FROM 子句中指定的操作所产生的行</p>
<p><code>group by</code>子句：分组 WHERE 子句的输出</p>
<p><code>having</code>子句：从分组的结果中筛选行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 统计各个分类商品的个数，且只显示个数大于4的信息</span><br><span class="line">select category_id,count(pid) from product group by category_id having count(pid) &gt; 4;</span><br></pre></td></tr></table></figure>
<h2 id="分页查询">分页查询</h2>
<p>由于数据量很大，显示屏长度有限，因此对数据需要采取分页显示方式</p>
<p>例如数据共有30条，每页显示5条，第一页显示1-5条，第二页显示6-10条</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 方式1-显示前n条</span><br><span class="line">select 字段1，字段2... from 表明 limit n</span><br><span class="line"></span><br><span class="line">-- 方式2-分页显示</span><br><span class="line">select 字段1，字段2... from 表明 limit m,n</span><br><span class="line"></span><br><span class="line">-- m: 整数，表示从第几条索引开始，计算方式 ：(当前页-1) * 每页显示条数</span><br><span class="line">-- n: 整数，表示查询多少条数据</span><br><span class="line"></span><br><span class="line">-- 查询product表的前5条记录</span><br><span class="line">select * from product limit 5;</span><br><span class="line"></span><br><span class="line">-- 从第4条开始显示，显示5条 </span><br><span class="line">select * from product limit 3,5;</span><br></pre></td></tr></table></figure>
<h2 id="导入表格">导入表格</h2>
<p>将一张表的数据导入到另一张表中，<code>目标表必须存在</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 将查询出来的表插入前面的表，两个表列需要一致</span><br><span class="line">insert into Table2(field1,field2,…) select value1,value2,… from Table1</span><br><span class="line">-- 全部导入</span><br><span class="line">insert into Table2 select * from Table1</span><br><span class="line"></span><br><span class="line">-- 创建表</span><br><span class="line">create table test(</span><br><span class="line">	pname varchar(20),</span><br><span class="line">	price double</span><br><span class="line">);</span><br><span class="line">-- 导入test表格</span><br><span class="line">insert into test(pname,price) select pname,price from product;</span><br><span class="line"></span><br><span class="line">create table test1(</span><br><span class="line">	category_id varchar(20),</span><br><span class="line">	product_count int</span><br><span class="line">);</span><br><span class="line">insert into test1 select category_id, count(*) from product group by category_id;</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式">正则表达式</h2>
<p>本身就是一个字符串，用来检索、替换哪些符合某个规则的文本</p>
<p>通过<code>REGEXP</code>关键字支持正则表达式进行字符串匹配</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>模式</strong></th>
<th style="text-align:center"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>^</strong></td>
<td style="text-align:center">匹配输入字符串的开始位置</td>
</tr>
<tr>
<td style="text-align:center"><strong>$</strong></td>
<td style="text-align:center">匹配输入字符串的结束位置</td>
</tr>
<tr>
<td style="text-align:center"><strong>.</strong></td>
<td style="text-align:center">匹配除 “\n” 之外的任何单个字符</td>
</tr>
<tr>
<td style="text-align:center"><strong>[…]</strong></td>
<td style="text-align:center">字符集合。匹配所包含的任意一个字符。例如：’[abc]’ 可以匹配 “plain” 中的 ‘a’</td>
</tr>
<tr>
<td style="text-align:center"><strong>[^…]</strong></td>
<td style="text-align:center">负值字符集合。匹配未包含的任意字符。例如：’[^abc]’ 可以匹配  “plain” 中的’p’</td>
</tr>
<tr>
<td style="text-align:center"><strong>p1|p2|p3</strong></td>
<td style="text-align:center">匹配 p1 或 p2  或 p3。例如：‘z|food’能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”</td>
</tr>
<tr>
<td style="text-align:center">*****</td>
<td style="text-align:center">匹配前面的子表达式零次或多次。例如：zo* 能匹配 “z” 以及 “zoo” *等价于{0,}</td>
</tr>
<tr>
<td style="text-align:center"><strong>+</strong></td>
<td style="text-align:center">匹配前面的子表达式一次或多次。例如：‘zo+’ 能匹配  “zo” 以及  “zoo”，但不能匹配  “z”。+ 等价于  {1,}</td>
</tr>
<tr>
<td style="text-align:center"><strong>{n}</strong></td>
<td style="text-align:center">n 是一个非负整数。匹配确定的 n 次。例如：‘o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o</td>
</tr>
<tr>
<td style="text-align:center"><strong>{n,m}</strong></td>
<td style="text-align:center">m 和 n 均为非负整数，其中n  &lt;= m。最少匹配 n 次且最多匹配 m 次</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- ^ 在字符串开头处进行匹配</span><br><span class="line">select &#x27;abc&#x27; regexp &#x27;^a&#x27;;  -- 1</span><br><span class="line">select * from product where pname regexp &#x27;^海&#x27;;</span><br><span class="line"></span><br><span class="line">-- $ 在字符串末尾开始匹配</span><br><span class="line">select &#x27;abc&#x27; regexp &#x27;a$&#x27;;	-- 0</span><br><span class="line">select &#x27;abc&#x27; regexp &#x27;c$&#x27;;	-- 1</span><br><span class="line">select * from product where pname regexp &#x27;水$&#x27;;</span><br><span class="line"></span><br><span class="line">-- . 匹配任意字符(除了换行符)</span><br><span class="line">select &#x27;abc&#x27; regexp &#x27;.b&#x27;;	-- 1</span><br><span class="line"></span><br><span class="line">-- [...] 括号内任意单个字符是否有与之匹配的</span><br><span class="line">select &#x27;abc&#x27; regexp &#x27;[xyz]&#x27;;	-- 0</span><br><span class="line">select &#x27;abc&#x27; regexp &#x27;[xaz]&#x27;;	-- 1</span><br><span class="line"></span><br><span class="line">-- [^...] 没有出现在括号内任意的字符</span><br><span class="line">-- 注意^符合只有在[]内才是取反的意思，在别的地方都是表示开始处匹配</span><br><span class="line">select &#x27;a&#x27; regexp &#x27;[^abc]&#x27;;	-- 0</span><br><span class="line">select &#x27;abc&#x27; regexp &#x27;[^axz]&#x27;;	-- 1</span><br><span class="line"></span><br><span class="line">-- a* 匹配0个或多个a,包括空字符串。 可以作为占位符使用.有没有指定字符都可以匹配到数据</span><br><span class="line">select &#x27;stab&#x27; regexp &#x27;.ta*b&#x27;; -- 1</span><br><span class="line">select &#x27;&#x27; regexp &#x27;a*&#x27;;</span><br><span class="line"></span><br><span class="line">-- a+ 匹配1个或者多个a,但是不包括空字符</span><br><span class="line">select &#x27;stab&#x27; regexp &#x27;.ta+b&#x27;;	-- 1</span><br><span class="line">select &#x27;stb&#x27; regexp &#x27;.ta+b&#x27;;	-- 0</span><br><span class="line"></span><br><span class="line">-- a? 匹配0个或者1个a</span><br><span class="line">select &#x27;stb&#x27; regexp &#x27;ta?b&#x27;;	-- 1</span><br><span class="line">select &#x27;staab&#x27; regexp &#x27;ta?b&#x27;; -- 0</span><br><span class="line"></span><br><span class="line">-- a1|a2 匹配a1或者a2</span><br><span class="line">select &#x27;a&#x27; regexp &#x27;a|b&#x27;;	-- 1</span><br><span class="line">select &#x27;c&#x27; regexp &#x27;a|b&#x27;;	-- 0</span><br><span class="line">select &#x27;a&#x27; regexp &#x27;^(a|b)&#x27;;	-- 1,以a或b开头的</span><br><span class="line"></span><br><span class="line">-- a&#123;m&#125; 匹配m个a(小于等于m个)</span><br><span class="line">select &#x27;abc&#x27; regexp &#x27;a&#123;1&#125;b&#x27;;	-- 1</span><br><span class="line">select &#x27;aaad&#x27; regexp &#x27;a&#123;6&#125;d&#x27;; -- 0</span><br><span class="line"></span><br><span class="line">-- a&#123;m,&#125; 匹配m个或更多个u</span><br><span class="line">select &#x27;auuuuuc&#x27; regexp &#x27;au&#123;3,&#125;c&#x27;;	-- 1</span><br><span class="line">select &#x27;auuc&#x27; regexp &#x27;au&#123;3,&#125;c&#x27;;	-- 0</span><br><span class="line"></span><br><span class="line">-- a&#123;m,n&#125; 匹配m到n个a,包含m和n</span><br><span class="line">select &#x27;auuuuc&#x27; regexp &#x27;au&#123;2,3&#125;c&#x27;;	-- 0</span><br><span class="line">select &#x27;auuuc&#x27; regexp &#x27;au&#123;2,3&#125;c&#x27;;	-- 1</span><br><span class="line"></span><br><span class="line">-- (abc) abc作为一个序列匹配，不用括号括起来都是用单个字符去匹配，如果要把多个字符作为一个整体去匹配就需要用到括号，所以括号适合上面的所有情况</span><br><span class="line">select &#x27;xababy&#x27; regexp &#x27;x(abab)y&#x27;;	-- 1</span><br><span class="line">select &#x27;xababy&#x27; regexp &#x27;x(ab)*y&#x27;;	-- 1</span><br><span class="line">select &#x27;xababy&#x27; regexp &#x27;x(ab)&#123;1,2&#125;y&#x27;;	-- 1</span><br></pre></td></tr></table></figure>
<h1>多表操作</h1>
<h2 id="多表关系">多表关系</h2>
<blockquote>
<p>一对多/多对一关系</p>
</blockquote>
<p>部门和员工</p>
<p>分析：一个部门有多个员工，一个员工只能对应一个部门</p>
<p>实现原则：在多的一方建立外键，指向一的一方的主键</p>
<blockquote>
<p>多对多关系</p>
</blockquote>
<p>学生和课程</p>
<p>分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择</p>
<p>原则：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，将多对多的关系，拆成一对多的关系，中间表至少要有两个外键，这两个外键分别指向原来的那两张表的主键</p>
<h2 id="外键约束">外键约束</h2>
<p>经常与主键约束一起使用，对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表（父表）外键所在的表就是从表（子表）</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/31/9Vva7n5CiwJuc63.jpg" alt="示例" style="zoom: 20%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<ul>
<li>外键中列的数据类型必须和主表主键中对应列的数据类型相同</li>
<li>必须给主表定义主键</li>
<li>主表必须已经存在于数据库中，或者是当前正在创建的表</li>
</ul>
<h3 id="添加外键约束">添加外键约束</h3>
<p>通过 <code>foreign key</code> 关键字来指定外键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建表时设置外键约束</span><br><span class="line">[constraint 外键名] foreign key (字段名) [，字段名2，…] references 主表名 主键列1 [，主键列2，…]</span><br><span class="line"></span><br><span class="line">-- 创建表后设置外键约束</span><br><span class="line">alter table 数据表名 add constraint 外键名 foreign key(列名) references 主表名 (&lt;列名&gt;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建部门表</span><br><span class="line">create table if not exists dept(</span><br><span class="line">	deptno varchar(20) primary key, -- 部门号 主键列</span><br><span class="line">	name varchar(20) -- 部门名字</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 在创建表时设置外键约束</span><br><span class="line">-- 员工表</span><br><span class="line">create table if not exists emp(</span><br><span class="line">	eid varchar(20) primary key,	-- 员工编号</span><br><span class="line">	ename varchar(20),	-- 员工名字</span><br><span class="line">	age int,	-- 员工年龄</span><br><span class="line">	dept_id varchar(20),	-- 员工所属部门</span><br><span class="line">	constraint emp_fk foreign key (dept_id) references dept(deptno)	 -- 外键约束</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 员工表</span><br><span class="line">create table if not exists emp1(</span><br><span class="line">	eid varchar(20) primary key,	-- 员工编号</span><br><span class="line">	ename varchar(20),	-- 员工名字</span><br><span class="line">	age int,	-- 员工年龄</span><br><span class="line">	dept_id varchar(20)	-- 员工所属部门</span><br><span class="line">);</span><br><span class="line">-- 创建表后设置外键约束</span><br><span class="line">alter table emp1 add constraint emp_fk1 foreign key(dept_id) references dept(deptno); </span><br></pre></td></tr></table></figure>
<h3 id="删除外键约束">删除外键约束</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table &lt;表名&gt; drop foreign key &lt;外键约束名&gt;;</span><br><span class="line"></span><br><span class="line">alter table emp1 drop foreign key emp_fk1;</span><br></pre></td></tr></table></figure>
<h3 id="外键约束下的数据操作">外键约束下的数据操作</h3>
<blockquote>
<p>数据插入</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> -- 添加主表数据</span><br><span class="line"> -- 注意必须先给主表添加数据</span><br><span class="line">insert into dept values(&#x27;1001&#x27;,&#x27;研发部&#x27;);</span><br><span class="line">insert into dept values(&#x27;1002&#x27;,&#x27;销售部&#x27;);</span><br><span class="line">insert into dept values(&#x27;1003&#x27;,&#x27;财务部&#x27;);</span><br><span class="line">insert into dept values(&#x27;1004&#x27;,&#x27;人事部&#x27;);</span><br><span class="line"></span><br><span class="line">-- 添加从表数据</span><br><span class="line">-- 注意给从表添加数据时，外键列的值不能随便写，必须依赖主表的主键列</span><br><span class="line">insert into emp values(&#x27;1&#x27;,&#x27;乔峰&#x27;,20, &#x27;1001&#x27;);</span><br><span class="line">insert into emp values(&#x27;2&#x27;,&#x27;段誉&#x27;,21, &#x27;1001&#x27;);</span><br><span class="line">insert into emp values(&#x27;3&#x27;,&#x27;虚竹&#x27;,23, &#x27;1001&#x27;);</span><br><span class="line">insert into emp values(&#x27;4&#x27;,&#x27;阿紫&#x27;,18, &#x27;1002&#x27;);</span><br><span class="line">insert into emp values(&#x27;5&#x27;,&#x27;扫地僧&#x27;,35, &#x27;1002&#x27;);</span><br><span class="line">insert into emp values(&#x27;6&#x27;,&#x27;李秋水&#x27;,33, &#x27;1003&#x27;);</span><br><span class="line">insert into emp values(&#x27;7&#x27;,&#x27;鸠摩智&#x27;,50, &#x27;1003&#x27;); </span><br><span class="line">insert into emp values(&#x27;8&#x27;,&#x27;天山童姥&#x27;,60, &#x27;1005&#x27;);	 -- 不可以(外键需要添加主键有的)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除数据</p>
</blockquote>
<p>主表的数据被从表依赖时，不能删除，否则可以删除</p>
<p>从表的数据可以随便删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1001部门号被外键绑定，不能删除</span><br><span class="line">delete from dept where deptno = &#x27;1001&#x27;;</span><br><span class="line">-- 1004部门号没有被外键依赖，可以删除</span><br><span class="line">delete from dept where deptno = &#x27;1004&#x27;;</span><br><span class="line">-- 从表数据随便删</span><br><span class="line">delete from emp where eid = &#x27;7&#x27;;</span><br></pre></td></tr></table></figure>
<h3 id="多对多关系">多对多关系</h3>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/31/lTp3MceKgx6SjGb.jpg" alt="多对多表" style="zoom:20%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>修改和删除时，中间从表可以随便删除和修改，但是两边的主表受从表依赖的数据不能删除或者修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建学生表student(左侧主表)</span><br><span class="line">create table if not exists student(</span><br><span class="line">	sid int primary key auto_increment,</span><br><span class="line">	name varchar(20),</span><br><span class="line">	age int,</span><br><span class="line">	gender varchar (20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 创建课程表course(右侧主表)</span><br><span class="line">create table course(</span><br><span class="line">	cid int primary key auto_increment,</span><br><span class="line">	cidname varchar(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 创建中间表student_course/score(从表)</span><br><span class="line">create table score(</span><br><span class="line">	sid int,</span><br><span class="line">	cid int,</span><br><span class="line">	score double</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 建立外键约束(2次)</span><br><span class="line">alter table score add foreign key(sid) references student(sid);</span><br><span class="line">alter table score add foreign key(cid) references course(cid);</span><br><span class="line"></span><br><span class="line">-- 给学生表添加数据</span><br><span class="line">insert into student values(1,&#x27;小龙女&#x27;,18,&#x27;女&#x27;),</span><br><span class="line">	(2,&#x27;阿紫&#x27;,19,&#x27;女&#x27;),</span><br><span class="line">	(3,&#x27;周芷若&#x27;,20,&#x27;男&#x27;);</span><br><span class="line">-- 给课程表添加数据</span><br><span class="line">insert into course values(1,&#x27;语文&#x27;),(2,&#x27;数学&#x27;),(3,&#x27;英语&#x27;);</span><br><span class="line">-- 给中间表添加数据</span><br><span class="line">insert into score values(1,1,58),(1,3,50),(2,1,89),(2,2,64),(3,2,25),(3,3,82);</span><br></pre></td></tr></table></figure>
<h2 id="多表联合查询">多表联合查询</h2>
<h3 id="交叉连接查询-了解">交叉连接查询(了解)</h3>
<p>一张表的每一行去和另外一张表的任意一行进行匹配</p>
<p>假如A表有m行数据，B表有n行数据，则返回m*n行数据</p>
<p>笛卡尔积会产生很多冗余的数据，后期的其他查询可以在该集合的基础上进行条件筛选</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from 表1,表2,表3….; </span><br><span class="line"></span><br><span class="line">select * from dept3,emp3;</span><br></pre></td></tr></table></figure>
<h3 id="内连接查询">内连接查询</h3>
<blockquote>
<p>[!NOTE]</p>
<p>查询求多张表的<code>交集</code>，关键字 <code>inner join</code> (inner可以省略)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 隐式内连接（SQL92标准）</span><br><span class="line">select * from A,B where 条件;</span><br><span class="line">-- 显示内连接（SQL99标准）</span><br><span class="line">select * from A inner join B on 条件;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询每个部门的所属员工</span><br><span class="line">-- 隐式内连接</span><br><span class="line">select * from dept3,emp3 where dept3.deptno = emp3.dept_id;</span><br><span class="line">-- 显示内连接</span><br><span class="line">select * from dept3 join emp3 on dept3.deptno = emp3.dept_id;</span><br><span class="line"></span><br><span class="line">-- 查询研发部所属员工</span><br><span class="line">-- 隐式内连接</span><br><span class="line">select * from dept3 a,emp3 b where a.deptno = b.dept_id and a.name = &#x27;研发部&#x27;;</span><br><span class="line">-- 显示内连接</span><br><span class="line">select * from dept3 a join emp3 b on a.deptno = b.dept_id and a.name = &#x27;研发部&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询研发部和销售部的所属员工</span><br><span class="line">-- 隐式内连接</span><br><span class="line">select * from dept3 a,emp3 b where a.deptno = b.dept_id and (a.name = &#x27;研发部&#x27; or a.name = &#x27;销售部&#x27;);</span><br><span class="line">-- 显示内连接</span><br><span class="line">select * from dept3 a join emp3 b on a.deptno = b.dept_id and (a.name = &#x27;研发部&#x27; or a.name = &#x27;销售部&#x27;);</span><br><span class="line">select * from dept3 a join emp3 b on a.deptno = b.dept_id and a.name in (&#x27;研发部&#x27; or &#x27;销售部&#x27;);</span><br><span class="line"></span><br><span class="line">-- 查询每个部门的员工数,并升序排序</span><br><span class="line">select a.name,a.deptno,count(1) c</span><br><span class="line">from dept3 a</span><br><span class="line">	join emp3 b on a.deptno = b.dept_id</span><br><span class="line">group by</span><br><span class="line">	a.deptno,a.name</span><br><span class="line">order by </span><br><span class="line">	 c desc;</span><br><span class="line"></span><br><span class="line">-- 查询人数大于等于3的部门，并按照人数降序排序</span><br><span class="line">select a.deptno,a.name,count(1) as total_cnt</span><br><span class="line">from dept3 a</span><br><span class="line">	join emp3 b on a.deptno = b.dept_id</span><br><span class="line">group by a.deptno,a.name</span><br><span class="line">having total_cnt &gt;= 3</span><br><span class="line">order by total_cnt desc;</span><br></pre></td></tr></table></figure>
<h3 id="外连接查询">外连接查询</h3>
<blockquote>
<p>[!NOTE]</p>
<p>关键字 <code>outer join </code>(<code>outer</code>可以省略)</p>
<p>显示符合连接条件的信息，信息内容是左表还是右边或都显示，看是左连接还是右连接或满连接</p>
<p><code>union</code>操作符用于合并两个或多个<code>select</code>语句的结果集，但是每个<code>select</code>语句必须选择相同数量的列，列也必须具有相似的数据类型，<code>union</code>默认会去除重复的行，如果需要保留重复的行，可以使用<code>union all</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 左外连接：left outer join</span><br><span class="line">select * from A left outer join B on 条件;</span><br><span class="line">-- 右外连接：right outer join</span><br><span class="line">select * from A right outer join B on 条件;</span><br><span class="line">--  满外连接: full outer join</span><br><span class="line">-- oracle里面有full join,可是在mysql对full join支持的不好，使用union来达到目的</span><br><span class="line">select * from A full outer join B on 条件;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 左连接</span><br><span class="line">-- 查询哪些部门有员工，哪些部门没有员工</span><br><span class="line">select * from dept3 a left outer join emp3 b on a.deptno = b.dept_id;</span><br><span class="line">select * from dept3 a left join emp3 b on a.deptno = b.dept_id;</span><br><span class="line"></span><br><span class="line">select * from A </span><br><span class="line">	left join B on 条件1</span><br><span class="line">	left join C on 条件2</span><br><span class="line">	left join D on 条件3;</span><br><span class="line"></span><br><span class="line">-- 右连接</span><br><span class="line">-- 查询哪些员工有对应的部门，哪些没有</span><br><span class="line">select * from dept3 a right outer join emp3 b on a.deptno = b.dept_id;</span><br><span class="line">select * from dept3 a right join emp3 b on a.deptno = b.dept_id;</span><br><span class="line"></span><br><span class="line">-- 满外连接</span><br><span class="line">-- 使用union关键字实现左外连接和右外连接的并集</span><br><span class="line">-- select * from dept3 a full join emp3 b on a.deptno = b.dept_id;	-- 不能执行</span><br><span class="line">select * from dept3 a left join emp3 b on a.deptno = b.dept_id</span><br><span class="line">union</span><br><span class="line">select * from dept3 a right join emp3 b on a.deptno = b.dept_id;</span><br></pre></td></tr></table></figure>
<h3 id="基本子查询">基本子查询</h3>
<p><code>select</code>的嵌套</p>
<blockquote>
<p>[!IMPORTANT]</p>
<p>子查询返回的数据类型：</p>
<p>单行单列：返回的是一个具体列的内容，可以理解为一个单值数据</p>
<p>单行多列：返回一行数据中多个列的内容</p>
<p>多行单列：返回多行记录之中同一列的内容，相当于给出了一个操作范围</p>
<p>多行多列：查询返回的结果是一张临时表</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询年龄最大的员工信息，显示信息包含员工号、员工名字，员工年龄</span><br><span class="line">-- 1.查询最大年龄</span><br><span class="line">select max(age) from emp3;</span><br><span class="line">-- 2.每一个员工的年龄和最大年龄进行比较，相等则满足条件</span><br><span class="line">select * from emp3 where age = (select max(age) from emp3);	-- 单行单列可以作为一个值来用</span><br><span class="line"></span><br><span class="line">-- 查询年研发部和销售部的员工信息，包含员工号、员工名字</span><br><span class="line">-- 内连接查询</span><br><span class="line">select * from emp3 a join dept b </span><br><span class="line">on a.dept_id = b.deptno </span><br><span class="line">and (b.name = &#x27;研发部&#x27; or b.name = &#x27;销售部&#x27;);</span><br><span class="line"></span><br><span class="line">-- 子查询</span><br><span class="line">-- 1.先查询研发部和销售部的部门号：deptno 1001 1002</span><br><span class="line">select dept.deptno from dept where dept.name = &#x27;研发部&#x27; or dept.name = &#x27;销售部&#x27;;</span><br><span class="line">-- 2.查询哪个员工的部门号是1001 或 1002</span><br><span class="line">select a.dept_id,a.ename from emp3  a where a.dept_id </span><br><span class="line">in (select dept.deptno from dept </span><br><span class="line">    where dept.name = &#x27;研发部&#x27; or dept.name = &#x27;销售部&#x27;);	-- 多行单列，多个值</span><br><span class="line"></span><br><span class="line">-- 查询研发部20岁以下的员工信息,包括员工号、员工名字，部门名</span><br><span class="line">-- 关联查询</span><br><span class="line">select * from emp3 a join dept b on (b.name = &#x27;研发部&#x27; and a.age &lt; 20);</span><br><span class="line">-- 子查询</span><br><span class="line">-- 2.1在部门表中查询研发部信息</span><br><span class="line">select * from dept3 where name =&#x27;研发部&#x27;; -- 一行多列</span><br><span class="line">-- 2.2在员工表中查询年龄小于30岁的员工信息慕容博</span><br><span class="line">select * from emp3 where age &lt; 30;</span><br><span class="line">-- 2.3将以上两个查询的结果进行关联查询</span><br><span class="line">select * </span><br><span class="line">from (select * from dept3 where name =&#x27;研发部&#x27;) t1 </span><br><span class="line">join (select *from emp3 where age&lt; 30) t2 </span><br><span class="line">on t1.deptno = t2.dept_id;	-- 多行多列</span><br></pre></td></tr></table></figure>
<h4 id="all关键字">all关键字</h4>
<blockquote>
<p>[!NOTE]</p>
<p>ALL: 与子查询返回的所有值比较为true 则返回true</p>
<p>ALL可以与=、&gt;、&gt;=、&lt;、&lt;=、&lt;&gt;结合是来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的其中的所有数据</p>
<p>ALL表示指定列中的值必须要大于子查询集的每一个值，即必须要大于子查询集的最大值；如果是小于号即小于子查询集的最小值。同理可以推出其它的比较运算符的情况</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select …from …where c &gt; all(查询语句)</span><br><span class="line">-- 等价于：select ...from ... where c &gt; result1 and c &gt; result2 and c &gt; result3</span><br><span class="line"></span><br><span class="line">-- 查询年龄大于‘1003’部门所有年龄的员工信息</span><br><span class="line">select * from emp3 where emp3.age &gt; all (select age from emp3 where emp3.dept_id = &#x27;1003&#x27;);</span><br><span class="line"></span><br><span class="line">-- 查询不属于任何一个部门的员工信息 </span><br><span class="line">select * from emp3 where emp3.dept_id &lt;&gt; all (select deptno from dept3);</span><br></pre></td></tr></table></figure>
<h4 id="any和some关键字">any和some关键字</h4>
<blockquote>
<p>[!NOTE]</p>
<p>ANY：与子查询返回的任意值比较为true 则返回true</p>
<p>ANY可以与=、&gt;、&gt;=、&lt;、&lt;=、&lt;&gt;结合是来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的其中的任何一个数据</p>
<p>表示制定列中的值要大于子查询中的任意一个值，即必须要大于子查询集中的最小值。同理可以推出其它的比较运算符的情况</p>
<p>SOME和ANY的作用一样，SOME可以理解为ANY的别名</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select … from … where c &gt; any(查询语句)</span><br><span class="line">-- 等价于：select ...from ... where c &gt; result1 or c &gt; result2 or c &gt; result3</span><br><span class="line"></span><br><span class="line">-- 查询年龄大于‘1003’部门任意一个员工年龄的员工信息</span><br><span class="line">select * from emp3 where age &gt; any (select age from emp3 </span><br><span class="line">where dept_id = &#x27;1003&#x27;)</span><br><span class="line">and dept_id != &#x27;1003&#x27;;</span><br></pre></td></tr></table></figure>
<h4 id="in关键字">in关键字</h4>
<blockquote>
<p>[!NOTE]</p>
<p>用于判断某个记录的值，是否在指定的集合中</p>
<p>在IN关键字前边加上not可以将条件反过来</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select …from …where c in(查询语句)</span><br><span class="line">-- 等价于：select ...from ... where c = result1 or c = result2 or c = result3</span><br><span class="line"></span><br><span class="line">-- 查询研发部和销售部的员工信息，包含员工号、员工名字</span><br><span class="line">select eid,ename from emp3 where dept_id </span><br><span class="line">in (select deptno from dept3 where name = &#x27;研发部&#x27; or name = &#x27;销售部&#x27;);</span><br></pre></td></tr></table></figure>
<h4 id="exists关键字">exists关键字</h4>
<blockquote>
<p>[!NOTE]</p>
<p>该子查询如果“有数据结果”(至少返回一行数据)，则该EXISTS() 的结果为“true”，外层查询执行</p>
<p>该子查询如果“没有数据结果”（没有任何数据返回），则该EXISTS()的结果为“false”，外层查询不执行</p>
<p>EXISTS后面的子查询不返回任何实际数据，只返回真或假，当返回真时 where条件成立</p>
<p>注意，EXISTS关键字，比IN关键字的运算效率高，因此，在实际开发中，特别是大数据量时，推荐使用EXISTS关键字</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select …from …where exists(查询语句)</span><br><span class="line"></span><br><span class="line">-- 查询公司是否有大于60岁的员工，有则输出</span><br><span class="line">select * from emp3 a where exists (select * from emp3 where a.age &gt; 60);</span><br><span class="line"></span><br><span class="line">-- 查询有所属部门的员工信息</span><br><span class="line">select * from emp3 a where exists (select * from dept3 b where a.dept_id = b.deptno);</span><br></pre></td></tr></table></figure>
<h3 id="自关联查询">自关联查询</h3>
<blockquote>
<p>[!NOTE]</p>
<p>有时在信息查询时需要进行对表自身进行关联查询，即一张表自己和自己关联，一张表当成多张表来用。注意自关联时表必须给表起别名</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段列表 from 表1 a , 表1 b where 条件;</span><br><span class="line">或者 </span><br><span class="line">select 字段列表 from 表1 a [left] join 表1 b on 条件;</span><br><span class="line"></span><br><span class="line">-- 1.查询每个三国人物及他的上级信息，如:  关羽  刘备 </span><br><span class="line">select a.ename,b.ename from t_sanguo a, t_sanguo b where a.manager_id = b.eid;</span><br><span class="line">select a.ename,b.ename from t_sanguo a join t_sanguo b on a.manager_id = b.eid;</span><br><span class="line"></span><br><span class="line">-- 查询所有任务及上级</span><br><span class="line">select a.ename,b.ename from t_sanguo a left join t_sanguo b on a.manager_id = b.eid;</span><br></pre></td></tr></table></figure>
<h1>函数</h1>
<h2 id="聚合函数">聚合函数</h2>
<p>group_concat()函数，数据的某一列合并成一行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 将所有员工的名字合并成一行(默认;分隔)</span><br><span class="line">select group_concat(emp_name) from emp;</span><br><span class="line"></span><br><span class="line">-- 指定分隔符合并 </span><br><span class="line">select group_concat(emp_name separator &#x27;;&#x27;) from emp;</span><br><span class="line"></span><br><span class="line">-- 指定排序方式和分隔符</span><br><span class="line">select department,group_concat(emp_name separator &#x27;;&#x27;)</span><br><span class="line">from emp</span><br><span class="line">group by department;</span><br><span class="line"></span><br><span class="line">select department,group_concat(emp_name order by salary desc separator &#x27;;&#x27;)</span><br><span class="line">from emp</span><br><span class="line">group by department;</span><br></pre></td></tr></table></figure>
<h2 id="数学函数">数学函数</h2>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>abs(x)</strong></th>
<th style="text-align:center">返回 x 的绝对值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>ceil(x)</strong></td>
<td style="text-align:center">返回大于或等于 x 的最小整数</td>
</tr>
<tr>
<td style="text-align:center"><strong>floor(x)</strong></td>
<td style="text-align:center">返回小于或等于 x 的最大整数</td>
</tr>
<tr>
<td style="text-align:center"><strong>greatest(expr1, expr2, expr3, …)</strong></td>
<td style="text-align:center">返回列表中的最大值</td>
</tr>
<tr>
<td style="text-align:center"><strong>least(expr1, expr2, expr3, …)</strong></td>
<td style="text-align:center">返回列表中的最小值</td>
</tr>
<tr>
<td style="text-align:center"><strong>mod(x,y)</strong></td>
<td style="text-align:center">返回 x 除以 y 以后的余数</td>
</tr>
<tr>
<td style="text-align:center"><strong>pi()</strong></td>
<td style="text-align:center">返回圆周率(3.141593）</td>
</tr>
<tr>
<td style="text-align:center"><strong>pow(x,y)</strong></td>
<td style="text-align:center">返回 x 的 y 次方</td>
</tr>
<tr>
<td style="text-align:center"><strong>rand()</strong></td>
<td style="text-align:center">返回 0 到 1 的随机数</td>
</tr>
<tr>
<td style="text-align:center"><strong>round(x)</strong></td>
<td style="text-align:center">返回离 x 最近的整数（遵循四舍五入）</td>
</tr>
<tr>
<td style="text-align:center"><strong>round(x,y)</strong></td>
<td style="text-align:center">返回指定位数的小数（遵循四舍五入）</td>
</tr>
<tr>
<td style="text-align:center"><strong>truncate(x,y)</strong></td>
<td style="text-align:center">返回数值 x 保留到小数点后 y 位的值（与 ROUND 最大的区别不会四舍五入）</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 求绝对值</span><br><span class="line">select abs (-10);	-- 10</span><br><span class="line"></span><br><span class="line">-- 向上取整</span><br><span class="line">select ceil(1.1);	-- 2</span><br><span class="line">select ceil(1.0);	-- 1</span><br><span class="line"></span><br><span class="line">-- 向下取整</span><br><span class="line">select floor(1.1);	-- 1</span><br><span class="line">select floor(1.9);	-- 1</span><br><span class="line"></span><br><span class="line">-- 取列表最大值</span><br><span class="line">select greatest(1,2,3);	-- 3</span><br></pre></td></tr></table></figure>
<h2 id="字符串函数">字符串函数</h2>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>char_length(s)</strong></th>
<th style="text-align:center">返回字符串 s 的字符数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>character_length(s)</strong></td>
<td style="text-align:center">返回字符串 s 的字符数</td>
</tr>
<tr>
<td style="text-align:center"><strong>concat(s1,s2…sn)</strong></td>
<td style="text-align:center">字符串 s1,s2 等多个字符串合并为一个字符串</td>
</tr>
<tr>
<td style="text-align:center"><strong>concat_ws(x,s1,s2…sn)</strong></td>
<td style="text-align:center">同 concat 函数，但是每个字符串之间要加上 x，x 可以是分隔符</td>
</tr>
<tr>
<td style="text-align:center"><strong>field(s,s1,s2…)</strong></td>
<td style="text-align:center">返回第一个字符串 s 在字符串列表(s1,s2…)中的位置</td>
</tr>
<tr>
<td style="text-align:center"><strong>ltrim(s)</strong></td>
<td style="text-align:center">去掉字符串 s 开始处的空格</td>
</tr>
<tr>
<td style="text-align:center"><strong>position(s1 IN s)</strong></td>
<td style="text-align:center">从字符串 s 中获取 s1 的开始位置</td>
</tr>
<tr>
<td style="text-align:center"><strong>replace(s,s1,s2)</strong></td>
<td style="text-align:center">字符串 s2 替代字符串 s 中的字符串 s1</td>
</tr>
<tr>
<td style="text-align:center"><strong>reverse(s)</strong></td>
<td style="text-align:center">将字符串s的顺序反过来</td>
</tr>
<tr>
<td style="text-align:center"><strong>right(s,n)</strong></td>
<td style="text-align:center">返回字符串 s 的后 n 个字符</td>
</tr>
<tr>
<td style="text-align:center"><strong>rtrim(s)</strong></td>
<td style="text-align:center">去掉字符串 s 结尾处的空格</td>
</tr>
<tr>
<td style="text-align:center"><strong>strcmp(s1,s2)</strong></td>
<td style="text-align:center">比较字符串 s1 和 s2，若 s1 与 s2 相等返回 0，若 s1&gt;s2 返回 1，若 s1&lt;s2 返回 -1</td>
</tr>
<tr>
<td style="text-align:center"><strong>mid(s,n,len)</strong></td>
<td style="text-align:center">从字符串 s 的 n 位置截取长度为 len 的子字符串</td>
</tr>
<tr>
<td style="text-align:center"><strong>subste(s, start, length)</strong></td>
<td style="text-align:center">从字符串 s 的 start 位置截取长度为 length 的子字符串</td>
</tr>
<tr>
<td style="text-align:center"><strong>substring(s, start, length)</strong></td>
<td style="text-align:center">从字符串 s 的 start 位置截取长度为 length 的子字符串</td>
</tr>
<tr>
<td style="text-align:center"><strong>trim(s)</strong></td>
<td style="text-align:center">去掉字符串 s 开始和结尾处的空格</td>
</tr>
<tr>
<td style="text-align:center"><strong>ucase(s)</strong></td>
<td style="text-align:center">字符串转换为大写</td>
</tr>
<tr>
<td style="text-align:center"><strong>upper(s)</strong></td>
<td style="text-align:center">字符串转换为大写</td>
</tr>
<tr>
<td style="text-align:center"><strong>lcase(s)</strong></td>
<td style="text-align:center">将字符串 s 的所有字母变成小写字母</td>
</tr>
<tr>
<td style="text-align:center"><strong>lower(s)</strong></td>
<td style="text-align:center">将字符串 s 的所有字母变成小写字母</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 获取字符串字符个数</span><br><span class="line">select char_length(&#x27;hello&#x27;);	-- 5</span><br><span class="line">select char_length(&#x27;你好吗&#x27;);	-- 3</span><br><span class="line"></span><br><span class="line">-- length取长度，返回单位是字节</span><br><span class="line">select length(&#x27;hello&#x27;);	-- 5</span><br><span class="line">select length(&#x27;你好吗&#x27;); -- 9</span><br><span class="line"></span><br><span class="line">-- 指定分隔符进行字符串合并</span><br><span class="line">select concat_ws(&#x27;-&#x27;,&#x27;hello&#x27;,&#x27;world&#x27;);	-- hello-world</span><br><span class="line"></span><br><span class="line">-- 返回字符串在列表中第一次出现的位置</span><br><span class="line">select field(&#x27;bbb&#x27;,&#x27;aaa&#x27;,&#x27;bbb&#x27;);	-- 2</span><br><span class="line"></span><br><span class="line">-- 去除字符串左边空格</span><br><span class="line">select ltrim(&#x27;  aaa&#x27;);</span><br><span class="line"></span><br><span class="line">-- 去除字符串右边空格</span><br><span class="line">select rtrim(&#x27;aaa   &#x27;);</span><br><span class="line"></span><br><span class="line">-- 去除字符串两边空格</span><br><span class="line">select trim(&#x27;   aaa   &#x27;);</span><br><span class="line"></span><br><span class="line">-- 字符串截取</span><br><span class="line">select mid(&quot;helloworld&quot;,2,3);	-- 第二个字符开始截取，截取长度为3</span><br><span class="line"></span><br><span class="line">-- 获取字符串A在字符串中出现的位置</span><br><span class="line">select position(&#x27;abc&#x27; in &#x27;helloabcworld&#x27;);	-- 6</span><br><span class="line"></span><br><span class="line">-- 字符串替换</span><br><span class="line">select replace(&#x27;helloaaaworld&#x27;,&#x27;aaa&#x27;,&#x27;bbb&#x27;);</span><br><span class="line"></span><br><span class="line">-- 字符串翻转</span><br><span class="line">select reverse(&#x27;hello&#x27;);</span><br><span class="line"></span><br><span class="line">-- 返回字符串后几个字符</span><br><span class="line">select right(&#x27;hello&#x27;,2);	-- lo</span><br><span class="line"></span><br><span class="line">-- 字符串比较</span><br><span class="line">select strcmp(&#x27;hello&#x27;,&#x27;world&#x27;);	-- -1</span><br><span class="line"></span><br><span class="line">-- 字符串截取</span><br><span class="line">select substr(&#x27;hello&#x27;,2,3);</span><br><span class="line">select substring(&#x27;hello&#x27;,2,3);</span><br><span class="line"></span><br><span class="line">-- 小写转大写</span><br><span class="line">select ucase(&quot;helloworlD&quot;);</span><br><span class="line">select upper(&quot;helloworlD&quot;);</span><br><span class="line"></span><br><span class="line">-- 大写转小写</span><br><span class="line">select lcase(&quot;HEllowdord&quot;);</span><br><span class="line">select lower(&quot;HEllowdord&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="日期函数">日期函数</h2>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>uix_timestamp()</strong></th>
<th style="text-align:center">返回从 1970-01-01 00:00:00 到当前毫秒值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>unix_timestamp(DATE_STRING)</strong></td>
<td style="text-align:center">将制定日期转为毫秒值时间戳</td>
</tr>
<tr>
<td style="text-align:center"><strong>from_unixtime(BIGINT UNIXTIME[,  STRING FORMAT])</strong></td>
<td style="text-align:center">将毫秒值时间戳转为指定格式日期</td>
</tr>
<tr>
<td style="text-align:center"><strong>curdate()</strong></td>
<td style="text-align:center">返回当前日期</td>
</tr>
<tr>
<td style="text-align:center"><strong>current_date()</strong></td>
<td style="text-align:center">返回当前日期</td>
</tr>
<tr>
<td style="text-align:center"><strong>current_time()</strong></td>
<td style="text-align:center">返回当前时间</td>
</tr>
<tr>
<td style="text-align:center"><strong>curtime()</strong></td>
<td style="text-align:center">返回当前时间</td>
</tr>
<tr>
<td style="text-align:center"><strong>current_timestamp()</strong></td>
<td style="text-align:center">返回当前日期和时间</td>
</tr>
<tr>
<td style="text-align:center"><strong>date()</strong></td>
<td style="text-align:center">从日期或日期时间表达式中提取日期值</td>
</tr>
<tr>
<td style="text-align:center"><strong>datediff(d1,d2)</strong></td>
<td style="text-align:center">计算日期 d1-&gt;d2 之间相隔的天数</td>
</tr>
<tr>
<td style="text-align:center"><strong>timediff(time1, time2)</strong></td>
<td style="text-align:center">计算时间差值</td>
</tr>
<tr>
<td style="text-align:center"><strong>date_format(d,f)</strong></td>
<td style="text-align:center">按表达式 f的要求显示日期 d</td>
</tr>
<tr>
<td style="text-align:center"><strong>str_to_date(string, format_mask)</strong></td>
<td style="text-align:center">将字符串转变为日期</td>
</tr>
<tr>
<td style="text-align:center"><strong>date_sub(date, interval expr type)</strong></td>
<td style="text-align:center">函数从日期减去指定的时间间隔，expr：数字</td>
</tr>
<tr>
<td style="text-align:center"><strong>adddate/date_add(d，interval expr type)</strong></td>
<td style="text-align:center">计算起始日期 d 加上一个时间段后的日期，expr：数字<br>type 值可以是：microsecond(微秒)、second(秒)、minute(分钟)、hour(小时)、day(天)、week(周)、month(月)、quarter(季)、year(年)、DAY_MINUTE day_minute(天和分钟)、day_hour(天和小时)、ear_month(年和月)</td>
</tr>
<tr>
<td style="text-align:center"><strong>extract(type from d)</strong></td>
<td style="text-align:center">从日期 d 中获取指定的值，type指定返回的值<br>type 可取值为：microsecond(微秒)、second(秒)、minute(分钟)、hour(小时)</td>
</tr>
<tr>
<td style="text-align:center"><strong>last_day(d)</strong></td>
<td style="text-align:center">返回给给定日期的那一月份的最后一天</td>
</tr>
<tr>
<td style="text-align:center"><strong>makedate(year, day-of-year)</strong></td>
<td style="text-align:center">基于给定参数年份 year 和所在年中的天数序号 day-of-year 返回一个日期</td>
</tr>
<tr>
<td style="text-align:center"><strong>year(d)</strong></td>
<td style="text-align:center">返回年份</td>
</tr>
<tr>
<td style="text-align:center"><strong>MONTH(d)</strong></td>
<td style="text-align:center">返回日期d中的月份值，1 到 12</td>
</tr>
<tr>
<td style="text-align:center"><strong>day(d)</strong></td>
<td style="text-align:center">返回日期值 d 的日期部分</td>
</tr>
<tr>
<td style="text-align:center"><strong>hour(t)</strong></td>
<td style="text-align:center">返回 t 中的小时值</td>
</tr>
<tr>
<td style="text-align:center"><strong>minute(t)</strong></td>
<td style="text-align:center">返回 t 中的分钟值</td>
</tr>
<tr>
<td style="text-align:center"><strong>second(t)</strong></td>
<td style="text-align:center">返回 t 中的秒钟值</td>
</tr>
<tr>
<td style="text-align:center"><strong>quarter(d)</strong></td>
<td style="text-align:center">返回日期d是第几季节，返回 1 到 4</td>
</tr>
<tr>
<td style="text-align:center"><strong>monthname(d)</strong></td>
<td style="text-align:center">返回日期当中的月份名称，如 November</td>
</tr>
<tr>
<td style="text-align:center"><strong>month(d)</strong></td>
<td style="text-align:center">返回日期d中的月份值，1 到 12</td>
</tr>
<tr>
<td style="text-align:center"><strong>dayname(d)</strong></td>
<td style="text-align:center">返回日期 d 是星期几，如 Monday,Tuesday</td>
</tr>
<tr>
<td style="text-align:center"><strong>dayofmonth(d)</strong></td>
<td style="text-align:center">计算日期 d 是本月的第几天</td>
</tr>
<tr>
<td style="text-align:center"><strong>dayofweek(d)</strong></td>
<td style="text-align:center">日期 d 今天是星期几，1 星期日，2 星期一，以此类推</td>
</tr>
<tr>
<td style="text-align:center"><strong>dayofyear(d)</strong></td>
<td style="text-align:center">计算日期 d 是本年的第几天</td>
</tr>
<tr>
<td style="text-align:center"><strong>week(d)</strong></td>
<td style="text-align:center">计算日期 d 是本年的第几个星期，范围是 0 到 53</td>
</tr>
<tr>
<td style="text-align:center"><strong>weekday(d)</strong></td>
<td style="text-align:center">日期 d 是星期几，0 表示星期一，1 表示星期二</td>
</tr>
<tr>
<td style="text-align:center"><strong>weekofyear(d)</strong></td>
<td style="text-align:center">计算日期 d 是本年的第几个星期，范围是 0 到 53</td>
</tr>
<tr>
<td style="text-align:center"><strong>yearweek(date, mode)</strong></td>
<td style="text-align:center">返回年份及第几周（0到53）mode 中 0 表示周天，1表示周一，以此类推</td>
</tr>
<tr>
<td style="text-align:center"><strong>now()</strong></td>
<td style="text-align:center">返回当前日期和时间</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 日期函数</span><br><span class="line">-- 1:获取时间戳 （毫秒值）</span><br><span class="line">select unix_timestamp();</span><br><span class="line"></span><br><span class="line">-- 2:将一个日期字符串转为毫秒值</span><br><span class="line">select unix_timestamp(&#x27;2021-12-21 08:08:08&#x27;);</span><br><span class="line"></span><br><span class="line">-- 3：将时间戳毫秒值转为指定格式的日期</span><br><span class="line">select from_unixtime(1640045288,&#x27;%Y-%m-%d %H:%i:%s&#x27;);</span><br><span class="line"></span><br><span class="line">-- 4：获取当前的年月日</span><br><span class="line">select curdate();</span><br><span class="line">select current_date();</span><br><span class="line"></span><br><span class="line">-- 5：获取当前的时分秒</span><br><span class="line">SELECT CURRENT_TIME();</span><br><span class="line">SELECT CURTIME();</span><br><span class="line"></span><br><span class="line">-- 6：获取年月日和时分秒</span><br><span class="line">SELECT CURRENT_TIMESTAMP();</span><br><span class="line"></span><br><span class="line">-- 从日期字符串中获取年月日</span><br><span class="line">select date(&#x27;2022-12-12 12:34:56&#x27;);</span><br><span class="line"></span><br><span class="line">-- 8:获取日期之间的差值</span><br><span class="line">select datediff(&#x27;2021-12-23&#x27;,&#x27;2008-08-08&#x27;);</span><br><span class="line"></span><br><span class="line">-- 9：获取时间的差值（秒级）</span><br><span class="line">select timediff(&#x27;12:12:34&#x27;,&#x27;10:18:56&#x27;); -- 01:53:38</span><br><span class="line"></span><br><span class="line">-- 10:日期格式化</span><br><span class="line">select date_format(&#x27;2021-1-1 1:1:1&#x27;,&#x27;%Y-%m-%d %H:%i:%s&#x27;);</span><br><span class="line">select date_format(&#x27;2021-12-13 11:11:11&#x27;,&#x27;%Y-%m-%d %H:%i:%s&#x27;);</span><br><span class="line"></span><br><span class="line">-- 11:将字符串转为日期</span><br><span class="line">select str_to_date(&#x27;2021-12-13 11:11:11&#x27;,&#x27;%Y-%m-%d %H:%i:%s&#x27;);</span><br><span class="line"></span><br><span class="line">-- 12：将日期进行减法  日期向前跳转</span><br><span class="line">select date_sub(&#x27;2021-10-01&#x27;,interval 2 day);</span><br><span class="line">select date_sub(&#x27;2021-10-01&#x27;,interval 2 month);</span><br><span class="line"></span><br><span class="line">-- 13：将日期进行加法  日期向后跳转</span><br><span class="line">select date_add(&#x27;2021-10-01&#x27;,interval 2 day);</span><br><span class="line">select date_add(&#x27;2021-10-01&#x27;,interval 2 month);</span><br><span class="line"></span><br><span class="line">-- 14：从日期中获取小时</span><br><span class="line">select extract(hour from&#x27;2021-12-13 11:12:13&#x27;);</span><br><span class="line">select extract(year from &#x27;2021-12-13 11:12:13&#x27;);</span><br><span class="line"></span><br><span class="line">-- 15：获取给定日期所在月的最后一天</span><br><span class="line">select last_day(&#x27;2021-08-13&#x27;);</span><br><span class="line"></span><br><span class="line">-- 16：获取指定年份和天数的日期</span><br><span class="line">select makedate(&#x27;2021&#x27;,53);</span><br><span class="line"></span><br><span class="line">-- 17:根据日期获取年月日，时分秒</span><br><span class="line">select year(&#x27;2021-12-13 11:12:13&#x27;);</span><br><span class="line">select minute(&#x27;2021-12-13 11:12:13&#x27;);</span><br><span class="line">select quarter(&#x27;2021-12-13 11:12:13&#x27;);	-- 获取季度</span><br><span class="line"></span><br><span class="line">-- 18:根据日期获取信息</span><br><span class="line">SELECT MONTHNAME(&#x27;2021-12-13 11:12:13&#x27;);	-- 获取月份的英文</span><br><span class="line">SELECT DAYNAME(&#x27;2021-12-13 11:12:13&#x27;);	-- 获取周几：Monday</span><br><span class="line">SELECT DAYOFMONTH(&#x27;2021-12-13 11:12:13&#x27;);	-- 当月的第几天</span><br><span class="line">SELECT DAYOFWEEK(&#x27;2021-12-13 11:12:13&#x27;);	-- 1:周日 2:周一</span><br><span class="line">SELECT DAYOFYEAR(&#x27;2021-12-13 11:12:13&#x27;);	-- 获取一年的第几天</span><br></pre></td></tr></table></figure>
<h2 id="控制流函数">控制流函数</h2>
<blockquote>
<p><strong>if逻辑判断语句</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>if(expr,v1,v2)</strong></th>
<th style="text-align:center">如果表达式 expr 成立，返回结果 v1 否则，返回结果 v2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong><a href="https://www.runoob.com/mysql/mysql-func-ifnull.html">ifnull(v1,v2)</a></strong></td>
<td style="text-align:center">如果 v1 的值不为 NULL，则返回 v1，否则返回 v2</td>
</tr>
<tr>
<td style="text-align:center"><strong>isnull(expression)</strong></td>
<td style="text-align:center">判断表达式是否为 NULL</td>
</tr>
<tr>
<td style="text-align:center"><strong>nullif(expr1, expr2)</strong></td>
<td style="text-align:center">比较两个字符串，如果字符串 expr1 与 expr2 相等 返回 NULL，否则返回 expr1</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 成绩大于85则优秀反之及格</span><br><span class="line">select *,if(score &gt;=85,&#x27;优秀&#x27;,&#x27;及格&#x27;) falg from score;</span><br><span class="line"></span><br><span class="line">-- comm为空则显示0</span><br><span class="line">select*,ifnull(comm,0)comm_flagfromemp</span><br><span class="line"></span><br><span class="line">selectisnull(5);	-- 0</span><br><span class="line">selectisnull(NULL); -- 1</span><br><span class="line"></span><br><span class="line">select nullif(12,12);	-- null</span><br><span class="line">select nullif(12,13);	-- 12</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>ucase when语句</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>CASE expression</strong><br><strong>WHEN condition1 THEN  result1</strong><br><strong>WHEN condition2 THEN  result2</strong><br><strong>…</strong>   <br><strong>WHEN conditionN THEN resultN</strong><br>   <strong>ELSE result</strong><br><strong>END</strong></th>
<th style="text-align:center">CASE 表示函数开始，END 表示函数结束。如果 condition1 成立，则返回 result1，如果 condition2 成立，则返回 result2，当全部不成立则返回 result，而当有一个成立之后，后面的就不执行了</th>
</tr>
</thead>
<tbody></tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">	case 5</span><br><span class="line">		when 1 then &#x27;1&#x27;</span><br><span class="line">		when 2 then &#x27;2&#x27;</span><br><span class="line">		when 5 then &#x27;3&#x27;</span><br><span class="line">		else</span><br><span class="line">			&#x27;4&#x27;</span><br><span class="line">	end as info;</span><br><span class="line"></span><br><span class="line">-- 方式1</span><br><span class="line">select *  ,</span><br><span class="line">case </span><br><span class="line">    when payType=1 then &#x27;微信支付&#x27; </span><br><span class="line">    when payType=2 then &#x27;支付宝支付&#x27; </span><br><span class="line">    when payType=3 then &#x27;银行卡支付&#x27; </span><br><span class="line">    else &#x27;其他支付方式&#x27; </span><br><span class="line">end  as payTypeStr</span><br><span class="line">from orders;</span><br><span class="line"></span><br><span class="line">-- 方式2</span><br><span class="line">select *  ,</span><br><span class="line">case payType</span><br><span class="line">    when 1 then &#x27;微信支付&#x27;</span><br><span class="line">    when 2 then &#x27;支付宝支付&#x27;</span><br><span class="line">    when 3 then &#x27;银行卡支付&#x27;</span><br><span class="line">    else &#x27;其他支付方式&#x27; </span><br><span class="line">end  as payTypeStr</span><br><span class="line">from orders;</span><br></pre></td></tr></table></figure>
<h1>窗口函数</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window_function ( expr ) over ( </span><br><span class="line">    PARTITION BY ... </span><br><span class="line">    ORDER BY ... </span><br><span class="line">    frame_clause </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>分区（PARTITION BY）
<ul>
<li>PARTITION BY 选项用于将数据行拆分成多个分区（组）它的作用类似于GROUP BY分组。如果省略了 PARTITION BY，所有的数据作为一个组进行计算</li>
</ul>
</li>
<li>排序（ORDER BY）
<ul>
<li>OVER 子句中的 ORDER BY 选项用于指定<strong>分区内</strong>的排序方式，与 ORDER BY 子句的作用类似</li>
</ul>
</li>
<li>以及窗口大小（frame_clause）
<ul>
<li>frame_clause 选项用于在<strong>当前分区</strong>内指定一个计算窗口，也就是一个与当前行相关的数据子集</li>
</ul>
</li>
</ul>
<h2 id="序号函数">序号函数</h2>
<p>序号函数有三个：row_number()、rank()、dense_rank()，可以用来实现分组排序，并添加序号</p>
<p>这三个功能相同但排序的序号方式不同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">row_number() | rank() | dense_rank() over ( </span><br><span class="line">  partition by ... </span><br><span class="line">  order by ... </span><br><span class="line">) </span><br><span class="line"></span><br><span class="line">-- 对每个部门的员工按照薪资降序排序，并给出排名</span><br><span class="line">select</span><br><span class="line">    dname,</span><br><span class="line">    ename,</span><br><span class="line">    salary,</span><br><span class="line">    row_number() over(partition by dname order by salary desc) as rn1,</span><br><span class="line">    rank() over(partition by dname order by salary desc) as rn2,</span><br><span class="line">    dense_rank() over(partition by dname order by salary desc) as rn3</span><br><span class="line">from employee;</span><br><span class="line"></span><br><span class="line">--求出每个部门薪资排在前三名的员工- 分组求TOPN</span><br><span class="line">select </span><br><span class="line">* </span><br><span class="line">from </span><br><span class="line">(</span><br><span class="line">    select </span><br><span class="line">        dname,</span><br><span class="line">        ename,</span><br><span class="line">        salary,</span><br><span class="line">        dense_rank() over(partition by dname order by salary desc)  as rn</span><br><span class="line">    from employee</span><br><span class="line">)t</span><br><span class="line">where t.rn &lt;= 3</span><br><span class="line"></span><br><span class="line">-- 对所有员工进行全局排序（不分组）</span><br><span class="line">-- 不加partition by表示全局排序</span><br><span class="line">select </span><br><span class="line">     dname,</span><br><span class="line">     ename,</span><br><span class="line">     salary,</span><br><span class="line">     dense_rank() over( order by salary desc)  as rn</span><br><span class="line">from employee;</span><br></pre></td></tr></table></figure>
<h2 id="开窗聚合函数">开窗聚合函数</h2>
<blockquote>
<p>sum()、avg()、max()、min()、count()</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">	dname,</span><br><span class="line">	ename,</span><br><span class="line">	salary,</span><br><span class="line">	sum(salary) over(partition by dname order by hiredate) as pvl</span><br><span class="line">from employee;</span><br><span class="line"></span><br><span class="line">-- 如果没有order by排序语句默认把分组内的所有</span><br><span class="line">select dname,ename,hiredate,salary,</span><br><span class="line">sum(salary) over(partition by dname) as c1</span><br><span class="line">-- sum(salary) over(partition by dname order by hiredate rows between unbounded preceding and current row) as c1</span><br><span class="line">from employee;</span><br><span class="line"></span><br><span class="line">-- 向前三行及本身及向后一行数据相加</span><br><span class="line">select  </span><br><span class="line">    dname,</span><br><span class="line">    ename,</span><br><span class="line">    salary,</span><br><span class="line">    sum(salary) over(partition by dname order by hiredate   rows between 3 preceding and 1 following) as c1 </span><br><span class="line">from employee;</span><br><span class="line"></span><br><span class="line">-- 当前行(包括本身)加到最后一行</span><br><span class="line">select  </span><br><span class="line">    dname,</span><br><span class="line">    ename,</span><br><span class="line">    salary,</span><br><span class="line">    sum(salary) over(partition by dname order by hiredate   rows between current row and unbounded following) as c1 </span><br><span class="line">from employee;</span><br></pre></td></tr></table></figure>
<h2 id="分布函数">分布函数</h2>
<blockquote>
<p>cume_dist：分组内小于、等于当前值的行数 / 分组内总行数</p>
<p>应用场景：查询小于等于当前薪资（salary）的比例</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">	dname,ename,salary,</span><br><span class="line">	cume_dist() over(order by salary)as rn1,</span><br><span class="line">	cume_dist() over(partition by dname order by salary)as rn2</span><br><span class="line">from employee;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>percent_rank：(rank-1) / (rows-1)进行计算，rank为RANK()函数产生的(不常用)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select dname,ename,salary,</span><br><span class="line">	rank() over(partition by dname order by salary desc) as rn,</span><br><span class="line">	percent_rank() over(partition by dname order by salary desc)as rn2</span><br><span class="line">from employee;</span><br></pre></td></tr></table></figure>
<h2 id="前后函数">前后函数</h2>
<blockquote>
<p>cume_dist：返回位于当前行的 <code>前n行</code>(lag(expr,n)）或 <code>后n行</code>（lead(expr,n)）的expr的值</p>
<p>应用场景：查询前1名同学的成绩和当前同学成绩的差值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- lag的用法</span><br><span class="line">select </span><br><span class="line">    dname, ename, hiredate, salary,</span><br><span class="line">    lag(hiredate,1,&#x27;2000-01-01&#x27;) over(partition by dname order by hiredate) as last_1_time,</span><br><span class="line">    lag(hiredate,2) over(partition by dname order by hiredate) as last_2_time </span><br><span class="line">from employee;</span><br><span class="line"></span><br><span class="line">-- lead的用法</span><br><span class="line">select </span><br><span class="line">    dname, ename, hiredate, salary,</span><br><span class="line">    lead(hiredate,1,&#x27;2000-01-01&#x27;) over(partition by dname order by hiredate) as last_1_time,</span><br><span class="line">    lead(hiredate,2) over(partition by dname order by hiredate) as last_2_time </span><br><span class="line">from employee;</span><br></pre></td></tr></table></figure>
<h2 id="头尾函数">头尾函数</h2>
<blockquote>
<p>返回第一个（first_value(expr)）或最后一个（last_value(expr)）expr的值</p>
<p>应用场景：截止到当前，按照日期排序查询第1个入职和最后1个入职员工的薪资</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 注意,  如果不指定ORDER BY，则进行排序混乱，会出现错误的结果</span><br><span class="line">select</span><br><span class="line">    dname, ename, hiredate, salary,</span><br><span class="line">    first_value(salary) over(partition by dname order by hiredate) as first,</span><br><span class="line">    last_value(salary) over(partition by dname order by  hiredate) as last </span><br><span class="line">from  employee;</span><br></pre></td></tr></table></figure>
<h2 id="其他函数">其他函数</h2>
<blockquote>
<p>nth_value(expr,n)</p>
<p>返回窗口中第n个expr的值。expr可以是表达式，也可以是列名</p>
<p>应用场景：截止到当前薪资，显示每个员工的薪资中排名第2或者第3的薪资</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询每个部门截止目前薪资排在第二和第三的员工信息</span><br><span class="line">select </span><br><span class="line">    dname, ename, hiredate, salary,</span><br><span class="line">    nth_value(salary,2) over(partition by dname order by hiredate) as second_score,</span><br><span class="line">    nth_value(salary,3) over(partition by dname order by hiredate) as third_score</span><br><span class="line">from employee</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ntile(n)</p>
<p>将分区中的有序数据分为n个等级，记录等级数</p>
<p>应用场景：将每个部门员工按照入职日期分成3组</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 根据入职日期将每个部门的员工分成3组</span><br><span class="line">select </span><br><span class="line">    dname, ename, hiredate, salary,</span><br><span class="line">    ntile(3) over(partition by dname order by  hiredate  ) as rn </span><br><span class="line">from employee;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>小狼毫配置</title>
    <url>/post/5f6e69ef.html</url>
    <content><![CDATA[<h1><center>下载小狼毫软件</center></h1>
<p>小狼毫下载：<a href="https://rime.im/download/#">地址</a></p>
<h1><center>安装步骤</center></h1>
<p>下载好安装包后，打开安装包，安装，步骤如下</p>
<p>点击我接受</p>
<img src="https://s2.loli.net/2024/08/19/Lqogmfe2ycFTYkr.png" alt="步骤三一" style="zoom:50%;">
<p>这里是软件安装路径，选择自己要安装的位置，后直接点击安装</p>
<img src="https://s2.loli.net/2024/08/19/iGubOEglz53qoKj.png" alt="步骤二" style="zoom:50%;">
<p>后续还有个<code>用户配置文件</code>的安装目录，这个目录保存好，在别的电脑可以直接恢复配置。</p>
<p>方案选定，选择图片单个即可，选择 中 下一步</p>
<img src="https://s2.loli.net/2024/08/19/1ErOwozGTXAFaPf.png" alt="步骤三" style="zoom:50%;">
<p>然后，选择自己喜欢的风格，点击中，即可安装完成。</p>
<h1>配置</h1>
<p>在任务栏中，在 中 字右键，选择用户文件夹</p>
<img src="https://s2.loli.net/2024/08/19/RcCwXz6QLV52l3I.png" alt="配置一" style="zoom:50%;">
<p>在大佬整理的文件下载词库配置，大佬的：GitHub<a href="https://github.com/iDvel/rime-ice">地址</a>，直接整个打包下载</p>
<img src="https://s2.loli.net/2024/08/19/kTMpCI3dtiwQmvY.png" alt="打包下载" style="zoom: 33%;">
<h1>重点配置</h1>
<p>解压下载好的词库配置包，右键退出算法服务（若点击退出没有反应，直接重启即可），然后删除用户文件夹内的所有文件（最好备份一下原本的文件），复制大佬仓库中的所有文件到你的用户文件夹中，重启电脑，刚重启之后，等待一会儿，如果还不行，再右键重新部署，这期间会出现 输入法调出来但是无法打字的问题，等重新部署完成，可以打字即部署完成</p>
<hr>
<p>tip：个人感觉不是很好用，可能不会配置，或者说没有精力去配置，如果想要好用需要花费精力去配置。本人已切换到微软自带输入法</p>
]]></content>
      <categories>
        <category>技术积累记录</category>
      </categories>
      <tags>
        <tag>小狼毫输入法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.集合</title>
    <url>/post/9e25cba9.html</url>
    <content><![CDATA[<h1><center>知识点一：集合框架</center></h1>
<h2 id="center-1-概念-center"><center>1、概念</center></h2>
<p>    如果处理一套通用逻辑就提供一个自定义封装处理数组的类，那么开发中可能会需要提供N这样类，问题在于需要自行完成操作，Java也发现这个问题，所有为了让程序猿可以更加的便捷的对数据进行操作，无需向数组一样提供【增删改查】的自定义实现，Java提供一个集合框架，便于程序猿对数据进行存储与管理操作</p>
<p>什么是集合框架？</p>
<p>    Java中的集合框架其实就是对【数据结构】的封装，这个封装中提供了一些常用方法，可方便操作数据，无需程序猿自定定义操作，只需要调用封装方法就可以完成对存在集合中数据【增删改查】集合其实就是对数据结构一种封装，所以之前sun公司就把集合放置到一个统一包中进行管理【java.util】包</p>
<p>什么是数据结构？</p>
<p>    数据结构其实就是计算机，组织和存储数据形式</p>
<p>    数据结构是指相互之间存在一种或多种特定关系的数据集合</p>
<p>    通常情况下，精心选择数据结构可以带来更加高效运行和存储效率，数据结构往往高效的原因在于【检索算法】和【索引计数】</p>
<p>    常见数据结构：【数组、栈、链表(单向和双向)、哈希表、队列(单向和双向)、堆、树、图】</p>
<p>    Java的集合框架其实就是对【数据结构实现】，我们需要掌握就是如何操作这个数据结构（即操作集合中方法），高效存储与处理数据</p>
<p>PS：根据不同数据结构，操作数据性能是不同（有地查询块、有的插入快、有地允许重复、有的不允许重复等等），在开发中只要选择合理数据结构即集合对数据存储与操作即可</p>
<p>推荐： 后期可以看一本书【大话数据结构】 —》兄弟 ----》【大话设计模式】</p>
<h2 id="center-2-集合架构-center"><center>2、集合架构</center></h2>
<p>PS：习惯性说Java中集合有三大框架【List、Set和Map】</p>
<p>如果详细说明的话应该2个框架3个实现：</p>
<p>    2个框架： Collection 和 Map</p>
<p>    3个实现 ：Collection这个集合下两个主要实现 List 和 set 所以称为三大集合List、set 和Map</p>
<p>集合和数组最大区别在于：</p>
<ol>
<li>集合中只能存储引用类型即对象</li>
<li>集合是一个变长容量，根据集合存储元素个数动态进行删减【扩容和减容】</li>
<li>数组是一个定长容器，创建大小数固定，无论存储多少数据长度都是唯一</li>
</ol>
<p>常见三大集合框架：</p>
<ol>
<li>List【列表】：集合中存储对象是按照索引位置进行存储，允许存储重复数据</li>
<li>Set【集】: 集合中存储对象不是按照特定方式进行存储，不允许出现重复数据</li>
<li>Map【映射】：集合中每一个存储元素都是以一种【键值对keyvalue】方式进行存储的，以一种key和value的形式存储的，key这个对象是不允许重复【唯一性】，value是允许重复</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271930400.WebP" alt="列表、集合、映射图" style="zoom: 33%;">
<p>无论什么时候都要先创建Collection对象</p>
<p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271930293.WebP" alt="集合"></p>
<h2 id="center-3-list集合-center"><center>3、List集合</center></h2>
<p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271930586.WebP" alt="List集合"></p>
<h1><center>知识点二：List集合之ArrayList集合</center></h1>
<h2 id="center-1-分析arraylist的效率-center"><center>1、分析ArrayList的效率</center></h2>
<p>因为ArrayList使用是数组实现所以可以得到如下以下特点：</p>
<ol>
<li>保存操作：</li>
</ol>
<p>    把一个数据保存到ArrayList中，最快的操作只要操作一次即可，最慢的操作可能操作N次</p>
<p>    平均执行效率(N+1)/2次 —》扩容问题</p>
<ol start="2">
<li>删除操作:</li>
</ol>
<p>删除ArrayList中某个数据，最快的只要操作一次即可， 最慢的操作可能操作N次</p>
<p>平均执行效率(N+1)/2次 —》减容问题</p>
<ol start="3">
<li>
<p>修改操作: 操作一次即可</p>
</li>
<li>
<p>查询操作：根据索引一次即可。如果遍历查询使用【检索算法】做优化效率高度，如果遍历从到为【顺序查找】效率是低</p>
</li>
</ol>
<p>因为ArrayList使用是数组的形式进行存储数据操作，所以基于这样数据结构做查询和修改效率是高，但是做增加和删除效率是低【动态扩容和减容】</p>
<h2 id="center-2-语法-center"><center>2、语法</center></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;泛型&gt; 变量名 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h2 id="center-3-常用方法-center"><center>3、常用方法</center></h2>
<p>1）向指定下标位置添加一个元素,下标范围：0~list.size	list.size：有多少个元素</p>
<p>    变量名.add(指定下标数,添加的元素);</p>
<p>2）移除指定下标位置的元素,下标范围：0~list.size-1</p>
<p>    变量名.remove(指定下标数);</p>
<p>3）修改指定下标位置的元素,下标范围：0~list.size-1</p>
<p>    变量名.set(指定下标数,修改元素内容);</p>
<p>4）获取指定下标位置上的元素，下标范围：0~list.size-1</p>
<p>    变量名.get(指定下标数)</p>
<p>    返回值为对应的数据类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.UnaryOperator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListAPIDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供ArrayList集合对象进行数据的存储操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1.ArrayList集合提供一个无参构造方法可以创建一个空的集合对象</span></span><br><span class="line"><span class="comment">            --&gt;空指定的是集合没有存储任何数据，但是集合引用是在的</span></span><br><span class="line"><span class="comment">            在Java7，使用new ArrayList无参构造方法创建对象，一个元素都不存储</span></span><br><span class="line"><span class="comment">            依旧会在堆中开辟一个大小为10的数据空间，并且数组的默认存储数据类型时Object</span></span><br><span class="line"><span class="comment">            在Java8中，Java开发人员发现，如果在使用ArrayList集合之前，如果使用无参构造方法</span></span><br><span class="line"><span class="comment">            创建ArrayList集合对象会出现一个10大小的堆中数组空间，这样会造成一定量的空间浪费</span></span><br><span class="line"><span class="comment">            所以在Java8中提供一个全新优化，使用 new ArrayList无参构造方法创建ArrayList对象时</span></span><br><span class="line"><span class="comment">            并不会创建一个大小为10数组在堆中进行存储，而是创建创建一个空的数组进行空间的开辟</span></span><br><span class="line"><span class="comment">            private static final Object[]</span></span><br><span class="line"><span class="comment">            DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span></span><br><span class="line"><span class="comment">            当通过集合对象调用集合集合中提供add方法时，此时才会真正的初始化数组空间</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//2.ArrayList集合使用其他的Collection集合对象中存储数据</span></span><br><span class="line">        作为新的集合中存储数据进行初始化</span><br><span class="line">        <span class="comment">//即将参数中Collection集合对象数据存储到新建ArrayList集合中</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(list);</span><br><span class="line">        <span class="comment">//3.自定义ArrayList集合的底层数组初始化容量 --》【使用较少】</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//常用API</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.向集合对象中添加元素【存储数据】 ---》 集合只能存储引用</span></span><br><span class="line">        类型即对象</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            集合中只能存储引用类型 --&gt; 明显调用add时存储的是1,2,3,4,5 int类型数据</span></span><br><span class="line"><span class="comment">            可以存储的，因为向集合中存储基本数据类型时，完成自动转换操作 --》将基本数据类型 转换为对应 包装类</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        list.add(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        <span class="comment">//集合在没有使用泛型之前是可以存储任何引用类型对象,因为方法参数类型时Object</span></span><br><span class="line">        <span class="comment">//ArrayList集合重写toString，所以可以直接打印集合对象查看集合内容</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.向集合中指定位置添加元素数据【第一个参数是下标位置，第二个参数是存储的元素】</span></span><br><span class="line">        list.add(<span class="number">2</span>,<span class="number">100</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.向集合中添加参数集合中数据到集合中进行存储</span></span><br><span class="line">        <span class="comment">//PS：参数是一个Collection集合，所以只要是List或Set集合实现类都是传递到这个参数中</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list1_1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list1_1.add(<span class="number">1</span>);</span><br><span class="line">        list1_1.add(<span class="number">2</span>);</span><br><span class="line">        list.addAll(list1_1);    <span class="comment">//将list1_1集合里面的数据存储到list集合中</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//addAll有一个重载在指定位置中添加添加参数集合数据 addAll(下标, Collection集合对象);</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            特别注意： add 和 addAll的区别</span></span><br><span class="line"><span class="comment">            add这个方法是向集合中添加引用类型对象，即向集合集合添加地址</span></span><br><span class="line"><span class="comment">            addAll这个方法是向集合中添加参数中集合数据</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList1.add(<span class="number">1</span>);</span><br><span class="line">        arrayList1.add(<span class="number">2</span>);</span><br><span class="line">        System.out.println(arrayList1);</span><br><span class="line">        arrayList2.add(<span class="number">3</span>);</span><br><span class="line">        arrayList2.add(<span class="number">4</span>);</span><br><span class="line">        arrayList1.add(arrayList2);    <span class="comment">//相当于将arrayList2中引用存储到arrayList1这个集合中，存储是对象即地址</span></span><br><span class="line">        System.out.println(arrayList1);</span><br><span class="line">        arrayList1.addAll(arrayList2);    <span class="comment">//相当于将arrayList2中存储数据存储到arrayList1这个集合中，存储的是数据内容</span></span><br><span class="line">        System.out.println(arrayList1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.清空集合中存储的数据，但是集合引用不会消失，消失的是集合数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;没有清空之前arrayList1中的数据是：&quot;</span>+arrayList1);</span><br><span class="line">        arrayList1.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;清空之后arrayList1中的数据是：&quot;</span>+arrayList1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.判断集合否为空，即判断集合是都没有存储任何数据 [true空/false不空]</span></span><br><span class="line">        System.out.println(arrayList1.isEmpty());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6.判断集合中是否存在指定元素【判断集合中是否存储在这个对象】 --&gt; true存在 false不存在</span></span><br><span class="line">        System.out.println(list.contains(<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7.判断集合中是否存在参数集合中数据 ---》这方法不是</span></span><br><span class="line">        ArrayList独有的而是List接口提供</span><br><span class="line">        System.out.println(list.containsAll(list1_1));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//8.通过集合中存储元素下标获取集合中元素 ---》【下标不要越界范围（0~集合存储元素个数-1）】</span></span><br><span class="line">        System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//9.查询集合中是否存在指定元素并返回下标【只会返回第一次遇到元素的下标】</span></span><br><span class="line">        <span class="comment">// 找到了就是下标 找不到就是负数</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//list.lastIndexOf(查找的数据) --》查询集合中是否存在指定元素并返回下标【从后向前寻找】</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10.集合是提供真正删除操作 ---&gt; 进行减容操作</span></span><br><span class="line">        <span class="comment">//10.1 根据数据删除集合中存在数据</span></span><br><span class="line">        list.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10.2 根据下标删除集合中数据</span></span><br><span class="line">        list.remove(<span class="number">6</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10.3 List集合接口提供方法 removeAll</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list1_2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list1_2.add(<span class="number">2</span>);</span><br><span class="line">        list1_2.add(<span class="number">100</span>);</span><br><span class="line">        list1_2.add(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//根据参数集合提供数据在当前集合进行删除操作</span></span><br><span class="line">        list.removeAll(list1_2);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10.4 List集合接口提供方法 retainAll</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list1_3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list1_3.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//根据参数集合提供数据保留当前集合中存储的数据，剩余的数据进行删除</span></span><br><span class="line">        list.retainAll(list1_3);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10.5 在java8中ArrayList提供一个新的处理集合删除方法removeIf</span></span><br><span class="line">        <span class="comment">//这个方法参数支持 Lambda表达式 和 匿名内部类方式处理</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list1_4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list1_4.add(<span class="number">1</span>);</span><br><span class="line">        list1_4.add(<span class="number">2</span>);</span><br><span class="line">        list1_4.add(<span class="number">3</span>);</span><br><span class="line">        list1_4.add(<span class="number">5</span>);</span><br><span class="line">        list1_4.add(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        list1_4.removeIf(<span class="keyword">new</span> <span class="title class_">Predicate</span>()&#123;</span><br><span class="line">        <span class="comment">//需要在这个方法方法执行删除规则 结果true就会进行删除操作</span></span><br><span class="line">        <span class="comment">//参数Object 中o会获取到集合每一个元素的值</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Object o)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Integer)o)%<span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//lambda表达式</span></span><br><span class="line">        list1_4.removeIf(o-&gt; ((Integer)o)%<span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">        System.out.println(list1_4);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//11.Java8中提供一个全新的方法【支持lambda表达式和匿名内部类】</span></span><br><span class="line">        <span class="comment">//根据指定规则进行元素的替换操作</span></span><br><span class="line">        list1_4.replaceAll(<span class="keyword">new</span> <span class="title class_">UnaryOperator</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//指定当前替换规则的方法，方法参数Object中o会获取到所有集合中数据</span></span><br><span class="line">            <span class="comment">//需要在方法内部提供替换规则，返回的是替换之后需要存在集合中数据</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">apply</span><span class="params">(Object o)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> o.equals(<span class="number">3</span>) ? <span class="number">30</span> : o;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        list1_4.replaceAll(o-&gt;o.equals(<span class="number">3</span>) ? <span class="number">30</span> : o);</span><br><span class="line">        System.out.println(list1_4);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//12. 修改【替换】集合中指定位置的数据 ---》第一个参数是下标，第二个参数修改数据</span></span><br><span class="line">        list1_4.set(<span class="number">0</span>,<span class="number">10000</span>);</span><br><span class="line">        System.out.println(list1_4);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//13.获取集合中存储元素个数【集合长度】</span></span><br><span class="line">        System.out.println(list1_4.size());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//14.将集合转换为数组</span></span><br><span class="line">        Object[] objects = list1_4.toArray();</span><br><span class="line">        <span class="comment">//PS：数组中也提供一个方法【Arrays】，将数组转换为List集合</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">objects1</span> <span class="operator">=</span> Arrays.asList(objects);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//15.【不太推荐】 截取指定范围内容集合数据得到一个新的集合</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList1_5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList1_5.add(<span class="number">1</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">2</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">3</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">4</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">5</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">6</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">7</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">//包括前不包括后 包括开始位置，不包括结束位置，参数都是下标</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> arrayList1_5.subList(<span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点三：List集合三种遍历方式</center></h1>
<h2 id="center-普通for循环-center"><center>普通for循环</center></h2>
<p>PS：因为ArrayList的底层实现是数组，所以支持数组中提供下标进行</p>
<p>对ArrayList进行操作</p>
<p>语法格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; 集合对象.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">    循环变量i值就是ArrayList集合下标变量，<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> 定义下标初始值</span><br><span class="line">    ArrayList它获取集合长度使用 size() 方法</span><br><span class="line">    通过ArrayList集合提供get方法或set方法对集合数据进行</span><br><span class="line">取值与赋值操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特点：因为这里操作的是下标，所以可以利用下标对集合数据进行【增删改查】操作</p>
<h2 id="center-增强for循环-foreach循环-center"><center>增强for循环【foreach循环】</center></h2>
<p>PS：因为ArrayList的底层实现是数组，所以支持数组中提供下标进行对ArrayList进行操作</p>
<p>语法格式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(集合中存储元素的类型 变量名 : 集合名)</span><br><span class="line">&#123;</span><br><span class="line">    通过操作局部变量就可以操作集合中数据了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：之前在学习数组的时候说过，数组遍历方式有两种一种普通for循环，一种是增强for循环，增强for循环只能使用在数组或集合中，在数组使用增强for循环它的实现原码是将数组值赋值给局部变量，所以对与增强for循环中局部变量修改是不会影响到数组，增强for循环适合简单数据运算、分支判断和打印数组中数据</p>
<p>特点：集合中增强for循环和数组中增强for循环同样效果，支持数组进行简单数据运算、分支判断和打印集合中数据，【但是不支持对集合中数据进行修改操作，也不允许在增强for循环中调用集合删除方法进行数据删除】，如果一旦删除就会出现一个【并发迭代修改异常 --》ConcurrentModificationException】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionForeach</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);    </span><br><span class="line">        list.add(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;cxk&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;尼古拉斯&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//List集合遍历方式1：使用迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.提供一个ArrayList集合对象</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line">        arrayList.add(<span class="number">2</span>);</span><br><span class="line">        arrayList.add(<span class="number">3</span>);</span><br><span class="line">        arrayList.add(<span class="number">4</span>);</span><br><span class="line">        arrayList.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//提供一个普通for循环操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;arrayList.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获取存储的数据</span></span><br><span class="line">            System.out.println(arrayList.get(i));</span><br><span class="line">            <span class="comment">// 通过下标对集合中数据进行修改</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">2</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                arrayList.set(i, <span class="number">100</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//通过下标进行数据删除操作 ---》 支持全套删除</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arrayList.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//增强for循环</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(Object obj : arrayList)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//obj中就会存储这个集合中所有数据</span></span><br><span class="line">            System.out.println(obj);<span class="comment">//打印集合数据</span></span><br><span class="line">            <span class="comment">//判断集合中数据做什么操作</span></span><br><span class="line">            <span class="keyword">if</span>(obj.equals(<span class="number">3</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//操作代码</span></span><br><span class="line">                System.out.println(obj);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//数据类型是可以做计算</span></span><br><span class="line">            sum += ((Integer)obj);</span><br><span class="line">            <span class="comment">//需要注意set方法无法使用，因为set第一个参数是下标</span></span><br><span class="line">            <span class="comment">//不能使用集合中删除方法，即在增强for循环中是不允许调用</span></span><br><span class="line">            删除方法的</span><br><span class="line">            <span class="keyword">if</span>(obj.equals(<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                arrayList.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>提供增强for循环的原码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> arrayList.iterator();</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!iterator.hasNext())</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">    <span class="keyword">if</span> (obj.equals(Integer.valueOf(<span class="number">3</span>)))</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">    sum += ((Integer)obj).intValue();</span><br><span class="line">    <span class="keyword">if</span> (obj.equals(Integer.valueOf(<span class="number">1</span>)))</span><br><span class="line">    arrayList.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>));</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"><span class="string">&quot;增强for循环之所以不可以删除,原因就是在于增强for循环即foreach底层实现就是一个迭代器，</span></span><br><span class="line"><span class="string">迭代器中是不允许使用集合中删除方法进行数据删除的，如果删除ConcurrentModificationException就出现这个异常&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="center-foreach方法遍历-center"><center>foreach方法遍历</center></h2>
<p>foreach是Java8中提供一个新增的方法，主要是以一个方法形态可以遍历打印集合中数据，因为这个方式Java8中提供，所以这个方法支持lambda表达式和匿名内部类实现</p>
<p>PS: 这个方法主要就是用于打印，其他方式较少</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8ForArrayList</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供一个ArrayList集合对象</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line">        arrayList.add(<span class="number">2</span>);</span><br><span class="line">        arrayList.add(<span class="number">3</span>);</span><br><span class="line">        arrayList.add(<span class="number">4</span>);</span><br><span class="line">        arrayList.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//方法内部可以指定打印效果</span></span><br><span class="line">        <span class="comment">//匿名内部类的形式</span></span><br><span class="line">        arrayList.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这个方法中就是咱们打印集合中数据的形式</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Object o)</span> &#123;<span class="comment">//Object类型o参数</span></span><br><span class="line">            可以获取到集合每一个数据</span><br><span class="line">            System.out.println(o);</span><br><span class="line">            <span class="comment">//提供一些判断打印效果，根据具体需求来，这个方法没</span></span><br><span class="line">            有返回值，所以打印效果是不会影响实际存储数据的</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//Lambda表达式实现</span></span><br><span class="line">        arrayList.forEach(o -&gt; System.out.println(o));</span><br><span class="line">        <span class="comment">//提供Lambda中方法引用操作</span></span><br><span class="line">        arrayList.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点四：ArrayList底层实现原理</center></h1>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271931515.WebP" alt="ArrayList底层实现原理" style="zoom: 50%;">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListDemo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1、构造方法初始化一个长度为0的Object数组</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * ArrayList底层的元素是数组</span></span><br><span class="line"><span class="comment">         * add方法的原理</span></span><br><span class="line"><span class="comment">         * 1、当第一次添加元素的时候，初始化一个长度为10的数组</span></span><br><span class="line"><span class="comment">         *  当添加元素超过数组的长度的时候，会对数组进行扩容，扩容到1.5倍</span></span><br><span class="line"><span class="comment">         * 2、将当前的元素添加到数组指定的下标位置上</span></span><br><span class="line"><span class="comment">         *    elementData[size++] = e;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *数组数据结构的特点：增删慢，查询快</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点五：迭代器</center></h1>
<p>Java中专门针对Collection集合提供了一种遍历方式，这种遍历方式是根据Iterable接口来决定，只要是Collection的集合接口在子接口基本上都会具备Iterable这个接口，这个接口中主要提供一个方法</p>
<table>
<thead>
<tr>
<th>Iterator</th>
<th>iterator() 返回按适当顺序在列表的元素上进行迭代的迭代器</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>这个方法会返回一个按照集合顺序并存储集合数据的一个迭代器对象</td>
</tr>
</tbody>
</table>
<h2 id="center-1-迭代器原理-center"><center>1、迭代器原理</center></h2>
<p>迭代是重复反馈过程的活动,其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”,而每一次迭代得到的结果会作为下一次迭代的初始值</p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291911167.WebP" alt="原理" style="zoom: 50%;">
<h2 id="center-2-获取迭代器对象-center"><center>2、获取迭代器对象</center></h2>
<p>Iterator 变量名 = Collection的变量名.iterator();</p>
<h2 id="center-3-迭代器的三个方法-center"><center>3、迭代器的三个方法</center></h2>
<p>（1）判断迭代器是否有下一个元素</p>
<p>    变量名.hasNext();</p>
<p>    返回值boolean类型</p>
<p>（2）获取当前游标对应元素并将游标向后移动一位</p>
<p>    变量名.next()</p>
<p>    返回迭代的下一个元素</p>
<p>（3）移除当前迭代器上对应的元素</p>
<p>    变量名.remove();</p>
<p>    说明：可以利用Iterator中提供三个核心方法操作迭代器影响集合中数据</p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292037504.WebP" alt="迭代器方法" style="zoom:50%;">
<p>PS： 迭代器中在没有使用泛型之前，next方法的返回值类型都是统一Object，所以将方法中返回E看做是Object即可，迭代器提供自身remove方法，所以在迭代器中删除数据时要调用迭代器提供remove，而不是集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorArrayList</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//基础迭代器</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line">        arrayList.add(<span class="number">2</span>);</span><br><span class="line">        arrayList.add(<span class="number">3</span>);</span><br><span class="line">        arrayList.add(<span class="number">4</span>);</span><br><span class="line">        arrayList.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//需要使用ArrayList集合对象调用iterator方法获取迭代器对象</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> arrayList.iterator();</span><br><span class="line">        <span class="comment">//利用迭代器对象调用hasNext进行操作判断迭代器中是否还存在下一个元素</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        while(iterator.hasNext())</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            //通过next方法获取迭代器中数据</span></span><br><span class="line"><span class="comment">            System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//迭代器使用问题--》删除数据</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> ((Integer) iterator.next());</span><br><span class="line">            <span class="keyword">if</span> (integer.equals(<span class="number">2</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//删除掉2这个值</span></span><br><span class="line">                <span class="comment">//iterator.remove();//使用迭代器中提供删除[删除迭代器中存储数据的同时会删除集合中对应数据]</span></span><br><span class="line">                <span class="comment">//千万不要调用集合中提供删除方法</span></span><br><span class="line">                <span class="comment">//ConcurrentModificationException --&gt; 就会出现并发迭代修改异常</span></span><br><span class="line">                </span><br><span class="line">                arrayList.remove(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-4-强化迭代器-center"><center>4、强化迭代器</center></h2>
<p>强化迭代器只有List集合具备，专门为List集合提供一个增强迭代器，因为原始迭代器中只有三个方法，不利于对集合数据的操作，增强迭代器就新增多个方法进行迭代器操作</p>
<p>ListIterator是List集合在Iterator迭代器接口之上提供一个更多方法操作的迭代器，ListIterator在原始迭代器基础上增加，新增数据，修改数据，从后向前遍历【获取数据】的操作，还可以获取下标</p>
<table>
<thead>
<tr>
<th>void</th>
<th>add(E e) 将指定的元素插入列表（可选操作）</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>hasNext() 以正向遍历列表时，如果列表迭代器有多个元素，则返回 true （换句话说，如果 next 返回一个元素而不是抛出异常，则返回 true ）</td>
</tr>
<tr>
<td>boolean</td>
<td>hasPrevious() 如果以逆向遍历列表，列表迭代器有多个元素，则返回 true</td>
</tr>
<tr>
<td>void</td>
<td>add(E e) 将指定的元素插入列表（可选操作）</td>
</tr>
<tr>
<td>E</td>
<td>next() 返回列表中的下一个元素</td>
</tr>
<tr>
<td>int</td>
<td>nextIndex() 返回对 next 的后续调用所返回元素的索引</td>
</tr>
<tr>
<td>E</td>
<td>previous() 返回列表中的前一个元素</td>
</tr>
<tr>
<td>int</td>
<td>previousIndex() 返回对 previous 的后续调用所返回元素的索引</td>
</tr>
<tr>
<td>void</td>
<td>remove() 从列表中移除由 next 或 previous 返回的最后一个元素（可选操作）</td>
</tr>
<tr>
<td>void</td>
<td>set(E e) 用指定元素替换 next 或 previous 返回的最后一个元素（可选操作）</td>
</tr>
</tbody>
</table>
<p>PS：在没有使用泛型之前，方法所有使用E的部分都看做是Object类型即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListIteratorArrayList</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//基础迭代器</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line">        arrayList.add(<span class="number">2</span>);</span><br><span class="line">        arrayList.add(<span class="number">3</span>);</span><br><span class="line">        arrayList.add(<span class="number">4</span>);</span><br><span class="line">        arrayList.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//需要使用ArrayList集合对象调用listiterator方法获取迭代器对象</span></span><br><span class="line">        <span class="type">ListIterator</span> <span class="variable">iterator</span> <span class="operator">=</span> arrayList.listIterator();</span><br><span class="line">        <span class="comment">//如果你想调用逆向遍历操作时，需要现将光标向后移动才可以，光标最先开始是在第一个元素位置上</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时对迭代器进行逆向遍历【从后向前】</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasPrevious())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(iterator.previous());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&quot;listIterator同样是遵守一个原则，不要再迭代器中使用后集合删除方法删除数据，要使用迭代器提供方法进行删除&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="center-5-迭代器注意事项-center"><center>5、迭代器注意事项</center></h2>
<p>（1）迭代器迭代完成之后，迭代器的位置在最后一位。 所以迭代器只能迭代一次</p>
<p>（2）迭代器在迭代的时候，不要调用多次next方法，可能会出错 NoSuchElementException</p>
<p>（3）在迭代器迭代的时候，不能向集合中添加或者删除元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionDemo03</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="string">&quot;jeck&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;马冬梅&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;Lisi&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、迭代器不能使用多次，如果要多次使用那么要多次获取</span></span><br><span class="line"><span class="comment">//        Iterator it = coll.iterator();</span></span><br><span class="line"><span class="comment">//        while (it.hasNext())</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(it.next());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        while (it.hasNext())</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(it.next());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、在同一次迭代中，不能多次使用next方法</span></span><br><span class="line"><span class="comment">//        Iterator it = coll.iterator();</span></span><br><span class="line"><span class="comment">//        while (it.hasNext())</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            //第一种</span></span><br><span class="line"><span class="comment">//            Object obj = it.next();</span></span><br><span class="line"><span class="comment">//            System.out.println(obj);</span></span><br><span class="line"><span class="comment">//            //第二种</span></span><br><span class="line"><span class="comment">//            System.out.println(it.next());</span></span><br><span class="line"><span class="comment">//            //不能这么多次使用</span></span><br><span class="line"><span class="comment">//            Object obj = it.next();</span></span><br><span class="line"><span class="comment">//            System.out.println(it.next());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、迭代器在迭代的过程中不能调用add或者remove方法</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            coll.add(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点六：List集合之LinkedList集合</center></h1>
<h2 id="center-1-说明-center"><center>1、说明</center></h2>
<p>LinkedList集合也是List集合接口中主要实现类，这个LinkedList的主要实现结构有【链表】，除了链表结构之外LinkeList还使用栈、 队	列、数组，LinkedList是允许存重复数据化并且可以快速插入数据</p>
<p><strong>LinkedList中实现的数据结构</strong></p>
<p><strong>栈</strong>：stack,又称堆栈，它是运算受限的线性表，其限制是仅允许在表的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</p>
<p>简单的说：采用该结构的集合，对元素的存取有如下的特点</p>
<p><strong>先进后出</strong>（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹</p>
<p><strong>栈的入口、出口的都是栈的顶端位置</strong></p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291919875.WebP" alt="栈的位置" style="zoom:67%;">
<p>这里两个名词需要注意：</p>
<p>    <strong>压栈</strong>：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置</p>
<p>    <strong>弹栈</strong>：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置</p>
<p><strong>队列</strong>：队列和栈有一些类似，也是一种受到限制的线性表，其限制是仅允许在表的一表进行插入，另外一段进行取出和删除，这样队列叫做单向队列【Queue】</p>
<p>队列是存在一个特点：先进先出</p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291920090.WebP" alt="队列" style="zoom: 33%;">
<p>队列：除了单向队列之外，还提供一种非受限制线性表，这表就是双端队列，依旧遵守先进先出原则，<strong>双端队列</strong>【Deque】</p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291921569.WebP" alt="双端队列" style="zoom:33%;">
<p>链表：链表属于一个线性表，线性表中包含了存储链接位置和数据的位置，利用链接位置进行相连接，使数据之间呈现一种链接状态，链表可以理解为：老鹰抓小鸡</p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291921058.WebP" alt="链表" style="zoom:50%;">
<p>链表和队列差不多，链表也分为单向和双向链表，类似于现实生活中的【火车】通过链接方式就可以获取得到链表中数据</p>
<p>单向链表和双向链表是有本质上区别的，单向链表包含两个区域【存储链接位置和数据存储位置】，通过【存储链接位置】让每一个单独链接节点进行相连，形成一个单向链表，即单向链表只能向一个方法进行遍历操作，双向链表包含是三个区域【2个存储链接位置和1个数据存储位置】 ，利用双向链表中两个存储链接的位置进行前后节点的链接，此时链表就形成了一个双向通道，即可以从头到尾，也可以从到头，允许直接在头尾两端进行操作</p>
<h2 id="center-2-分析linkedlist的执行效率-center"><center>2、分析LinkedList的执行效率</center></h2>
<p>主要实现方式是【双向链表】，所以使用LinkedList效果</p>
<ol>
<li>
<p>保存数据 ：只要执行一次即可【API中也提供 addFirst 和addLast】</p>
</li>
<li>
<p>删除操作： 只要执行一次即可【API中也提供 removeFirst 和removeLast】，就选中间节点(1+N)/2</p>
</li>
<li>
<p>查询操作和修改操作：平均值(N+1)/2</p>
</li>
</ol>
<p>结论：LinkedList增删执行效率是高的，但是查询和修改执行效率是低的</p>
<h2 id="center-3-常用方法-center"><center>3、常用方法</center></h2>
<p>常用的方法与ArrayList一致。自己独有一些向首尾添加移除等方法(可以模拟对列、堆栈等数据结构)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListAPIDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//因为LinkedList实现了List集合接口，所以具备所有List集合</span></span><br><span class="line">        操作方法</span><br><span class="line">        <span class="comment">//LinkedList中List方法操作完全参考ArrayList即可</span></span><br><span class="line">        <span class="comment">//LinkedList集合独有方法</span></span><br><span class="line">        <span class="comment">//1.创建LinkedList对象</span></span><br><span class="line">        <span class="comment">//1.1 创建一个空的LinkedList集合对象</span></span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="comment">//1.2使用参数中Collection集合对象中存储数据初始化LinkedList集合对象</span></span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">linkedList1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>(linkedList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//独有API        </span></span><br><span class="line">        <span class="comment">//1.向集合开头的位置添加元素</span></span><br><span class="line">        linkedList.addFirst(<span class="number">1</span>);</span><br><span class="line">        System.out.println(linkedList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.向集合结尾的位置添加元素</span></span><br><span class="line">        linkedList.addLast(<span class="number">2</span>);</span><br><span class="line">        System.out.println(linkedList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.获取集合第一个元素的数据【但是不删除集合数据】</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">element</span> <span class="operator">=</span> linkedList.element();</span><br><span class="line">        System.out.println(element);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.获取集合中第一个数据和最后一个数据【但是不删除集合数据】</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">first</span> <span class="operator">=</span> linkedList.getFirst();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">last</span> <span class="operator">=</span> linkedList.getLast();</span><br><span class="line">        <span class="comment">//PS： LinkedList允许使用下标形式进行数据获取</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> linkedList.get(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.添加元素到集合的末尾</span></span><br><span class="line">        linkedList.offer(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//添加到第一个位置offerFirst和最后一个位置offerLast</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6.获取集合集合第一个元素但是【不删除集合数据】，有元素就返回，没有就是null</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">peek</span> <span class="operator">=</span> linkedList.peek();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> linkedList.peekFirst();</span><br><span class="line">        <span class="comment">//获取最后一个元素的值，有元素就返回，没有就是null</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> linkedList.peekLast();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7.poll系列也是也可以获取集合中第一个和最后一个元素的【删除数据】</span></span><br><span class="line">        <span class="comment">//在获取数据的同时删除集合中数据</span></span><br><span class="line">        <span class="comment">// Object poll = linkedList.poll();</span></span><br><span class="line">        <span class="comment">// Object o3 = linkedList.pollFirst();</span></span><br><span class="line">        <span class="comment">// Object o4 = linkedList.pollLast();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//8. 弹出集合中第一个数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">pop</span> <span class="operator">=</span> linkedList.pop();</span><br><span class="line">        <span class="comment">//向集合中添加数据</span></span><br><span class="line">        linkedList.push(<span class="number">4</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//9.删除集合中第一个或最后一个元素值</span></span><br><span class="line">        linkedList.removeFirst();</span><br><span class="line">        linkedList.removeLast();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10.List集合特点就是允许存储重复数据，下面两个方法的作用就是遍历集合</span></span><br><span class="line">        <span class="comment">//First的方法从前之后 Last的方法从后向前</span></span><br><span class="line">        <span class="comment">//遇到第一个相同数据删除</span></span><br><span class="line">        linkedList.removeFirstOccurrence(<span class="number">1</span>);</span><br><span class="line">        linkedList.removeLastOccurrence(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//LinkedList有一个独有的迭代器，允许逆向的遍历迭代器中数据值</span></span><br><span class="line">        <span class="comment">//但是它的操作方式和iterator是一样</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> linkedList.descendingIterator();</span><br><span class="line">        <span class="comment">//它的方式只有三个 hasNext next 和 remove</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//不同点在于：它的光标最先开始是放置在迭代器最后一个元素的位置，你hasNext是向前判断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-4-linkedlist实现原理-center"><center>4、LinkedList实现原理</center></h2>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291923333.WebP" alt="实现原理" style="zoom:50%;">
<h1><center>知识点七：List集合总结</center></h1>
<p>List集合是Collection集合子集合即List集合是继承与Collection集合，因为List集合是接口所以无法直接操作，Java就提供了两个可以便捷操作List集合实现类ArrayList和LinkedList</p>
<p>List集合的特点：允许存储重复数据并给存储数据是有顺序</p>
<p>在官方API文档中可以查看到：public interface List extends Collection</p>
<p>有序的 collection（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素</p>
<p><strong>所有已知实现类</strong>： ArrayList 和 LinkedList</p>
<p><strong>所有超级接口</strong>： Collection 和 Iterable</p>
<p>因为也继承了Iterable所以List集合中是支持的迭代器【Iterator】</p>
<p>List接口中提供常用方法已经在ArrayList集合中完全进行演示，所以使用List集合时只要参考ArrayList提供方法演示就可以操作集合</p>
<p>ArrayList和LinkedList实现类是实现List接口，所以List相当于是他们的父类，所以List集合接口支持多态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List集合接口允许这样这样创建对象</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">或者</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line"><span class="string">&quot;这样直接使用较少，多用于在方法中如果需要设置List集合参数，优先会</span></span><br><span class="line"><span class="string">将List作为参数类型，而不是实现类&quot;</span></span><br><span class="line"><span class="string">&quot;因为这样做可以接收ArrayList或LinkedList&quot;</span></span><br><span class="line"><span class="string">&quot;上面这种方式是不使用泛型，所以默认数据类型时Object，操作时就一定</span></span><br><span class="line"><span class="string">注意转换问题【对象的向下转型】&quot;</span></span><br><span class="line"><span class="string">&quot;Java中所有集合都是有泛型语法，所以可以使用泛型方式进行创建对象&quot;</span></span><br><span class="line">    List&lt;数据类型&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="string">&quot;泛型语法形式：&quot;</span></span><br><span class="line">    集合的数据类型&lt;数据类型&gt; 集合对象名字 = <span class="keyword">new</span> 集合数据类型&lt;&gt;();</span><br><span class="line"><span class="string">&quot;集合都是使用new关键字创建，所以它是引用类型&quot;</span></span><br><span class="line"><span class="string">&quot;现在学习ArrayList和LinkedList都是线程不安全的集合，在多线程操</span></span><br><span class="line"><span class="string">作前提下是不能使用这两个集合进行数据存储操作，这两个集合只适合在单线程下使用&quot;</span></span><br></pre></td></tr></table></figure>
<p>List集合接口还有一个<strong>实现类Vector</strong></p>
<p>Vector在JDK1.0的时候就已经存在，这个类其实是ArrayList集合类“前身”，在JDK1.2时候Java开始强调了集合框架概念，所以提供Collection集合框架，在Collection下面提供List和Set，Vector的实现也是数组，所以被归类到了List接口的实现类中，现在开发已经不在使用Vector这个类，主要使用ArrayList这个类</p>
<p>Vector和ArrayList之间相似点和区别在于什么？</p>
<p>相似点：都是List集合接口的实现类，都使用数组作为集合数据结构进行实现</p>
<p>不同点：Vector这个集合是线程安全的，但是效率低，提供较早并且使用率低</p>
<p>    ArrayList这个集合是线程不安全，但是效率高，提供较晚并且使用率高</p>
<p>PS：就算Vector是线程安全的，但实际开发中也不会使用Vector，还是使用ArrayList</p>
<p>从Java5开始提供ArrayList和LinkeList线程安全处理模式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;集合中是存在一个工具类，这个类叫做Collections，这个工具类提供</span></span><br><span class="line"><span class="string">了如果将线程不安全集合转换为线程安装集合的方法&quot;</span></span><br><span class="line">Collections.synchronizedList(List集合对象); ---》可以将</span><br><span class="line">一个线程不安全集合转换为线程安全</span><br><span class="line"><span class="string">&quot;除了这种处理方式之外,现在主要处理方式可以使用Java在JDK1.5中提</span></span><br><span class="line"><span class="string">供的一个新包java.util.concurrent 并发工具包，</span></span><br><span class="line"><span class="string">这个包中提供大量的线程安全处理时可以使用的集合&quot;</span></span><br></pre></td></tr></table></figure>
<p>Stack(栈集合)和Queue、Deque(队列集合)</p>
<p>Stack是List集合的实现类，而Queue、Deque集合接口：有专门实现类来实现主要体现在于LinkedList</p>
<h1><center>知识点八：泛型基本使用</center></h1>
<h2 id="center-1-作用-center"><center>1、作用</center></h2>
<p>什么是泛型？</p>
<p>    泛型是一个特殊类型，泛型是统称指代任何引用数据类型，泛型本身代表【通用类型含义】，在定义泛型时如果没有对泛型进行数据类型赋值之前，泛型本身是不具备任何含义，只有赋值为具体数据类型时，泛型才会真正意义</p>
<p>为什么要使用这个泛型?</p>
<p>    泛型解决了集合中存储数据类型的问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CenericityList</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在学习集合之前，是没有使用泛型，所以集合中默认类型就是Object</span></span><br><span class="line"><span class="comment">            我们面临的问题就是取出数据时，需要进行向下转型操作才可以</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//对集合存储的数据进行计算求和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span><span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(Object obj : list)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += ((Integer) obj);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//因为不使用泛型默认类型时Object类型所以和这个集合中就可以存储任何数据类型只要是Object子类</span></span><br><span class="line">        list.add(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line">        list.add(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//如果你在不清楚集合中存储在什么样数据类型数据时，如果进行转换操作？代码就无形中增加开发成本</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            所以在这种情况下，集合建议使用泛型，来约束集合中存储数据</span></span><br><span class="line"><span class="comment">            一旦集合使用泛型就要可以约束集合只能 存储泛型中提供的数据类型对应数据，从而减少转换操作</span></span><br><span class="line"><span class="comment">            此时list1这个集合中只能存储Integer类型数据，使用泛型作为约束</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list1.add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//list1.add(&quot;1&quot;);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer i : list1)</span><br><span class="line">        &#123;</span><br><span class="line">            sum1+=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS： 如何定义泛型集合？</p>
<h3 id="语法">语法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">集合数据类型&lt;存储数据的数据类型&gt; 集合对象名 = <span class="keyword">new</span> 集合数据类型&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>此时就可以使用【存储数据的数据类型】约束集合中存储的数据了</p>
<p>PS：集合泛型你就可以理解为 就是创建数组是</p>
<p>数组中存储元素数据类型[] —》相当于 集合数据类型&lt;存储数据的数据类型&gt;	只能引用数据类型</p>
<p>泛型解决通用性问题</p>
<p>编程原则：DRY【不要重复你自己（不要写重复性代码）】</p>
<p>需求： 求点中x和y的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer x;</span><br><span class="line">    <span class="keyword">private</span> Integer y;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Double x;</span><br><span class="line">    <span class="keyword">private</span> Double y;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Long x;</span><br><span class="line">    <span class="keyword">private</span> Long y;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String x;</span><br><span class="line">    <span class="keyword">private</span> String y;</span><br><span class="line">&#125; </span><br><span class="line">为了Point类型可以获得不同参数类型数据，需要提供大量相同逻辑类，此时就触发DRY原则，</span><br><span class="line">现有解决方案就是将数据类型替换成Object类型，但</span><br><span class="line">是我们需要面临数据类型转换和传递非计算类型问题，有没有什么方式可以</span><br><span class="line">动态决定类中x和y属性类型操作，根据外界传递类型来进行x和y的限制操作 ---》 可以使用<span class="string">&quot;泛型&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="keyword">private</span> T y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-2-定义-center"><center>2、定义</center></h2>
<p>PS：泛型中会出现一个【占位符】的概念，这个占位符本身是没有任何意义，就是一个占位，对泛型进行赋值时，占位符才会有具体的意义</p>
<p>泛型的概念是Java5开始引入到Java中，它可以通过对泛型赋值进行对数据赋值约束，通过泛型动态决定数据类型时什么</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;占位符&gt;</span><br><span class="line">PS：这种语法在Java中叫做<span class="string">&quot;菱形语法&quot;</span>，这样语法与占位符组合就是成</span><br><span class="line">为<span class="string">&quot;泛型&quot;</span></span><br><span class="line">这个语法可以使用在 <span class="string">&quot;类、方法和接口&quot;</span>上</span><br><span class="line">占位符<span class="string">&quot;一般是一个大写字母[A~Z]&quot;</span>,不建议使用其他形式进行占位符定义</span><br><span class="line">习惯书写占位符是 <span class="string">&quot;T&quot;</span> --&gt; <span class="string">&quot;Type(类型)&quot;</span> ---&gt; &lt;T&gt; 泛型T</span><br><span class="line">占位符可以在一个语法存在多个需要使用<span class="string">&quot;,&quot;</span>分隔，使用占位符的多少就相</span><br><span class="line">当于你定义多个泛型</span><br><span class="line">泛型语法:只能存在在编译时期，一旦程序运行泛型就会自动消失<span class="string">&quot;称之为泛型擦除&quot;</span></span><br><span class="line">        定义的泛型在编译字节码文件中即[.class文件]看不到</span><br></pre></td></tr></table></figure>
<h2 id="center-3-泛型的使用之集合-center"><center>3、泛型的使用之集合</center></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CenericityList</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 集合的数据类型&lt;泛型赋值数据类型&gt; 集合对象名字 = new 集合的数据类型&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// 声明的就是带有泛型集合，泛型可以作为集合类型一部分，可以出现在方法参数位置和返回值类型的位置</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list1.add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//一旦集合使用泛型之后，集合只允许使用泛型定义数据类型，非泛型定义数据类型时无法存储到集合中</span></span><br><span class="line">        <span class="comment">//list1.add(&quot;1&quot;);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//集合使用泛型之后，确定了集合中存储数据的数据类型，在集合中的数据就无需向下转型操作</span></span><br><span class="line">        <span class="keyword">for</span>(Integer i : list1)</span><br><span class="line">        &#123;</span><br><span class="line">            sum1+=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showList</span><span class="params">(ArrayList&lt;Integer&gt; list)</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title function_">showList</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-4-泛型的使用之泛型类-center"><center>4、泛型的使用之泛型类</center></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    当前类在没有使用任何其他修饰符之前【final 或 abstract】,没有使用泛</span></span><br><span class="line"><span class="comment">型语法之前 都是一个普通类</span></span><br><span class="line"><span class="comment">    public class CenericityClass </span></span><br><span class="line"><span class="comment">    &#123;&#125;</span></span><br><span class="line"><span class="comment">    利用泛型语法 &lt;占位符&gt; 可以将当前类变成泛型类</span></span><br><span class="line"><span class="comment">    语法：</span></span><br><span class="line"><span class="comment">        public class 类名&lt;占位符&gt;    //这个类就是泛型类</span></span><br><span class="line"><span class="comment">        &#123; </span></span><br><span class="line"><span class="comment">            此时这个泛型是定义在类上，所以在类中成员变量和成员方法都可以使用</span></span><br><span class="line"><span class="comment">            这个泛型</span></span><br><span class="line"><span class="comment">作为数据类型使用</span></span><br><span class="line"><span class="comment">        &#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CenericityClass</span>&lt;T&gt; <span class="comment">// 使用泛型是 T 这个T现在是没有意义 只是一个占位符号</span></span><br><span class="line">&#123;     </span><br><span class="line">    <span class="comment">//此时这个T是没意义，为了保证语法不错误，占位使用</span></span><br><span class="line">    <span class="comment">//泛型T只有被赋值之后【数据类型（必须是引用数据类型）】 T才会有意义</span></span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="keyword">public</span> T y;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CenericityClass</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CenericityClass</span><span class="params">(T x, T y)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//在类上定义泛型，如何确定泛型数据类型，只要在创建类的对象时对泛型进行赋值，泛型就有具体的数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 类名&lt;泛型赋值数据类型&gt; 对象名字 = new 类名&lt;&gt;();</span></span><br><span class="line">        CenericityClass&lt;Integer&gt; cc = <span class="keyword">new</span></span><br><span class="line">        <span class="title class_">CenericityClass</span>&lt;&gt;();</span><br><span class="line">        cc.y = <span class="number">1</span>;</span><br><span class="line">        cc.show(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//这样创建对象,创建泛型的同时不对泛型进行赋值操作</span></span><br><span class="line">        <span class="comment">//此时没有对泛型进行赋值，所以泛型类型默认使用Object</span></span><br><span class="line">        <span class="type">CenericityClass</span> <span class="variable">cc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CenericityClass</span>();</span><br><span class="line">        cc1.y = <span class="number">1</span>;</span><br><span class="line">        cc1.y = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        cc1.show(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">PS：泛型在动态决定数据类型时什么的时候，不存在继承关系&quot;</span></span><br><span class="line"><span class="string">&quot;不要这样写，这个语法是错误，对泛型进行赋值什么数据类型时，就决定这个数类型，所不允许赋值为其他类&quot;</span></span><br><span class="line">CenericityClass&lt;Object&gt; cc = <span class="keyword">new</span></span><br><span class="line"><span class="title class_">CenericityClass</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>
<h2 id="center-5-泛型使用之泛型方法-center"><center>5、泛型使用之泛型方法</center></h2>
<p>泛型方法的定义主要是为了摆脱使用泛型类上或泛型接口上的泛型约束问题，就相当于方法向使用自己定义泛型作为类型操作，就可以定义为泛型方法</p>
<p>泛型类和泛型接口上定义泛型，不能在静态方法上使用，所以只能定义泛型方法对方法进行泛型使用修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericityMethod</span>&lt;T&gt; <span class="comment">// 使用泛型是 T 这个T现在是没有意义 只是一个占位符号</span></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个成员方法 泛型类上定义泛型就可以在方法中使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//泛型类上定义泛型是不能在静态方法上使用</span></span><br><span class="line">    <span class="comment">//public static void showInfos(T t)&#123; &#125;</span></span><br><span class="line">    <span class="comment">//给方法添加泛型</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        泛型静态方法：</span></span><br><span class="line"><span class="comment">            访问权限修饰符 static&lt;占位符&gt; 返回值类型 方法名(参数列表)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                此时这个占位符可以使用在返回值类型上 和 参数列表定义中</span></span><br><span class="line"><span class="comment">            &#125; </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;E&gt; <span class="keyword">void</span> <span class="title function_">showInfos</span><span class="params">(E e)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//E a;// 方法上泛型主要是为了 返回值类型和参数类型而提供的，在内部就不在使用</span></span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        泛型成员方法：</span></span><br><span class="line"><span class="comment">            访问权限修饰符&lt;占位符&gt; 返回值类型 方法名(参数列表)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                此时这个占位符可以使用在返回值类型上 和 参数列表定义中</span></span><br><span class="line"><span class="comment">            &#125; </span></span><br><span class="line"><span class="comment">        此时不仅可以使用泛型方法上定义泛型，也可以使用类上或接口上定义泛型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span>&lt;F&gt; <span class="keyword">void</span> <span class="title function_">showInfoss</span><span class="params">(F f,T t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//F a;// 方法上泛型主要是为了 返回值类型和参数类型而提供的，在内部就不在使用</span></span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//定义泛型方法泛型，不能单独使用在方法返回值类型位置，需要配合使用参数列表定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;O&gt; O <span class="title function_">showInfosss</span><span class="params">(O o)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//静态方法可以这样操作，成员的不可以</span></span><br><span class="line">        <span class="comment">//return o;</span></span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如何给方法定义泛型进行赋值操作---》赋值数据类型</span></span><br><span class="line">        <span class="comment">//在调用方法对泛型定义参数列表赋值时，可以决定方法的泛型是什么，定义泛型方法时</span></span><br><span class="line">        <span class="comment">//一定要将泛型定义在参数列表中，以确定数据类型是什么</span></span><br><span class="line">        GenericityMethod.showInfos(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="type">GenericityMethod</span> <span class="variable">genericityMethod</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">        <span class="title class_">GenericityMethod</span>();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> GenericityMethod.showInfosss(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-6-泛型使用之接口泛型-center"><center>6、泛型使用之接口泛型</center></h2>
<p>接口泛型和泛型类差不多，在接口上定义泛型，这个泛型可以在接口内部使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    public interface 接口名&lt;占位符&gt;</span></span><br><span class="line"><span class="comment">    &#123;&#125;泛型接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenericityInterface</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在接口上定义泛型可以在接口内部使用</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(T t)</span>;</span><br><span class="line">    <span class="comment">//支持抽象方法自定义泛型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span>&lt;E&gt; <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(E e)</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//1. 在使用类实现接口时可以对泛型接口的泛型进行赋值，决定泛型类型是什么 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">GenericityInterface</span>&lt;Integer&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在接口中定义方法使用泛型位置都会变成数据类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Integer integer)</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(E e)</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 使用泛型类实现泛型接口，使用泛型类中泛型作为接口中新泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo2</span>&lt;P&gt; <span class="keyword">implements</span> <span class="title class_">GenericityInterface</span>&lt;P&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在创建泛型类对象时可以决定泛型类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(P p)</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(E e)</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        GenericityInterface&lt;Double&gt; gi = <span class="keyword">new</span> <span class="title class_">Demo2</span>&lt;&gt;();</span><br><span class="line">        gi.run(<span class="number">1.0</span>);</span><br><span class="line">        Demo2&lt;String&gt; demo2 = <span class="keyword">new</span> <span class="title class_">Demo2</span>&lt;&gt;();</span><br><span class="line">        demo2.run(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">//这种操作其实就是List集合中使用List集合创建对象的方式</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Long&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//3.直接使用匿名内部类的形似进行泛型接口上泛型的赋值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">GenericityInterface</span>&lt;Integer&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Integer integer)</span> </span><br><span class="line">            &#123;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(E e)</span> </span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-7-泛型的限定-center"><center>7、泛型的限定</center></h2>
<p>泛型限定其实就是定义泛型可以赋值哪些数据类型，只有满足限定要求的数据类型才可以进行定义赋值操作</p>
<p><strong>泛型通配符【?】</strong></p>
<p>?代表未知，可以作为通配符使用，但是不能作为参数类型单独使用，通配符多用于在泛型限定上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericityDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ? 是一个通配符</span></span><br><span class="line">        List&lt;?&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>); <span class="comment">// 这里是无法确定数据类型，无法单独使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>&lt; ? extends 类&gt; 这是使用途径 此时 ？ 就代表着可以接收extends关键字后的相同类型或子类</strong></p>
<p><strong>&lt; ? super 类&gt; 这是使用途径 此时 ？ 就代表着可以接收super关键字后的相同类型或父类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericityDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供4个List集合对象</span></span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Number&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Object&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//调用泛型的上限操作，即参数类型使用的是List&lt;? extends Number&gt;进行限制</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            泛型限定必须是 Number类型或Number子类</span></span><br><span class="line"><span class="comment">            而list1是Integer类型即Number子类 list3是Number类型即</span></span><br><span class="line"><span class="comment">Number类型所以可以进行传递</span></span><br><span class="line"><span class="comment">            而list2和list4分别是String和Object，既不是Number类型也</span></span><br><span class="line"><span class="comment">不是Number子类，所以无法传递到方法中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        doWork1(list1);</span><br><span class="line">        <span class="comment">//doWork1(list2);</span></span><br><span class="line">        doWork1(list3);</span><br><span class="line">        <span class="comment">//doWork1(list4);</span></span><br><span class="line">        <span class="comment">//调用泛型下限操作，即参数类型使用的是List&lt;? super Number&gt;进行限制</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            泛型限定必须是Number类型或Number父类</span></span><br><span class="line"><span class="comment">            而list1和list2分别是Integer和String，既不是Number类型也不是Number父类，所以无法传递到方法中</span></span><br><span class="line"><span class="comment">            list3和list4 分别是Number和Object 满足了必须是Number类型或Number父类，所以传递到方法中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//doWork2(list1);</span></span><br><span class="line">        <span class="comment">//doWork2(list2);</span></span><br><span class="line">        doWork2(list3);</span><br><span class="line">        doWork2(list4);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//泛型的上限，此时的泛型中?(通配符) 必须是Number的类型或Number子类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doWork1</span><span class="params">(List&lt;? extends Number&gt; list)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//泛型的下限，此时的泛型中?(通配符) 必须是Number的类型或Number父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doWork2</span><span class="params">(List&lt;? <span class="built_in">super</span> Number&gt; list)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-8-特点-center"><center>8、特点</center></h2>
<p>（1）泛型集合在存储元素的时候，支持多态(不推荐使用)</p>
<p>（2）泛型定义的时候，不存在多态</p>
<p>    Collection coll1 = new ArrayList(); err</p>
<p>（3）泛型擦除</p>
<p>    在JDK1.7之后，右边的&lt;&gt;中不需要定义泛型类型</p>
<p>    集合的泛型不能是基本数据类型，要使用它们的包装类</p>
<p>CollectionDemo01类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionDemo01</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型：参数化类型     JKD1.5之后</span></span><br><span class="line"><span class="comment">     * 泛型作用：因为在没有使用泛型之前，向集合中存储实际上是Object类型的数据，所以获取的时候也是Object类型</span></span><br><span class="line"><span class="comment">     *         如果想要使用这个对象，需要发生向下转型，那么在整个集合存储元素的时候，不停的发生向上和向下转型,可能会发生异常</span></span><br><span class="line"><span class="comment">     * 泛型的好处：类型转换的操作提前到了编译器</span></span><br><span class="line"><span class="comment">     *泛型特点：</span></span><br><span class="line"><span class="comment">     *      泛型集合在存储元素的时候，支持多态(不推荐使用)</span></span><br><span class="line"><span class="comment">     *      泛型定义的时候，不存在多态</span></span><br><span class="line"><span class="comment">     *         Collection&lt;Person&gt; coll1 = new ArrayList&lt;Student&gt;(); err</span></span><br><span class="line"><span class="comment">     *      泛型擦除</span></span><br><span class="line"><span class="comment">     *          在JDK1.7之后，右边的&lt;&gt;中不需要定义泛型类型</span></span><br><span class="line"><span class="comment">     *      集合的泛型不能是基本数据类型，要使用它们的包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        Collection coll = new ArrayList();</span></span><br><span class="line"><span class="comment">//        coll.add(new Student(&quot;jack&quot;,28));</span></span><br><span class="line"><span class="comment">//        coll.add(new Student(&quot;尼古拉斯&quot;,23));</span></span><br><span class="line"><span class="comment">//        coll.add(new Teacher(&quot;rose&quot;,32));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //遍历集合  迭代器</span></span><br><span class="line"><span class="comment">//        Iterator it = coll.iterator();</span></span><br><span class="line"><span class="comment">//        while (it.hasNext())</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            //没有向下转型时时Object类</span></span><br><span class="line"><span class="comment">//            //System.out.println(it.next().play());</span></span><br><span class="line"><span class="comment">//            Object obj = it.next();</span></span><br><span class="line"><span class="comment">//            Student stu = (Student) obj;</span></span><br><span class="line"><span class="comment">//            stu.play();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        Collection&lt;Student&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;niu&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        Iterator&lt;Student&gt; it = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> it.next();</span><br><span class="line">            student.play();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//泛型集合在存储元素的时候，支持多态</span></span><br><span class="line">        Collection&lt;Person&gt; coll1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        coll1.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        coll1.add(<span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;sdf&quot;</span>,<span class="number">34</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不能用基本数据类型</span></span><br><span class="line">        <span class="comment">//Collection&lt;int&gt; coll2 = new ArrayList&lt;&gt;();</span></span><br><span class="line">        Collection&lt;Integer&gt; coll3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Person类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Student类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Student类中的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student玩。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Teacher类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Teacher&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点九：Set集合的介绍</center></h1>
<p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291933362.WebP" alt="set集合"></p>
<h1><center>知识点十：Set集合实现类HashSet</center></h1>
<p>HashSet集合是Set集合主要实现类，也是日常开发使用最常用Set集合实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span> <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>
<p>HashSet集合继承了Set集合的特点，向hashSet集合中存储数据时，是不允许出现重复数据，如果有存储重复数据HashSet集合会进行自动排重操作，<strong>HashSet集合的主要实现数据结构“Hash表”</strong>,存储数据顺序是无序，<strong>通过观察API文档发现HashSet集合的所有方法都是Set集合接口提供，本身没有任何特殊方法</strong></p>
<p>特点:</p>
<ul>
<li>无序 （插入顺序）</li>
<li>无下标</li>
<li>不可重复</li>
</ul>
<h2 id="center-1-hash表-center"><center>1、Hash表</center></h2>
<p><strong>什么是hash表？</strong></p>
<p>    Hash 一般被翻译为“散列”，也可以直接音译为“哈希”，它是基于【快速存取的角度而设计的一种存储结构】，而且是一个典型【空间换时间】的做法，利用Hash表的原理进行数据存储操作</p>
<p>    Hash表其实就是【“数组+链表”】的组合形式，在Hash表数组起到作用提供存储位置，在Hash表链表起到作用提供数据存储结构</p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291936873.WebP" alt="Hash表" style="zoom:50%;">
<p>上图中是典型Hash表的结构，Hash表也别称之为【散列表(Hashtable)】，Hash表是根据键值对（Key-value）而直接进行访问的数据结构，也就是说【通过把key值映射到表中一个位置来记录访问位置】，以加快查找数据（这个操作就是确定数据在Hash表中存储的位置），这个操作也被称之为【散列函数】，通过散列函数计算出存储位置会后，会将存储数据以链表形似挂载在存储位置中，这种方式成为【桶】如果存储70个元素，但是存储70个元素时申请100个空间，70/100 = 0.7 ，这个0.7这个值就称之为“负载（加载）因子”，通过这个因子对hash表进行扩容操作</p>
<p>因为Hash表是基于【快速存取】的操作，所以Hash表会尽量的平均将数据分配到Hash表中进行存储，但是在存储过程中就会触发，在同一个存储空间中出现重复数据问题，此时Hash就会启动自动排重操作，原则就是equals比较，只要equals比较结果为true，就不在这个空间存储相同数据</p>
<p>假如：向上面Hash表中存储12这个数据如果进行存储计算</p>
<p>第一步：通过散列函数计算12需要存储的位置 --》hash(key)%len【散列函数】</p>
<p>hash(key) —》 key 是要存储数据 hash(key) —》<strong>计算key的hash值即Java中hashcode值</strong></p>
<p>len —》其实就是存储Hash表中数组长度，上图中数组长度为16所以散列函数计算效果</p>
<p>hash(12) % 16 —》 12%16 ----》 余数12 ，利用12这个值去数组中提供存储位置对别查找存</p>
<p><strong>Hash表的扩容机制？</strong></p>
<p>    Hash表示一个自动扩容机制，<strong>当达到【加载因子】参数要求时，Hash表就会进行自动扩容</strong></p>
<p>    Java中使用<strong>Hash表默认大小给16，加载因子0.75</strong>当16个存储位置发生了75%位置都存储了数据即16*0.75 = 12，也就说12个下标位置中都存储数据，Hash表就会发生自动扩容，扩容机制就以2的幂次进行扩容【16是2^4】扩容之后2^5即hash表每次扩容之后都是原有容量一倍，就会从原有16扩容到32</p>
<p>    在介绍HashSet时说过HashSet中存储数据不能保证存储位置永久不变，只要Hash表发生一次扩容，那么Hash表中存储的数据就要重新计算存储位置</p>
<p>原始数据28 存储在大小为16的hash表中 计算位置 28%16 --》 余数12</p>
<p>一旦扩容大小从16变成32 此时原始数据28可就要重新计算存储位置</p>
<p>在hash表 计算位置 28%32 —》 余数 28</p>
<p><strong>总结：Hash表数据存储和查找是非常优秀，但是一旦扩容就会降低Hash表的性能</strong></p>
<h2 id="center-2-hashset基本使用-center"><center>2、HashSet基本使用</center></h2>
<h3 id="1-语法">(1）语法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet&lt;泛型&gt; 变量名 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>HashSet是实现Set集合接口，查看API时可以发现HashSet中并没有任何特殊方法，所以知己使用Set接口提供方法就完成HashSet集合操作【<strong>HashSet集合中操作方法方式和ArrayList集合中介绍方式是一样的，只不过HashSet带有排重的效果，可以完全参考ArrayList集合中API使用在HashSet中进行使用</strong>】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetAPI</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建HashSet集合对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            表面上代码操作是在创建一个HashSet集合，但是实际底层操作过程中是在创建HashMap集合</span></span><br><span class="line"><span class="comment">            向HashSet集合存储的数据其实就是在想HashMap中key的位置存储</span></span><br><span class="line"><span class="comment">数据，为什么要这样会做</span></span><br><span class="line"><span class="comment">            Hash表存储数据值是以【key-value】进行数据存储操作 --》</span></span><br><span class="line"><span class="comment">Java集合中可以提供Key-value形式存储只有Map集合</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//1.提供一个空的HashSet集合对象【默认容量16,加载因子0.75】</span></span><br><span class="line">        HashSet&lt;Integer&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//PS：HashSet是Set集合的实现类，也就相当于是Set集合&quot;子类&quot;</span></span><br><span class="line">        <span class="comment">//利用Set集合接口使用多态形式创建Set集合对象</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.可以利用参数Collection集合对象中存储数据初始化HashSet集合对象</span></span><br><span class="line">        HashSet&lt;Integer&gt; hashSet1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;</span><br><span class="line">(hashSet);</span><br><span class="line">        <span class="comment">//3.指定HashSet集合初始化容量大小【使用默认加载因子0.75】</span></span><br><span class="line">        <span class="comment">//遵守大小原则是2次幂来定义的，但是不要小于16</span></span><br><span class="line">        HashSet&lt;Double&gt; hashSet2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;</span><br><span class="line">(((<span class="type">int</span>)Math.pow(<span class="number">2</span>,<span class="number">5</span>)));    <span class="comment">//2的5次幂(double类型)强转int</span></span><br><span class="line">        <span class="comment">//4.指定HashSet集合初始化容量大小和加载因子 第二参数加载因子是float类型</span></span><br><span class="line">        HashSet&lt;Character&gt; hashSet3 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt; (((<span class="type">int</span>)Math.pow(<span class="number">2</span>,<span class="number">5</span>)),<span class="number">0.85f</span>);</span><br><span class="line">        <span class="comment">//常用API</span></span><br><span class="line">        <span class="comment">//向集合中添加数据</span></span><br><span class="line">        hashSet.add(<span class="number">1</span>);</span><br><span class="line">        hashSet.add(<span class="number">20</span>);</span><br><span class="line">        hashSet.add(<span class="number">4</span>);</span><br><span class="line">        hashSet.add(<span class="number">9</span>);</span><br><span class="line">        hashSet.add(<span class="number">7</span>);</span><br><span class="line">        hashSet.add(<span class="number">17</span>);</span><br><span class="line">        <span class="comment">//hashSet是可以对存储在集合数据提供排重操作的</span></span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将参数集合对象中数据存储到当前HashSet中</span></span><br><span class="line">        <span class="comment">//addAll(Collection集合对象); </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//清空HashSet集合中数据</span></span><br><span class="line">        <span class="comment">//hashSet.clear();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断HashSet集合是否为空【指没有任何数据，而不是当前hashset地址为null】</span></span><br><span class="line">        <span class="comment">//isEmpty();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断HashSet集合中是否存在指定元素</span></span><br><span class="line">        <span class="keyword">if</span>(hashSet.contains(<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;返回true证明存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;返回false证明不存在&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//containsAll(Collection集合对象) 判断Collection集合对象中个存储数据是否存在在Hashset集合对象中</span></span><br><span class="line">        <span class="comment">//因为HashSet不存在下标的概念所以HashSet是不支持普通for循环的</span></span><br><span class="line">        <span class="comment">//HashSet支持循环方式有</span></span><br><span class="line">        <span class="comment">// 增强for循环</span></span><br><span class="line">        <span class="keyword">for</span>(Integer integer : hashSet)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(integer);</span><br><span class="line">            <span class="comment">//不要调用集合删除方法</span></span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// foreach方法</span></span><br><span class="line">        hashSet.forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//普通迭代器(HashSet集合只支持普通迭代器，不支持增强迭代器即listIterator)</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = hashSet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">            <span class="comment">//删除数据就调用 迭代器中remove</span></span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除集合中数据 参数是要删除的数据</span></span><br><span class="line">        hashSet.remove(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//删除参数结合提供提供数据所在HashSet集合对象中数据</span></span><br><span class="line">        <span class="comment">//removeAll(Collection集合对象);</span></span><br><span class="line">        <span class="comment">//保留参数集合对象中数据在HashSet集合中然后删除剩余HashSet集合中数据</span></span><br><span class="line">        <span class="comment">//retainAll(Collection集合对象);</span></span><br><span class="line">        hashSet.removeIf(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Integer&gt;() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Integer integer)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> integer%<span class="number">2</span> ==<span class="number">0</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        hashSet.removeIf(integer -&gt; integer%<span class="number">2</span> ==<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取集合中存储元素的个数</span></span><br><span class="line">        System.out.println(hashSet.size());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//转换成数组</span></span><br><span class="line">        Object[] objects = hashSet.toArray();</span><br><span class="line">        Integer[] integers = hashSet.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[hashSet.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-hashset集合的排重操作">(2)HashSet集合的排重操作</h3>
<p>需求:创建一个Person对象，提供属性名字和年龄【按照标准JavaBean提供，提供toString重写】在提供PersonTest类型在类中创建两个Person对象，赋值为张三，18，存储在HashSet集合中，然后打印集合中数据，查看是否排重？如果没有排重如何处理？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        HashSet&lt;Person&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        <span class="comment">//利用HashSet中存储机制【Hash表】可以存储重复数据进行排重操作</span></span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line">        HashSet&lt;Integer&gt; hashSet1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet1.add(<span class="number">1</span>);</span><br><span class="line">        hashSet1.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(hashSet1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashSet底层实现是什么？—》</p>
<p>使用Hash表实现的，Hash表示如何进行数据存储的？ —》</p>
<p>使用Hash表提供散列函数，散列函数是什么？ —》</p>
<p>这是散列函数 hash(key)%len， hash(key)得到结果什么？len得到结果什么？ —》</p>
<p><strong>hash(key)计算存储数据所在内存中hashcoded地址值</strong></p>
<p>len是Hash表中容量的大小，默认是16 —》</p>
<p>利用散列函数【 hash(key)%len】 求得存储在Hash表中位置以进行数据的存储</p>
<p>Hash表的排重机制是：通过散列函数计算出数据存储的位置进行数据存储，如果出现同一个数据计算出位置相同，此时也会向存储位置进行插入存储，但是要进行equals比较，如果equals 比较结果为false就整存储位置中，没有与之相同数据，以链表存储，如果equals比较结果为true，证明这个存储位置有与之相同数据，此时就会放弃新添加的数据存，从而不会进行存储数据操作，那么些就是HashSet即Hash表排重机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        HashSet&lt;Person&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        hashSet.add(p1);</span><br><span class="line">        hashSet.add(p2);</span><br><span class="line">        System.out.println(<span class="string">&quot;p1对象的hashcode值：&quot;</span>+ p1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;p2对象的hashcode值:&quot;</span>+ p2.hashCode());</span><br><span class="line">        <span class="comment">//利用HashSet中存储机制【Hash表】可以存储重复数据进行排重操作</span></span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line">        HashSet&lt;Integer&gt; hashSet1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet1.add(<span class="number">1</span>);</span><br><span class="line">        hashSet1.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(hashSet1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么存储自定类的对象到HashSet集合没有进行排重？</p>
<p>就是因为自动以类并没对对象提供同一个hashcode的实现并且在Person类中也没有一共equals方法的实现，所以我们根本没有提供排重操作的原则，所以向HashSet中存储自定义类的对象是无法排重</p>
<p><strong>如果需要向HashSet集合存储自定义类的对象并提供排重机制，那么自定义类必须提供equals和hashcode方法的重写</strong></p>
<p>从写hashcode的目的在于：</p>
<ol>
<li>在Java中认为两个对象相等是通过equals方决定，决定原则在于类中提供属性完全或部分相等，认为两个对象相等，既然两个对象已经相等了，那么他们的地址也要相等，但是Java语言是无法直接操作真实内存地址的，但是我们可以获取到真实内存地址映射hashcode值，所以将equals比较相等对象的hashcode修改为相等就间接的满足【真实内存地址相等】</li>
<li>当向HashSet集合存储数据时候，HashSet集合底层实现是Hash表，而Hash表有需要通过hashcode计算存数据位置，只有在hash表存储位置相同才可能出现相同数据，这样一来就需要提供相同对象hashcode地址是相同的，通过这个方法将对象计算到同一个存储位置，在通过equals方法计算相等操作触发Hash表排重机制</li>
</ol>
<p>综上所述：对Person这类提供equals和hashcode的重写操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Objects;</span><br><span class="line">public class Person </span><br><span class="line">&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public Person() </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    public Person(String name, int age) </span><br><span class="line">    &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    public String getName() </span><br><span class="line">    &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125; </span><br><span class="line">    public void setName(String name) </span><br><span class="line">    &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    public int getAge() </span><br><span class="line">    &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125; </span><br><span class="line">    public void setAge(int age) </span><br><span class="line">    &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() </span><br><span class="line">    &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">        &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">        &quot;, age=&quot; + age +</span><br><span class="line">        &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">        IDEA编译器提供两个版本的equals和hashcode的重写</span><br><span class="line">        这两个版本都是可以，只能二选一不能共存</span><br><span class="line">    */    </span><br><span class="line">    </span><br><span class="line">    //这个版本IDEA默认版本</span><br><span class="line">    /*</span><br><span class="line">        生成equals和hashcode方法是最后选项中有一个non-null</span><br><span class="line">        这里不建议勾选这个选中给提供属性，因为引用类型还是进行非null判断</span><br><span class="line">        如果你勾选在那么系统就默认认为引用类型时为null值</span><br><span class="line">        就会使用这个引用类型方法，如果此时你引用类型属性被赋值null，必</span><br><span class="line">出空指针异常</span><br><span class="line">    */</span><br><span class="line">    //勾选之后 non-null选项之后提供 equals实现</span><br><span class="line">    /* </span><br><span class="line">        @Override</span><br><span class="line">        public boolean equals(Object o) </span><br><span class="line">        &#123;</span><br><span class="line">            if (this == o) return true;</span><br><span class="line">            if (o == null || getClass() != o.getClass())</span><br><span class="line">            return false;</span><br><span class="line">            Person person = (Person) o;</span><br><span class="line">            if (age != person.age) return false;</span><br><span class="line">            return name.equals(person.name);</span><br><span class="line">        &#125;</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    //没有勾选 non-null选项之后提供 equals实现</span><br><span class="line">    /* </span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) </span><br><span class="line">    &#123;</span><br><span class="line">        //比较了地址，这个地址是真实地址，如果真实地址都相等 必然是同一个对象</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        */</span><br><span class="line">        /*</span><br><span class="line">            如果输入对象引用地址null那么 必然对象不同一个</span><br><span class="line">getClass方法的作用是用过字节码文件[.class]文件进行对象获</span><br><span class="line">取</span><br><span class="line">            只要是同一个类创建对象，他们字节码文件都是同一个【唯一】</span><br><span class="line">            两个对象字节码文件都不一样必然不是同一个对象</span><br><span class="line">        */</span><br><span class="line">        /*</span><br><span class="line">            if (o == null || getClass() != o.getClass())</span><br><span class="line">            return false;</span><br><span class="line">            //多态向下转型操作</span><br><span class="line">            Person person = (Person) o;</span><br><span class="line">        */        </span><br><span class="line">        //如果当前对象age属性与传入对象的age属性不一致 返回false，</span><br><span class="line">如果相等就不做任何操作</span><br><span class="line">        /*</span><br><span class="line">        if (age != person.age) return false;</span><br><span class="line">        */</span><br><span class="line">        /*</span><br><span class="line">        提供引用类型非null判断</span><br><span class="line">		只要当前对象的name属性值不为null 就通过name调用String类</span><br><span class="line">		equals方法</span><br><span class="line">        与传入对象name进行比较 相等为true，不相等为false</span><br><span class="line">        如果对象的name属性为null 就判断传入对象的name属性是否为null</span><br><span class="line">        如果也为null 结果就是true 否则就是false</span><br><span class="line">        */</span><br><span class="line">        /*</span><br><span class="line">        return name != null ? name.equals(person.name) :</span><br><span class="line">        person.name == null;</span><br><span class="line">    &#125; </span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() </span><br><span class="line">    &#123;</span><br><span class="line">        //获取引用类hashcode值作为新的hashcode值计算</span><br><span class="line">        int result = name != null ? name.hashCode() : 0;</span><br><span class="line">        //使用31这个值 乘以 引用类型hashcode值 然后加上 值类型属性值 得到最终hashcode</span><br><span class="line">        //最大的限度保证hashcode不出现重复</span><br><span class="line">        result = 31 * result + age;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    //这个版本IDEA使用Java7中提供Objects工具类</span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) </span><br><span class="line">    &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (o == null || getClass() != o.getClass())</span><br><span class="line">        return false;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        /*</span><br><span class="line">            变化现在使用:值类型比较融入到返回值比较结果中</span><br><span class="line">            调用了Objects工具类中equals方法进行 引用类型比较 --》原码实现</span><br><span class="line">            public static boolean equals(Object a, Object b)</span><br><span class="line">            &#123;</span><br><span class="line">            地址相等就是同一个对象或者判断 a 参数不为null 然后用a调用equals进行比较</span><br><span class="line">            return (a == b) || (a != null &amp;&amp; a.equals(b));</span><br><span class="line">            &#125; </span><br><span class="line">        */</span><br><span class="line">        return age == person.age &amp;&amp;</span><br><span class="line"> Objects.equals(name, person.name);</span><br><span class="line">    &#125; </span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() </span><br><span class="line">    &#123;</span><br><span class="line">        /*</span><br><span class="line">        Objects工具类中提供 hash方法 这个方法可以计算新的hashcode值</span><br><span class="line">        */</span><br><span class="line">        return Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-底层原理">(3)底层原理</h3>
<p>HashSet底层实现原理是HashMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet.add(<span class="number">3</span>);</span><br><span class="line">        hashSet.add(<span class="number">2</span>);</span><br><span class="line">        hashSet.add(<span class="number">1</span>);</span><br><span class="line">        hashSet.add(<span class="number">4</span>);</span><br><span class="line">        hashSet.add(<span class="number">4</span>);</span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//HashSet没有特殊方法，它的方法与Collection中学的方法是一致的</span></span><br><span class="line">        <span class="comment">//Set集合的遍历方式(迭代器)</span></span><br><span class="line">        Iterator&lt;Integer&gt; it = hashSet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//foreach遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Integer integer :</span><br><span class="line">                hashSet)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(integer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//HashSet的底层实现原理：HashSet底层实现原理是HashMap</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十一：LinkedHashSet类</center></h1>
<p>特点：</p>
<ul>
<li>有序</li>
<li>无下标</li>
<li>不可重复</li>
</ul>
<p>与父类的方法(HashSet)一致,去重的原理，也与父类一致</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSetDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 特点：</span></span><br><span class="line"><span class="comment">     *     1、有序（插入顺序）</span></span><br><span class="line"><span class="comment">     *     2、不重复</span></span><br><span class="line"><span class="comment">     *     3、无下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        LinkedHashSet&lt;String&gt; linkedHashSet = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        System.out.println(linkedHashSet);</span><br><span class="line">        <span class="comment">//1、底层实现 (LinkedHashMap)</span></span><br><span class="line">        <span class="comment">//2、去重原理 (与hashSet一致)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十二：Set集合实现类TreeSet</center></h1>
<p>TreeSet是Set集合接口实现类之一，它是一个特殊集合【这个集合不仅可以排重而且可以对存储到集合中的数据提供升序排序】，在以往开发中可以利用TreeSet这个特性对需要排序数据进行操作</p>
<p>PS：从Java8开始List集合专门提供方法sort方法，List集合也可以调用集合提供Sort方法进行对数据排序操作，但是不能排重，所以学习TreeSet的目的为类接触可以排序接口</p>
<p>在API文档中有说明：基于 TreeMap 的 NavigableSet 实现。使用元素的 自然顺序Comparable 对元素进行排序，或者根据创建 set 时提供的 自定义排序Comparator 进行排序，具体取决于使用的构造方法</p>
<p>Set集合系列主要实现都是依赖于Map集合，HashSet底层实现是HashMap，TreeSet底层实现是TreeMap，在Java8之前TreeSet底层实现的结构【二叉树+Hash表】，从Java8开始之后将底层实现的结构【红黑树+Hash表】</p>
<p>TreeSet中的使用API可以完全参考Set集合即可，其余API文档中提供方法自行查看</p>
<p>提供一个基础的TreeSet使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//向TreeSet中存储系统提供数据类型</span></span><br><span class="line">        TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        set.add(<span class="number">100</span>);</span><br><span class="line">        set.add(<span class="number">20</span>);</span><br><span class="line">        set.add(<span class="number">17</span>);</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        set.add(<span class="number">6</span>);</span><br><span class="line">        set.add(<span class="number">88</span>);</span><br><span class="line">        set.add(<span class="number">66</span>);</span><br><span class="line">        set.add(<span class="number">33</span>);</span><br><span class="line">        set.add(<span class="number">77</span>);</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//存储数据中提供两个1进行存储 ---》 自动排重和排序操作【默认是升序】</span></span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向TreeSet中存储自定义类的对象Student，根据学生年龄进行排序操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> height, <span class="type">int</span></span></span><br><span class="line"><span class="params"> weight)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">int</span> height)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">int</span> weight)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">        <span class="string">&quot;, height=&quot;</span> + height +</span><br><span class="line">        <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供TreeSet集合对象用于存储Student类的对象</span></span><br><span class="line">        TreeSet&lt;Student&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">178</span>,<span class="number">100</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>,<span class="number">181</span>,<span class="number">200</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">16</span>,<span class="number">200</span>,<span class="number">10</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;赵六&quot;</span>,<span class="number">19</span>,<span class="number">145</span>,<span class="number">150</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;田七&quot;</span>,<span class="number">21</span>,<span class="number">190</span>,<span class="number">160</span>));</span><br><span class="line">        System.out.println(treeSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题：使用TreeSet存储系统提供数据类型时，可以对数据进行排重与排序操作，但是向TreeSet中添加自定义类对象时，并没有进行排重排序操作，出现了一个异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException:com.qfedu.TreeSet.</span><br><span class="line">    Student cannot be cast tojava.lang.Comparable</span><br></pre></td></tr></table></figure>
<p>问题原因所在：当用TreeSet的无参构造方法时创建Set集合对象，【该 set 根据其元素的自然顺序进行排序。插入该 set 的所有元素都必须实现 Comparable 接口】，刚刚插入到TreeSet集合中Student类的对象并没有实现Comparable接口，所以出现ClassCastException</p>
<h1><center>知识点十三：Comparable接口【自然排序接口】</center></h1>
<p>官方文档说明:此接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 compareTo 方法被称为它的自然比较方法,【间接的说明Comparable接口是一个自然排序接口，对与实现接口类会提供排序操作，这个排序操作需要完成compareTo这个方法】</p>
<p>当前调用TreeSet集合的无参构造方法时，就要求向TreeSet中存储的数据必须实现Comparbale</p>
<p>实现Comparbale接口就需要实现接口中给提供方法</p>
<table>
<thead>
<tr>
<th>int</th>
<th>compareTo(T o) 比较此对象与指定对象的顺序</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>compareTo这个方法使用接口上泛型作为方法参数泛型，所以在实现Comparable的时候需要指定接口中泛型是什么类型，这样可以避免不必要向下转型，泛型T如何赋值，Comparbale提供谁进行比较这个类型就是谁Comparable提供compareTo方法对数据进行比较时遵守的原则 比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。compareTo这个方法的返回值类型时int类型，这个方法返回值是一个数字</td>
</tr>
</tbody>
</table>
<p>PS：compareTo这个方法不建议理解为比较方法，理解为交换方法即通过这个方法的得到返回值决定如何进行数据交换【存储】</p>
<p>之前有接触过一些排序的操作，例如冒泡、选择这些手写排序，但是这些排序中都会有一个必要的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提供比较操作，进行数据交换</span></span><br><span class="line"><span class="keyword">if</span>(arr[i] &gt; arr[i+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[i+<span class="number">1</span>];</span><br><span class="line">    arr[i+<span class="number">1</span>] = tmp;</span><br><span class="line">&#125; </span><br><span class="line">-------------------------------------</span><br><span class="line"><span class="keyword">if</span>(arr[i] &lt; arr[i+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[i+<span class="number">1</span>];</span><br><span class="line">    arr[i+<span class="number">1</span>] = tmp;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//通过修改比较操作中 大于号 或 小于号 可以决定 排序顺序</span></span><br><span class="line"><span class="comment">//那么Comparable接口中compareTo得到的int类型数值就是决定数据如何排序</span></span><br></pre></td></tr></table></figure>
<p>需要对CompareTo方法进行深入的理解【万能公式】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;CompareTo这方法会返回三个值 正整数、 负整数 和 0&quot;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    一般来说自定义类中提供比较属性基本上都是系统类型，就可以通过两个数</span></span><br><span class="line"><span class="comment">据之间记性“差值计算”从而得到 正整数、 负整数 和 0</span></span><br><span class="line"><span class="comment">    Student类为例 需要比较是年龄 --》年龄的属性是 int类型</span></span><br><span class="line"><span class="comment">    用两个int类型进行相减 得到结果就是 正整数、 负整数 和 0 正好满</span></span><br><span class="line"><span class="comment">足了CompareTo方法需求</span></span><br><span class="line"><span class="comment">    谁减谁可以得到什么结果，如果不是基本数据类型时引用类型减也不能计</span></span><br><span class="line"><span class="comment">算？</span></span><br><span class="line"><span class="comment">    不用担心引用类型问题，基本上能用来比较的引用类型都实现了</span></span><br><span class="line"><span class="comment">Comparable，</span></span><br><span class="line"><span class="comment">    所以比较引用类型调用这个引用类型中对应CompareTo方</span></span><br><span class="line"><span class="comment">法就可以</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="string">&quot;需要区分当前对象和传入对象&quot;</span></span><br><span class="line"><span class="string">&quot;调用CompareTo方法的就是当前对象使用【this表示】&quot;</span></span><br><span class="line"><span class="string">&quot;对CmpareTo方法参数赋值的就是传入对象使用【other表示】&quot;</span></span><br><span class="line"><span class="string">&quot;由此就可以得到一个万能公式：</span></span><br><span class="line"><span class="string">&quot;</span>当前对象 - 传入对象 【得到排序结果就是升序】<span class="string">&quot; ---》 正整数</span></span><br><span class="line"><span class="string">&quot;</span>传入对象 - 当前对象 【得到排序结果就是降序】<span class="string">&quot; ---》 负整数</span></span><br><span class="line"><span class="string">&quot;</span>切记：TreeSet的排重机制并不是equals和HashCode，而是实现排序</span><br><span class="line">接口中CompareTo或Compare方法的返回值，只要返回值为<span class="number">0</span>，TreeSet</span><br><span class="line">就会认为是同一个对象，进行排重操作<span class="string">&quot;</span></span><br><span class="line"><span class="string">//当前使用万能公式做计算时，如果遇到得到0时，出现排重效果，建议在得到0时在提供一个排序条件操作，或者使用List中sort方法排序</span></span><br><span class="line"><span class="string">使用这个公式进行排序时会面临到问题：</span></span><br><span class="line"><span class="string">问题1：此时排序数据类型时自定义类Student</span></span><br><span class="line"><span class="string">我们是不能使用 Student - Student 也不可能</span></span><br><span class="line"><span class="string">Student.CompareTo(Student)</span></span><br><span class="line"><span class="string">对自定义对象排序时，排序时*自定义对象的属性*，将当前公式变形为</span></span><br><span class="line"><span class="string">&quot;</span>当前对象.属性 - 传入对象.属性 【得到排序结果就是升序】<span class="string">&quot; ---》正整数</span></span><br><span class="line"><span class="string">&quot;</span>传入对象.属性 - 当前对象.属性 【得到排序结果就是降序】<span class="string">&quot; ---》负整数</span></span><br><span class="line"><span class="string">问题2：此时排序数据类型时系统类型Integer</span></span><br><span class="line"><span class="string">&quot;</span>当前对象 - 传入对象 【得到排序结果就是升序】<span class="string">&quot; ---》 正整数</span></span><br><span class="line"><span class="string">&quot;</span>传入对象 - 当前对象 【得到排序结果就是降序】<span class="string">&quot; ---》 负整数</span></span><br><span class="line"><span class="string">问题3: 如果遇到是引用类型无法使用减号进行计算时</span></span><br><span class="line"><span class="string">&quot;</span>当前对象.compareTo(传入对象) 【得到排序结果就是升序】<span class="string">&quot; ---》正整数</span></span><br><span class="line"><span class="string">&quot;</span>传入对象.compareTo(当前对象) 【得到排序结果就是降序】<span class="string">&quot; ---》负整数</span></span><br></pre></td></tr></table></figure>
<p>修改Student类进行年龄属性排序操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> height, <span class="type">int</span> weight)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125; </span><br><span class="line">    p</span><br><span class="line">ublic <span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">int</span> height)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125; </span><br><span class="line">    p</span><br><span class="line">ublic <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">int</span> weight)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">        <span class="string">&quot;, height=&quot;</span> + height +</span><br><span class="line">        <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student other)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//比较的是student类中age属性值 [升序排序]</span></span><br><span class="line">        <span class="comment">//return this.age - other.age;</span></span><br><span class="line">        <span class="comment">//比较的是student类中age属性值 [降序排序]</span></span><br><span class="line">        <span class="comment">//return other.age - this.age;</span></span><br><span class="line">        <span class="comment">//防止出现比较结果为0的时候怎么办？ ---&gt; 在提供一个比较数据即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age - other.age == <span class="number">0</span> ? <span class="built_in">this</span>.height - other.height : <span class="built_in">this</span>.age - other.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十四：Comparator接口【自定义排序接口】</center></h1>
<p>除了TreeSet集合中可以使用Comparable接口进行自然排序之外，还有一个更加灵活方便的接口Comparator，在系统API文档中说明：强行对某个对象 collection 进行整体排序 的比较函数。可以将Comparator 传递给 sort 方法（如 Collections.sort 或Arrays.sort ），从而允许在排序顺序上实现精确控制。还可以使用Comparator 来控制某些数据结构（如 有序 set 或 有序映射）的顺序，或者为那些没有 自然顺序的对象 collection 提供排序</p>
<p><strong>综上所述：Comparator接口不仅可以对TreeSet提供排序操作，而且可以针对Java系统API提供sort方法进行自定义排序操作</strong></p>
<p>Comparator接口中的核心比较方法</p>
<table>
<thead>
<tr>
<th>int</th>
<th>compare(T o1, T o2) 比较用来排序的两个参数</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>compare这个方法和Comparable接口中compareTo方法是一个道理也是返回 正整数、负整数和0 代表对象 大于 小于和等于</td>
</tr>
</tbody>
</table>
<p>刚刚在Comparable中提供万能公式可以直接使用在Comparator</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">这里是需要注意的是：</span></span><br><span class="line"><span class="string">&quot;</span>Comparator接口中compare方法有两个参数,两个参数谁是当前对象，谁是传入对象<span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span>compare方法中第一个参数 即 o1 就是当前对象即<span class="built_in">this</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span>compare方法中第二个参数 即 o2 就是传入对象即other<span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span>由此就可以得到一个万能公式：</span><br><span class="line"><span class="string">&quot;当前对象 - 传入对象 【得到排序结果就是升序】&quot;</span> ---》 正整数</span><br><span class="line"><span class="string">&quot;传入对象 - 当前对象 【得到排序结果就是降序】&quot;</span> ---》 负整数</span><br><span class="line"><span class="string">&quot;切记：TreeSet的排重机制并不是equals和HashCode，而是实现排序</span></span><br><span class="line"><span class="string">接口中CompareTo或Compare方法的返回值，</span></span><br><span class="line"><span class="string">只要返回值为0，TreeSet就会认为是同一个对象，进行排重操作&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当前使用功能公式做计算时，如果遇到得到0时，出现排重效果，建议在</span></span><br><span class="line">得到<span class="number">0</span>时在提供一个排序条件操作，或者算着List中sort方法排序</span><br><span class="line">使用这个公式进行排序时会面临到问题：</span><br><span class="line">问题<span class="number">1</span>：此时排序数据类型时自定义类Student</span><br><span class="line">我们是不能使用 Student - Student 也不可能</span><br><span class="line"> Student.CompareTo(Student)</span><br><span class="line">对自定义对象排序时，排序时自定义对象的属性，将当前公式变形为</span><br><span class="line"><span class="string">&quot;当前对象.属性 - 传入对象.属性 【得到排序结果就是升序】&quot;</span> ---》正整数</span><br><span class="line"><span class="string">&quot;传入对象.属性 - 当前对象.属性 【得到排序结果就是降序】&quot;</span> ---》负整数</span><br><span class="line">问题<span class="number">2</span>：此时排序数据类型时系统类型Integer</span><br><span class="line"><span class="string">&quot;当前对象 - 传入对象 【得到排序结果就是升序】&quot;</span> ---》 正整数</span><br><span class="line"><span class="string">&quot;传入对象 - 当前对象 【得到排序结果就是降序】&quot;</span> ---》 负整数</span><br><span class="line">问题<span class="number">3</span>: 如果遇到是引用类型无法使用减号进行计算时</span><br><span class="line"><span class="string">&quot;当前对象.compareTo(传入对象) 【得到排序结果就是升序】&quot;</span> ---》正整数</span><br><span class="line"><span class="string">&quot;传入对象.compareTo(当前对象) 【得到排序结果就是降序】&quot;</span> ---》负整数</span><br></pre></td></tr></table></figure>
<p><strong>复制Student类创建Student2来进行Comparator接口操作</strong></p>
<p>Comparator接口对应的是TreeSet中有参构造方法，所以要使用Comparator进行排序就需要使用当前这个有参构造方法【传入实现Comparator接口的实现类对象】方可进行排序操作</p>
<p><strong>提供两种实现Comparator接口的方式</strong>:</p>
<p>    第一种:提供一个比较原则类实现Comparator接口，实现compare方法定义排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student2</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student2</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> height, <span class="type">int</span> weight)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">int</span> height)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125; </span><br><span class="line">    p</span><br><span class="line">ublic <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">int</span> weight)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">        <span class="string">&quot;, height=&quot;</span> + height +</span><br><span class="line">        <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="comment">//提供一个类实现Comparator接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortGZ</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student2&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student2 o1, Student2 o2)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.getAge()-o1.getAge();</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用TreeSet中具备Comparator接口方法,参数赋值就是实现Comparator接口的对象</span></span><br><span class="line">        TreeSet&lt;Student2&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">SortGZ</span>());</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">178</span>,<span class="number">100</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>,<span class="number">181</span>,<span class="number">200</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">16</span>,<span class="number">200</span>,<span class="number">10</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;赵六&quot;</span>,<span class="number">19</span>,<span class="number">145</span>,<span class="number">150</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;田七&quot;</span>,<span class="number">21</span>,<span class="number">190</span>,<span class="number">160</span>));</span><br><span class="line">        treeSet.forEach(System.out::println);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>    第二种方式：就是使用匿名内部类或者lambda表达式实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest3</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用TreeSet中具备Comparator接口方法,参数赋值就是实现</span></span><br><span class="line">        Comparator接口的对象</span><br><span class="line">        <span class="comment">//匿名内部类版本</span></span><br><span class="line">        TreeSet&lt;Student2&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span></span><br><span class="line">        <span class="title class_">Comparator</span>&lt;Student2&gt;() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student2 o1, Student2 o2)</span> </span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">178</span>,<span class="number">100</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>,<span class="number">181</span>,<span class="number">200</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">16</span>,<span class="number">200</span>,<span class="number">10</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;赵六&quot;</span>,<span class="number">19</span>,<span class="number">145</span>,<span class="number">150</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;田七&quot;</span>,<span class="number">21</span>,<span class="number">190</span>,<span class="number">160</span>));</span><br><span class="line">        treeSet.forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Lambda表达式</span></span><br><span class="line">        TreeSet&lt;Student2&gt; treeSet2 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((o1,o2) -&gt; o2.getAge()-o1.getAge());</span><br><span class="line">        treeSet2.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">178</span>,<span class="number">100</span>));</span><br><span class="line">        treeSet2.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>,<span class="number">181</span>,<span class="number">200</span>));</span><br><span class="line">        treeSet2.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">16</span>,<span class="number">200</span>,<span class="number">10</span>));</span><br><span class="line">        treeSet2.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;赵六&quot;</span>,<span class="number">19</span>,<span class="number">145</span>,<span class="number">150</span>));</span><br><span class="line">        treeSet2.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;田七&quot;</span>,<span class="number">21</span>,<span class="number">190</span>,<span class="number">160</span>));</span><br><span class="line">        treeSet2.forEach(System.out::println);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结comparable和comparator接口">总结Comparable和Comparator接口</h2>
<p>    现在Java而言不仅只有TreeSet能排序，List集合也可以排序，Map集合也可以排序，合理规划使用排序即可，Comparable这个接口值专门针对TreeSet集合进行排序而设计一个接口，它的局限性在于它只适合自定义类存储在TreeSet进行使用，其他位置提供Sort方法是不使用Comparable作为参数，Comparator属于自定义排序接口，使用比较广泛，除了在TreeSet中可以使用之外，List集合中提供Sort和JavaAPI中提供其他Sort方法基本上都是使用Comparator参数类型，所以这两个接口建议优先掌握Comparator接口【使用广泛】，其次Comparable</p>
<h1><center>知识点十五：Set集合总结</center></h1>
<p>Set集合是一个接口继承与Collection接口和Iterable接口,Set集合本身具备排重功能和存储无序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Set</span> &lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p>Set集合集合主要的实现类有HashSet、LinkedHashSet和TreeSet，所以Set集合接口是支持多态创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">Set&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">Set&lt;Integer&gt; set3 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>Set集合中提供可操作集合都是线程不安全，所以面临多线程处理数据的时候</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.synchronizedSet(Set集合的对象); --》将一个Set集合对象变成线程安全集合</span><br></pre></td></tr></table></figure>
<p>除了这种方式之外可以使用Java5开始提供java.util.concurrent包下提供线程集合完全类来进行操作</p>
<p><strong>HashSet它是Set集合主要实现类，也是实际开发中使用比较广泛的一个类</strong>，这个类的主要实现是Hash表，底层实现是创建一个HashMap对象作为HashSet的具体实现，并且向HashSet存储数据时，其实是向HashMap中key值的位置进行数据存储</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//添加数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashSet的默认容量是16，加载因子是0.75，扩容大小是原有一倍</p>
<p>在Java8之前HashSet底层主要实现是Hash表【数组+链表】形式，从Java8开始对底层存储进行优化，提供存储和查询效果将原有Hash表进行优化【数组+链表或红黑树】，向Hash表中如果存储数据，<strong>某个存储位置中链表长度大达到8的时候【存储了8个数据】，就将链表修改为红黑树，从而提高查询效率</strong></p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291950536.WebP" alt="红黑树" style="zoom:50%;">
<p>HashSet存储自定义类对象时，如果需要进行排重操作，需要提供equals和hashcode重写</p>
<p>LinkedHashSet是HashSet子类，本身不具备任何特殊方法，所有都是来源于Set接口，唯一特点就是提供一个链表来记录存储顺序，开发中是几乎与不用，它操作可有完全仿照HashSet</p>
<p>TreeSet 是Set集合中一个排序排重的集合，这个集合使用 红黑树+Hash表，当使用TreeSet的无参构造方法创建对象时，向TreeSet集合存数据，这个存储的数据必须实现Comparable接口，也可使用TreeSet的有参构造方法，方法参数是Comparator类型，实现Comparator接口进行存储数据的自定义排序</p>
<p>PS:不是只有TreeSet才可以排序，List和Map集合都可以进行排序操作，但是这个俩个集合都会使用到Comparator</p>
<h1><center>知识点十六：Collection集合</center></h1>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291950700.WebP" alt="Collection集合" style="zoom:50%;">
<p>Collection集合接口是List和Set集合接口父接口，Collection集合接口继承Iterable接口，所以List和Set集合接口都是支持迭代器操作，因为List和Set集合接口都是Collection集合子接口，所以List和Set集合接口的实现了可以作为Collection集合接口的实现类使用，所以支持多态创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Collection集合接口创建对象</span></span><br><span class="line">Collection &lt;Integer&gt; c1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collection &lt;Integer&gt; c2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">Collection &lt;Integer&gt; c3 = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">Collection &lt;Integer&gt; c4 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">Collection &lt;Integer&gt; c5 = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">Collection &lt;Integer&gt; c6 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>因为Collection是集合接口，所以里面的方法都已经讲解完毕</p>
<p>PS：在实际开发中List集合接口中最常用类是ArrayList，Set集合接口中最常用类是HashSet</p>
<h1><center>知识点十七：Collections工具类</center></h1>
<p>将集合中的元素反转</p>
<p>    Collections.reverse(List list)</p>
<p>将集合中的元素随机打乱</p>
<p>    Collections.shuffle(List list)</p>
<p>将集合中的元素排序 （必须要实现Comparable接口）</p>
<p>    Collections.sort(List list)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;大娃&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;二娃&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;妖怪&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;蛇妖&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;蛇妖&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//按照字典顺序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将集合元素进行翻转</span></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将集合中的元素进行随机打乱</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Arrays数组工具类 Collections集合工具类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十七：Map集合</center></h1>
<p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291953280.WebP" alt="Map集合"></p>
<h2 id="center-1-map集合介绍-center"><center>1、Map集合介绍</center></h2>
<p>    Map集合是两大集合之一和Collection之间是并存关系，Map不是Collection的子类，Map一般会和List和Set这两个集合并称三大集合【List、Set和Map】，因为Map和Collection并没有什么关系，所以Map集合和Iterable接口也没有任何关系，所以Map集合是不提供迭代器操作</p>
<p>    Map集合在Java提供一种存储数据方式，这种方式称之为“映射”【keyvalue键值对】，通过映射这种关系将将两个数据进行相连形成数据存储形式就是key-value键值对</p>
<p>PS：key和value值不要过分纠结，只要提供Map存储数据数据类型就可以决定key值存储什么value值存储什么，他们在底层存储形式是以一种键值对相连的【情侣】</p>
<p>    映射的说明: 在数学中假设A，B两个非空集合，如果存在一个法则F，使用A集合中每一个元素按照法则F在B集合中有一个唯一对应，则成F为A到B集合映射关系</p>
<p>在做映射关系时：</p>
<p>    提供key值要求是唯一的 ，A集合中相当于存储Key而<strong>Key是唯一</strong>的，所以可以想象存储key的集合其实就是Set集合提供vlaue值是可以不唯一的，B集合相当于存储Value而<strong>value是不唯一的</strong>，所以可以想象存储value的集合其实就是List集合</p>
<p>提供一个链接法则【链接原则】 让A集合key可以和B集合中value进行一个链接形成一个键值对，Map提供存储方式就是这个方法Entry(key-value),Map中存储大量Entry实体存储就是相当与键值对存储了</p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291954387.WebP" alt="介绍" style="zoom:50%;">
<h2 id="center-2-map集合主要实现类hashmap-center"><center>2、Map集合主要实现类HashMap</center></h2>
<p>HashMap与Map接口之间关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>
<p>    HashMap的主要实现接就是Map，HashMap也是Map接口的最主要实现类HashMap在官方文档中说明：基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外， HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变</p>
<p>    说明：HashMap的主要实现使用Hash表，但是在Java7之前使用的是原始Hash表的形式即【数组+链表】形式存储数据，但是从Java8开始HashMap集合提供Hash表实现从【数组+链表】转换为【数组+链表或红黑树】，当前向HashMap中某个“桶节点【即存储位置】”，添加的数据达到8个时，就会将链表结构转换红黑树，8这个数字在链表中的查询效果是可以控制，因为链表的查询方式是线性查询【从前之后】，所以最快效率是1，最慢效率N，平均值(1+N)/2,随着N值不断变大，这个查询效率会逐渐降低，所以在8节点时将链表转换为红黑树，就是为提高查询效率而是用，红黑树是平衡树，而且树的查询效率是【2倍效率】</p>
<p>HashMap集合是线程不安全集合，在多线程前提现可以使用</p>
<p>Hashtable【之前做法】，现在开发不在使用Hashtable，如何解决线程不安全问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>()); ---&gt; 得到一个线程安全集合或者</span><br><span class="line">                                                    使用线程安全Map集合---》ConcurrentHashMap集合</span><br></pre></td></tr></table></figure>
<p>HashMap是存储key-value键值对形式集合，所以创建HashMap对象时需要提供Key和Value的泛型的数据类型，HashMap毕竟底层是Hash表所以在Java中初始容量16,加载因子0.75，扩容方式是原有容量2倍，并且会重新计算所有存储在HashMap中数据存储位置即从新计算key的存储位置</p>
<p>HashMap在Java8之前和Java8之后API有很大的变化，将Java8之前API看做是基础API，将Java8提供API看做增强操作API即可</p>
<h2 id="center-3-hashmap常用方法-java8之前-center"><center>3、HashMap常用方法(Java8之前)</center></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiConsumer;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供HashMap的对象创建方式</span></span><br><span class="line">        <span class="comment">//1.1创建一个空HashMap集合对象【默认初始容量16，加载因子0.75】 ---&gt; 常用</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//1.2创建一个提供初始容量大小的HashMap集合对象【加载因子0.75】</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">32</span>);</span><br><span class="line">        <span class="comment">//1.3创建一个提供初始容量大小和加载因子的HashMap对象---》提供的容量是16的倍数，加载因子不易过小</span></span><br><span class="line">        HashMap&lt;Character,Double&gt; map3 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt; (<span class="number">32</span>,<span class="number">0.5f</span>);</span><br><span class="line">        <span class="comment">//1.4将参数Map集合对象中存储数据赋值给当前HashMap集合对象进行存储 ---&gt; 偶尔</span></span><br><span class="line">        HashMap&lt;String, Integer&gt; map4 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt; (map);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//提供常用API;</span></span><br><span class="line">        <span class="comment">//1.向HashMap集合对象中添加数据 [第一个参数是存储的key值，第二个参数参数存储是value值]</span></span><br><span class="line">        map.put(<span class="string">&quot;1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(map);<span class="comment">//HashMap已经重写toString方法所以直接打印集合对象查看结果</span></span><br><span class="line">        <span class="comment">//PS：在使用put方法向map集合对象中添加 &quot;1&quot;,2 键值对</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1.向Map集合添加Key-value键值对时 key值必须是唯一的，又使用key = &quot;1&quot; 那么系统并没有</span></span><br><span class="line"><span class="comment">                提示任何语法错误信息和异常信息，是否会出现运行时异常呢？ ---》不会出现异常</span></span><br><span class="line"><span class="comment">            2.put方法的第二个作用：修改指定key对应value值</span></span><br><span class="line"><span class="comment">                当使用put方法提供一个已经在map集合对象中存在key时，将put操作认为是覆盖原有已经存在map集合中key-value</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        map.put(<span class="string">&quot;1&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//putAll(Map集合对象) --&gt; 将参数Map集合对象中存储的数据赋值给Map集合</span></span><br><span class="line">        <span class="comment">// clear() ---&gt; 将Map集合中存储数据清空，map对象的引用是保留</span></span><br><span class="line">        <span class="comment">// isEmpty() ---&gt;判断Map集合中是否有存储数据 存储数据返回false 没有存储返回true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断Map集合中是否存在指定key值 --&gt; 存储返回true 不存在返回false</span></span><br><span class="line">        System.out.println(map.containsKey(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">        <span class="comment">//判断Map集合中是否存在指定value值 --&gt;存储返回true 不存在返回false</span></span><br><span class="line">        System.out.println(map.containsValue(<span class="number">2</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取存储在Map集合value值时 ---》key存在会得到对应value，key不存在会得到null值</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> map.get(<span class="string">&quot;2&quot;</span>);    <span class="comment">//参数：key值</span></span><br><span class="line">        <span class="keyword">if</span>(Objects.nonNull(integer)) <span class="comment">//建议添加非null判断</span></span><br><span class="line">        &#123; </span><br><span class="line">            integer.intValue();</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将存储在Map集合中key-value键值对删除，条件是一个key值</span></span><br><span class="line">        map.remove(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;获取Map集合中存储元素的个数：&quot;</span>+map.size());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Map集合遍历方式比较麻烦，没有迭代器，不支持普通for循环遍历，不支持增强for</span></span><br><span class="line">        <span class="comment">//获取map集合中所有key的值存储在一个Set集合中</span></span><br><span class="line">        Set&lt;String&gt; strings = map.keySet(); <span class="comment">//通过这种方式获取到所有key</span></span><br><span class="line">        <span class="comment">//获取map集合中所有value的值存储在一个Collection集合中</span></span><br><span class="line">        Collection&lt;Integer&gt; values = map.values(); <span class="comment">//通过这种方式获取到所有value值</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Map提供了一种遍历方式entrySet方法 --&gt;返回值是一个Set集合</span></span><br><span class="line"><span class="comment">            Set集合存在一个泛型类型 Map.Entry ---》Set集合中存储的数据类型</span></span><br><span class="line"><span class="comment">            Map.Entry&lt;String,Integer&gt; --&gt; 相当Map.Entry类型中存储数据是 String类型key 和 Integer类型value</span></span><br><span class="line"><span class="comment">            通过entrySet这个方法，返回一个Set集合这个集合存储这个Entry的类型，Entry类型的内部存储的是key-value兼职对</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; map5 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map5.put(<span class="string">&quot;key1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        map5.put(<span class="string">&quot;key2&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        map5.put(<span class="string">&quot;key3&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        map5.put(<span class="string">&quot;key4&quot;</span>,<span class="number">4</span>);</span><br><span class="line">        map5.put(<span class="string">&quot;key5&quot;</span>,<span class="number">5</span>);</span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map5.entrySet();</span><br><span class="line">        System.out.println(entries);</span><br><span class="line">        <span class="comment">//提供Set集合之增强for循环遍历</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : entries)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//entry就得到了存储在Set集合中key-value键值对 即 key1=1</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Key的值是：&quot;</span>+entry.getKey());</span><br><span class="line">            System.out.println(<span class="string">&quot;Value的值是：&quot;</span>+entry.getValue());</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//在Java8中时提供一个foreach方法可以便捷遍历集合中key和value</span></span><br><span class="line">        map5.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;String, Integer&gt;() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * </span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> s map集合中key值</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> integer map集合汇总value</span></span><br><span class="line"><span class="comment">            * 这个方法被出触发时可以获取map集合中每一对：keyvalue</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s, Integer integer)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//这个可以进行操作但是只是打印的结果，不会影响最终map集合中的结果</span></span><br><span class="line">                System.out.println(s);</span><br><span class="line">                System.out.println(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        map5.forEach((k,v)-&gt; System.out.println(k+<span class="string">&quot;=&quot;</span>+v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-4-hashmap常用方法-java8之后-center"><center>4、HashMap常用方法(Java8之后)</center></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 提供HashMap基础API【Java8之后】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapAPIDemo_2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供HashMap的对象创建方式</span></span><br><span class="line">        <span class="comment">//1.1创建一个空HashMap集合对象【默认初始容量16，加载因子0.75】 ---&gt; 常用</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//新Java8中方法</span></span><br><span class="line">        <span class="comment">//1向map集合中添加数据 ---&gt;如果key已经存在则不添加，否则添加数据 【建议向Map集合存储数据使用】</span></span><br><span class="line">        map.putIfAbsent(<span class="string">&quot;1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        map.putIfAbsent(<span class="string">&quot;2&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        map.putIfAbsent(<span class="string">&quot;3&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        map.putIfAbsent(<span class="string">&quot;1&quot;</span>,<span class="number">1000</span>);</span><br><span class="line">        map.putIfAbsent(<span class="string">&quot;1&quot;</span>,<span class="number">10000</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">//2.提供了一个全系列对map集合中k和v进行存储的方法 ---》computeXXX方法</span></span><br><span class="line">        <span class="comment">//2.1 map集合中指定key在map集合进行操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        执行原理:</span></span><br><span class="line"><span class="comment">            无论key是否存在都会执行参数中提供Lambda表达式</span></span><br><span class="line"><span class="comment">            1.如果key值存在，后面提供Lambda表达式就会取出key所对应value并在Lambda表达式中进行操作，然后修改原有k和v值</span></span><br><span class="line"><span class="comment">            2.如果key值不存在，后面提供Lambda表达式就会将key进行存到 map集合操作</span></span><br><span class="line"><span class="comment">                第一个参数就是key值，第二个参数就是提供操作key对应Lambda表达式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        map.compute(<span class="string">&quot;3&quot;</span>,(k,v) -&gt; v == <span class="literal">null</span> ? <span class="number">0</span> : v+<span class="number">1</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        map.compute(<span class="string">&quot;4&quot;</span>,(k,v) -&gt; v == <span class="literal">null</span> ? <span class="number">0</span> : v+<span class="number">1</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">//2.2 判断map集合key是否存在提供对应操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        执行原理：</span></span><br><span class="line"><span class="comment">            1.如果key存在，后面提供Lambda表达式就不会执行，并返回key对应value值</span></span><br><span class="line"><span class="comment">            2.如果key不存储，后面提供Lambda表达式就会执行操作者并将Lambda表达式中处理</span></span><br><span class="line"><span class="comment">            之后value值与key一起存储到map集合中</span></span><br><span class="line"><span class="comment">            PS：Lambda表达式是你如何处理这个value操作 ，你自己决定</span></span><br><span class="line"><span class="comment">            但是一定要返回这个value即添加return</span></span><br><span class="line"><span class="comment">            第一个参数就是key值，第二个参数就是提供操作key对应Lambda表达式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> map.computeIfAbsent(<span class="string">&quot;3&quot;</span>,key -&gt; <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">5</span>));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        map.computeIfAbsent(<span class="string">&quot;5&quot;</span>,key -&gt; <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">5</span>));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">//2.3 判断map集合key是否存在提供对应操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        执行原理：</span></span><br><span class="line"><span class="comment">            1.如果key存在，就执行后lambda表达式，并修改map集合key所对应value值</span></span><br><span class="line"><span class="comment">            2.如果key不存在，就不会执行后面lambda表达式，不会像Map集合中做任何操作，但是方法会返回一个null</span></span><br><span class="line"><span class="comment">            第一个参数就是key值，第二个参数就是提供操作key对应Lambda表达式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        map.computeIfPresent(<span class="string">&quot;3&quot;</span>,(k,v) -&gt; v+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            相当于 你调用map.containsKey() --》 在调用 map.get()--》得到value之后进行操作</span></span><br><span class="line"><span class="comment">            在调用 ---&gt;map.put 这个存储回去</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(map);</span><br><span class="line">        map.computeIfPresent(<span class="string">&quot;6&quot;</span>,(k,v) -&gt; v+<span class="number">1</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            getOrDefault这个方法作用是通过key值获取对应value，这个方法根get方法最大区别在于</span></span><br><span class="line"><span class="comment">            这个方法提供一个默认值，如果key不存在则返回对应默认值， 存在则返回value值</span></span><br><span class="line"><span class="comment">            get方法在则返回value不在则返回null值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//第一个参数是key值 第二个参数是默认值</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">orDefault</span> <span class="operator">=</span> map.getOrDefault(<span class="string">&quot;7&quot;</span>, Integer.MAX_VALUE);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//merge(合并) --》方法含义 对存在在map集合中kv键值对进行更新操作【更新value值】</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一个参数 是map集合存在key值</span></span><br><span class="line"><span class="comment">            第二个参数 这个参数的作用是向Lambda表达式中提供方法参数中</span></span><br><span class="line"><span class="comment">            第二个参数赋值 即 newVal</span></span><br><span class="line"><span class="comment">            第三个参数 需要对存在在集合key所对应value所提供更新数据操作 --》 提供一个lambda</span></span><br><span class="line"><span class="comment">            lambda中第一个参数即oldVal是获取出提供key所对应的value值</span></span><br><span class="line"><span class="comment">            第二个参数即newVal或获取方法中第二个参数值</span></span><br><span class="line"><span class="comment">            提供这两个参数计算更新key所对应value值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        map.merge(<span class="string">&quot;1&quot;</span>,<span class="number">2</span>,(oldVal,newVal)-&gt;oldVal+newVal);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除方法--》根据提供k和v值进行删除，如果存在在map中删除成功返回true，如果不存在删除失败返回false</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">remove</span> <span class="operator">=</span> map.remove(<span class="string">&quot;1&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(remove);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Java8中提供一个操作，官方文档意思在于使用这个方法替代put方法修改操作</span></span><br><span class="line">        <span class="comment">//根据key值替换存储对应value值，如果key存在则替换，不存在则不替换</span></span><br><span class="line">        map.replace(<span class="string">&quot;2&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">// 多参数版本 提供完整key-value键值对，进行替换操作 如果key和value匹配成功存在则替换，不存在则替换</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一个参数是 key值</span></span><br><span class="line"><span class="comment">            第二个参数是 key对应原理的value值</span></span><br><span class="line"><span class="comment">            第三个参数是 新替换value值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        map.replace(<span class="string">&quot;2&quot;</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//只要满足lambda表达式提供替换条件，就会将value值进行替换</span></span><br><span class="line">        map.replaceAll((key,value)-&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供替换操作者条件</span></span><br><span class="line">            <span class="keyword">if</span>(key.length() &gt;= <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//提供替换操作</span></span><br><span class="line">                value = <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//需要将替换的value值提提供return返回</span></span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">// forEach打印方法</span></span><br><span class="line">        map.forEach((k,v)-&gt; System.out.println(k+<span class="string">&quot;=&quot;</span>+v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashMap有一个子类LinkedHashMap这个集合 操作方式和HashMap是一样，只不过就是存储结构有所变化多了一个链表存储，Hashtable已经不在使用了，所以这个API执行查看和HashMap操作一样的</p>
<h2 id="center-5-map集合之treemap集合-center"><center>5、Map集合之TreeMap集合</center></h2>
<p>TreeMap集合是Map集合实现类之一，TreeMap集合提供排序操作，TreeMap集合排序操作和TreeSet道理相同的，需要提供Comparator和Comaprable接口，根据使用TreeMap中构造方法决定说那个那个接口来实现排序操作</p>
<p>在官方的API文档中的介绍：基于红黑树（Red-Black tree）的NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法</p>
<p>TreeMap集合的排序点在于存储的键值key，将要排序数据存储到key中就可以进行排序操作</p>
<p>当调用无参构造方法创建TreeMap对象时，使用Comparable进行的比较操作</p>
<p>TreeMap() 使用键的自然顺序构造一个新的、空的树映射</p>
<p>当调用有参构造方法创建TreeMap对象时，使用Comparator进行的比较操作</p>
<p>TreeMap(Comparator comparator) 构造一个新的、空的树映射，该映射根据给定比较器进行排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMapDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        TreeMap&lt;Integer,String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">10</span>,<span class="string">&quot;value10&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">8</span>,<span class="string">&quot;value8&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">15</span>,<span class="string">&quot;value15&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">7</span>,<span class="string">&quot;value7&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">1</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">9</span>,<span class="string">&quot;value9&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">20</span>,<span class="string">&quot;value20&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">13</span>,<span class="string">&quot;value13&quot;</span>);</span><br><span class="line">        System.out.println(treeMap);</span><br><span class="line">        </span><br><span class="line">        TreeMap&lt;Integer,String&gt; treeMap2 = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt; (<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> </span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">10</span>,<span class="string">&quot;value10&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">8</span>,<span class="string">&quot;value8&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">15</span>,<span class="string">&quot;value15&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">7</span>,<span class="string">&quot;value7&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">1</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">9</span>,<span class="string">&quot;value9&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">20</span>,<span class="string">&quot;value20&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">13</span>,<span class="string">&quot;value13&quot;</span>);</span><br><span class="line">        System.out.println(treeMap2);</span><br><span class="line">        </span><br><span class="line">        TreeMap&lt;Integer,String&gt; treeMap3= <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt; ((o1,o2)-&gt;o2 - o1);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">10</span>,<span class="string">&quot;value10&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">8</span>,<span class="string">&quot;value8&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">15</span>,<span class="string">&quot;value15&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">7</span>,<span class="string">&quot;value7&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">1</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">9</span>,<span class="string">&quot;value9&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">20</span>,<span class="string">&quot;value20&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">13</span>,<span class="string">&quot;value13&quot;</span>);</span><br><span class="line">        System.out.println(treeMap3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TreeMap集合排序的时候也是会对key值进行排重操作，这个排重操作依据是提供Comparable和Comparator接口中方法实现时，如果结果为0，就会进行排重操作</p>
<h2 id="center-6-collections工具类-center"><center>6、Collections工具类</center></h2>
<p>Collections工具类类似于Arrays工具类，Collections工具类是为了给Collection集合提供便捷操作工具类，虽然Collection集合已经提供很多方法了，但是Collections工具类也提供一些操作方法，弥补开发时所需要自行定义方法</p>
<p>Collections工具类提供方法大部分都是给Collection集合使用，极少部分是给Map集合使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsAPIDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.一次性向Collection集合对象中添加多个数据--》【推荐】</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//向集合中存这些数据：【 321,34,3,1,4,4231,4123,353,1】</span></span><br><span class="line">        list.add(<span class="number">321</span>);</span><br><span class="line">        list.add(<span class="number">34</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">4231</span>);</span><br><span class="line">        list.add(<span class="number">4123</span>);</span><br><span class="line">        list.add(<span class="number">353</span>);</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//不用上面这样麻烦操作了,直接使用addAll方法就可以了</span></span><br><span class="line">        <span class="comment">//这个方法的第一个参数是 Collection集合对象， 第二个参数就是要存储值使用【,】分隔即可</span></span><br><span class="line">        Collections.addAll(list,<span class="number">321</span>,<span class="number">34</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">4231</span>,<span class="number">4123</span>,<span class="number">353</span>,<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.提供Collection集合排序操作【针对是List集合】</span></span><br><span class="line">        Collections.sort(list); <span class="comment">//默认是升序排序操作【要去排序数据要么实现Comparable要么实现Comparator】</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//可以使用Collections工具类中提供静态方法进行降序排序【仅针对集合中存储系统引用类型有效】</span></span><br><span class="line">        Collections.sort(list,Collections.reverseOrder());</span><br><span class="line"></span><br><span class="line">        System.out.println(list); <span class="comment">//指针对系统类型</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//自定义排序操作</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> o1 - o2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Collections.sort(list,(o1,o2)-&gt;o2-o1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从Java8开始List集合接口提供sort方法，所以可以直接调用List集合的sort方法进行排序操作</span></span><br><span class="line">        list.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> o1-o2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        list.sort((o1,o2)-&gt;o2-o1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将List、set和Map集合转换为线程安全的集合</span></span><br><span class="line">        List&lt;Integer&gt; lists = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        Set&lt;String&gt; sets = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;());</span><br><span class="line">        Map&lt;String, Integer&gt; maps = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 提供二分查找【要排序数据】 找到 下标 找不到 负数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Collections.binarySearch(list, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//交换List集合存储元素的位置 位置参数是下标</span></span><br><span class="line">        Collections.swap(list,<span class="number">0</span>,list.size()-<span class="number">1</span>);<span class="comment">//第一个元素和最后一个元素互换</span></span><br><span class="line">        <span class="comment">//打乱List集合对象中存储数据的顺序【将有序存储数据打乱存储】</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        <span class="comment">//向List集合中填充同一个数据</span></span><br><span class="line">        Collections.fill(list,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-7-collection集合和map集合的总结-center"><center>7、Collection集合和Map集合的总结</center></h2>
<p>Collection是Java集合框架中根接口也是List和Set集合的父接口，Collection集合接口也继承Iterable接口所有Collection系的集合都支持迭代器进行遍历操作，在Collection集合接口中常用的就是List和Set接口，List和Set接口中常用的实现类集合<strong>ArrayList【允许存储重复数据并且使用数组实现】和HashSet【不允许存储重复数据并且使用Hash表实现】</strong></p>
<p>Map集合本身没是不在Collection范围内容，它是一个独立的集合，Map提供一种【键值对】即key-value的形式进行数据存储操作，在存储数据时要求key值必须是唯一的，value值可以不唯一，<strong>在Map集合接口中主要使用实现类是HashMap</strong></p>
<p><strong>PS：List集合使用ArrayList 、Set集合使用HashSet、Map集合使用HashMap</strong></p>
<h2 id="center-8-hashmap应用-center"><center>8、HashMap应用</center></h2>
<ul>
<li>可以使用Map 表示一个实体类</li>
<li>可以使用List&gt; 表示一个实体类集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapDemo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在java一个用户对象</span></span><br><span class="line"><span class="comment">     *      一个用户对象</span></span><br><span class="line"><span class="comment">     *      public class user</span></span><br><span class="line"><span class="comment">     *      &#123;</span></span><br><span class="line"><span class="comment">     *          private String username;</span></span><br><span class="line"><span class="comment">     *          private String password;</span></span><br><span class="line"><span class="comment">     *          private int age;</span></span><br><span class="line"><span class="comment">     *          private String phone;</span></span><br><span class="line"><span class="comment">     *          private String address;</span></span><br><span class="line"><span class="comment">     *          ......</span></span><br><span class="line"><span class="comment">     *      &#125;</span></span><br><span class="line"><span class="comment">     *      User user = new User(&quot;admin&quot;,&quot;123&quot;,30);</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      多个用户对象</span></span><br><span class="line"><span class="comment">     *      以前：User[]</span></span><br><span class="line"><span class="comment">     *      现在：List&lt;User&gt;</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     * 在实战开发中，如果这个类使用不多，那么这个时候就没有必要创建一个User类</span></span><br><span class="line"><span class="comment">     * 可以使用Map来代替</span></span><br><span class="line"><span class="comment">     *      一个用户对象</span></span><br><span class="line"><span class="comment">     *       HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">     *       map.put(&quot;username&quot;,&quot;admin&quot;);</span></span><br><span class="line"><span class="comment">     *       map.put(&quot;password&quot;,&quot;123&quot;);</span></span><br><span class="line"><span class="comment">     *       map.put(&quot;age&quot;,20);</span></span><br><span class="line"><span class="comment">     *       多个用户对象</span></span><br><span class="line"><span class="comment">     *       List&lt;Map&lt;String,Object&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-9-hashmap底层实现原理-center"><center>9、HashMap底层实现原理</center></h2>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292004683.WebP" alt="实现原理" style="zoom: 50%;">
<h2 id="center-10-put的过程原码-center"><center>10、put的过程原码</center></h2>
<p>put流程</p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292004096.WebP" alt="put流程" style="zoom:50%;">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//tab表示存放Node节点的数据 p表示当前节点 n表示长度 i表示节点在数组中的下标</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">//判断数组如果为空或者数组长度为0，那么就对数组进行扩容，数组默认初始大小为16</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//将数组的长度-1与hash值进行与运算(计算的结果一定是0~数组长度-1)得到元素应该存放的下标</span></span><br><span class="line">    <span class="comment">//如果当前下标位置为空，那么直接将Node节点存放在当前位置</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//如果当前位置不为空(分为三种情况)</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//情况1：要添加的元素与当前位置上的元素相同(hash(hashCode)、key(equals)一致),则直接替换</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//情况2:如果要添加的元素是红黑树节点，那么将其添加到红黑树上</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//情况3:如果要添加的元素是链表，则需要遍历</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//将当前元素的下一个节点赋给e</span></span><br><span class="line">                <span class="comment">//如果e为空，则创建新的元素节点放在当前位置的下一个元素上，并退出循环</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//如果链表的元素个数大于8个(且当数组中的元素个数大于64)，则将其转换成红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)     <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//要添加的元素与当前位置上的元素相同(hash(hashCode)、key(equals)一致),则直接退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; </span><br><span class="line">          <span class="comment">//如果返回的e不为null</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="literal">null</span>)</span><br><span class="line">          &#123; </span><br><span class="line">              <span class="comment">// existing mapping for key</span></span><br><span class="line">              <span class="comment">//将e的值赋给oldValue</span></span><br><span class="line">              <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                  e.value = value;afterNodeAccess(e);</span><br><span class="line">                  <span class="comment">//返回以前的值(当添加的元素已经存在返回的是以前的值)</span></span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//如果数组的元素个数大于阈值则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-11-resize过程原码-center"><center>11、resize过程原码</center></h2>
<p>扩容流程</p>
<img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292005741.WebP" alt="扩容时机" style="zoom:50%;">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//oldTab 表示原来数组(如果是第二次扩容：长度为16的那个)</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//oldCap 表示原数组的容量(长度)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//oldThr 表示数组原来的阈值 12</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="comment">//newCap 新数组的容量 newThr 新数组的阈值</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">        &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;<span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//新数组的容量扩大一半 newCap 32</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">        <span class="comment">//新阈值扩大老阈值的一半 newThr 24</span></span><br><span class="line">        newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)     <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?(<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//threshold 24</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">//创建一个长度为32的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    <span class="comment">//table指向新数组</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将原数组中的元素拷贝到新数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">//如果当前位置元素不为空</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//情况1：当前位置上的下一个元素为空，则直接将这个元素拷贝到新数组中</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//情况2：当前位置上的元素红黑树类型，则需要进行切割</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">//情况3：当前位置上的元素链表类型，则需要进行分散拷贝</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                             loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-12-get的过程原码-center"><center>12、get的过程原码</center></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e;</span><br><span class="line">    <span class="type">int</span> n;K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;(first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当前first与要找到的hash和key都相等直接返回当前这个first元素</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">            <span class="comment">//如果当前first不为空(有两种情况)</span></span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//当前位置是一个红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//根据hash、key从红黑树上找到对应的元素z</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="comment">//当前位置是一个链表</span></span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//循环进行比较直到找到向的hash和key的元素，并返回</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">     &#125; </span><br><span class="line">    <span class="comment">//如果数组的为空、数组的长度为0、当前下标位置上的值为null,这三种情况都返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十八：常见的集合面试面试题</center></h1>
<ul>
<li>1、简述：ArrayList、LinkedList、Vector的区别</li>
<li>2、简述：HashSet、TreeSet的去重原理</li>
<li>3、ArrayList、LinkedList底层实现</li>
<li>4、HashMap、HashTable的区别</li>
<li>5、HashMap底层实现原理</li>
<li>6、HashMap扩容机制</li>
<li>7、HashMap的数组容量为什么是2的次方数</li>
<li>8、HashMap的负载因子为什么是0.75</li>
<li>9、HashMap添加元素的过程</li>
<li>10、谈谈了解的数据结构</li>
</ul>
]]></content>
      <categories>
        <category>Java语言</category>
      </categories>
      <tags>
        <tag>Java语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows使用相关问题</title>
    <url>/post/6928cd3f.html</url>
    <content><![CDATA[<h1><center>office无法初始化VisualBasic</center></h1>
<p>1.打开word，将 无法初始化visual basic 的弹出框先关掉</p>
<p>2.点击左上角的 <code>文件</code></p>
<img src="https://s2.loli.net/2024/08/19/dR4COBbWFSykfKn.png" alt="点击文件" style="zoom:50%;">
<p>3.点击帮助栏目下的 <code>选项</code>，然后点击 <code>加载项</code></p>
<img src="https://s2.loli.net/2024/08/19/ONbW38nYyapSMA2.png" alt="进入选项" style="zoom:50%;">
<hr>
<img src="https://s2.loli.net/2024/08/19/nBGQD25ZUHhFfsi.png" alt="进入设置" style="zoom:50%;">
<p>4.在弹出的com加载项中将所有带√的选项都去掉(此处不是删除，只是将<code>√去掉</code>)，最后点击<code>确定</code>，重新打开文件</p>
<img src="https://s2.loli.net/2024/08/19/JDBRsFjE6aICH7h.png" alt="取消" style="zoom:50%;">
<h1><center>完美解决443端口被vmware占用的问题</center></h1>
<p>第一步，打开虚拟机，找到首选项</p>
<img src="https://s2.loli.net/2024/08/19/cUmt1MFpeDLVAxg.png" alt="进入首选项" style="zoom:50%;">
<p>第二步，选择共享虚拟机，修改端口号，保存</p>
<img src="https://s2.loli.net/2024/08/19/5tJrqO2o3cSTYQH.png" alt="修改端口" style="zoom:50%;">
<h1><center>win10桌面图标变白</center></h1>
<p>1、双击打开此电脑，点击【查看】，勾选**【隐藏的项目】**</p>
<img src="https://s2.loli.net/2024/08/19/bHVnR4fCvKPWkdU.png" alt="关闭隐藏" style="zoom:40%;">
<p>2、同时按 【Win + R】键打开运行，输入**【%localappdata%】**回车确定</p>
<img src="https://s2.loli.net/2024/08/19/zS47mboVWUT2t8L.png" alt="打开命令" style="zoom:50%;">
<p>3、右键选择删除<strong>lconCache.db</strong>文件</p>
<img src="https://s2.loli.net/2024/08/19/xVD4t6Z2waeOobJ.png" alt="删除文件" style="zoom:50%;">
<p>4、同时按【Shift + Ctrl + Esc】键打开任务管理器，找到<strong>Windows 资源管理器</strong>，右键选择重新启动</p>
<img src="https://s2.loli.net/2024/08/19/Br4WZfbVKH3ahiy.png" alt="资源管理器" style="zoom:40%;">
<h1>Windows 11 修改Edge按 Alt+Tab 键为单个窗口</h1>
<p>在任务栏中，点击放大镜搜索alt，选择<code>为桌面选择 Alt+Tab行为</code>，然后进入</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/10/14/216Jjbs4gDqadSR.webp" alt="设置不显示选项卡" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
]]></content>
      <categories>
        <category>错误记录</category>
      </categories>
  </entry>
  <entry>
    <title>博客搭建相关</title>
    <url>/post/cb87841d.html</url>
    <content><![CDATA[<h1><center>GitHub博客搭建及使用手册</center></h1>
<p>Hexo+github搭建个人博客 教程：<a href="https://blog.csdn.net/wushibo123/article/details/124619123">网址</a></p>
<p>hexo博客换主题 教程：<a href="https://zhuanlan.zhihu.com/p/385525053">网址</a></p>
<p>珍藏的 Hexo 博客主题：安知鱼：<a href="https://docs.anheyu.com/">网址</a>，Solitude：<a href="https://solitude.js.org/zh/guide/intro">网址</a></p>
<p>GitHub+Typora写博客+图片上传 教程，插入图片时若前面有弹出选择不需要选，在source下<code>_posts</code> 文件夹下生成 md 文件，生成完成之后，会有对应名称的文件夹生成（要删除移到其他文件夹，或改文件夹名字再移动进去），图中要保存在设置的路径下的${fiilename}文件夹中，然后再复制进去（注意：文章距图片路径）参考：<a href="https://blog.csdn.net/Qxiaofei_/article/details/124629908">网址</a></p>
<img src="https://s2.loli.net/2024/08/19/BdvDUiE2wKxAV9y.png" alt="Typora图片插入设置" style="zoom:50%;">
<p>在项目中的_config.yml网址需要用这个，否则可能上传时卡顿导致错误</p>
<img src="https://s2.loli.net/2024/08/19/Dj2spAewZL6BWlc.png" alt="项目地址" style="zoom:50%;">
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">//创建md文件</span><br><span class="line">hexo new post &quot;新建博客文章名&quot;</span><br><span class="line"></span><br><span class="line">//上传博客</span><br><span class="line">hexo cl <span class="built_in">&amp;</span><span class="built_in">&amp;</span> hexo g  <span class="built_in">&amp;</span><span class="built_in">&amp;</span> hexo d</span><br><span class="line"></span><br><span class="line">//文章分类方法</span><br><span class="line">categories:</span><br><span class="line">- 分类名字</span><br><span class="line"></span><br><span class="line">//文章标签</span><br><span class="line">tags:</span><br><span class="line">- 标签名字</span><br></pre></td></tr></table></figure>
<p>Hexo添加分类和标签，<a href="https://blog.csdn.net/cflsup/article/details/123452683">网址</a></p>
<p>npm下载插件慢等问题，改用淘宝源 教程：<a href="https://blog.csdn.net/m0_52861000/article/details/132412681">网址</a></p>
<p>Hexo设置文章置顶+私密文章 教程：<a href="https://blog.csdn.net/cungudafa/article/details/104346521">网址</a></p>
<p>Typora编写技巧：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">&amp;</span>ensp;<span class="built_in">&amp;</span>ensp;<span class="built_in">&amp;</span>ensp;<span class="built_in">&amp;</span>ensp;	//编写的缩进要在网页中显示，需要在文本前加入四个</span><br><span class="line">&lt;center&gt;需要输入的文本&lt;/center&gt;	//需要文本居中</span><br><span class="line">&lt;font color=&quot;red&quot;&gt;&lt;strong&gt;需要输入的文本&lt;/strong&gt;&lt;/font&gt;	//文本标红加粗</span><br><span class="line">https://blog.csdn.net/lose<span class="built_in">_</span>hair/article/details/128576954	//文字高亮以及文字标红教程</span><br><span class="line">https://blog.csdn.net/qq<span class="built_in">_</span>41261251/article/details/102817673	//一些文本编辑技巧教程</span><br><span class="line">//高亮</span><br><span class="line">    ==highlight 1==		//高亮黄色，但网页不显示</span><br><span class="line">    &lt;mark&gt;highlight 2&lt;/mark&gt;	//高亮黄色</span><br><span class="line">    &lt;span style=&quot;background-color:rgb(100,200,200,0.5)&quot;&gt;highlight 3&lt;/span&gt;	//高亮自定义颜色</span><br><span class="line">    ```code 1```	//高亮灰色</span><br><span class="line">    `code 2`	//高亮灰色</span><br><span class="line">若一些符号显示不了，则在前面打一个 <span class="keyword">\ </span>显示，或打空格</span><br><span class="line">图片有两种语法，一种HTML（可以缩放但不美观且图片下面没有小标题）另一种 Markdown（美观且有小标题</span><br><span class="line">但不能缩放图片）图片右键可选择图片转换语法，选择对应需要的语法</span><br><span class="line">超链接：[名字](链接)	快捷键：ctrl+k</span><br></pre></td></tr></table></figure>
<h1>博客上传报错解决方案</h1>
<p>在确保配置ssh秘钥等正确情况下尝试一下解决方法，报错如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2025/01/02/iZoxgJ6CE21bQMH.webp" alt="报错" style="zoom: 67%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>解决方法一：删除博客文件夹中的 <strong>.deploy_git</strong> 文件夹，在git命令窗口中输入<code>git config --global core.autocrlf false</code>，再重新上传</p>
<p>解决方法二：找到 <strong>.deploy_git</strong> 文件夹中的 <strong>index.lock</strong> 文件，删除就好了</p>
<p>解决方法三：在C盘——用户——你的主机名文件夹中找到.ssh文件夹中找到 config 文件，如果没有可以新建一个，文件添加下面内容保存，重新上传</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User YourEmail（你的邮箱）</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id<span class="built_in">_</span>rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure>
<h1>博客搜索配置</h1>
<p>配置完成之后，需要去主题配置文件将搜索配置成 algolia 或 本地</p>
<h2 id="algolia搜索">algolia搜索</h2>
<p>进入官网注册并登录账号：<a href="https://dashboard.algolia.com/users/sign_in?redirect_to=%2Fapps%2FV1R8T877I8%2Fdashboard">网址</a>，参考：<a href="https://www.mebi.me/hexo-with-algolia#6-%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E8%AE%B0%E5%BD%95">网址</a></p>
<h3 id="创建应用">创建应用</h3>
<p>选择地区时，不是全部地区都可以，选择亮颜色的就可以</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/11/10/gXxmbvMDAnirKOe.webp" alt="创建应用" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>创建之后，可以回到首页可以看到我们三个API值（等等需要用）</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/11/10/fPR95VY1Ta7eEXK.webp" alt="获取API" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h3 id="配置">配置</h3>
<p>进入博客目录，安装插件 <code>hexo-algoliasearch</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-algoliasearch --save</span><br></pre></td></tr></table></figure>
<p>安装成功后在博客根目录 <code>_config.yml</code> 中添加下面代码，将appId、apiKey、adminApiKey中的值替换为上面三个API的值</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">algolia:</span></span><br><span class="line">  <span class="attr">appId:</span> <span class="string">&quot;Z7A3XW4R2I&quot;</span></span><br><span class="line">  <span class="attr">apiKey:</span> <span class="string">&quot;12db1ad54372045549ef465881c17e743&quot;</span></span><br><span class="line">  <span class="attr">adminApiKey:</span> <span class="string">&quot;40321c7c207e7f73b63a19aa24c4761b&quot;</span></span><br><span class="line">  <span class="attr">chunkSize:</span> <span class="number">5000</span></span><br><span class="line">  <span class="attr">indexName:</span> <span class="string">&quot;my-hexo-blog&quot;</span></span><br><span class="line">  <span class="attr">fields:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">content:strip:truncate,0,500</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">excerpt:strip</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">gallery</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">permalink</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">photos</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">slug</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tags</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">title</span></span><br></pre></td></tr></table></figure>
<p>执行下面命令上传博客内容供 algolia 生成检索</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo algolia</span><br></pre></td></tr></table></figure>
<h3 id="自动上传记录">自动上传记录</h3>
<p>修改博客根目录中的 <code>package.json</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo generate&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;clean&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo clean&quot;</span><span class="punctuation">,</span></span><br><span class="line">-    <span class="attr">&quot;deploy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo deploy&quot;</span><span class="punctuation">,</span></span><br><span class="line">+    <span class="attr">&quot;deploy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo deploy &amp;&amp; hexo algolia&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo server&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  ...</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>或者借助 github 的工作流，添加 algolia.yml 文件</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/11/10/N8au9GBXoks7rOp.webp" alt="32" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Algolia</span> <span class="string">Upload</span> <span class="string">Records</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="string">branches</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span>   <span class="comment"># 替换为你的分支名</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">algolia:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">submodules:</span> <span class="string">recursive</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm install hexo-cli &amp;&amp; \</span></span><br><span class="line"><span class="string">          npm install hexo-algoliasearch &amp;&amp; \</span></span><br><span class="line"><span class="string">          npx hexo generate &amp;&amp; \</span></span><br><span class="line"><span class="string">          npx hexo algolia -n</span></span><br></pre></td></tr></table></figure>
<h2 id="本地搜索">本地搜索</h2>
<p>安装插件，二选一即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br><span class="line"></span><br><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure>
<p>安装完成之后，在博客根目录中 <code>_config.yml</code> 中添加下面代码</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">template:</span> <span class="string">./search.xml</span></span><br></pre></td></tr></table></figure>
<h1>新电脑 个人博客迁移</h1>
<h2 id="center-安装和配置软件-center"><center>安装和配置软件</center></h2>
<p>安装Git 客户端，安装过程省略，一般默认下一步</p>
<p>​    下载地址：<a href="https://git-scm.com/downloads">Git客户端</a></p>
<p>​    这个无脑下一步即可无需配置</p>
<p>安装node JS，安装过程省略，一般默认下一步</p>
<p>​    下载地址：<a href="https://nodejs.cn/download/">node JS</a></p>
<p>​    配置看这位大佬教程：<a href="https://blog.csdn.net/qq_42006801/article/details/124830995">地址</a></p>
<p>如果出现以下错误，需要将下面三个文件夹修改权限</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/11/18/JdGUSoDN9Ek7r6R.webp" alt="修改文件夹权限" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>拷贝个人博客文件夹中，部分文件，到新电脑，存放个人博客文件的文件夹中</p>
<blockquote>
<p>_config.yml 、package.json 、scaffolds 、source 、themes 、.gitignore(这个图中没标，注意保留)</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/AoIgTLb6Rrhqax8.png" alt="需要的文件" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="center-安装hexo-center"><center>安装hexo</center></h2>
<p>在 cmd 下输入下面指令安装 hexo</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/Bg7KiZJ8Ul9ORTn.png" alt="安装" style="zoom: 67%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="center-配置博客-center"><center>配置博客</center></h2>
<p>进入 F:/Blog 目录（你拷贝到新电脑的目录），右键git，输入下面指令安装相关模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// “ ”内换成自己对应的</span><br><span class="line">git config --global user.name &quot;HuGen&quot;</span><br><span class="line">git config --global user.email &quot;LoveHuGen@126q.com&quot;</span><br><span class="line">ssh-keygen -t rsa -C &quot;LoveHuGen@126q.com&quot;</span><br></pre></td></tr></table></figure>
<p>Github 添加 SSH Keys</p>
<p>1、在本地创建 <code>SSH Keys</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;wujiajiansh@163.com&quot;</span><br><span class="line">//一直回车，直到结束</span><br></pre></td></tr></table></figure>
<p>2、复制key</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/XgVy1kJISwYto6s.png" alt="查询ssh" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>进入登录GitHub，在设置中添加ssh key</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/jxziPbs3hYKCR8k.png" alt="4.webp" style="zoom: 33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>将上一步中的文件里面的内容全部复制进去 ，点击添加</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/vJS6WsGpboCe4r5.png" alt="添加key" style="zoom: 33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="center-部署博客-center"><center>部署博客</center></h2>
<p>打开电脑的：Windows PowerShell 进入博客目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save  // 文章部署到 git 的模块</span><br><span class="line">（下面为选择安装）</span><br><span class="line">npm install hexo-generator-feed --save  // 建立 RSS 订阅</span><br><span class="line">npm install hexo-generator-sitemap --save // 建立站点地图</span><br></pre></td></tr></table></figure>
<p>依次命令安装</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/ADRph3ibdqr6wjY.png" alt="结果" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>全部安装完成之后，一键三连部署上传</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo cl &amp;&amp; hexo g  &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<h1><center>GitHub+Picgo图片上传</center></h1>
<p>Picgo下载，修改安装路径，其他一路下一步！</p>
<blockquote>
<p><a href="https://github.com/Molunerfinn/picgo/releases">地址</a></p>
</blockquote>
<p>注册GitHub，注册过程不详细展开，不会的百度一下</p>
<blockquote>
<p><a href="https://github.com/">地址</a></p>
</blockquote>
<h2 id="新建github仓库">新建GitHub仓库</h2>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/dR5tQVzMIGZsXmO.png" alt="新建" style="zoom: 33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>填写好图片信息，创建即可</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/1x6WyFLjSmckINR.png" alt="填写信息" style="zoom: 80%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="生成token令牌">生成Token令牌</h2>
<p>点击头像，点击Settings</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/RXkvA9QybLqfjUx.png" alt="进入设置" style="zoom:33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>滑到最后，点击图中圈出</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/RK7oqWrXAsdtH31.png" alt="进入生成令牌" style="zoom: 33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>按图中顺序依次进入</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/S9KrUbOyA3mCks4.png" alt="选择对应选项" style="zoom: 80%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>过期时间：<code>No expiration</code>(永久不过期)</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/LzcklmEHJ7U93Fw.png" alt="设置令牌信息" style="zoom: 80%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<blockquote>
<p><strong>务必将令牌保存起来</strong>，放在一个安全的地方，页面关掉后就看不到了</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/acvK3dnykuBI62Q.png" alt="生产令牌" style="zoom:80%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="创建img文件夹">创建img文件夹</h2>
<p>回到刚才新建存放图片的仓库，新建文件夹</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/Tmjdut3PbeZvG4l.png" alt="创建文件夹" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>给文件夹命名</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/CaPxDSzTrLyRYAo.png" alt="命名文件夹" style="zoom: 33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="设置github图床">设置GitHub图床</h2>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">自定义域名需要配置为：https://cdn.jsdelivr.net/gh/用户名/仓库名，这样就才可以通过cdn访问图片</span><br><span class="line">仓库名：GitHub用户名/GitHub仓库地址</span><br><span class="line">分支名：main</span><br><span class="line">Token：GitHub中设定的AccessToken</span><br><span class="line">自定义域名：https://cdn.jsdelivr.net/gh/用户名/仓库名</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/9CsJkxDIVQfbi75.png" alt="Picgo设置" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>点击上传区上传图片，上传成功之后</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/cKNE3A47CkaQYR8.png" alt="例图" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>如果提示网络不好等错误，可能不稳定，稍后再试试看。或者可以重启试试看!！</p>
<p>在Typora中，文件-》偏好设置中，设置成下图，将语法偏好所有选项关闭，可以避免直接复制图片进Typora报错</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/DMqkKLRu1txbmwg.png" alt="取消选项" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>仓库可能最多只能存放1g，网上说的，所以最好快到的时候重新建一个仓库</p>
<p>差不多到达1g，重新建一个仓库，建仓库上述有说，但新仓库不能与旧仓库同名，可在后面加1，创建完成后，其他无需设置，在PicGo设置一下新仓库名，和自定义域名后面的仓库名</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/oSRC2aWPF3sY1Ai.png" alt="设置新仓库名" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h1><center>gitee搭建并部署</center></h1>
<p>目前页面已经停止服务</p>
<p>点击加号，选择从GitHub仓库导入（目前已经不能部署）</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/gDcXrCp9GEyOiH3.png" alt="导入仓库" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>选择导入GitHub仓库</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/BXnIlNCqthLOi8Y.png" alt="选择仓库" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>导入对应GitHub仓库，此时需要注意仓库名字需要和你创建gitee时的名字相同，如果不知道名字可先往下看，中间可修改仓库名字</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/nJ7wx2daIjc56Pk.png" alt="导入仓库" style="zoom: 33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>查看名字为哪个，可看浏览器网址，中间名字就是</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/ICPowKNlRxyDAtE.png" alt="查看用户名" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>设置仓库为公有，为了可以开启pages，进入仓库，点击管理</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/Cz8o7NEZ3QtP5Al.png" alt="进入设置" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>基本信息最下方找到，是否开源，点击开源</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/OduA1s2Q934ywKj.png" alt="开源" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="部署gitee-pages">部署gitee pages</h2>
<p>进入对应仓库，点击服务，点击gitee pages，此处需要实名认证，实名认证完之后才可以开启</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/5QOfA96RoJnbcvg.png" alt="部署" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>进入之后，直接选中对应仓库中的分支，点击部署即可</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/JLdVrum8DTPv4q1.png" alt="部署中" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>GitHub上传部署之后不会自动更新gitee，需要手动部署，只需要在对应的仓库中，点击仓库名字旁边的旋转图标，强制更新即可，更新就直接部署了，不需要自己再进入pages重新部署</p>
]]></content>
      <categories>
        <category>技术积累记录</category>
      </categories>
      <tags>
        <tag>博客搭建相关</tag>
      </tags>
  </entry>
  <entry>
    <title>营业执照相关</title>
    <url>/post/ff4327d1.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="c0772de6bc64bc381ce6df6a7a5f496b07711c665f65cb3dbcf83cab3d50d764">d0082e95ce53ece4a4c0f5b8a727fc3f533e28ce2694a547a3622e7901aaededac1a35633401a8d097841e1e149d3cc4e5dba9dc285053d6310ca7cb20ba6a08f2befafd658b32718b33566b9add48ee075d53ddda5a06d5dc019ddbbc4df336f54482b9eee46cff9992e9c9ae8c0eb1e4bfa16649d0b45238e6b516749bc1a806243a66d83a20fb904ecbc67e5281bf224ffecf4f6f875673066e203e967ab67a336a5faa61b599e2bccf68f5d3f4d6651c47cb8efc826a88328ff8f83bcea703d60b3e8a24be8e5cafe23c9bc9736b06a9090e0ddaa593db6f108c16b291dd78ae1f3345fcad07c47ccea51bdf776780ef40beaf2a495f0b82c1a125c2df70372f195f9ed86ab61fb363afb08522d76bd205482419196dea82ff42ef610cfbadd134951e4bffaace3ef05ecda7af517ace1c2a9707463c223a707ec80e15f8dd32959a9e39c87d1ce6dd909db0e3dcd35f44fb8b20de4a5bd976e38e38b14d55ba343073715fc8181de37cc0e0af3efd2151b5dc771015c4a64ed60532ad24b6737da52841d2fcd1725c064f13f4914b6a182ab9addb0439bb18c1aa07393ab627428e5a8d41f2d8209c377ebe1f268af5bd1a3f0a21cdd5d5d02c5e1d8843aa10f056083f27daa094917d9626488fdf45c9396f61c9635ec89901b72e15ed5ad562fbce7f8a6cd0659abe9ca5ebd4a7a389fe8740053333e18812d43c281369b4b87013a9c80532cd10d56a5ad020fa5baad1bfc874743d64a5d9a8cb8cdfa60668338b4b90ee53527aff034537d43c6e0d1547647945f2692508132196e30c9392626cfd9ea274362f1d61d260b2a871193954fbaf860cf278c56b43518e5f11f454b5f319ea497222f43c8d98ded57db06cc7d91dd54952dbc7c725415fddb6f3c7533cae769c08788f8ada75f3eb7f1fd976ace290635ec956f51d413b391996a640e37476c1737f7bdcaeacff413e43e5ca1b98e8dddaaf366e26408d5f921f7347127861000ac07e53c5715a903ac3c6d7adda4ec3ce76f65607387bc62ef9519393372f44123689fe575948576a639d9365a7fe4b9f15ede70b7e528d21e0e9a6028a7bdba35f2028c7852b00886f52453c9ec178b9631c5e2983cd2b23b7eb0843d8de65e6a8970e391924409bdfec8beb0dd9f78fda8129ede9763b4843e84c47be46defe483a447099cbcaeb5ed8616dfc0c6f1286681651212dc9648193ad5c14a01021328b3ee6907dd006fb99963fe991a42d070982adf4ac6faecacae2c0f38b3b47a621bc70762d480140ae2c67a76940667492f92bd653008ea666eaf534f0858f3f9c844c93608585e63360479481a6d08f30b71e511e7ddbf7c98e81bf9113dc2dc9daa65edb5ae1fd9300ceb1a3501ff47cca9dcdc23b04251cef6d21d0a655486dc01ece08d7b2f5d42153721ddfa56165686ee849b1306bd4cfe6688f1133bcc8bd48fe1f5549db7e6e63bd0f92303c16e4bb5017abda09df8ed55b730cdbc925739f29f371d20947b107583ed1ec7a29ef21d3d5de5684430e07f46e72fb1ad52b6ecb11612a93c1bcacecaebc1642f54aa23759dfb48079a445dc93df825f75f9c8474d0b31a26a084c878081a9bd35a313b710c937253c1a33d4e9d49ba1d3cb10bb24d95028cc50f059b9c516b07a43c1ea0b2b095fe17b4b2704a4bf882bb22f27ffe5c3a94acb4b33f3a75a6243b6b1759a497ba55e4a298d252b7d929007716a7950bed64419bb86a932c9597495d355532ef298a3196629e2cd29833e363147772fe1839681006e3b4dc0db67e228154fe9e0e2ec11cf85d9947348cf055e34e3964c33fd19b52b4a8709bb351e16a6fa2ee8228acb37e15495f2152e844ea101ecaf059f2fc4660308833440ed041845fcba7acab6cd54c46ef604cb39e31ef2660ca074ab3b0cf669cc30dbc974b09ecbdc3882c8eecb79443d0ac9fb4d9fcaa09757a81d091c2e0d588f7a7ae46051a675aa30b5f1640cda72ee891de3ec8307b2f58dd2a8d484c7166a414539c0beadc7e1e0b3a9f33920f62189f9d4ef5035d24640007cf74195a488ffa77941b4b61646c9fe213c7dc3d69fb2020bdc1bfafe613b8c7de6b30cd28d1d2693c39164c5be83d1ff871c9da168cd42e6f13a2bf6c06d51fb4af4086558dcfb3eec68a8f6186b0e9b62183329e4421f49c37aa262a1e1c1e566b20e272d9cab3e04a26627dc6d4753a5e1fa1de650982591cd8af07885554f55a8cb91370f2b4bc8ab343cd46a4ce1486b4aa39a358cb7f59c4a637c668463cd3e22483fa1580e7b41ad5e09c71aa188a2c556dfc8794fb1f4459da5854658a7119eaf4e62b642d668bbab96a25da560864b9b25d7c831415c4ba38c4ccca50cd9b3649d6e990f4899b412a30052025429d8daf0d53b02da25581f1aa987d927d35fb5b67ba8345509046bd84c73c987b643886ecb1e73260097c4a02482b904fd50e66800ad64160acc4190aec90ad03d7527ba1aa5adc3b6a7c9b79ae65f994eea09658ed0077f08a057cdbd21025850e85cc4b4af659467a40a5395aa8616a134d3a0c77a2c1a91d6ca5fc9b31aefa382a2235c5d20e2e738b881ce53f79891446f1050606ee1ed14c7e3832fcc0897290122795027b1fbfa9740c0e9a5fa8a2087c4ab18782281052d8f3be48fa1102a8aac8d7c5b5c74cf566a986ba34106a164cb2ad9a996b698498a25437f756bad83d4ed0a70b9cc7faa4aa70d3e03002089e22fad770601c61c413c6724d1dff85c096040ce8bbafc258fdda4e8fd138aad267f6dbbde378bee98680c53d8b9b5917b06b194fb19ac3afb4a3f21037133e7bb939d487c6947ad26e67fde0ccceea56acfe63f69ab9d92f7d1d971fd44db7ef98e2901900f3f268d0e71c350003e92c44a454d3c7bd93155bd3ed4d5951b3fc705d11a0183ceb484bf4c6751e8205c308ca8feda793efbf1543793372adc90328868e8dee66507a2637762f43a2b38ddaa92090d70cd59968baeac62ec1821a35165f796345a61ff0b1178e5d27f9920605f8c138de122358427484de6190f891e154a20d175b475aeeb24c684af49552827c93f340bfc495da4294a59724b8cc6bba409c87a9f9da5b9bd328b6ad293423c53729ae4a8d4f8129301a1724bead803b2c2b04a956103b1114313c1dd0084eb3a9d344865714998885a114808024260cb03ba911738ebea1c853fd251eec03330e7fc55dece447fc8c39fd55fac6f52f5ce2c79ee16c126ae72de7615e7b490d61aacc7e09034b8cde8760f9dac34383ac96c15440165a0d4a3985420047241d444ebddd8a4fb7ab375860b3e02f41ece1cece805f5c89a0db279f0a09da4f7594551ae4d708fcfc3852e505d9e8ee0d1e9f1a861f520972a345038cecadde98cf358a6205d4d7357fcfdaa1ee8ccbb1ce7bbc0ca20deb113aa814bdff039ee98a62596175cec9482f5c2241394a0dd3c23a5be586c7568ea7c7663672aed053299c75f25d08d4d330bc64db6204e6cde7dd1cd8dc043b67bb59f41965bf907402ddf98311b258208ca7c82cff1ec1fe7432807ab32233b9dde3afd728f3c1b722bc1c02a8aa152372465e9c33dde7745d2e936082d582853ef07e47eca329294e58fbd32156891c0c52d1870732d7b326e4db3a4b228a8e811263e84b150138958f8a0dd470bb42c68e60362a39c6d3e2e6800635ae1f3e1882bcac985a7a43dd1ed81680a7766fbd2191b39366fcb7ecdebe6a43c3789260f839d7df7097a650be7a68ad2e38bbb2836516b75061721d69cd1bcc8e3f4a3255eb50d1bfa3a8d8b17b119c707e4f5464ceb6cd5cfcd0a6b8e27efc9e10313c6558634a0983f6f2c66d74eae9c2dabf29e4444c0e29e1da0fe73d2c5adb5bada7397f3ae840da451a140acb67fdcd388cdf7b1caf30580d049e3ddb9726a65e2b34e3c6655b5b995cc4a46b33dca99f5f59c52e0c5a90523feb89d96058aad2a389b413377c257795d7dc1f9ef3e7d28768d735cce645bea177d9c705f07fedecad75db1b2e7048f6a63b625d3495408c0ee2913a06e250d93337ffa6a937226d4e271267203a5c67f9e5c2db596eb0eef39ea6ee3de8f520ed7f48b0a241d7a631f4e2ff4cb66fb1ab161b318bb545ab48f776c4e55fd689e1bb9de3c54703736ef1bec4e9521dc3173f88466286489f52835d426c4ffdb3d96d8ab8180e023b267e4257073454f14a078ae739a5cd291f5f3a01b423c4bfc7b6dfa239ffc6b2162e541cebb0dbe602abcf6fe5b5bb87232b044a4f6f6ed159dbf9cc5d9d7db9891abab7e626e005b7371e0f126f05da4805aa0a40921ea76a2d9b1f1880ead5b0c5a5a5973673d81017a4038d7b480e5a2507cad83bbf5b5cd2bff47c75c49459c663c2e145f78d53dbe098451f21e2c0ae8c7e1a1a5e8b6194340080d2535f53f250f40bf033294a2a3fed288e7498e4eb2b6fd198f3cf5144864f786ec0eb27133369ed772d581070c9309f4233b72740394c31ce69e85c2ea6e1c2add407ab7e5c95026247b40d56ffc31c6302581ad918199bc0506081fd1a3a7947a19288f7172ecbd1f7607fab487e7f3c2262e8bcce520dcbf74c4915eb9e57af8e06057bbb46d9415f8f65d1c6b7c384ad375b44f612f1a8f6e3e50920d9eaadc47e32d159fc6d5cf757b15bc60b136de11a2a543b02a9d562cdfdd01f682f095ea5176bb403a5435d9e7c3e7dded311abed9ed3b96af1f72c5ecda918a212ec1e1922713020003c22b9fc34ac23c32d91ae72c85b3e33462219c584acf275d2a7beb0c6a6caa85267cf7e407bc7c410fddfabdf71759e8f0882bf91de4b05466afaed6d1b0514af65e4a3b9c8bacfbfc819a884e2fcb77e88215778557ad1a346a287d84d18de402843419812b08127011001055b945562f85baad74fa3fdcabb1eeb4644e12e0380514dd60ce742eb93b678496cd8765bbf6862a9fde955e3a48e5fe03530f56899a3c4abd5f1d834da59a3ee39434f15ee5c4aac621521270648a956a78c4dbe284f68e189ef034a22278684c1d78afa5d08283cf0bd05cdffbc79c5157a064825be3b0bb50709adb3ae0626fdc2075cdf253dc778b19be43fc2b2d4585fe341f6f85eec5db93d875ec3f07c5702c02e41b265271d5017796b821da45deceee052896e1021ac6efc259810dd0e5318503a41a59eb097cc36e00b4afe5617c1059feee9b67bdb8263d5f987152cfa104e925accd0a36b17853153c85e3d5d72ab960e0c320e8503b38f7f219eea7bcd17e8787ae9d37e0a88205c60ebbff8a0c8350874729bb2c735f3a6c03c6651d1ff3b46d2a5f9e741ed0f7af099a17ffc0a68891888b65335193251196038c4fd8b538bf2c4e6dcf1080cf0092bd7b3eab415e6b5cd62aa5777bed1327e1f2bdfc40a35a47eac788877941aceee8abad2ffd925613985c94a8eb806af9dd6c1f10a2343761b29d0b6e26127fbb81fbd2a173e516a59fcea7dbaced50140811d17168a19422aeb0a97f61fd05d93b126cf5028a2bdc2462b6fbc0eaf18cc36cf89cfddee0e01448b4eeba2e46313bdf33eda2aab5753ec7c2725b098e732981a20c98788aeecf05a7cc96236377db91da36d4bacbad5399bbff99e7dbce56517a096b2e5f6a07ec242856782fa342a935e3dd540e4bb68f62ef24a250e68e0f264710d22af2c4666b73ed73be0468eca926b85ef331ca5e42d7bfed41ff86fb1abfa1a23cd4bf9e43b4aae1e525d6c9129d9648d6a08ac26332bc38da3a89b0c14af1cff2cb639b18e107ed19c69fa6e8893a3c27b0776af45e15c0e1e1b86c8c4c144e286c3f4f1600d906008302b04e9d6d5dd4cea6a6cb4df2e1cc4eebcc3bd3fd1d2f8f923b9fdd16b0bc079ac6e3b156be270b8573b06b6b476cbf0587465de4f57027d938725b2c5a3d36029fef8a368cb93df73361c78035d8b71cbe25f31150225c7d0bae4c7a2855e816b07dd45842dda4fad298cae39cec5e59b9fde2550ad345227297bdded26f2b2a496e546a2c51ec637ce298431b82121926003bb74c57a39d59c84c03f8868274b5b2974cd64d914c2bbbbe59731819277c5bad825763d030e5282c3e213c118b5a26ec69071c97304625f3aaf03ef1f096f40d3a0b14aebe5fca5c5599e20a93d858e0643ed04f513dcc1360e3d3a2e1ab910f8baa5b1c8d4be7649bfaea1691f6d572649c4cec4e3e27569e3cd494bf52dc3556d1278b78b1f7dd6d63c84cb581e198794ea1817fd5b7aa9ddca379f8601dce5f044fb962da6e6f37d1d2c56e244bcaacb4f71230e6bd678dbd5f6d8b3ac94d71dd160d32ff3772bfa7bdd32e1520bf678b14ed3dfc15e33563a5e01ddd19a5f380ace0ea0edb9af7a91dbd44692153c3aa78dc9b14cb194b3437b7ae7d9a837bafda60c266d004dc21609c6a68d71273555ce96f1f7c88ce7fc3210c331d96b049cac60e1336ecbe3bcbb91b5399f2c89b57025fa452dec2c3f2e2307979579e4f1da4c9cedfc07a1b7cd65fbf1654b04659f3465f867b203c5a9e9a338edd6944729d6bd0e80ece1d4435a9abd9de9c5c56c3136b02eaff346abfd8230c66b43f98b781b7d927f5221ed492bc171751947d92ac266be1f0744929c566e492d0f55096a879a79ece5f411d176ddb925754195fd31e236b5c2202533128a586358ccd4494e24d7681c1bb088f9980488518516a5cae58e08f46e8649fbe5b6bd2f07a9b2e558b95e86dea0a219cbed3e060b34f613029088a3c66063b58b2a57a76084e3e6ecb353703f59f5b718fcfac7574633a2409895468ac7252a5ee7912a814cdd3627aa577996ac00320d1c4ae75b386e69d58aaf53808bb026fb5a93fa8b4d180a1c388fdd1edb301a8f009158964c7a2cf1a80797a607c2f1dafd03aed1db2ebcd4357490c7e1ba785086749ac9ccb8274b873b3a22c6719109c9fbe6e7637b84227bcbfa5645c3a92ab31183d1030a815accf0db29d8a418f7076c4d082b43a31e742bca2200830221a0caeafb55a1851b7020aeba0035f5117e4067de22873babb2d3ff05619cbb71544387435b035d87ddf87f73fd05deb018a85d6fdfa9aa92cc3132f4156ab158fb8a8a2be2acf1fd130f8bc41ce6404a13c5e98fb76f754d7ec6dd3366d6501d88f112d68b7cdc65d8a50d7e3f601a25fcf387dcf70d3f08df34168b3123ebaaaef35075679f61769ccb36575b351913a885a90e4bea9c5f568ffb53b870e8706cd61efaa50cadf7f40a05e81b9ab0a45982029edb80abdcb3ff5d4b99590ce114f62b27f366ccaa21c0fd1fc321dd15a535a0d2105834d09b03614c39b94867a3ac048914f132d8ea772639e2edbdd8542499172104093974afd312688c1f7020ea9d372e4d88f4c14bc1b120c7fe55cb4a868f39d1a2599e3febccc1e3defac60ff9e312f92027e6f7664d9a238897bbdffee48acc5919a3eeeeee9068b1e45b3e17d6d34885ec9322e22384bff5711eb972157</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章。</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>技术积累记录</category>
      </categories>
      <tags>
        <tag>营业执照</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言相关报错</title>
    <url>/post/c4236caa.html</url>
    <content><![CDATA[<h1>DHT11dht11.c(18) error C174 return-expression on void-function</h1>
<p>表示在函数dht11.c的第18行，有一个返回表达式出现在了一个返回类型为void的函数中。在C语言中，如果一个函数的声明或定义中指定了返回类型为void，那么这个函数不能有任何返回值。</p>
<p>​    要解决这个问题，你需要检查dht11.c文件中第18行的代码，确保没有返回值。如果该行代码确实需要返回一个值，那么你需要将该函数的返回类型修改为非void类型</p>
]]></content>
      <categories>
        <category>错误记录</category>
      </categories>
  </entry>
  <entry>
    <title>博客CDN解析</title>
    <url>/post/e9f3074a.html</url>
    <content><![CDATA[<h1><center>HurricaneDNS解析博客</center></h1>
<p>首先需要一个域名，之前已经写过域名怎么注册，参考<a href="https://d3iiz.top/post/b7e3ace9.html">地址</a>。这只是个人推荐购买的地方，没有商业目的</p>
<p>购买完域名之后，我们打开HurricaneDNS：<a href="https://dns.he.net/">地址</a></p>
<p>先注册账号，注册过程按照提示填写注册即可</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/09/15/9rHzZocQWgap48L.webp" alt="注册账号" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>注册好之后，我们直接登陆，直接添加域名</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/09/15/4ILlDvqd7FkwuA1.webp" alt="添加域名" style="zoom: 40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>输入购买的域名</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/09/15/VsTESFPkj387ZMH.webp" alt="输入域名" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>进入添加记录</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/09/15/Kl28CdUDrSFE1aL.webp" alt="进入添加" style="zoom: 40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>添加对应的类型添加，按照如下方式添加<code>类型为A</code>，名称为<code>@</code>，IPv4地址为<code>185.199.108.153</code>，<strong>按照上述方式再添加以下三条记录，类型和名称和上述相同，IPv4地址分别为</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">185.199.109.153</span><br><span class="line">185.199.110.153</span><br><span class="line">185.199.111.153</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/09/15/g3k21tdcvyoixLP.webp" alt="添加" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>添加好后我们去购买域名的地方，<a href="https://mi.aliyun.com/?spm=5176.29045373.J_2177541330.5.3d1d183838ot1j#eyJwcm9kdWN0VHlwZSI6MiwicXVpY2tTZWFyY2giOiJbXCJcIl0iLCJrZXl3b3JkIjoiIiwiY29uc3RpdHV0ZUFyciI6WyIiXSwiZml4ZWRQcmljZVNlYXJjaFR5cGUiOiIiLCJxdWlja1NvcnQiOlsicHJpY2UiLCJhc2NlbmQiXSwibWF4U2FsZUF2YWlsRGF5IjoiIiwic2FsZUF2YWlsRGF5UmFuZ2UiOnsibWluU2FsZUF2YWlsRGF5IjoiIiwibWF4U2FsZUF2YWlsRGF5IjoiIn0sIm1pbkRvbWFpbkF2YWlsRGF5IjozMDAsImRvbWFpbkF2YWlsRGF5UmFuZ2UiOnsibWluRG9tYWluQXZhaWxEYXkiOjMwMCwibWF4RG9tYWluQXZhaWxEYXkiOiIifSwic2Vzc2lvbkNvZGUiOiIxZXhsWEVsYTZsRGhfb21sT2M5ZzUiLCJjb25zdGl0dXRlIjoiIiwibWluU2FsZUF2YWlsRGF5IjoiIiwibWF4RG9tYWluQXZhaWxEYXkiOiIiLCJ0YWIiOiJzZWxlY3RlZCJ9">地址</a>，进入控制台</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/09/15/aeqmkODdHWJR2Tt.webp" alt="进入控制台" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>进入域名管理</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/09/15/MJcFN2Q1eI7Wskq.webp" alt="域名管理" style="zoom: 40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>进入域名列表，点击管理</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/09/15/rnDvMPG4HOz3cKu.webp" alt="进入管理" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>进入DSN管理，修改DNS</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/09/15/MJa9YqTlo5r7ykf.webp" alt="修改DNS" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>将以下这些全部填入</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">NS1.HE.NET、NS2.HE.NET、NS3.HE.NET、NS4.HE.NET、NE5.HE.NET</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/09/15/I64lukWEKFfXGTQ.webp" alt="填入" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>每次上传好之后，需要去GitHub对应项目里面，进入设置，进入pages，设置一下域名</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/09/15/mO3v1W6yClHwI4s.webp" alt="设置域名" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h1><center>cloudflare CDN解析</center></h1>
<h2 id="center-域名购买-center"><center>域名购买</center></h2>
<p>阿里可能需要实名认证等，在注册账号是，按照提示注册即可，购买期间若需补充其它信息，按要求补充即可</p>
<p>这里选择阿里云的域名，提供的这个的非常便宜实惠的域名，但是续费可能就是原价，可以一年换一次，购买：<a href="https://mi.aliyun.com/?spm=5176.29045373.J_2177541330.5.3d1d183838ot1j#eyJwcm9kdWN0VHlwZSI6MiwicXVpY2tTZWFyY2giOiJbXCJcIl0iLCJrZXl3b3JkIjoiIiwiY29uc3RpdHV0ZUFyciI6WyIiXSwiZml4ZWRQcmljZVNlYXJjaFR5cGUiOiJzZWxlY3RlZCIsInF1aWNrU29ydCI6WyJwcmljZSIsImFzY2VuZCJdLCJtYXhTYWxlQXZhaWxEYXkiOiIiLCJzYWxlQXZhaWxEYXlSYW5nZSI6eyJtaW5TYWxlQXZhaWxEYXkiOiIiLCJtYXhTYWxlQXZhaWxEYXkiOiIifSwibWluRG9tYWluQXZhaWxEYXkiOjMwMCwiZG9tYWluQXZhaWxEYXlSYW5nZSI6eyJtaW5Eb21haW5BdmFpbERheSI6MzAwLCJtYXhEb21haW5BdmFpbERheSI6IiJ9LCJzZXNzaW9uQ29kZSI6ImV6bXZHaF81WWEyVGtxNXZGMEs5cyIsImNvbnN0aXR1dGUiOiIiLCJtaW5TYWxlQXZhaWxEYXkiOiIiLCJtYXhEb21haW5BdmFpbERheSI6IiIsInRhYiI6InNlbGVjdGVkIn0=">地址</a>。</p>
<p>购买完成后，在控制台看是否成功，可能需要等待几分钟</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/08/19/PCDavO6Ws24dxqF.png" alt="控制台" style="zoom: 33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>进入控制台后，进入域名控制台</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/08/19/nxbOyZ9dekuaqiQ.png" alt="查看域名" style="zoom: 33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>这里可查看域名</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/08/19/C6uaRMOSYngUb3A.png" alt="域名列表" style="zoom:33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="center-修改dns-center"><center>修改DNS</center></h2>
<p>在域名列表点击 管理</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/08/19/JHVeQP26MWrxYlF.png" alt="第一步" style="zoom: 33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>修改DNS，添加需要的</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/08/19/praL8wKd2TtJoqx.png" alt="修改DSN" style="zoom:33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="center-域名购买-center"><center>域名购买</center></h2>
<p><a href="https://www.cloudflare-cn.com/">cloudflare地址</a>，进入后直接先注册账号</p>
<p>设置成中文，进入网站绑定域名</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/08/19/3dOVXtECnAIUvuM.png" alt="进入网站选项" style="zoom:33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>在左侧栏中进入网站一栏，点击右方添加站点，第一次可能没有这个，但中间有一个可以直接添加</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/08/19/2g4ZDBu73IUnQzL.png" alt="添加站点" style="zoom:33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>输入自己的域名，注意不要带<code>www</code>或者<code>https</code>，比如我的就直接填写<code>qinyu.space</code></p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/08/19/eOshYyxlUoM3JpP.png" alt="添加域名" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>选择套餐，<code>free</code>即可</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/08/19/CmZ18OLqXItDFw7.png" alt="选择套餐" style="zoom: 33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>点击继续后 cloudflare 会自动扫描域名的 dns 记录，如果是刚刚创建的域名，可能扫描的结果为空。<strong>截图中的几条记录可以不用管</strong></p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/08/19/vQ3KEqijzxAnGm4.png" alt="添加DNS记录" style="zoom: 33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>这一步很重要，点击添加记录，按照如下方式添加<code>类型为A</code>，名称为<code>@</code>，IPv4地址为<code>185.199.108.153</code>，<strong>按照上述方式再添加以下三条记录，类型和名称和上述相同，IPv4地址分别为</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">185.199.109.153</span><br><span class="line">185.199.110.153</span><br><span class="line">185.199.111.153</span><br></pre></td></tr></table></figure>
<p>完成之后应该能看到列表中有以下四条这样的记录，除了名称是自己的域名外其他应该都和图中相同</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/08/19/tKYZCgTSnbExFhm.png" alt="添加后" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>上述添加的4条ip地址均是GitHub Pages 的 IP 地址，具体可查看<a href="https://docs.github.com/zh/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site">地址</a></p>
<p>点击继续后，往下滑 cloudflare 会要求将我们DNS服务器修改为以下图中所示的的服务器，可以先截个图或者存文档里</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/08/19/XynqkHMOZBagd6Y.png" alt="DNS服务器" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>点击下方继续后会有一个快速入门指南，里面的配置可以都开启：</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/08/19/yZEQ6RPhUNkgYfn.png" alt="配置都开启" style="zoom: 40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>回到上面讲述修改DNS，DNS服务器更改后生效需要一段时间，少则几分钟，慢则需要几个小时</p>
<p>返回 cloudflare，如果看到 “Cloudflare 正在保护您的站点”说明已经配置成功了：</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/08/19/cO1BGk7CXFNMeTU.png" alt="配置成功" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="center-设置github-page-center"><center>设置Github page</center></h2>
<p>进入github.io对应的仓库，进入 <code>Settings</code>：</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/08/19/oe5MBzLKwDOriES.png" alt="进入设置" style="zoom: 33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>进入左栏中的<code>pages</code>，在 <code>Custom domain</code>中输入自己的域名，点击<code>save</code>，如果成功会显示下图：</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/08/19/x7vT54ZHGwgaWCM.png" alt="添加域名" style="zoom: 33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>这样就可以通过域名来访问自己的博客了，还可以在上图中勾选 <code>Enforcrs HTTPS</code>，这样网站仅会通过https提供服务</p>
<blockquote>
<p>如果如下图显示dns配置不正确，推测可能是使用了cloudflare后，GitHub验证DNS时返回的是cdn服务器的ip地址，而不是在cloudflare上开始配置的4个GitHub page的ip地址，可以在线dig一下自己的域名验证一下。不过只要网站能通过域名正常访问就没什么问题。</p>
<img src="https://s2.loli.net/2024/08/19/1aWPU4ry8Obgj9l.png" alt="提示" style="zoom:50%;">
</blockquote>
<p>本文参考：<a href="https://qinyu.space/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%88%A9%E7%94%A8cloudflare%E5%8A%A0%E9%80%9Fgithub%E4%B8%BB%E9%A1%B5%E8%AE%BF%E9%97%AE/#%E9%85%8D%E7%BD%AE-cloudflare">地址</a></p>
<h2 id="center-cloudflare自动部署博客-center"><center>cloudflare自动部署博客</center></h2>
<p>新建部署，绑定GitHub账号选择对应仓库绑定即可</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/08/19/uFgSrPBvxpLb4zK.png" alt="新建部署" style="zoom:33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>绑定自己的域名，这里的域名可以设置成自己的子域名，这样就可以拥有两个不同域名的博客，详细设置看下文</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/08/19/sF9ChQeiypZRMO7.png" alt="绑定域名" style="zoom: 33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h1><center>DNS解析填写</center></h1>
<p>首先进入我们购买域名的页面，这里以阿里为例，进入阿里控制台</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/10/18/vQn5qXW6f2om1Ul.webp" alt="进入控制台" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>进入域名列表，进入管理</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/10/18/AGVXw4joN2W867y.webp" alt="进入管理" style="zoom: 33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>这里的DNS修改，意思就是说，你DNS要选择哪家来控制你域名的解析，例如：如果你域名想在腾讯控制，填写解析，你就要先去腾讯的DNS服务添加你的域名，然后将服务地址复制到这里更换，更换完成之后，以后域名的相关解析就在腾讯控制，不在阿里控制了</p>
<p>这里一般选择一家即可，不能添加多家的DNS，这里我是配置到腾讯控制</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/10/18/AGVXw4joN2W867y.webp" alt="DNS修改" style="zoom: 33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>现在我们打开腾讯的DNS：<a href="https://console.dnspod.cn/">网址</a>，添加域名(可能要添加TXT记录在原域名解析里面添加后验证即可)，然后进入解析</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/10/18/rbXqHCJnjApLdu7.webp" alt="进入解析" style="zoom:33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>进入解析页面后，点击域名设置，可以看到我们腾讯所属的服务器，然后去阿里的域名管理将DNS修改成腾讯的服务器地址，则就完成了，如果你想更换别家的NDS也是相同的步骤，先添加域名，后查看服务器地址，再修改DNS</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/10/18/GkumatOXyT5VUez.webp" alt="查看服务器地址" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>现在来看解析里面应该怎么添加（以腾讯为例），对应的意思是什么。一般www.主域名等于主域名不能作为子域名使用</p>
<p>主机记录：</p>
<ul>
<li>@：则你原域名</li>
<li>如果写了别的则就是子域名，如：xinzai，则为xinzai.主域名（注意：www不能作为子域名）</li>
</ul>
<p>记录类型：</p>
<ul>
<li>A：将主机记录的域名解析到记录值的服务器地址</li>
<li>CNAME：将域名指向另一个域名地址，与其保持相同解析</li>
<li>TXT：一般添加域名等作为验证用，一般验证的时候会给出<code>主机记录</code>及<code>记录值</code></li>
<li>NS：一般是将子域名交给别家DNS解析，也就是，现在主域名是在腾讯DNS，子域名要在阿里解析，则需要选择NS</li>
</ul>
<p>记录值：</p>
<ul>
<li>记录类型为A：填写解析的服务器地址，例解析GitHub的静态博客，则将GitHub的服务器地址填写进入</li>
<li>记录类型为CNAME：填写域名，需要指向的域名</li>
<li>记录类型为TXT：按照需要验证的给出值填写即可</li>
<li>记录类型为NS：填写你要在哪家解析的服务地址（先去添加域名，再查看服务器地址）</li>
</ul>
<p>TTL ：</p>
<ul>
<li><strong>指解析记录在 DNS 服务器缓存的生存时间，数值越小则生效越快</strong></li>
<li>600：一般默认值，如不了解请保留 600 秒即可</li>
<li>3600：当记录值较少变动时，建议选择 3600 秒，有利于提升解析速度</li>
<li>60：当记录值频繁变动，可选择 60 秒，但解析速度可能略受影响</li>
</ul>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/10/18/Tl2pAqLsgbdf1KD.webp" alt="解析例图"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>目前我是这样的，域名在阿里购买，再阿里将DNS修改为cloudflare ，后面解析都在cloudflare 添加和删除</p>
<p>主域名在cloudflare自动部署页面绑定，再使用NS解析，将子域名指向阿里、腾讯，在阿里、腾讯添加A解析(GitHub服务地址)，再去GitHub页面设置绑定子域名，这样就两个域名访问博客</p>
<h1>Cloudflare 和 JsDelivr 免费加速博客 GitHub 图床等静态资源(失效)</h1>
<p>使用免费图床，参考已写博文：<a href="https://68565200.xyz/post/2ec6e870">链接</a></p>
<h2 id="center-前言-center"><center>前言</center></h2>
<p>本文通过学习此博客编写：<a href="https://www.haoyep.com/posts/github-graph-beds-cdn/#%E9%85%8D%E7%BD%AE%E5%9F%9F%E5%90%8D">地址</a>，通过 Cloudflare 和 jsDelivr 免费加速博客 GitHub 静态资源(GitHub图床)，自动实现 CDN 资源的海内外分流，加速博客访问速度</p>
<h2 id="center-配置-center"><center>配置</center></h2>
<p>首先，要配置好域名以及DNS，本人已经写了配置域名以及 Cloudflare DNS加速部署博客：<a href="https://d3iiz.top/post/b7e3ace9.html">地址</a></p>
<p>进入部署好的DNS</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/08/19/wByunPAEVNeRHhr.png" alt="进入" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>在 DNS 配置中，新增一条 CNAME 解析记录，并启用代理。 如图，我这里是将 <a href="http://cdn.haoyep.com">cdn.haoyep.com</a> 解析到了 <a href="http://jsd.cdn.zzko.cn">jsd.cdn.zzko.cn</a>，并使用 Cloudflare 代理（点亮小云朵）</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/08/19/sWP96IXVZEliOY2.png" alt="添加记录" style="zoom: 33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>目标：资源链接都使用 <a href="http://cdn.haoyep.com">cdn.haoyep.com</a>，Cloudflare 在代理 <a href="http://cdn.haoyep.com">cdn.haoyep.com</a> 时，判断请求来源是国内，则将 <a href="http://cdn.haoyep.com">cdn.haoyep.com</a> 重定向到 <a href="http://jsd.cdn.zzko.cn">jsd.cdn.zzko.cn</a>；国外的请求则重定向到 <a href="http://cdn.jsdelivr.net">cdn.jsdelivr.net</a>。</p>
<h3 id="center-配置国内重定向-center"><center>配置国内重定向</center></h3>
<p>规则名称 （必需）：标注国内，方便区分</p>
<p>自定义筛选表达式：<code>(http.host eq &quot;cdn.haoyep.com&quot; and ip.geoip.country eq &quot;CN&quot;)</code></p>
<p>URL 重定向</p>
<ul>
<li>类型：<code>动态</code></li>
<li>表达式：<code>concat(&quot;https://jsd.cdn.zzko.cn&quot;, http.request.uri.path)</code></li>
<li>状态代码：<code>302</code></li>
</ul>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/08/19/RtB3Af12IjbdZa7.png" alt="配置国内重定向" style="zoom: 50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h3 id="center-配置国外重定向-center"><center>配置国外重定向</center></h3>
<p>规则名称 （必需）：标注国外，方便区分</p>
<p>自定义筛选表达式：(<code>http.host eq &quot;cdn.haoyep.com&quot; and ip.geoip.country ne &quot;CN&quot;</code>)</p>
<p>URL 重定向</p>
<ul>
<li>类型：<code>动态</code></li>
<li>表达式：<code>concat(&quot;https://cdn.jsdelivr.net&quot;, http.request.uri.path)</code></li>
<li>状态代码：<code>302</code></li>
</ul>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/08/19/kcNSnDshqaTyHrU.png" alt="配置国外重定向" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<blockquote>
<p>技巧：<br>
HTTP 重定向状态选择302而不是301。虽然两类请求都会被 Cloudflare 缓存，但301理论上是永久跳转而302是临时跳转，因此301可能会导致长时间缓存，不利于今后修改重定向到新地址。</p>
</blockquote>
<h3 id="center-picgo-设置-center"><center>PicGo 设置</center></h3>
<p>我们已经除了GitHub上传图片教程：<a href="https://blog.csdn.net/qq_65047384/article/details/140401010">地址</a></p>
<p>这里只需修改，自定义域名连接里面的<code>cdn.haoyep.com</code>，修改成自己的，其它按之前的配置即可</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2024/08/19/lGdpRj7S5ngZ9XA.png" alt="PicGo配置" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>之前已经上传的图片，也只需要将图片链接中的<code>cdn.haoyep.com</code>，修改成自己的，在Typora可以ctrl+f，直接全部替换即可</p>
<p>后续没有什么效果，已转至云图床</p>
]]></content>
      <categories>
        <category>技术积累记录</category>
      </categories>
      <tags>
        <tag>博客CDN解析</tag>
      </tags>
  </entry>
  <entry>
    <title>0.ArkTS基础语法</title>
    <url>/post/d98607ab.html</url>
    <content><![CDATA[<p>打印日志：console.log(‘消息说明’,‘打印的内容’)</p>
<p>对象等复杂数据，需要日志打印需要JSON.stringify()转换</p>
<h1>变量</h1>
<h2 id="基础数据类型">基础数据类型</h2>
<p>① string 字符串, ‘’ 和 &quot;&quot;都可以</p>
<p>② number 数字</p>
<p>③ boolean 布尔（真、假）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//语法</span><br><span class="line">let 变量名: 类型 = 值  </span><br><span class="line"></span><br><span class="line">// 字符类型，&#x27;&#x27; 或 &quot;&quot; 包裹</span><br><span class="line">let title: string = &#x27;巨无霸汉堡&#x27;;</span><br><span class="line">console.log(&#x27;字符串title&#x27;,title);</span><br><span class="line"></span><br><span class="line">//数字</span><br><span class="line">let age: number = 18</span><br><span class="line">console.log(&#x27;年龄age:&#x27;,age);</span><br><span class="line"></span><br><span class="line">//布尔</span><br><span class="line">let islogin: boolean = true</span><br><span class="line">console.log(&#x27;是否登陆成功：&#x27;,islogin)</span><br><span class="line"></span><br><span class="line">//修改</span><br><span class="line">title = &#x27;xinzai&#x27;</span><br><span class="line">console.log(&#x27;字符串title&#x27;,title);</span><br><span class="line">age = 90</span><br><span class="line">console.log(&#x27;年龄age:&#x27;,age);</span><br><span class="line">islogin = false</span><br><span class="line">console.log(&#x27;是否登陆成功：&#x27;,islogin)</span><br></pre></td></tr></table></figure>
<h2 id="状态变量">状态变量</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@State 变量名: 变量类型 = 值</span><br><span class="line"></span><br><span class="line">@State msg3: string = &#x27;Hello World&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="联合类型">联合类型</h2>
<p>灵活的数据类型，它修饰的变量可以存储不同类型的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let 变量: 类型1 | 类型2 | 类型3 = 值</span><br><span class="line"></span><br><span class="line">let judge : number | string = 100</span><br><span class="line">judge = &#x27;A&#x27;</span><br><span class="line">console.log(judge)  //A</span><br><span class="line">//变量值限定在一组数据范围内选择</span><br><span class="line">let gender: &#x27;man&#x27; | &#x27;woman&#x27; | &#x27;secret&#x27; = &#x27;secret&#x27;</span><br><span class="line">console.log(&#x27;性别：&#x27;,gender)</span><br></pre></td></tr></table></figure>
<h2 id="枚举类型">枚举类型</h2>
<p>约定变量只能在一组数据范围内选择值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum 枚举名 &#123;  </span><br><span class="line">    常量1 = 值,  </span><br><span class="line">    常量2 = 值,  </span><br><span class="line">    ......  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义枚举</span><br><span class="line">enum ThemeColor&#123;</span><br><span class="line">    //常量列表</span><br><span class="line">    Red = &#x27;#ff0f29&#x27;,</span><br><span class="line">    Orange = &#x27;#ff7100&#x27;,</span><br><span class="line">    Green = &#x27;#30b30e&#x27;</span><br><span class="line">&#125;</span><br><span class="line">//给变量设定枚举类型</span><br><span class="line">let color: ThemeColor = ThemeColor.Red</span><br><span class="line">console.log(&#x27;颜色&#x27;,color)</span><br></pre></td></tr></table></figure>
<h1>常量</h1>
<p>用来存储不可变数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const 常量名: 类型 = 值</span><br><span class="line"></span><br><span class="line">const PI: number = 3.14</span><br><span class="line">console.log(&quot;PI&quot;,PI);</span><br></pre></td></tr></table></figure>
<h1>运算符</h1>
<p>一元运算符单独一行的时候前加和后加效果都一致</p>
<table>
<thead>
<tr>
<th style="text-align:center">算数运算符</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">赋值运算符</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">一元运算符</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">比较运算符</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">逻辑运算符</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">加</td>
<td style="text-align:center">+=</td>
<td style="text-align:center">加等于</td>
<td style="text-align:center">++i</td>
<td style="text-align:center">先加后使用</td>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">大于</td>
<td style="text-align:center">&amp;&amp;</td>
<td style="text-align:center">与，都真才真</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">减</td>
<td style="text-align:center">-=</td>
<td style="text-align:center">减等于</td>
<td style="text-align:center">i++</td>
<td style="text-align:center">先使用后加</td>
<td style="text-align:center">&gt;=</td>
<td style="text-align:center">大于等于</td>
<td style="text-align:center">||</td>
<td style="text-align:center">或，一真则真</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">乘</td>
<td style="text-align:center">*=</td>
<td style="text-align:center">乘等于</td>
<td style="text-align:center">–i</td>
<td style="text-align:center">先减后使用</td>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">小于</td>
<td style="text-align:center">!</td>
<td style="text-align:center">非，取反</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">除</td>
<td style="text-align:center">/=</td>
<td style="text-align:center">除等于</td>
<td style="text-align:center">i–</td>
<td style="text-align:center">先使用后减</td>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">小于等于</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">取余</td>
<td style="text-align:center">%=</td>
<td style="text-align:center">取余等于</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">==</td>
<td style="text-align:center">判断相等</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">!=</td>
<td style="text-align:center">判断不等于</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let num: number = 1</span><br><span class="line">let num1: number = 2</span><br><span class="line">console.log(&#x27;值&#x27;, num + num1)	//3</span><br><span class="line"></span><br><span class="line">let num: number = 1</span><br><span class="line">console.log(&#x27;值&#x27;, num += 1)	//2</span><br><span class="line"></span><br><span class="line">let num: number = 1</span><br><span class="line">//let a: number = num++ //1</span><br><span class="line">let a1: number = ++num    //2</span><br><span class="line">console.log(&#x27;值：&#x27;,a1)</span><br></pre></td></tr></table></figure>
<h1>字符串</h1>
<h2 id="字符串拼接">字符串拼接</h2>
<p>用于拼接字符串和变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let name: string = &#x27;小明</span><br><span class="line">console.log（&#x27;简介信息&#x27;，&#x27;名字是&#x27; + name)</span><br></pre></td></tr></table></figure>
<h2 id="模板字符串">模板字符串</h2>
<p>更适合于 多个变量 的字符串拼接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`...$&#123;变量名1&#125;.....$&#123;变量名2&#125;.....`</span><br><span class="line"></span><br><span class="line">let name: string = &#x27;xinzai&#x27;</span><br><span class="line">let age: number = 18</span><br><span class="line">console.log(&#x27;信息：&#x27;,`名字是$&#123;name&#125;，年龄是$&#123;age&#125;`)</span><br></pre></td></tr></table></figure>
<h1>类型转换</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//字符串转数字</span><br><span class="line">Number(变量名)	//字符串 直接转数字，转换失败返回NaN（字符串中包含非数字）</span><br><span class="line">parseInt(变量名)	//去掉小数部分 转数字，转换失败返回NaN</span><br><span class="line">parseFloat(变量名)	//保留小数部分 转数字，转换失败返回NaN</span><br><span class="line"></span><br><span class="line">let num: string = &#x27;1.1&#x27;</span><br><span class="line">let num1: string = &#x27;1.1a1&#x27;</span><br><span class="line">console.log(&#x27;值：&#x27;,Number(num))   //1.1</span><br><span class="line">console.log(&#x27;值：&#x27;,parseInt(num))	//1</span><br><span class="line">console.log(&#x27;值：&#x27;,parseFloat(num))   //1.1</span><br><span class="line">console.log(&#x27;值：&#x27;,Number(num1))  //NaN</span><br><span class="line"></span><br><span class="line">//数字转字符串</span><br><span class="line">变量名.toString()	//数字直接转字符串</span><br><span class="line">变量名.toFixed()	//四舍五入转字符串，可设置保留几位小数</span><br><span class="line"></span><br><span class="line">let num: number = 1.12523</span><br><span class="line">console.log(&#x27;值：&#x27;,num.toString())   //&#x27;1.12523&#x27;</span><br><span class="line">console.log(&#x27;值：&#x27;,num.toFixed()) //&#x27;1&#x27;</span><br><span class="line">console.log(&#x27;值：&#x27;,num.toFixed(2))    //&#x27;1.13&#x27;，保留两位小数</span><br></pre></td></tr></table></figure>
<h1>数组</h1>
<p>下标从零开始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let 数组名: 类型[] = []	//定义</span><br><span class="line">let 数组名: 类型[] = [数据1, 数据2,...]</span><br><span class="line"></span><br><span class="line">let names: string[] = [&#x27;nihao&#x27;,&#x27;xinzai&#x27;,&#x27;bs&#x27;]</span><br><span class="line">console.log(&#x27;数组：&#x27;,names)</span><br><span class="line">console.log(&#x27;1:&#x27;,names[1])</span><br></pre></td></tr></table></figure>
<h2 id="数组的操作">数组的操作</h2>
<p>任意位置 增加 或删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组名.splice(起始位置, 删除的个数, 新增元素1, 新增元素2, ......)	//从起始位置开始增加或删除</span><br><span class="line"></span><br><span class="line">name.splice(1,1,&#x27;123&#x27;)</span><br><span class="line">console.log(&#x27;任意新增/删除：&#x27;,name)    //xinzai,123,wfeng,xiaowng</span><br></pre></td></tr></table></figure>
<h3 id="查找">查找</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组名[下标]	//对应下标中的值</span><br><span class="line">数组名.length	//数组长度</span><br><span class="line"></span><br><span class="line">let name: string[] = [&#x27;xinzai&#x27;,&#x27;jueni&#x27;,&#x27;wfeng&#x27;,&#x27;xiaowng&#x27;]</span><br><span class="line">console.log(&#x27;查询第1个数组中的值：&#x27;, name[1])	//jueni</span><br><span class="line">console.log(&#x27;长度：&#x27;, name.length)	//4</span><br></pre></td></tr></table></figure>
<h3 id="修改">修改</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组名[下标] = 新值</span><br><span class="line"></span><br><span class="line">name[2] = &#x27;xinzai&#x27;</span><br><span class="line">console.log(&#x27;修改：&#x27;,name)	//修改：xinzai,jueni,xinzai,xiaowng</span><br></pre></td></tr></table></figure>
<h3 id="增加">增加</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组名.unshift(数据1, 数据2, 数据3, ......)	//从开头加</span><br><span class="line">数组名.push(数据1, 数据2, 数据3, ......)	//从结尾加</span><br><span class="line"></span><br><span class="line">name.unshift(&#x27;123&#x27;,&#x27;321&#x27;)</span><br><span class="line">console.log(&#x27;增加：&#x27;,name) //123,321,xinzai,jueni,wfeng,xiaowng</span><br><span class="line">name.push(&#x27;123&#x27;,&#x27;321&#x27;)</span><br><span class="line">console.log(&#x27;增加：&#x27;,name) //xinzai,jueni,wfeng,xiaowng,123,321</span><br></pre></td></tr></table></figure>
<h3 id="删除">删除</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组名.shift()	//从开头删</span><br><span class="line">数组名.pop()	//从结尾删</span><br><span class="line"></span><br><span class="line">name.shift()</span><br><span class="line">console.log(&#x27;删除：&#x27;,name) //jueni,wfeng,xiaowng</span><br><span class="line">name.pop()</span><br><span class="line">console.log(&#x27;删除：&#x27;,name) //xinzai,jueni,wfeng</span><br></pre></td></tr></table></figure>
<h2 id="遍历数组">遍历数组</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//方式一：普通for循环遍历输出</span><br><span class="line">let name: string[] = [&#x27;xinzai&#x27;,&#x27;lisi&#x27;,&#x27;wangwu&#x27;]</span><br><span class="line">for (let i = 0;i &lt; name.length;i++)&#123;</span><br><span class="line">    console.log(&#x27;名字&#x27;,name[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//方式二</span><br><span class="line">for (let item of 数组名) &#123;&#125;	//item: 声明的一个变量, 用来在循环的时候接收 每一个数组元素</span><br><span class="line"></span><br><span class="line">let name: string[] = [&#x27;xinzai&#x27;,&#x27;lisi&#x27;,&#x27;wangwu&#x27;]</span><br><span class="line">for (let item of name)&#123;</span><br><span class="line">    console.log(&#x27;名字&#x27;,item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>对象数组</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义接口</span><br><span class="line">interface  接口名&#123;</span><br><span class="line">    //属性</span><br><span class="line">&#125;</span><br><span class="line">//定义对象数组</span><br><span class="line">let 对象数组名: 接口名[] = [&#123; 属性名1: 值, 属性名2: 值, ... &#125;, ...]</span><br><span class="line">//访问</span><br><span class="line">对象数组名[下标].属性值</span><br><span class="line">//需要修改数据，要整个对象都修改，不能修改对象中的一个数据</span><br><span class="line">this.对象数组名[下标值] = &#123;</span><br><span class="line">    属性名1: 值</span><br><span class="line">    属性名2: 值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface  Person&#123;</span><br><span class="line">    stuId: number</span><br><span class="line">    name: string</span><br><span class="line">&#125;</span><br><span class="line">let pArr: Person[] = [&#123;stuId: 1,name:&#x27;小红&#x27;&#125;,&#123;stuId: 2, name:&#x27;xinzai&#x27;&#125;]</span><br><span class="line">console.log(&#x27;数&#x27;,pArr[1].name)</span><br><span class="line">this.images[this.random] = &#123;</span><br><span class="line">    url: `app.media.img_0$&#123;this.random&#125;`,</span><br><span class="line">    count1: this.images[this.random].count1 + 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>函数(function)</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义函数</span><br><span class="line">function 函数名(形参1: 类型, 形参2: 类型,...): 返回值类型&#123;</span><br><span class="line">    return 返回值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用函数</span><br><span class="line">let 变量名: 类型 = 函数名(实参1,实参2,...)</span><br><span class="line"></span><br><span class="line">//定义函数</span><br><span class="line">function test()&#123;</span><br><span class="line">    console.log(&#x27;五角星&#x27;,&#x27;*&#x27;)</span><br><span class="line">    console.log(&#x27;五角星&#x27;,&#x27;**&#x27;)</span><br><span class="line">    console.log(&#x27;五角星&#x27;,&#x27;***&#x27;)</span><br><span class="line">    console.log(&#x27;五角星&#x27;,&#x27;****&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">//调用函数</span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line">function buy(price: number,num: number)&#123;</span><br><span class="line">    let result: number = price*num</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;价格：&#x27;,buy(10,3));</span><br></pre></td></tr></table></figure>
<h1>箭头函数</h1>
<p>普通函数和箭头函数，在后面开发中会有不同的使用场景</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let 函数名 = (形参1: 类型, 形参2: 类型,...) =&gt; &#123;  </span><br><span class="line">    // 函数体</span><br><span class="line">    return 返回值</span><br><span class="line">&#125;</span><br><span class="line">函数名(实参1,实参2,...)</span><br><span class="line"></span><br><span class="line">let num_Price = (price: number, num: number)=&gt;&#123;</span><br><span class="line">    let result: number = price*num</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;总价格：&#x27;, num_Price(3,2))</span><br></pre></td></tr></table></figure>
<h1>剩余参数和展开运算符</h1>
<p>将 函数 或 方法 中一个不定数量的参数表示为一个数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function 函数名(参数1, 参数2, ...剩余参数数组)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function num(a1: number,a2: number,...theArgs:number[])&#123;</span><br><span class="line">    let count = a1+a2</span><br><span class="line">    for(const flags of theArgs)&#123;</span><br><span class="line">        count += flags</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&#x27;值&#x27;,count)</span><br><span class="line">    return count</span><br><span class="line">&#125;</span><br><span class="line">num(1,2,3)</span><br></pre></td></tr></table></figure>
<p>展开运算符只能用在数组上(一般用在合并上)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const 数组名: 数据类型[] = [...数据名1, ...数组名2]</span><br><span class="line"></span><br><span class="line">const a1: number[] = [1,2,3,4,5,6]</span><br><span class="line">const a2: number[] = [3,4,6,17,27]</span><br><span class="line">const num: number[] = [...a1,...a2]</span><br><span class="line">console.log(&#x27;结果&#x27;,num)</span><br></pre></td></tr></table></figure>
<h1>接口</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义接口约束对象中变量及函数的类型</span><br><span class="line">interface 接口名&#123;</span><br><span class="line">    属性1: 类型1</span><br><span class="line">    属性2: 类型2</span><br><span class="line">    属性3: 类型3</span><br><span class="line"></span><br><span class="line">    方法名: (参数: 类型) =&gt; 返回值类型</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义接口</span><br><span class="line">interface Person&#123;</span><br><span class="line">    //声明属性类型</span><br><span class="line">    name: string</span><br><span class="line">    age: number</span><br><span class="line">    weight: number</span><br><span class="line"></span><br><span class="line">    //声明方法</span><br><span class="line">    dance: () =&gt; void</span><br><span class="line">    sing: (sing: string) =&gt; void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口继承">接口继承</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface 接口2 extends 接口1 &#123;</span><br><span class="line">    //属性2:类型</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IAnimal&#123;</span><br><span class="line">    name: string</span><br><span class="line">    age: number</span><br><span class="line">&#125;</span><br><span class="line">interface IDog extends IAnimal&#123;</span><br><span class="line">    color: string</span><br><span class="line">&#125;</span><br><span class="line">let dog1: IDog = &#123;</span><br><span class="line">    //不仅要实现IDog子接口还需要实现父接口</span><br><span class="line">    name: &#x27;s&#x27;,</span><br><span class="line">    age: 12,</span><br><span class="line">    color: &#x27;s&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口实现">接口实现</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class 类 implements 接口&#123;</span><br><span class="line">    // 必须实现 接口中定义的 属性、方法，</span><br><span class="line">    // 否则会报错</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IDog &#123;</span><br><span class="line">    name: string</span><br><span class="line">    age: number</span><br><span class="line">    color: string</span><br><span class="line">    jump: () =&gt; void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test implements IDog &#123;</span><br><span class="line">    name: string</span><br><span class="line">    age: number</span><br><span class="line">    color: string</span><br><span class="line"></span><br><span class="line">    constructor(name: string, age: number, color: string) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">        this.age = age</span><br><span class="line">        this.color = color</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jump = () =&gt; &#123;</span><br><span class="line">        console.log(&#x27;名字&#x27;,this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let test:Test = new Test(&#x27;x&#x27;,12,&#x27;s&#x27;)</span><br><span class="line">test.jump()</span><br></pre></td></tr></table></figure>
<h1>对象</h1>
<p>存储多个不同数据的容器</p>
<p>定义的接口可以给不同的对象重复使用，但对象需要的是相同的结构类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义对象并使用属性及方法</span><br><span class="line">let 对象名称: 对象结构类型 = &#123;</span><br><span class="line">    属性名1: 值,</span><br><span class="line">    属性名2: 值,</span><br><span class="line">    </span><br><span class="line">    方法名: (形参名1: 类型,...) =&gt;&#123;</span><br><span class="line">        //方法体</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用属性及方法</span><br><span class="line">对象名.属性名1</span><br><span class="line">对象名.方法名1()</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义对象</span><br><span class="line">let ym: Person = &#123;</span><br><span class="line">    name: &#x27;李四&#x27;,</span><br><span class="line">    age: 19,</span><br><span class="line">    weight: 88,</span><br><span class="line"></span><br><span class="line">    dance: () =&gt;&#123;</span><br><span class="line">    	console.log(&#x27;nihao&#x27;,&#x27;xinzai&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">    sing: (song: string) =&gt; &#123;</span><br><span class="line">    	console.log(&#x27;唱歌：&#x27;,song)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//调用对象属性</span><br><span class="line">console.log(&#x27;名字&#x27;,ym.name)</span><br><span class="line">console.log(&#x27;年龄：&#x27;,ym.age)</span><br><span class="line">//调用对象方法</span><br><span class="line">ym.dance()</span><br><span class="line">ym.sing(&#x27;奇迹&#x27;)</span><br></pre></td></tr></table></figure>
<h1>分支语句</h1>
<h2 id="if">if</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let score: number = 66</span><br><span class="line">if (score &gt;= 90)&#123;</span><br><span class="line">    console.log(&#x27;优秀&#x27;)</span><br><span class="line">&#125;else if (score &gt;= 70)&#123;</span><br><span class="line">    console.log(&#x27;良好&#x27;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    console.log(&#x27;不及格&#x27;)  //不及格</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="switch">switch</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let m: number = 2</span><br><span class="line">switch (m)&#123;</span><br><span class="line">    case 1:</span><br><span class="line">        console.log(&#x27;1&#x27;)</span><br><span class="line">        break</span><br><span class="line">    case 2:</span><br><span class="line">        console.log(&#x27;2&#x27;)    //2</span><br><span class="line">        break</span><br><span class="line">    case 3:</span><br><span class="line">        console.log(&#x27;3&#x27;)</span><br><span class="line">        break</span><br><span class="line">    default :</span><br><span class="line">        console.log(&#x27;其他&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三元条件表达式">三元条件表达式</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//当变量名1 的值大于 变量名2 的值，返回变量名1 的值否则返回变量名2 的值</span><br><span class="line">变量名1 &gt; 变量名2? 变量名1 : 变量名2</span><br><span class="line"></span><br><span class="line">let num1: number = 5</span><br><span class="line">let num2: number = 10</span><br><span class="line">let res: number = num1 &gt; num2 ? num1 : num2	// 返回较大值</span><br><span class="line">console.log(&#x27;结果是&#x27;, res)	//10</span><br></pre></td></tr></table></figure>
<h1>循环语句</h1>
<h2 id="for">for</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (let i: number = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    console.log(&#x27;for&#x27;, &#x27;重复执行的代码&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (const arg of 数组名) &#123;</span><br><span class="line">   console.log(&#x27;值&#x27;, &#x27;arg&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="while">while</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (条件) &#123;</span><br><span class="line">    条件成立重复执行的代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let i: number = 1</span><br><span class="line">while (i &lt; 5) &#123;</span><br><span class="line">    console.log(&#x27;while~i&#x27;, &#x27;重复执行的代码&#x27;)</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>随机数生成</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Math.random()	//默认0~1</span><br><span class="line">//需要0~5，需要乘6</span><br><span class="line"></span><br><span class="line">Math.floor()	//向下取整</span><br></pre></td></tr></table></figure>
<h1>Class类</h1>
<p>用于 创建对象 模板。同时类声明也会引入一个 新类型，可定义其 实例属性、方法 和 构造函数</p>
<h2 id="语法">语法</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 类名 首字母大写（规范）</span><br><span class="line">class 类名&#123;</span><br><span class="line">    // 1. 实例属性(字段)</span><br><span class="line">    // 2. 构造函数</span><br><span class="line">    // 3. 方法</span><br><span class="line">&#125;</span><br><span class="line">// 使用类 实例化对象 基于类 创建对象</span><br><span class="line">let 实例化类名: 类名 = new 类名()</span><br></pre></td></tr></table></figure>
<h2 id="实例属性">实例属性</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字段名.类型 = 值	//没有构造函数时必须有初始化值</span><br><span class="line">字段名?:类型</span><br><span class="line"></span><br><span class="line">class cat&#123;</span><br><span class="line">    name: string = &#x27;小黑&#x27;</span><br><span class="line">    food?: string</span><br><span class="line">&#125;</span><br><span class="line">let mycat: cat = new cat()</span><br><span class="line">console.log(&#x27;名字&#x27;,mycat.name)</span><br><span class="line">//mycat.food = &#x27;小黄鱼&#x27;</span><br><span class="line">// ?. 可以保证若food没有赋值不会报错，没有赋值显示undefined</span><br><span class="line">console.log(&#x27;食物&#x27;,mycat?.food)</span><br></pre></td></tr></table></figure>
<h2 id="构造函数">构造函数</h2>
<p>不同实例 有不同的 字段 初始值，在实例化对象时将参数传进构造函数将字段初始化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constructor(形参名1: 类型, 形参名2: 类型) &#123;	//也可以传对象</span><br><span class="line">    this.属性名1 = 形参1</span><br><span class="line">    this.属性名2 = 形参2</span><br><span class="line">&#125;</span><br><span class="line">let 实例化类名: 类名 = new 类名(值1 ,值2)	//传入的参数必须和构造函数形参顺序一致</span><br><span class="line"></span><br><span class="line">class Food&#123;</span><br><span class="line">    name: string</span><br><span class="line">    price?: number</span><br><span class="line"></span><br><span class="line">    constructor(name: string, price: number) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">        this.price = price</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let mycat: Food = new Food(&#x27;西蓝花&#x27;,20)</span><br><span class="line">console.log(&#x27;名字&#x27;,mycat.name)</span><br><span class="line">console.log(&#x27;食物&#x27;,mycat.price)</span><br><span class="line"></span><br><span class="line">//扩展，使用接口，构造函数传入对象</span><br><span class="line">interface IFood&#123;</span><br><span class="line">    name: string</span><br><span class="line">    price: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Food&#123;</span><br><span class="line">    name: string</span><br><span class="line">    price?: number</span><br><span class="line"></span><br><span class="line">    constructor(paramsObj: IFood) &#123;</span><br><span class="line">        this.name = paramsObj.name</span><br><span class="line">        this.price = paramsObj.price</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let myfood: Food = new Food(&#123;</span><br><span class="line">    //此时传入的参数可以不用按照构造函数参数的顺序</span><br><span class="line">    name: &#x27;菜心&#x27;,</span><br><span class="line">    price: 20</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#x27;名字&#x27;,myfood.name)</span><br><span class="line">console.log(&#x27;食物&#x27;,myfood.price)</span><br></pre></td></tr></table></figure>
<h2 id="定义方法">定义方法</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法名(参数...): 返回值类型&#123;</span><br><span class="line">    // 逻辑...</span><br><span class="line">    // 可以通过 this 获取实例对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Food&#123;</span><br><span class="line">    name: string</span><br><span class="line">    price?: number</span><br><span class="line"></span><br><span class="line">    constructor(name: string, price: number) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">        this.price = price</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    style(name:string)&#123;</span><br><span class="line">        console.log(`你好$&#123;name&#125;`,`菜名$&#123;this.name&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let myfood: Food = new Food(&#x27;西蓝花&#x27;,20)</span><br><span class="line">myfood.style(&#x27;xinzai&#x27;)</span><br></pre></td></tr></table></figure>
<h2 id="静态属性和静态方法">静态属性和静态方法</h2>
<p>给类添加 静态属性、方法，通过类名访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static 静态属性名: 类型 = 值</span><br><span class="line">static 静态方法名(参数): 返回值类型&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Roboot&#123;</span><br><span class="line">    static version: string = &#x27;v2.0&#x27;</span><br><span class="line">    static getRomdom(): number&#123;</span><br><span class="line">        return Math.random()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;版本&#x27;,Roboot.version)</span><br><span class="line">console.log(&#x27;随机数&#x27;,Roboot.getRomdom())</span><br></pre></td></tr></table></figure>
<h2 id="继承">继承</h2>
<p>子类可以继承父类的方法和属性，super 可以访问父类的实例字段、实例方法和构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class 子类 extends 父类&#123;</span><br><span class="line">    // 自己的字段（属性）</span><br><span class="line">    // 自己的方法</span><br><span class="line">    // 可以重写父类方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    name: string</span><br><span class="line">    age: number</span><br><span class="line">    </span><br><span class="line">    constructor(name: string,age: number) &#123;</span><br><span class="line">        this.age = age</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi()&#123;</span><br><span class="line">        console.log(&#x27;大家好&#x27;,this.name,this.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    worker: string = &#x27;学习&#x27;   //子类自己的属性</span><br><span class="line"></span><br><span class="line">    constructor(name: string,age: number, worker: string) &#123;</span><br><span class="line">        //子类无法继承父类构造方法，需要类似重写重新调用</span><br><span class="line">        super(name,age)</span><br><span class="line">        this.worker = worker    //初始化子类属性</span><br><span class="line">    &#125;</span><br><span class="line">    //重写父类方法</span><br><span class="line">    sayHi(): void &#123;</span><br><span class="line">        super.sayHi()   //调用父类的方法</span><br><span class="line">        console.log(&#x27;hello&#x27;, this.name,this.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let student: Student = new Student(&#x27;李四&#x27;,19,&#x27;学习&#x27;)</span><br></pre></td></tr></table></figure>
<h2 id="检测实例">检测实例</h2>
<p>instanceof 检测某个对象是否是某个类的实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">&#125;</span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let student: Student = new Student()</span><br><span class="line">console.log(&#x27;判断结果&#x27;, student instanceof Person)</span><br><span class="line"></span><br><span class="line">let temp: number[] = []</span><br><span class="line">console.log(&#x27;判断结果&#x27;,temp instanceof Array)   //判断变量是否是数组</span><br></pre></td></tr></table></figure>
<h2 id="修饰符">修饰符</h2>
<p>readonly：只可以取值，无法修改</p>
<p>private：修饰的成员只能在本类访问，不能在声明该成员的类之外访问, 包括子类</p>
<p>protected：与private修饰符非常相似，不同点protected修饰的成员允许在 派生类(子类)中访问</p>
<p>public：任何地方都可以访问，省略不写默认为 public</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readonly legs: number = 4</span><br><span class="line"></span><br><span class="line">class 类&#123;</span><br><span class="line">    private 属性:类型</span><br><span class="line">    private 方法()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 类&#123;</span><br><span class="line">    protected 属性:类型</span><br><span class="line">    protected 方法()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>泛型</h1>
<p>让【函数】等， 与多种【不同的类型】一起工作，灵活可复用</p>
<h2 id="泛型函数">泛型函数</h2>
<p>类型是 可变 的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function 函数名&lt;泛型参数名&gt;(形参名1: 泛型参数名) : 泛型参数名&#123;</span><br><span class="line">&#125;</span><br><span class="line">//调用，类型传了什么类型，形参和返回值类型都是同样的类型</span><br><span class="line">函数名&lt;类型&gt;(实参)</span><br><span class="line">函数名(实参)	//调用时也可以不用显式写出类型，会根据输入的参数判断</span><br><span class="line"></span><br><span class="line">function fn&lt;T&gt;(name: T): T &#123;</span><br><span class="line">    return name</span><br><span class="line">&#125;</span><br><span class="line">console.log(fn(&#x27;n&#x27;))</span><br><span class="line">console.log(&#x27;zhi&#x27;,fn&lt;number[]&gt;([1,2,3,45,5]))</span><br></pre></td></tr></table></figure>
<p>进阶</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fn&lt;T&gt;(s: T[]): T[] &#123;</span><br><span class="line">    return s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn1&lt;T&gt;(s: T[]): T &#123;</span><br><span class="line">    return s[s.length-1]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&#x27;值&#x27;, fn&lt;Number&gt;([1, 2, 3, 4, 5]).length)</span><br><span class="line">console.log(&#x27;值&#x27;, fn&lt;string&gt;([&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]).length)</span><br><span class="line">console.log(&#x27;值&#x27;, fn1&lt;string&gt;([&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;40&#x27;]))</span><br></pre></td></tr></table></figure>
<h3 id="多个泛型参数">多个泛型参数</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fn&lt;T1,T2&gt; (parm1:T1,parm2:T2)&#123;</span><br><span class="line">    console.log(&#x27;z1&#x27;,parm1)</span><br><span class="line">    console.log(&#x27;z2&#x27;,parm2)</span><br><span class="line">&#125;</span><br><span class="line">fn(&#x27;aa&#x27;,123)</span><br></pre></td></tr></table></figure>
<h2 id="泛型约束">泛型约束</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface 接口&#123;</span><br><span class="line">    //属性: 类型</span><br><span class="line">&#125;</span><br><span class="line">function 函数&lt;Type extends 接口&gt;()&#123;&#125;	// 传入的类型必须要有 接口中的属性</span><br><span class="line"></span><br><span class="line">interface Ilength &#123;</span><br><span class="line">    length: number</span><br><span class="line">&#125;</span><br><span class="line">function fn&lt;T extends Ilength&gt;(param: T): T &#123;</span><br><span class="line">    return param</span><br><span class="line">&#125;</span><br><span class="line">//传入的参数必须有接口中length属性</span><br><span class="line">console.log(&#x27;值&#x27;, fn(&#x27;132&#x27;))</span><br><span class="line"></span><br><span class="line">class Desk &#123;</span><br><span class="line">    length: number = 2</span><br><span class="line">&#125;</span><br><span class="line">let d = new Desk()</span><br><span class="line">fn&lt;Desk&gt;(d)</span><br></pre></td></tr></table></figure>
<h2 id="泛型接口">泛型接口</h2>
<h2 id="泛型类">泛型类</h2>
]]></content>
      <categories>
        <category>鸿蒙next应用开发</category>
      </categories>
      <tags>
        <tag>鸿蒙next应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>前端相关报错</title>
    <url>/post/bcf1b676.html</url>
    <content><![CDATA[<h1>npm install-g@vue/cli报错错</h1>
<p>错误如图：</p>
<img src="https://s2.loli.net/2024/09/27/U3iBFknjNr6Eb1I.webp" alt="错误视图" style="zoom:60%;">
<p>解决方法：修改文件夹权限</p>
<img src="https://s2.loli.net/2024/09/27/WSvq3c9TlMZbF1x.webp" alt="进入node文件夹" style="zoom:50%;">
<p>按照途中顺序，将上图三个文件夹修改权限，修改完即可</p>
<img src="https://s2.loli.net/2024/09/27/skMA6OCmifdjuQF.webp" alt="修改权限" style="zoom:45%;">
<h1>解决npm ERR! code ENOENT npm ERR! syscall open npm ERR! path X:\RuoYi-Vue-master\RuoYi-Vue-master/pack</h1>
<p>执行npm命令报错：</p>
<blockquote>
<p>npm ERR! code ENOENT<br>
npm ERR! syscall open<br>
npm ERR! path X:\RuoYi-Vue-master\RuoYi-Vue-master/package.json<br>
npm ERR! errno -4058<br>
npm ERR! enoent ENOENT: no such file or directory, open ‘X:\RuoYi-Vue-master\RuoYi-Vue-master\package.json’<br>
npm ERR! enoent This is related to npm not being able to find a file.<br>
npm ERR! enoent</p>
</blockquote>
<p><strong>问题原因：</strong> 报错中已经说了 在xxxl路径下找不到 <code>package.json</code>文件，所以罪魁祸首就是执行npm命令的目录不对</p>
<p><strong>解决办法：</strong> 找到 <code>package.json</code>正确的目录，然后再在终端执行npm命令即可</p>
]]></content>
      <categories>
        <category>错误记录</category>
      </categories>
  </entry>
  <entry>
    <title>linux相关报错</title>
    <url>/post/8a87b27f.html</url>
    <content><![CDATA[<h1>unstable发行版，这也许是因为系统无法达到您要求的状态造成的</h1>
<p>错误：</p>
<blockquote>
<p>有一些软件包无法被安装。如果您用的是 unstable 发行版，这也许是</p>
<p>因为系统无法达到您要求的状态造成的。该版本中可能会有一些您需要的软件</p>
<p>包尚未被创建或是它们已被从新到(Incoming)目录移出。</p>
<p>下列信息可能会对解决问题有所帮助：</p>
<p>下列软件包有未满足的依赖关系：</p>
<p>fcitx : 依赖: fcitx-data 但是它将不会被安装</p>
<p>E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。</p>
</blockquote>
<p>解决方法：</p>
<p>打开更新设置，在“更新”选项卡中选则：<code>重要安全更新</code> 和 <code>推荐更新</code></p>
<img src="https://s2.loli.net/2024/09/12/nXSaiu5Nbh71k2A.webp" alt="打开更新" style="zoom: 33%;">
<p>打勾：重要安全更新 和 推荐更新，如果有提示更新一般不更新</p>
<img src="https://s2.loli.net/2024/09/12/uASdOqa9H2vM4Vi.webp" alt="打开更新" style="zoom: 67%;">
<p>最后在命令行里输入</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>错误记录</category>
      </categories>
  </entry>
  <entry>
    <title>单片机相关报错</title>
    <url>/post/63d3dd68.html</url>
    <content><![CDATA[<h1>STM32烧录的时候报错：Error :Flash Download failed -“Cortex-M3“</h1>
<p>点击图中标号1，按顺序点击进入设置</p>
<img src="https://s2.loli.net/2024/08/19/HUSwrAaseI4LKOD.png" alt="进入设置" style="zoom:50%;">
<p>按图中标序，进入添加页面</p>
<img src="https://s2.loli.net/2024/08/19/6w1Kh5v2Bg74qud.png" alt="添加页面" style="zoom:50%;">
<p>添加图中所选，然后一直确定退出即可，若没有图中所示选项，可能软件没下载对</p>
<img src="https://s2.loli.net/2024/08/19/t5pIKjw6uFSZmc1.png" alt="确定" style="zoom:50%;">
<p>添加后，即可烧录成功。</p>
<h1>ST-LINK未能串口keil识别的一个可能解决方案（前提驱动安装无问题）</h1>
<p>打开这个软件，在点击清除之前，按住单片机复位按钮不放，点击清除按钮，等待3-5秒放开复位按钮，即可清除重置，若提示没识别到，多重复几次，即可重置，重置完成之后再回到烧写软件，即可烧写成功</p>
<img src="https://s2.loli.net/2024/08/19/AQEx5HyvjGhpwu2.png" alt="软件图" style="zoom:50%;">
<p>在烧写时提示烧写成功后会显示如图所示</p>
<img src="https://s2.loli.net/2024/08/19/BPqYOIGQ2v3UDVh.png" alt="错误提示图" style="zoom:80%;">
<p>解决方法：可能某个地方设置错误，我这里是这个没有设置成 Serial Wire，可以把全部设置重新检查一遍</p>
<img src="https://s2.loli.net/2024/08/19/YKCqVMwZr7PJ5LG.png" alt="方法图" style="zoom:80%;">
<h1>RT-Thread Studio请修改链接脚本以扩大ROM大小</h1>
<p>错误：请修改链接脚本以扩大ROM大小</p>
<p>解决：选择对应项目，将ROM改大</p>
<img src="https://s2.loli.net/2024/09/11/n87GXrBxIwq3CkD.webp" alt="解决" style="zoom:50%;">
]]></content>
      <categories>
        <category>错误记录</category>
      </categories>
  </entry>
  <entry>
    <title>2.交互开发</title>
    <url>/post/36f99b3f.html</url>
    <content><![CDATA[<h1>点击事件</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onClick( (参数) =&gt; &#123;&#125; )	//当点击的时候</span><br><span class="line"></span><br><span class="line">Button(&#x27;点我&#x27;)</span><br><span class="line">    .onClick(() =&gt; &#123;</span><br><span class="line">    //弹窗</span><br><span class="line">    AlertDialog.show(&#123;</span><br><span class="line">        message: &#x27;你好~ 这是个弹框 &#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1>状态管理</h1>
<p>普通变量：只能在初始化时渲染，后续将不会再刷新</p>
<p>状态变量：需要装饰器装饰，改变会引起 UI 的渲染刷新</p>
<p>定义在 组件内(struct Index内) 普通变量 或 状态变量，都需要 通过 <code>this</code> 访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Index &#123;</span><br><span class="line">    @State msg3: string = &#x27;Hello World&#x27;;	//状态变量</span><br><span class="line">    build() &#123;</span><br><span class="line">        Column()&#123;</span><br><span class="line">            Text(this.msg3)</span><br><span class="line">            Button(&#x27;点我&#x27;)</span><br><span class="line">                .onClick(() =&gt; &#123;</span><br><span class="line">                    this.msg3 = &#x27;xinzai&#x27;</span><br><span class="line">                &#125;)</span><br><span class="line">                .width(&#x27;80%&#x27;)</span><br><span class="line">                .margin(50)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>鸿蒙next应用开发</category>
      </categories>
      <tags>
        <tag>鸿蒙next应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>项目</title>
    <url>/post/a2c247c4.html</url>
    <content><![CDATA[<p>生肖抽奖卡</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义接口 (每个列表项的数据结构)</span><br><span class="line">interface ImageCount &#123;</span><br><span class="line">    url: string</span><br><span class="line">    count: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Entry</span><br><span class="line">@Component</span><br><span class="line">struct Index &#123;</span><br><span class="line">    // 随机的生肖卡序号 0-5</span><br><span class="line">    @State randomIndex: number = -1 // 表示还没开始抽</span><br><span class="line"></span><br><span class="line">    // 基于接口, 准备数据</span><br><span class="line">    @State images: ImageCount[] = [</span><br><span class="line">        &#123; url: &#x27;app.media.bg_00&#x27;, count: 0 &#125;,</span><br><span class="line">        &#123; url: &#x27;app.media.bg_01&#x27;, count: 0 &#125;,</span><br><span class="line">        &#123; url: &#x27;app.media.bg_02&#x27;, count: 0 &#125;,</span><br><span class="line">        &#123; url: &#x27;app.media.bg_03&#x27;, count: 0 &#125;,</span><br><span class="line">        &#123; url: &#x27;app.media.bg_04&#x27;, count: 0 &#125;,</span><br><span class="line">        &#123; url: &#x27;app.media.bg_05&#x27;, count: 0 &#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    // 控制遮罩的显隐</span><br><span class="line">    @State maskOpacity: number = 0 // 透明度</span><br><span class="line">    @State maskZIndex: number = -1 // 显示层级</span><br><span class="line"></span><br><span class="line">    // 控制图片的缩放</span><br><span class="line">    @State maskImgX: number = 0 // 水平缩放比</span><br><span class="line">    @State maskImgY: number = 0 // 垂直缩放比</span><br><span class="line"></span><br><span class="line">    // 控制中大奖遮罩的显隐</span><br><span class="line">    @State isGet: boolean = false</span><br><span class="line"></span><br><span class="line">    @State arr: string[] = [&#x27;pg&#x27;, &#x27;hw&#x27;, &#x27;xm&#x27;] // 奖池</span><br><span class="line">    @State prize: string = &#x27;&#x27; // 默认没中奖</span><br><span class="line"></span><br><span class="line">    build() &#123;</span><br><span class="line">        Stack() &#123;</span><br><span class="line">            // 初始化的布局结构</span><br><span class="line">            Column() &#123;</span><br><span class="line">                Grid() &#123;</span><br><span class="line">                    ForEach(this.images, (item: ImageCount, index: number) =&gt; &#123;</span><br><span class="line">                        GridItem() &#123;</span><br><span class="line">                            Badge(&#123;</span><br><span class="line">                                count: item.count,</span><br><span class="line">                                position: BadgePosition.RightTop,</span><br><span class="line">                                style: &#123;</span><br><span class="line">                                    fontSize: 14,</span><br><span class="line">                                    badgeSize: 20,</span><br><span class="line">                                    badgeColor: &#x27;#fa2a2d&#x27;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;) &#123;</span><br><span class="line">                                Image($r(item.url))</span><br><span class="line">                                    .width(80)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">                .columnsTemplate(&#x27;1fr 1fr 1fr&#x27;)</span><br><span class="line">                    .rowsTemplate(&#x27;1fr 1fr&#x27;)</span><br><span class="line">                    .width(&#x27;100%&#x27;)</span><br><span class="line">                    .height(300)</span><br><span class="line">                    .margin(&#123; top: 100 &#125;)</span><br><span class="line"></span><br><span class="line">                Button(&#x27;立即抽卡&#x27;)</span><br><span class="line">                    .width(200)</span><br><span class="line">                    .backgroundColor(&#x27;#ed5b8c&#x27;)</span><br><span class="line">                    .margin(&#123; top: 50 &#125;)</span><br><span class="line">                    .onClick(() =&gt; &#123;</span><br><span class="line">                    // 点击时, 修改遮罩参数, 让遮罩显示</span><br><span class="line">                    this.maskOpacity = 1</span><br><span class="line">                    this.maskZIndex = 99</span><br><span class="line">                    // 点击时, 图片需要缩放</span><br><span class="line">                    this.maskImgX = 1</span><br><span class="line">                    this.maskImgY = 1</span><br><span class="line"></span><br><span class="line">                    // 计算随机数 Math.random()  [0,1) * (n + 1)</span><br><span class="line">                    this.randomIndex = Math.floor(Math.random() * 6)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            .width(&#x27;100%&#x27;)</span><br><span class="line">                .height(&#x27;100%&#x27;)</span><br><span class="line"></span><br><span class="line">            // 抽卡遮罩层 (弹层)</span><br><span class="line">            Column(&#123; space: 30 &#125;) &#123;</span><br><span class="line">                Text(&#x27;获得生肖卡&#x27;)</span><br><span class="line">                    .fontColor(&#x27;#f5ebcf&#x27;)</span><br><span class="line">                    .fontSize(25)</span><br><span class="line">                    .fontWeight(FontWeight.Bold)</span><br><span class="line">                Image($r(`app.media.img_0$&#123;this.randomIndex&#125;`))</span><br><span class="line">                    .width(200)</span><br><span class="line">                // 控制元素的缩放</span><br><span class="line">                    .scale(&#123;</span><br><span class="line">                    x: this.maskImgX,</span><br><span class="line">                    y: this.maskImgY</span><br><span class="line">                &#125;)</span><br><span class="line">                    .animation(&#123;</span><br><span class="line">                    duration: 500</span><br><span class="line">                &#125;)</span><br><span class="line">                Button(&#x27;开心收下&#x27;)</span><br><span class="line">                    .width(200)</span><br><span class="line">                    .height(50)</span><br><span class="line">                    .backgroundColor(Color.Transparent)</span><br><span class="line">                    .border(&#123; width: 2, color: &#x27;#fff9e0&#x27; &#125;)</span><br><span class="line">                    .onClick(() =&gt; &#123;</span><br><span class="line">                    // 控制弹层显隐</span><br><span class="line">                    this.maskOpacity = 0</span><br><span class="line">                    this.maskZIndex = -1</span><br><span class="line"></span><br><span class="line">                    // 图像重置缩放比为 0</span><br><span class="line">                    this.maskImgX = 0</span><br><span class="line">                    this.maskImgY = 0</span><br><span class="line"></span><br><span class="line">                    // 开心收下, 对象数组的情况需要更新, 需要修改替换整个对象</span><br><span class="line">                    // this.images[this.randomIndex].count++</span><br><span class="line">                    this.images[this.randomIndex] = &#123;</span><br><span class="line">                        url: `app.media.img_0$&#123;this.randomIndex&#125;`,</span><br><span class="line">                        count: this.images[this.randomIndex].count + 1</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // 每次收完卡片, 需要进行简单的检索, 判断是否集齐</span><br><span class="line">                    // 需求: 判断数组项的count, 是否都大于0, 只要有一个等于0,就意味着没集齐</span><br><span class="line">                    let flag: boolean = true // 假设集齐</span><br><span class="line"></span><br><span class="line">                    // 验证是否集齐</span><br><span class="line">                    for (let item of this.images) &#123;</span><br><span class="line">                        if (item.count == 0) &#123;</span><br><span class="line">                            flag = false // 没集齐</span><br><span class="line">                            break // 后面的没必要判断了</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    this.isGet = flag</span><br><span class="line"></span><br><span class="line">                    // 判断是否中奖了, 如果是 需要抽奖</span><br><span class="line">                    if (flag) &#123;</span><br><span class="line">                        let randomIndex: number = Math.floor(Math.random() * 3)</span><br><span class="line">                        this.prize = this.arr[randomIndex]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            .justifyContent(FlexAlign.Center)</span><br><span class="line">                .width(&#x27;100%&#x27;)</span><br><span class="line">                .height(&#x27;100%&#x27;)</span><br><span class="line">            // 颜色十六进制色值,如果是八位,前两位,就是透明度</span><br><span class="line">                .backgroundColor(&#x27;#cc000000&#x27;)</span><br><span class="line">            // 设置透明度</span><br><span class="line">                .opacity(this.maskOpacity)</span><br><span class="line">                .zIndex(this.maskZIndex)</span><br><span class="line">            // 动画 animation, 当我们元素有状态的改变,可以添加animation做动画</span><br><span class="line">                .animation(&#123;</span><br><span class="line">                duration: 200</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            // 抽大奖的遮罩层</span><br><span class="line">            if (this.isGet) &#123;</span><br><span class="line">                Column(&#123; space: 30 &#125;) &#123;</span><br><span class="line">                    Text(&#x27;恭喜获得手机一部&#x27;)</span><br><span class="line">                        .fontColor(&#x27;#f5ebcf&#x27;)</span><br><span class="line">                        .fontSize(25)</span><br><span class="line">                        .fontWeight(700)</span><br><span class="line">                    Image($r(`app.media.$&#123;this.prize&#125;`))</span><br><span class="line">                        .width(300)</span><br><span class="line">                    Button(&#x27;再来一次&#x27;)</span><br><span class="line">                        .width(200)</span><br><span class="line">                        .height(50)</span><br><span class="line">                        .backgroundColor(Color.Transparent)</span><br><span class="line">                        .border(&#123; width: 2, color: &#x27;#fff9e0&#x27; &#125;)</span><br><span class="line">                        .onClick(() =&gt; &#123;</span><br><span class="line">                        this.isGet = false</span><br><span class="line">                        this.prize = &#x27;&#x27;</span><br><span class="line">                        this.images = [</span><br><span class="line">                            &#123; url: &#x27;app.media.bg_00&#x27;, count: 0 &#125;,</span><br><span class="line">                            &#123; url: &#x27;app.media.bg_01&#x27;, count: 0 &#125;,</span><br><span class="line">                            &#123; url: &#x27;app.media.bg_02&#x27;, count: 0 &#125;,</span><br><span class="line">                            &#123; url: &#x27;app.media.bg_03&#x27;, count: 0 &#125;,</span><br><span class="line">                            &#123; url: &#x27;app.media.bg_04&#x27;, count: 0 &#125;,</span><br><span class="line">                            &#123; url: &#x27;app.media.bg_05&#x27;, count: 0 &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">                .justifyContent(FlexAlign.Center)</span><br><span class="line">                    .width(&#x27;100%&#x27;)</span><br><span class="line">                    .height(&#x27;100%&#x27;)</span><br><span class="line">                    .backgroundColor(&#x27;#cc000000&#x27;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>鸿蒙next应用开发</category>
      </categories>
      <tags>
        <tag>鸿蒙next应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>0.SMT32原理概述</title>
    <url>/post/99cd7d8.html</url>
    <content><![CDATA[<h1><center>51和32区别</center></h1>
<p>位数：</p>
<ul>
<li>51：8位（STC89C52）</li>
<li>32：32位（STM32F103ZET6）</li>
</ul>
<p>时钟：</p>
<ul>
<li>51：11.0592Mhz晶振</li>
<li>32
<ul>
<li>F103：8Mhz晶振(×9)，主频：72Mhz</li>
<li>F103：12Mhz晶振(×6)，主频：72Mhz</li>
<li>F407：168Mhz主频</li>
</ul>
</li>
</ul>
<h1><center>时钟</center></h1>
<p>E：外部，I：内部</p>
<p>高速外部晶振：HSE</p>
<p>低速外部晶振：LSE</p>
<p>高速内部晶振：HSI</p>
<p>低速内部晶振：LSI</p>
<p>锁相环：让8MHz晶振变成72MHz主频</p>
<p>每个外设初始化的大致流程</p>
<ol>
<li>把图形化界面配置的参数赋值给对应的结构体的成员变量</li>
<li>把结构体地址当做参数传给初始化函数</li>
<li>初始化函数根据每个结构体成员变量操作对应的寄存器</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//时钟初始化</span></span><br><span class="line">SystemClock_Config();</span><br><span class="line"></span><br><span class="line">RCC_OscInitTypeDef RCC_OscInitStruct = &#123;<span class="number">0</span>&#125;;	<span class="comment">//结构体类型变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在void SystemClock_Config(void)中(main.c第133)</span></span><br><span class="line">RCC_OscInitStruct.HSEState = RCC_HSE_ON;	<span class="comment">//(144行)</span></span><br><span class="line"></span><br><span class="line">HAL_RCC_OscConfig(&amp;RCC_OscInitStruct);	<span class="comment">//(main.c第148)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)中</span></span><br><span class="line">__HAL_RCC_HSE_CONFIG(RCC_OscInitStruct-&gt;HSEState);	<span class="comment">//377行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAL_RCC_HSE_CONFIG(__STATE__)	<span class="comment">//__STATE__ = RCC_OscInitStruct-&gt;HSEState(RCC_HSE_ON)  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((__STATE__) == RCC_HSE_ON)                        </span><br><span class="line">&#123;                                                     </span><br><span class="line">    SET_BIT(RCC-&gt;CR, RCC_CR_HSEON);	<span class="comment">//RCC-&gt;CR = 时钟控制寄存器(RCC_CR)</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_CR_HSEON_Pos           (16U)</span></span><br><span class="line"><span class="comment">//0x1左移16位（注意是二进制左移）               </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_CR_HSEON_Msk           (0x1UL &lt;&lt; RCC_CR_HSEON_Pos)   <span class="comment">/*!&lt; 0x00010000 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_CR_HSEON               RCC_CR_HSEON_Msk</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第17个数为1，则是第十六位，第16位：0：HSE振荡器关闭，1：HSE振荡器开启。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_BIT(REG, BIT)     ((REG) |= (BIT))	<span class="comment">//BIT = RCC_CR_HSEON(0x00010000)</span></span></span><br></pre></td></tr></table></figure>
<h1><center>STM32芯片参数</center></h1>
<p>Core: ARM 32-bit Cortex™-M3 CPU：ARM架构，32位单片机，内核型号</p>
<p>72 MHz maximum frequency：72MHz主频</p>
<p>芯片型号含义：</p>
<img src="https://s2.loli.net/2024/08/18/Xf4AWgFkqEMdImR.png" alt="芯片型号含义" style="zoom:50%;">
<p>Flash：磁盘，RAM：运行内存</p>
<p>一般软件、代码等运行在RAM，但32单片机代码运行在Flash</p>
<ul>
<li>
<p>3 × 12-bit A/D converter = ADC：A：模拟信号，D：数字信号，模拟信号转数字信号</p>
</li>
<li>
<p>3：3路ADC</p>
</li>
<li>
<p>Conversion range: 0 to 3.6 V：采样值 0-3.6V</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>12</mn><mi>b</mi><mi>i</mi><mi>t</mi><mtext>：</mtext><msup><mn>2</mn><mn>12</mn></msup><mo>=</mo><mn>4096</mn><mtext>，将采样范围分成</mtext><mn>4096</mn><mtext>份，即为采样精度，这个越高精度越高</mtext></mrow><annotation encoding="application/x-tex">12bit：2^{12} = 4096，将采样范围分成4096份，即为采样精度，这个越高精度越高
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">：</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">9</span><span class="mord">6</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">将</span><span class="mord cjk_fallback">采</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">范</span><span class="mord cjk_fallback">围</span><span class="mord cjk_fallback">分</span><span class="mord cjk_fallback">成</span><span class="mord">4</span><span class="mord">0</span><span class="mord">9</span><span class="mord">6</span><span class="mord cjk_fallback">份</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">即</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">采</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">精</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">越</span><span class="mord cjk_fallback">高</span><span class="mord cjk_fallback">精</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">越</span><span class="mord cjk_fallback">高</span></span></span></span></span></p>
</li>
<li>
<p>2 × 12-bit D/A converters = DAC：数字信号转模拟信号</p>
</li>
<li>
<p>Serial wire debug (SWD) ：STL烧写</p>
</li>
<li>
<p>Up to 112 fast I/O ports：112个IO口功能引脚</p>
</li>
<li>
<p>Up to 11 timers：11个定时器</p>
</li>
</ul>
<h1><center>软件安装与使用</center></h1>
<p>注意：<code>所有路径不能有中文</code>(包含用户名)</p>
<p>安装：keil、STM32CubeMX、STM32CubeIDE</p>
<p><a href="https://68565200.xyz/post/32e9e993">STM32CubeIDE与STM32CubeMX库文件安装路径自定义设置</a></p>
<p>搜索自己芯片型号（我的型号：<code>STM32F103ZET6</code>）</p>
<img src="https://s2.loli.net/2024/08/18/BcU893rOSfuJI7d.png" alt="便捷技巧" style="zoom: 33%;">
<h2 id="center-新建工程必须设置-center"><center>新建工程必须设置</center></h2>
<h3 id="stm32cubemx">STM32CubeMX</h3>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/18/zVXJctPDauYAiEe.png" alt="设置1" style="zoom: 33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/18/Z295FijITYL1ceM.png" alt="设置2" style="zoom:33%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<hr>
<img src="https://s2.loli.net/2024/08/18/3naEX7eYcKoGSgw.png" alt="时钟配置" style="zoom:33%;">
<hr>
<img src="https://s2.loli.net/2024/08/18/SRziQZt6OrF3Xk4.png" alt="工程" style="zoom: 33%;">
<hr>
<img src="https://s2.loli.net/2024/08/18/ULEWDrq1JtKAf6v.png" alt="工程1" style="zoom:33%;">
<hr>
<p>完成，建工程</p>
<img src="https://s2.loli.net/2024/08/18/diSyXbuJqtn6RVG.png" alt="完成" style="zoom: 33%;">
<h3 id="stm32cubeide">STM32CubeIDE</h3>
<p>新建工程</p>
<img src="https://s2.loli.net/2024/08/18/spVr96oLQuyWYSj.png" alt="新建工程" style="zoom: 50%;">
<hr>
<img src="https://s2.loli.net/2024/08/18/nQOqtFurGC58kfK.png" alt="选型号" style="zoom: 33%;">
<hr>
<img src="https://s2.loli.net/2024/08/18/8x5RlgjHTpS6BAv.png" alt="工程名" style="zoom: 33%;">
<hr>
<p>版本号这里：1.8.5</p>
<img src="https://s2.loli.net/2024/08/18/8ysUn6aKjRJPh9o.png" alt="完成" style="zoom: 33%;">
<p>若别人工程为别的版本，需下载别的版本</p>
<img src="https://s2.loli.net/2024/08/18/4L5dn7K2akWYr6l.png" alt="下载1" style="zoom: 50%;">
<p>下载工程对应版本即可</p>
<img src="https://s2.loli.net/2024/08/18/NtTjY59AI3mziJs.png" alt="载对应版本" style="zoom:50%;">
<hr>
<p>这里与STM32CubeMX相同，参考上面配置，最后：<code>ctrl + s</code> 保存</p>
<img src="https://s2.loli.net/2024/08/18/g9cr27yvVWJZ3SH.png" alt="在这里插入图片描述" style="zoom: 33%;">
<p>Keil+CubeMX = CubeIDE</p>
<h1><center>烧录</center></h1>
<p>代码烧录方式</p>
<h2 id="center-st-link-center"><center>ST-Link</center></h2>
<p>将ST-Link烧写器与单片机连接</p>
<p><strong>CubeMX keil软件烧录</strong></p>
<p>编译无错误后，点击图中框选按钮烧录</p>
<img src="https://s2.loli.net/2024/08/18/xGsj9lcXDpNEKUZ.png" alt="烧录按钮" style="zoom:50%;">
<p>若烧录不成功，可看是否是这个错误：<a href="https://blog.csdn.net/qq_65047384/article/details/140702048?spm=1001.2014.3001.5501">链接</a></p>
<p><strong>CubeIDE软件烧录</strong></p>
<p>编译无错误后，点击图中框选按钮烧录</p>
<img src="https://s2.loli.net/2024/08/18/pDr7oWnvOHNE63d.png" alt="烧录介绍" style="zoom:50%;">
<h2 id="center-stm32-st-link-utility-center"><center>STM32 ST-LINK Utility</center></h2>
<p>其实是一个烧写软件，看图可知，对应功能</p>
<img src="https://s2.loli.net/2024/08/18/6EMkKljU4OPSIwC.png" alt="介绍" style="zoom:50%;">
<p>选择好对应hex文件，直接烧写即可</p>
<img src="https://s2.loli.net/2024/08/18/ed8lY9jhPgntsHL.png" alt="烧写界面" style="zoom:50%;">
<h2 id="center-串口烧录-center"><center>串口烧录</center></h2>
<p>步骤：</p>
<ol>
<li>
<p>数据线连接电脑和单片机串口1</p>
</li>
<li>
<p>手动将板子的BOOT0置1，BOOT1置0，使用Bootloader方式</p>
</li>
<li>
<p>断电 重启</p>
</li>
<li>
<p>打开FlyMCU软件烧写（若没有反应可按复位按钮尝试）</p>
 <img src="https://s2.loli.net/2024/08/18/YDcR9GamM1gBJ4K.png" alt="界面介绍" style="zoom:50%;">
</li>
<li>
<p>手动将板子的BOOT0置0，BOOT1置0</p>
</li>
<li>
<p>板子重新上电</p>
</li>
</ol>
]]></content>
      <categories>
        <category>32单片机</category>
      </categories>
      <tags>
        <tag>32单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>1.界面开发</title>
    <url>/post/de777d6b.html</url>
    <content><![CDATA[<h1>组件属性方法</h1>
<p>Ctrl+p：提示方法</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性方法</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.width()，参数：数字 或 数字%</td>
<td style="text-align:center">宽度</td>
</tr>
<tr>
<td style="text-align:center">.height()，参数：数字 或 数字%</td>
<td style="text-align:center">高度</td>
</tr>
<tr>
<td style="text-align:center">.aspectRatio(数字)，参数比例</td>
<td style="text-align:center">宽高比例</td>
</tr>
<tr>
<td style="text-align:center">.pading()，参数：数字 或 {top/right/bottom(下)/left: 数字}</td>
<td style="text-align:center">内边距</td>
</tr>
<tr>
<td style="text-align:center">.margin()，参数：数字 或 {top/right/bottom(下)/left: 数字}</td>
<td style="text-align:center">外边距</td>
</tr>
<tr>
<td style="text-align:center">.border(参数)，参数：数值 或 对象 (四边单独设置)</td>
<td style="text-align:center">边框</td>
</tr>
<tr>
<td style="text-align:center">.borderRadius(参数)，参数：数值 或 对象 (四个角单独设置)</td>
<td style="text-align:center">圆角</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">.backgroundcolor()，参数：Color.自带枚举颜色 或 ‘#十六进制’</td>
<td style="text-align:center">背景色</td>
</tr>
<tr>
<td style="text-align:center">.backgroundImage(背景图地址, 背景图平铺方式)，图地址：本地或图片链接</td>
<td style="text-align:center">背景图</td>
</tr>
<tr>
<td style="text-align:center">.backgroundImagePosition(参数)</td>
<td style="text-align:center">背景图位置</td>
</tr>
<tr>
<td style="text-align:center">.backgroundImageSize(宽高对象 或 枚举)</td>
<td style="text-align:center">背景图尺寸</td>
</tr>
<tr>
<td style="text-align:center">.fillColor()，参数：Color.自带枚举颜色 或 ‘#十六进制’</td>
<td style="text-align:center">svg图标颜色</td>
</tr>
<tr>
<td style="text-align:center">.fontsize(数字)，默认16</td>
<td style="text-align:center">字体大小</td>
</tr>
<tr>
<td style="text-align:center">.fontWeight()，参数：FontWeight.自带枚举粗细 或 200~900值(默认400,粗700)</td>
<td style="text-align:center">字体粗细</td>
</tr>
<tr>
<td style="text-align:center">.fontColor()，参数：Color.自带枚举颜色 或 ‘#十六进制’</td>
<td style="text-align:center">字体颜色</td>
</tr>
<tr>
<td style="text-align:center">.textAlign(TextAlign.枚举值)</td>
<td style="text-align:center">字体对齐</td>
</tr>
<tr>
<td style="text-align:center">.fontStyle(FontStyle.Italic)</td>
<td style="text-align:center">字体倾斜</td>
</tr>
<tr>
<td style="text-align:center">.lineHeight(数字)</td>
<td style="text-align:center">行高</td>
</tr>
<tr>
<td style="text-align:center">.maxLines(行数)</td>
<td style="text-align:center">显示最大的行数</td>
</tr>
<tr>
<td style="text-align:center">.placeholderColor()，参数：Color.自带枚举颜色 或 ‘#十六进制’</td>
<td style="text-align:center">输入框占位符字体颜色</td>
</tr>
<tr>
<td style="text-align:center">.type(InputType.Normal)</td>
<td style="text-align:center">基本输入模式，无特殊限制</td>
</tr>
<tr>
<td style="text-align:center">.type(InputType.Password)</td>
<td style="text-align:center">密码输入模式</td>
</tr>
<tr>
<td style="text-align:center">{space: 间隙大小}</td>
<td style="text-align:center">控制组件间的距离</td>
</tr>
<tr>
<td style="text-align:center">.zIndex(数字)</td>
<td style="text-align:center">层级</td>
</tr>
<tr>
<td style="text-align:center">.position({x: 数字, y: 数字})</td>
<td style="text-align:center">绝对定位</td>
</tr>
<tr>
<td style="text-align:center">.layoutWeight(数字)</td>
<td style="text-align:center">自适应伸缩</td>
</tr>
<tr>
<td style="text-align:center">.opacity(数字) //0~1</td>
<td style="text-align:center">透明度</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h1>简单界面布局</h1>
<p>构建页面的最小单位就是 “组件”</p>
<p>布局思路：先排版，再放内容，再美化</p>
<p>组件分类：</p>
<ul>
<li>基础组件：界面呈现的基础元素
<ul>
<li>如：文字、图片、按钮等</li>
</ul>
</li>
<li>容器组件：控制布局排布
<ul>
<li>如：<code>Row行</code>、<code>Column列</code>(默认有居中效果)等</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">build() &#123;</span><br><span class="line">    //最外层只能有一个容器组件</span><br><span class="line">    容器组件()&#123;</span><br><span class="line">        基础组件(参数)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build() &#123;</span><br><span class="line">    //纵向排列</span><br><span class="line">    Column()&#123;</span><br><span class="line">        Text(&#x27;小说简介&#x27;)</span><br><span class="line"></span><br><span class="line">        //横向排列</span><br><span class="line">        Row()&#123;</span><br><span class="line">            Text(&#x27;都市&#x27;)</span><br><span class="line">            Text(&#x27;都市生活&#x27;)</span><br><span class="line">            Text(&#x27;情感&#x27;)</span><br><span class="line">            Text(&#x27;男频&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>组件属性方法的使用</h1>
<p>参数有特殊符号都需要 ‘’ 包裹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">容器组件() &#123;</span><br><span class="line">&#125;</span><br><span class="line">.属性方法1(参数)</span><br><span class="line">.属性方法2(参数)</span><br><span class="line"></span><br><span class="line">基础组件(参数)</span><br><span class="line">    .属性方法1(参数)</span><br><span class="line">    .属性方法2(参数)</span><br><span class="line"></span><br><span class="line">build() &#123;</span><br><span class="line">    //纵向排列</span><br><span class="line">    Column()&#123;</span><br><span class="line">        Text(&#x27;小说简介&#x27;)</span><br><span class="line">            .fontSize(20)</span><br><span class="line">            .width(&#x27;100%&#x27;)  //有特殊符号都需要&#x27;&#x27;包裹</span><br><span class="line">            .height(30)</span><br><span class="line">        //.fontWeight(FontWeight.Bold)</span><br><span class="line">            .fontWeight(700)</span><br><span class="line">            .fontColor(Color.Red)</span><br><span class="line"></span><br><span class="line">        //横向排列</span><br><span class="line">        Row()&#123;</span><br><span class="line">            Text(&#x27;都市&#x27;)</span><br><span class="line">                .width(50)</span><br><span class="line">                .height(30)</span><br><span class="line">                .backgroundColor(Color.Orange)</span><br><span class="line">            Text(&#x27;都市生活&#x27;)</span><br><span class="line">                .width(90)</span><br><span class="line">                .height(30)</span><br><span class="line">                .backgroundColor(&#x27;#32f2&#x27;)</span><br><span class="line">            Text(&#x27;情感&#x27;)</span><br><span class="line">                .width(50)</span><br><span class="line">                .height(30)</span><br><span class="line">                .backgroundColor(Color.Yellow)</span><br><span class="line">        &#125;</span><br><span class="line">        .width(&#x27;100%&#x27;)</span><br><span class="line">        .height(30)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>文本</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Text(&#x27;文本&#x27;)</span><br><span class="line">Text()&#123;</span><br><span class="line">    ImageSpan(图片资源)	//文本中小图标</span><br><span class="line">    Span(&#x27;文本&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>文字溢出省略</h1>
<p>需要配合<code>.maxLines(行数)</code>使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.textOverflow(&#123;</span><br><span class="line">    //XXX：文本超出后显示的样式</span><br><span class="line">    overflow: TextOverflow.XXX</span><br><span class="line">&#125;)</span><br><span class="line">    .maxLines(行数)</span><br><span class="line"></span><br><span class="line">Column()&#123;</span><br><span class="line">    Text(&#x27;HarmonyOS开发初体验&#x27;)</span><br><span class="line">        .width(&#x27;100%&#x27;)</span><br><span class="line">        .fontSize(20)</span><br><span class="line">        .lineHeight(20)</span><br><span class="line">        .fontWeight(FontWeight.Bold)</span><br><span class="line">    Text(&#x27;方舟开发框架（简称ArkUl）为HarmonyOS应用的\n&#x27; +</span><br><span class="line">         &#x27;UI开发提供了完整的基础设施，包括简洁的UI语\n&#x27; +</span><br><span class="line">         &#x27;法、丰富的UI功能（组件、布局、动画以及交互事\n&#x27; +</span><br><span class="line">         &#x27;件），以及实时界面预览工具等，可以支持开发者\n&#x27; +</span><br><span class="line">         &#x27;进行可视化界面开发&#x27;)</span><br><span class="line">        .width(&#x27;100%&#x27;)</span><br><span class="line">        .lineHeight(20)</span><br><span class="line">        .textOverflow(&#123;</span><br><span class="line">        overflow: TextOverflow.Ellipsis</span><br><span class="line">    &#125;)</span><br><span class="line">        .maxLines(2)</span><br><span class="line">&#125;</span><br><span class="line">.width(&#x27;100%&#x27;)</span><br></pre></td></tr></table></figure>
<h1>图片组件</h1>
<p>工程中图片存放路径：<code>src/main/resources/base/media</code> 中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Image(&#x27;https://www.itheima.com/images/logo.png&#x27;)	//网络图片资源</span><br><span class="line">Image( $r(&#x27;app.media.文件名&#x27;) )	//本地图片资源</span><br><span class="line"></span><br><span class="line">Column() &#123;</span><br><span class="line">    Image(&#x27;https://www.itheima.com/images/logo.png&#x27;)</span><br><span class="line">        .width(200) //只需设置宽或高 就会等比例缩放</span><br><span class="line">    Image($r(&#x27;app.media.background&#x27;))</span><br><span class="line">        .width(200)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>输入框 与 按钮</h1>
<blockquote>
<p>placeholder 提示文本</p>
<p>type(InputType.Normal)：基本输入模式，无特殊限制</p>
<p>type(InputType.Password)：密码输入模式</p>
<p>给 Column 或 Row 设置 {space: 间隙大小}：控制组件间的距离</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//输入框</span><br><span class="line">TextInput(&#123;</span><br><span class="line">    placeholder: &#x27;占位符文本&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">.placeholderColor()	//十六进制或枚举值</span><br><span class="line"></span><br><span class="line">//按钮</span><br><span class="line">Button(&#x27;按钮文本&#x27;)</span><br><span class="line"></span><br><span class="line">Column(&#123;space: 10&#125;) &#123;</span><br><span class="line">    TextInput(&#123;</span><br><span class="line">        placeholder: &#x27;请输入用户名&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">    TextInput(&#123;</span><br><span class="line">        placeholder: &#x27;请输入密码&#x27;</span><br><span class="line">    &#125;).type(InputType.Password)</span><br><span class="line">    Button(&#x27;登录&#x27;)</span><br><span class="line">        .width(200)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>svg图标</h1>
<p>任意放大缩小不失真、可以改颜色，使用方法与普通图片一致，图片后缀 .svg</p>
<p>HarmonyOS图标库：<a href="https://developer.huawei.com/consumer/cn/design/harmonyos-icon/">地址</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Column() &#123;</span><br><span class="line">    Image($r(&#x27;app.media.ic_fly&#x27;))</span><br><span class="line">        .width(&#x27;10%&#x27;)</span><br><span class="line">        //.fillColor(Color.Green)</span><br><span class="line">        .fillColor(&#x27;#b0473d&#x27;) //设置图标颜色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>布局元素和边框</h1>
<p>内边距：padding 在 组件内 添加间距，拉开内容与组件边缘之间的距离</p>
<p>外边距：margin 在 组件外 添加间距，拉开两个组件之间的距离</p>
<p>边框：border 给组件添加边界</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//内边距</span><br><span class="line">.padding(20)	//四周都有内边距</span><br><span class="line">.padding(&#123;</span><br><span class="line">    right: 20,	//右内边距20</span><br><span class="line">    top: 30,	//上内边距30</span><br><span class="line">    bottom: 40,	//下内边距40</span><br><span class="line">    left: 20	//左内边距20</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//外边距</span><br><span class="line">.margin(10)</span><br><span class="line">.margin(&#123;</span><br><span class="line">    right: 20,	//右外边距20</span><br><span class="line">    top: 30,	//上外边距30</span><br><span class="line">    bottom: 40,	//下外边距40</span><br><span class="line">    left: 20	//左外边距20</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//边框</span><br><span class="line">.border(&#123;</span><br><span class="line">    width: 1, 	//边框宽度</span><br><span class="line">    color: Color.Blue,</span><br><span class="line">    style: BorderStyle.Dotted 	//样式(虚线、实线、点线)</span><br><span class="line">&#125;)</span><br><span class="line">.border(&#123;</span><br><span class="line">    width: &#123; left: 1 &#125;,</span><br><span class="line">    color: &#123; left: &#x27;red&#x27; &#125;,</span><br><span class="line">    style: &#123; left: BorderStyle.Solid &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Column() &#123;</span><br><span class="line">    Row() &#123;</span><br><span class="line">        Text(&#x27;小龙女&#x27;)</span><br><span class="line">            .backgroundColor(Color.Green)</span><br><span class="line">            .padding(20)//四周都有内边距</span><br><span class="line">            .margin(&#123;</span><br><span class="line">            right: 20,	//右外边距20</span><br><span class="line">            top: 30,	//上外边距30</span><br><span class="line">            bottom: 40,	//下外边距40</span><br><span class="line">            left: 20	//左外边距20</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        Text(&#x27;大佬&#x27;)</span><br><span class="line">            .backgroundColor(Color.Orange)</span><br><span class="line">            .padding(&#123;</span><br><span class="line">            right: 20,	//右内边距20</span><br><span class="line">            top: 30,	//上内边距30</span><br><span class="line">            bottom: 40,	//下内边距40</span><br><span class="line">            left: 20	//左内边距20</span><br><span class="line">        &#125;)</span><br><span class="line">            .margin(10)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Text(&#x27;待完善&#x27;)</span><br><span class="line">        .padding(10)</span><br><span class="line">        .fontColor(Color.Blue)</span><br><span class="line">        .border(&#123;</span><br><span class="line">        width: 1, 	//边框宽度</span><br><span class="line">        color: Color.Blue,</span><br><span class="line">        style: BorderStyle.Dotted 	//样式(虚线、实线、点线)</span><br><span class="line">    &#125;)</span><br><span class="line">    Text(&#x27;单边框&#x27;)</span><br><span class="line">        .margin(&#123;</span><br><span class="line">        top: 10</span><br><span class="line">    &#125;)</span><br><span class="line">        .padding(10)</span><br><span class="line">        .border(&#123;</span><br><span class="line">            width: &#123; left: 1 &#125;,</span><br><span class="line">            color: &#123; left: &#x27;red&#x27; &#125;,</span><br><span class="line">            style: &#123; left: BorderStyle.Solid &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>角标组件</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Badge(&#123;</span><br><span class="line">    count: 数字,	//角标数值</span><br><span class="line">    position: BadgePosition.枚举值,	//角标位置</span><br><span class="line">    style: &#123;</span><br><span class="line">        fontSize: 14,	//角标文字大小</span><br><span class="line">        badgeSize: 20,	// 角标大小</span><br><span class="line">        badgeColor:&#x27;#fa2a2d&#x27;	// 角标底色</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)&#123;</span><br><span class="line">    //这里写角标下面的图片</span><br><span class="line">    Image(图片链接)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Badge(&#123;</span><br><span class="line">    count: 1,</span><br><span class="line">    position: BadgePosition.RightTop,</span><br><span class="line">    style: &#123;</span><br><span class="line">        fontSize: 14,</span><br><span class="line">        badgeSize: 20,</span><br><span class="line">        badgeColor:&#x27;#fa2a2d&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)&#123;</span><br><span class="line">    Image($r(&#x27;app.media.bg_00&#x27;))</span><br><span class="line">        .width(100)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>组件圆角</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.borderRadius(5) 	// 四个圆角相同</span><br><span class="line">    .borderRadius(&#123;</span><br><span class="line">    topLeft: 5,</span><br><span class="line">    topRight: 10,</span><br><span class="line">    bottomRight: 15,</span><br><span class="line">    bottomLeft: 20</span><br><span class="line">&#125;) // 四个方向圆角，单独设置</span><br><span class="line"></span><br><span class="line">Column() &#123;</span><br><span class="line">    Text(&#x27;xinzai&#x27;)</span><br><span class="line">        .width(50)</span><br><span class="line">        .height(50)</span><br><span class="line">        .backgroundColor(Color.Orange)</span><br><span class="line">    //.borderRadius(6)</span><br><span class="line">        .borderRadius(&#123;</span><br><span class="line">        topLeft: 5,</span><br><span class="line">        topRight: 10,</span><br><span class="line">        bottomLeft: 2,</span><br><span class="line">        bottomRight: 9</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="特殊形状圆角">特殊形状圆角</h2>
<p>正圆：宽高都一样，圆角为宽或高的一半</p>
<p>胶囊：宽大高小，圆角为高的一半</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Column() &#123;</span><br><span class="line">    Image($r(&#x27;app.media.ic_more&#x27;))</span><br><span class="line">        .width(60)</span><br><span class="line">        .height(60)</span><br><span class="line">        .backgroundColor(Color.Green)</span><br><span class="line">        .borderRadius(30)</span><br><span class="line">    Text(&#x27;胶囊&#x27;)</span><br><span class="line">        .width(100)</span><br><span class="line">        .height(50)</span><br><span class="line">        .backgroundColor(Color.Orange)</span><br><span class="line">        .borderRadius(25)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>单位</h1>
<p>px：实际的物理像素点</p>
<p>vp：虚拟像素，相对于不同的设备会自动转换，保证不同设备视觉一致 （推荐）</p>
<p>px 转 vp：<code>px2vp(数值)</code></p>
<p>vp 转 px：<code>vp2px(数值)</code></p>
<h1>背景图</h1>
<p>背景图：backgroundImage</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.backgroundImage(背景图地址, ImageRepeat.平铺方式)</span><br><span class="line">/*</span><br><span class="line">背景图平铺方式(可省略)：</span><br><span class="line">    NoRepeat：不平铺，默认值</span><br><span class="line">    X：水平平铺</span><br><span class="line">    Y：垂直平铺</span><br><span class="line">    XY：水平垂直均平铺	*/</span><br><span class="line"></span><br><span class="line">Column() &#123;</span><br><span class="line">    Text(&#x27;花朵&#x27;)</span><br><span class="line">        .width(200)</span><br><span class="line">        .height(100)</span><br><span class="line">        .backgroundColor(Color.Pink)</span><br><span class="line">        .backgroundImage($r(&#x27;app.media.flower&#x27;),ImageRepeat.XY)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>背景图位置：backgroundImagePosition</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.backgroundImagePosition(&#123; x: 数字, y: 数字 &#125;)</span><br><span class="line">.backgroundImagePosition(Alignment.枚举值)</span><br><span class="line"></span><br><span class="line">Column() &#123;</span><br><span class="line">    Text(&#x27;花朵&#x27;)</span><br><span class="line">        .width(200)</span><br><span class="line">        .height(100)</span><br><span class="line">        .backgroundColor(Color.Pink)</span><br><span class="line">        .backgroundImage($r(&#x27;app.media.flower&#x27;))</span><br><span class="line">    //.backgroundImagePosition(&#123;x: 100,y: 10&#125;)</span><br><span class="line">        .backgroundImagePosition(Alignment.Center)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>背景图尺寸：backgroundImageSize</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.backgroundImageSize( &#123;&#123;width: 数字, height: 数字&#125; &#125;)</span><br><span class="line">.backgroundImageSize(ImageSize.枚举值)</span><br><span class="line">/*枚举值：</span><br><span class="line">Contain：等比例缩放背景图，当宽或高与组件尺寸相同停止缩放</span><br><span class="line">Cover：等比例缩放背景图至图片完全覆盖组件范围</span><br><span class="line">Auto：默认，原图尺寸	*/</span><br><span class="line"></span><br><span class="line">Column()&#123;</span><br><span class="line">    Text()</span><br><span class="line">        .width(300)</span><br><span class="line">        .height(200)</span><br><span class="line">        .backgroundColor(Color.Pink)</span><br><span class="line">        .backgroundImage($r(&#x27;app.media.user&#x27;))</span><br><span class="line">        .backgroundImagePosition(Alignment.Center)</span><br><span class="line">            //.backgroundImageSize(&#123;width: 300, height: 200&#125;)</span><br><span class="line">        .backgroundImageSize(ImageSize.Contain)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>线性布局</h1>
<p>排布主方向上的对齐方式，<code>Row行</code>、<code>Column列</code>效果相似(主轴)，对齐的那个方向必须设置大小</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/11/16/XE1bMO9pfWusNDm.jpg" alt="效果图" style="zoom:15%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.justifyContent(FlexAlign.枚举值)</span><br><span class="line"></span><br><span class="line">Column()&#123;</span><br><span class="line">    Text()</span><br><span class="line">        .width(200)</span><br><span class="line">        .height(100)</span><br><span class="line">        .backgroundColor(Color.Pink)</span><br><span class="line">        .border(&#123;</span><br><span class="line">        width: 1</span><br><span class="line">    &#125;)</span><br><span class="line">    Text()</span><br><span class="line">        .width(200)</span><br><span class="line">        .height(100)</span><br><span class="line">        .backgroundColor(Color.Blue)</span><br><span class="line">        .border(&#123;</span><br><span class="line">        width: 1</span><br><span class="line">    &#125;)</span><br><span class="line">    Text()</span><br><span class="line">        .width(200)</span><br><span class="line">        .height(100)</span><br><span class="line">        .backgroundColor(Color.Green)</span><br><span class="line">        .border(&#123;</span><br><span class="line">        width: 1</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">.width(&#x27;100%&#x27;)</span><br><span class="line">.height(&#x27;100%&#x27;)</span><br><span class="line">.justifyContent(FlexAlign.Center)</span><br><span class="line">.justifyContent(FlexAlign.SpaceBetween)</span><br><span class="line">.justifyContent(FlexAlign.SpaceEvenly)</span><br><span class="line">.justifyContent(FlexAlign.SpaceAround)</span><br></pre></td></tr></table></figure>
<h2 id="交叉轴对齐方式">交叉轴对齐方式</h2>
<p>若主轴为垂直方向，则交叉轴为水平方向，反之则垂直方向，对齐的那个方向必须设置大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//交叉轴在水平方向</span><br><span class="line">.alignItems(HorizontalAlign.枚举值)</span><br><span class="line">//交叉轴在垂直方向</span><br><span class="line">.alignItems(VerticalAlign.枚举值)</span><br><span class="line"></span><br><span class="line">Column()&#123;</span><br><span class="line">    Text()</span><br><span class="line">        .width(100)</span><br><span class="line">        .height(100)</span><br><span class="line">        .backgroundColor(Color.Blue)</span><br><span class="line">    Text()</span><br><span class="line">        .width(100)</span><br><span class="line">        .height(100)</span><br><span class="line">        .backgroundColor(Color.Gray)</span><br><span class="line">&#125;</span><br><span class="line">.width(&#x27;100%&#x27;)</span><br><span class="line">.height(&#x27;100%&#x27;)</span><br><span class="line">.backgroundColor(&#x27;#3c3c3c3c&#x27;)</span><br><span class="line">.alignItems(HorizontalAlign.Start)</span><br></pre></td></tr></table></figure>
<h1>自适应伸缩</h1>
<p>按照权重(数字越大权重越高) 进行分配 主轴 的 空间 (剩余空间)，必须设置交叉轴的大小，否则没效果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.layoutWeight(数字)</span><br><span class="line"></span><br><span class="line">Column()&#123;</span><br><span class="line">    Row()&#123;</span><br><span class="line">        Text()</span><br><span class="line">            .width(100)</span><br><span class="line">            .height(100)</span><br><span class="line">            .backgroundColor(Color.Orange)</span><br><span class="line">        Text()</span><br><span class="line">            .layoutWeight(1)</span><br><span class="line">            .height(100)</span><br><span class="line">            .backgroundColor(Color.Blue)</span><br><span class="line">        Text()</span><br><span class="line">            .layoutWeight(2)</span><br><span class="line">            .height(100)</span><br><span class="line">            .backgroundColor(Color.Green)</span><br><span class="line">    &#125;</span><br><span class="line">    .width(300)</span><br><span class="line">        .height(200)</span><br><span class="line">        .backgroundColor(Color.White)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>弹性布局和弹簧组件</h1>
<p>弹簧组件：Blank()</p>
<p>线性布局性能更高，不规则的时候需要换行，才使用，如下图所示</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/11/23/IjZYl42K8PxuGHq.webp" alt="场景" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Flex(&#123;</span><br><span class="line">    direction: FlexDirection.枚举值,	//主轴方向</span><br><span class="line">    justifyContent: FlexAlign.枚举值,	//主轴对齐方式</span><br><span class="line">    alignItems: ItemAlign.枚举值,	//交叉轴对齐方式</span><br><span class="line">    wrap: FlexWrap.枚举值	//布局换行</span><br><span class="line">&#125;)&#123;</span><br><span class="line">    //组件</span><br><span class="line">&#125;</span><br><span class="line">//FlexWrap.NoWrap  单行布局</span><br><span class="line">//FlexWrap.Wrap   多行布局</span><br><span class="line"></span><br><span class="line">Column()&#123;</span><br><span class="line">    Flex(&#123;</span><br><span class="line">        direction: FlexDirection.Row, //设置主轴方向</span><br><span class="line">        justifyContent: FlexAlign.SpaceAround,  //主轴对齐方式</span><br><span class="line">        alignItems: ItemAlign.End,  //交叉轴对齐方式</span><br><span class="line">        wrap: FlexWrap.NoWrap   //布局换行</span><br><span class="line">    &#125;)&#123;</span><br><span class="line">        Text()</span><br><span class="line">            .width(100)</span><br><span class="line">            .height(100)</span><br><span class="line">            .backgroundColor(     Color.Blue)</span><br><span class="line">            .margin(10)</span><br><span class="line">        Text()</span><br><span class="line">            .width(100)</span><br><span class="line">            .height(100)</span><br><span class="line">            .backgroundColor(Color.Orange)</span><br><span class="line">            .margin(10)</span><br><span class="line">    &#125;</span><br><span class="line">    .width(&#x27;100%&#x27;)</span><br><span class="line">        .height(500)</span><br><span class="line">        .backgroundColor(&#x27;#ece&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>轮播组件</h1>
<p>容器组件，当设置了多个子组件后，可以对子组件 进行轮播显示</p>
<h2 id="语法">语法</h2>
<p>一般轮播要设置宽高比例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Swiper() &#123;</span><br><span class="line">    //  轮播内容</span><br><span class="line">&#125;</span><br><span class="line">//设置尺寸（内容会自动拉伸）</span><br><span class="line"></span><br><span class="line">Swiper()&#123;</span><br><span class="line">    Text(&#x27;1&#x27;)</span><br><span class="line">    Text(&#x27;2&#x27;)</span><br><span class="line">    Text(&#x27;3&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">.width(&#x27;100%&#x27;)</span><br><span class="line">.height(100)</span><br></pre></td></tr></table></figure>
<h2 id="基本属性">基本属性</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//是否开启循环</span><br><span class="line">.loop(false)	//默认true</span><br><span class="line"></span><br><span class="line">//是否自动播放</span><br><span class="line">.autoPlay(true)	//默认false</span><br><span class="line"></span><br><span class="line">//自动播放的时间间隔（ms）</span><br><span class="line">.interval(1000)	//3000</span><br><span class="line"></span><br><span class="line">//纵向滑动轮播</span><br><span class="line">.vertical(true)	//默认false</span><br></pre></td></tr></table></figure>
<h2 id="样式自定义">样式自定义</h2>
<p>一般选中的比默认的要高一点点，动画会好些</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Swiper() &#123;</span><br><span class="line">   // ...</span><br><span class="line">&#125;</span><br><span class="line">.indicator(</span><br><span class="line">    Indicator.dot()	// 小圆点</span><br><span class="line">    .itemWidth(20)	// 默认的宽</span><br><span class="line">    .itemHeight(20)	// 默认的高</span><br><span class="line">    .color(Color.Black)	// 默认的颜色</span><br><span class="line">    .selectedItemWidth(30)	// 选中的宽</span><br><span class="line">    .selectedItemHeight(30)	// 选中的高</span><br><span class="line">    .selectedColor(Color.White)	// 选中的颜色</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1>绝对定位和层级</h1>
<p>绝对定位作用：控制组件位置，可以实现层叠效果</p>
<ol>
<li>参照 父组件左上角 进行偏移</li>
<li>绝对定位后的组件 不再占用自身原有位置</li>
</ol>
<p>层级作用：调整组件层级</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.position(&#123; x: 水平偏移量, y: 垂直偏移量 &#125;)</span><br><span class="line">.zIndex(数字)	//取值为整数数字，取值越大，显示层级越高</span><br><span class="line"></span><br><span class="line">Column()&#123;</span><br><span class="line">    Text(&#x27;1&#x27;)</span><br><span class="line">        .width(100)</span><br><span class="line">        .height(100)</span><br><span class="line">        .backgroundColor(Color.Green)</span><br><span class="line">    Text(&#x27;定位&#x27;)</span><br><span class="line">        .width(100)</span><br><span class="line">        .height(100)</span><br><span class="line">        .backgroundColor(Color.Grey)</span><br><span class="line">        .position(&#123; x: 20, y: 20 &#125;) //绝对定位</span><br><span class="line">        .zIndex(1)</span><br><span class="line">    Text(&#x27;1&#x27;)</span><br><span class="line">        .width(100)</span><br><span class="line">        .height(100)</span><br><span class="line">        .backgroundColor(Color.Red)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>层叠布局</h1>
<p>卡片层叠效果，层叠操作更简洁，编码效率高（绝对定位的优势是更灵活）</p>
<p>子元素的顺序为 Item1 -&gt; Item2 -&gt; Item3（越往后层级越高）也可以zIndex手动调层级(若手动则每一层都需要手动设置)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stack(&#123;</span><br><span class="line">    alignContent: Alignment.枚举值	//层叠方向</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    Item1()</span><br><span class="line">    Item2()</span><br><span class="line">    Item3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Column()&#123;</span><br><span class="line">    Stack(&#123;</span><br><span class="line">        alignContent: Alignment.Bottom</span><br><span class="line">    &#125;)&#123;</span><br><span class="line">        Text(&#x27;1&#x27;)</span><br><span class="line">            .width(250)</span><br><span class="line">            .height(250)</span><br><span class="line">            .backgroundColor(Color.Brown)</span><br><span class="line">        //.zIndex(1)</span><br><span class="line">        Text(&#x27;2&#x27;)</span><br><span class="line">            .width(200)</span><br><span class="line">            .height(200)</span><br><span class="line">            .backgroundColor(Color.Blue)</span><br><span class="line">        //.zIndex(2)</span><br><span class="line">        Text(&#x27;3&#x27;)</span><br><span class="line">            .width(150)</span><br><span class="line">            .height(150)</span><br><span class="line">            .backgroundColor(Color.Green)</span><br><span class="line">        //.zIndex(3)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Grid 布局</h1>
<p>一般使用在固定行列的布局</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Grid()&#123;</span><br><span class="line">    GridItem()&#123;	//每个小方格</span><br><span class="line">	//小方格中写的内容</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.columnsTemplate(&#x27;1fr 1fr 1fr&#x27;)	//列有几个1fr就有几个小方格，1代表小方格所占的空间份数</span><br><span class="line">.columnsGap(10)	//列方向小方块之间的间隙</span><br><span class="line">.rowsTemplate(&#x27;1fr 1fr 1fr&#x27;)	//行有几个1fr就有几个小方格，1代表小方格所占的空间份数</span><br><span class="line">.rowsGap(10)	//行方向小方块之间的间隙</span><br><span class="line"></span><br><span class="line">Grid()&#123;</span><br><span class="line">    GridItem()&#123;</span><br><span class="line">        Column()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        .width(80)</span><br><span class="line">            .height(80)</span><br><span class="line">            .backgroundColor(Color.Green)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    GridItem()&#123;</span><br><span class="line">        Column()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        .width(80)</span><br><span class="line">            .height(80)</span><br><span class="line">            .backgroundColor(Color.Green)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line">.columnsTemplate(&#x27;1fr 1fr 1fr&#x27;)</span><br><span class="line">.columnsGap(10)</span><br><span class="line">.rowsTemplate(&#x27;1fr 1fr 1fr&#x27;)</span><br><span class="line">.rowsGap(10)</span><br></pre></td></tr></table></figure>
<h1>透明度</h1>
<p>设置透明度之后，注意层级关系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//十六进制若为八位则前两位则为透明度	//设置背景颜色透明度</span><br><span class="line"></span><br><span class="line">//设置整个组件或整个布局的透明度</span><br><span class="line">.opacity(数字)	//0~1</span><br></pre></td></tr></table></figure>
<h1>动画</h1>
<p>元素配合点击事件来改变 缩放中xy值、透明度、层级等等的值 再配置动画才有效果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//元素有状态的改变，可以添加animation做动画</span><br><span class="line">.animation(&#123;</span><br><span class="line">    duration: 300	//动画时间，单位毫秒</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//缩放</span><br><span class="line">.scale(&#123;</span><br><span class="line">    x: 1,	//1：原组件大小</span><br><span class="line">    y: 1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1>滚动容器</h1>
<p>当子组件的布局尺寸 超过Scroll的尺寸 时，内容可以滚动</p>
<h2 id="语法">语法</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scroll()&#123;</span><br><span class="line">    //只支持一个子组件</span><br><span class="line">    Column()&#123;</span><br><span class="line">        // 内容放在内部</span><br><span class="line">        // 尺寸超过 Scroll 即可滚动</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.width(&#x27;100%&#x27;)</span><br><span class="line">.height(200)</span><br><span class="line">.scrollable(ScrollDirection.xxx)	//滚动方向</span><br><span class="line"></span><br><span class="line">Scroll()&#123;</span><br><span class="line">    Column(&#123;space: 20&#125;)&#123;</span><br><span class="line">        ForEach(Array.from(&#123;length: 10&#125;),(item: string,index) =&gt; &#123;</span><br><span class="line">            Text(&#x27;测试文本&#x27; + (index+1))</span><br><span class="line">                .width(&#x27;100%&#x27;)</span><br><span class="line">                .height(100)</span><br><span class="line">                .backgroundColor(Color.Orange)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.width(&#x27;100%&#x27;)</span><br><span class="line">.height(500)</span><br><span class="line">..scrollable(ScrollDirection.Vertical)	//滚动方向</span><br></pre></td></tr></table></figure>
<h2 id="常见属性">常见属性</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> //滚动条状态</span><br><span class="line">.scrollBar(BarState.枚举值)  </span><br><span class="line"></span><br><span class="line">//滚动条颜色</span><br><span class="line">.scrollBarColor(Color.Red)</span><br><span class="line"></span><br><span class="line">//滚动条宽度</span><br><span class="line">.scrollBarWidth(数值)</span><br><span class="line"></span><br><span class="line">//边缘滑动效果</span><br><span class="line">.edgeEffect(EdgeEffect.枚举值)</span><br></pre></td></tr></table></figure>
<h2 id="控制器">控制器</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建Scroller对象(实例化)</span><br><span class="line">实例变量名: Scroller = new Scroller()</span><br><span class="line">//绑定Scroller对象</span><br><span class="line">Scroll(this.scroller)</span><br><span class="line">//控制滚动位置，不一定得Edge(有动画) 也可以别的</span><br><span class="line">this.scroller.scrollEdge(Edge.枚举值)</span><br><span class="line">//获取已经滚动的距离，返回number类型</span><br><span class="line">this.scroller.currentOffset().枚举值</span><br><span class="line"></span><br><span class="line">Button(&#x27;控制滚动位置&#x27;)</span><br><span class="line">    .onClick(() =&gt;&#123;</span><br><span class="line">        this.scroller.scrollEdge(Edge.Top)</span><br><span class="line">    &#125;)</span><br><span class="line">Button(&#x27;获取已经滚动的距离&#x27;)</span><br><span class="line">    .onClick(() =&gt;&#123;</span><br><span class="line">        const y = this.scroller.currentOffset().yOffset</span><br><span class="line">        AlertDialog.show(&#123;message: `y: $&#123;y&#125;`&#125;)	//弹窗</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="事件">事件</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.onDidScroll((x,y) =&gt;&#123;</span><br><span class="line">    // 滚动时 一直触发</span><br><span class="line">    // 可以结合 scroller的currentOffset方法 获取滚动距离</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">.onDidScroll((x,y) =&gt;&#123;</span><br><span class="line">    console.log(&#x27;1&#x27;,this.scroller.currentOffset().yOffset)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1>分类容器组件</h1>
<p>当页面内容较多时，可以通过<code>Tabs</code>组件进行 分类展示</p>
<h2 id="语法">语法</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tabs()&#123;</span><br><span class="line">    TabContent()&#123;</span><br><span class="line">        //导航显示的内容</span><br><span class="line">    &#125;</span><br><span class="line">    .tabBar(导航按钮样式)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tabs()&#123;</span><br><span class="line">    TabContent()&#123;</span><br><span class="line">        Text(&#x27;首页内容&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    .tabBar(&#x27;首页&#x27;)</span><br><span class="line">    TabContent()&#123;</span><br><span class="line">        Text(&#x27;推荐内容&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    .tabBar(&#x27;推荐&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用属性">常用属性</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//调整导航栏位置(垂直：左还是右，水平：上方、下方)</span><br><span class="line">Tabs(&#123;barPosition: BarPosition.枚举值&#125;)</span><br><span class="line"></span><br><span class="line">//设置导航栏方向，true：垂直，flase：水平</span><br><span class="line">.vertical(false)</span><br><span class="line"></span><br><span class="line">//设置导航栏是否允许滑动</span><br><span class="line">.scrollable(true)</span><br><span class="line"></span><br><span class="line">//导航切换动画时间</span><br><span class="line">.animationDuration(1)</span><br><span class="line"></span><br><span class="line">//设置导航栏是否滚动</span><br><span class="line">.barMode(BarMode.枚举值)	//Scrollable：滚动</span><br></pre></td></tr></table></figure>
<h2 id="自定义tabbar">自定义TabBar</h2>
<p>导航栏显示 图形 和 文字，甚至有 特殊的图标，若有</p>
<p>onChange：滑动切换、点击切换 均会触发</p>
<p>onTabBarClick：只有点击才会触发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Builder</span><br><span class="line">自定义函数名() &#123;</span><br><span class="line">    // 自定义的Tabbar结构</span><br><span class="line">&#125;</span><br><span class="line">Tabs() &#123;</span><br><span class="line">    TabContent() &#123;</span><br><span class="line">        // 内容略</span><br><span class="line">    &#125;.</span><br><span class="line">    tabBar(this.自定义函数名())</span><br><span class="line">&#125;</span><br><span class="line">.onChange((index: number) =&gt; &#123;	//index索引值，从0开始，但代表的是导航栏1开始</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//存储激活的索引值</span><br><span class="line">@State selectedIndex:number = 0</span><br><span class="line">@Builder</span><br><span class="line">mytabs(itemIndex: number, name: string,url: ResourceStr,selurl: ResourceStr)&#123;</span><br><span class="line">    Column(&#123;space: 5&#125;)&#123;</span><br><span class="line">        Image(itemIndex == this.selectedIndex? selurl : url)</span><br><span class="line">            .width(30)</span><br><span class="line">        Text(name)</span><br><span class="line">            .fontSize(12)</span><br><span class="line">        //通过传递本身和获取到的索引作比较，从而知道选中的是哪个</span><br><span class="line">            .fontColor(itemIndex == this.selectedIndex? Color.Red: Color.Black)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">build() &#123;</span><br><span class="line">    Tabs()&#123;</span><br><span class="line">        TabContent()&#123;</span><br><span class="line">            Text(&#x27;购物车内容&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">        .tabBar(this.mytabs(0,&#x27;购物车&#x27;,$r(&#x27;app.media.ic_tabbar_icon_2&#x27;),$r(&#x27;app.media.ic_tabbar_icon_2_selected&#x27;)))</span><br><span class="line">        TabContent()&#123;</span><br><span class="line">            Text(&#x27;我的内容&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">        .tabBar(this.mytabs(1,&#x27;我的&#x27;,$r(&#x27;app.media.ic_tabbar_icon_3&#x27;),$r(&#x27;app.media.ic_tabbar_icon_3_selected&#x27;)))</span><br><span class="line">    &#125;</span><br><span class="line">    .onChange((index: number) =&gt; &#123;</span><br><span class="line">        this.selectedIndex = index</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>渲染控制</h1>
<p>基于数组的个数，渲染组件的个数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//如果不在组件内的变量不用加this，属性类型也可能是接口名</span><br><span class="line">//测试时可用Array.from(&#123;length: 10&#125; 替代this.数组名</span><br><span class="line">ForEach(this.数组名, (自定义属性变量名: 属性类型, 自定义下标变量名: 下标类型) =&gt; &#123;</span><br><span class="line">    //组件</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ForEach([1,2,3,4,5,6], () =&gt; &#123;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">@State titles: string[] = [&#x27;电子产品&#x27;,&#x27;精品服饰&#x27;,&#x27;母婴产品&#x27;]</span><br><span class="line">build() &#123;</span><br><span class="line">    Column()&#123;</span><br><span class="line">        ForEach(this.titles, (item: string,index: number) =&gt; &#123;</span><br><span class="line">            Text(`$&#123;index + 1&#125;,$&#123;item&#125;`)</span><br><span class="line">                .fontSize(20)</span><br><span class="line">                .width(500)</span><br><span class="line">                .padding(15)</span><br><span class="line">                .fontWeight(700)</span><br><span class="line">                .width(&#x27;100%&#x27;)</span><br><span class="line">                .fontColor(Color.Orange)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>样式&amp;结构重用</h1>
<p>重点：@Extend、@Builder，了解：@Styles</p>
<p>全局有function，组件内没function</p>
<h2 id="extend-扩展组件">@Extend(扩展组件)</h2>
<p>扩展 组件的 样式、事件，实现 复用 效果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Extend(复用的组件名)</span><br><span class="line">function 自定义函数名(参数)&#123;</span><br><span class="line">	//封装的组件、事件等</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Extend(Text)</span><br><span class="line">function textExtend(color: ResourceColor,txt: string)&#123;</span><br><span class="line">    .textAlign(TextAlign.Center)</span><br><span class="line">    .backgroundColor(color)</span><br><span class="line">    .fontSize(30)</span><br><span class="line">    .onClick(() =&gt;&#123;</span><br><span class="line">        AlertDialog.show(&#123;</span><br><span class="line">            message: txt</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">Text(&#x27;1&#x27;)</span><br><span class="line">    .textExtend(Color.Orange, &#x27;轮播1&#x27;)</span><br></pre></td></tr></table></figure>
<h2 id="抽取-styles">抽取(@Styles)</h2>
<p>抽取<code>通用</code>属性、事件，侧重样式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//全局定义</span><br><span class="line">@Styles function 自定义函数名()&#123;</span><br><span class="line">    //抽取的样式、事件</span><br><span class="line">&#125;</span><br><span class="line">//组件内定义 需要调用组件内属性变量时</span><br><span class="line">@Styles setBg()&#123;</span><br><span class="line">    //抽取的样式、事件</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//全局定义</span><br><span class="line">@Styles function commonStyle()&#123;</span><br><span class="line">    .width(200)</span><br><span class="line">    .height(200)</span><br><span class="line">&#125;</span><br><span class="line">struct Index &#123;</span><br><span class="line">    @State colors: string = &#x27;#3333&#x27;</span><br><span class="line">    //组件内定义</span><br><span class="line">    @Styles setBg()&#123;</span><br><span class="line">        .backgroundColor(this.colors)</span><br><span class="line">    &#125;</span><br><span class="line">    build() &#123;</span><br><span class="line">        Column() &#123;</span><br><span class="line">            Text(&#x27;1&#x27;)</span><br><span class="line">                .setBg()</span><br><span class="line">                .commonStyle()</span><br><span class="line">            Button(&#x27;点击&#x27;)</span><br><span class="line">                .commonStyle()</span><br><span class="line">                .setBg()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义构建函数-builder">自定义构建函数@Builder</h2>
<p>结构(侧重)、样式、事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//全局</span><br><span class="line">@Builder</span><br><span class="line">function 自定义函数名(参数)&#123;</span><br><span class="line">    //封装的结构以及组件 样式等</span><br><span class="line">&#125;</span><br><span class="line">//局部</span><br><span class="line">@Builder</span><br><span class="line">自定义函数名(参数)&#123;</span><br><span class="line">    //封装的结构以及组件 样式等</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Builder</span><br><span class="line">function navItem(icon: ResourceStr, text: string)&#123;</span><br><span class="line">    Column()&#123;</span><br><span class="line">        Image(icon)</span><br><span class="line">            .width(&#x27;80%&#x27;)</span><br><span class="line">        Text(text)</span><br><span class="line">    &#125;</span><br><span class="line">    .width(&#x27;25%&#x27;)</span><br><span class="line">    .onClick(() =&gt;&#123;</span><br><span class="line">        AlertDialog.show(&#123;message: &#x27;点了&#x27; + text&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">@Entry</span><br><span class="line">@Component</span><br><span class="line">struct Index &#123;</span><br><span class="line">    build() &#123;</span><br><span class="line">        Column() &#123;</span><br><span class="line">            navItem($r(&#x27;app.media.ic_reuse_01&#x27;),&#x27;阿里拍卖&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>鸿蒙next应用开发</category>
      </categories>
      <tags>
        <tag>鸿蒙next应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>10.DMA</title>
    <url>/post/acb77072.html</url>
    <content><![CDATA[<h1><center>理论</center></h1>
<p>12个通道：DMA1（7）DMA2（5）</p>
<img src="https://s2.loli.net/2024/08/19/SeZd3kAG2j9FslO.webp" alt="通道" style="zoom:50%;">
<p>方向：存储器和存储器间(DMA_MEMORY_TO_MEMORY)、外设到存储器(DMA_PERIPH_TO_MEMORY)、存储器到外设(DMA_MEMORY_TO_PERIPH)</p>
<p>闪存、 SRAM、外设的SRAM、 APB1、 APB2和AHB外设均可作为访问的源和目标</p>
<p>数据宽度：字节(Byte 8)、半字(Half Word 16)、全字(Word 32)</p>
<p>可编程的数据传输数目： 0 ~ 65535</p>
<p>若可编程的数据传输数目为10，数据宽度为字节，半字，全字<br>
传输总数据大小：10字节，20字节，40字节</p>
<p>若传输总数据大小与实际传输不符，会让传输标志(__HAL_DMA_GET_FLAG) ≠ 0</p>
<h1><center>代码编写</center></h1>
<p>存储器和存储器间实验，两个数组，将一个数组的数据通过DMA传到另一个数组，通过串口打印出来</p>
<h2 id="center-dma配置-center"><center>DMA配置</center></h2>
<img src="https://s2.loli.net/2024/08/19/nj8ws4YqxbAf6NW.webp" alt="DMA配置" style="zoom:50%;">
<p>串口初始化参考：<a href="https://68565200.xyz/post/2c4c3bc3">链接</a></p>
<h2 id="center-cube-ide代码-center"><center>Cube IDE代码</center></h2>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN PD */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFF_SIZE 100	<span class="comment">//37行</span></span></span><br><span class="line"><span class="comment">/* USER CODE END PD */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PV */</span></span><br><span class="line"><span class="type">uint8_t</span> SRC_Buff[BUFF_SIZE];	<span class="comment">//48行</span></span><br><span class="line"><span class="type">uint8_t</span> DEST_Buff[BUFF_SIZE];</span><br><span class="line"><span class="comment">/* USER CODE END PV */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; BUFF_SIZE; i++)	<span class="comment">//95行</span></span><br><span class="line">    SRC_Buff[i] = i+<span class="number">2</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 参数1：指向 DMA_HandleTypeDef 结构的指针，该结构包含指向 DMA 通道的配置信息</span></span><br><span class="line"><span class="comment">* 参数2：源内存缓冲区地址</span></span><br><span class="line"><span class="comment">* 参数3：目标内存缓冲区地址，参数4：从源传输到目标的数据长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">HAL_DMA_Start(&amp;hdma_memtomem_dma1_channel1, (<span class="type">uint32_t</span>)SRC_Buff, (<span class="type">uint32_t</span>)DEST_Buff, BUFF_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//while里,111行</span></span><br><span class="line">hdma_memtomem_dma1_channel1.Instance-&gt;CNDTR = BUFF_SIZE;	<span class="comment">//可编程的数据传输数目：CNDTR</span></span><br><span class="line">__HAL_DMA_ENABLE(&amp;hdma_memtomem_dma1_channel1);	<span class="comment">//启用指定的 DMA 通道</span></span><br><span class="line"><span class="keyword">while</span>(__HAL_DMA_GET_FLAG(&amp;hdma_memtomem_dma1_channel1, DMA_FLAG_TC1) == <span class="number">0</span>);	<span class="comment">//判断是否传输完成</span></span><br><span class="line">HAL_UART_Transmit(&amp;huart1, DEST_Buff, BUFF_SIZE, <span class="number">100</span>);	<span class="comment">//串口发送据</span></span><br><span class="line">__HAL_DMA_CLEAR_FLAG(&amp;hdma_memtomem_dma1_channel1, DMA_FLAG_TC1);	<span class="comment">//清除标志</span></span><br><span class="line">__HAL_DMA_DISABLE(&amp;hdma_memtomem_dma1_channel1);	<span class="comment">//禁用指定的 DMA 通道</span></span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>32单片机</category>
      </categories>
      <tags>
        <tag>32单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>11.SPI通信</title>
    <url>/post/bd740709.html</url>
    <content><![CDATA[<h1><center>SPI理论</center></h1>
<p>常规四线：SCLK、CS、MOSI(主向从发)、MISO(从向主发)</p>
<p>同步、串行、全双工、速率(MHz)</p>
<p>一主一从、一主多从、不能多主</p>
<img src="https://s2.loli.net/2024/08/19/IjLng81mSXNrDG7.png" alt="一主多从" style="zoom:50%;">
<img src="https://s2.loli.net/2024/08/19/UgsHwTY6L2XlbPo.png" alt="一主多从" style="zoom:50%;">
<p>工作模式：</p>
<ul>
<li>CPOL
<ul>
<li>0：总线空闲状态时钟为低电平，1：总线空闲状态时钟为高电平</li>
</ul>
</li>
<li>CPHA
<ul>
<li>0：时钟第一个沿对数据采样，1：时钟第二个沿对数据采样</li>
</ul>
</li>
</ul>
<p>QSPI：相比SPI区别，四个数据线，一个时钟内传输4个bit</p>
<p>时序：</p>
<img src="https://s2.loli.net/2024/08/19/VQgSONhEI46pkjb.webp" alt="SPI时序" style="zoom:50%;">
<h1><center>网络理论</center></h1>
<p>TCP三次握手，四次挥手。参考：<a href="https://blog.csdn.net/weixin_45393094/article/details/104965561?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169864750516800182774327%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169864750516800182774327&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-104965561-null-null.142%5Ev96%5Epc_search_result_base9&amp;utm_term=%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3&amp;spm=1018.2226.3001.4187">参考</a></p>
<p>TCP和UDP区别参考：<a href="https://blog.csdn.net/weixin_45272371/article/details/129378067">链接</a></p>
<p>网络模型：OSI七层网络模型（<a href="https://blog.csdn.net/troubleshooter/article/details/122376824">链接</a>）、五层网络模型（<a href="https://blog.csdn.net/weixin_44417441/article/details/113769242?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-3-113769242-blog-123167871.235%5Ev38%5Epc_relevant_sort&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-3-113769242-blog-123167871.235%5Ev38%5Epc_relevant_sort&amp;utm_relevant_index=6">链接</a>）</p>
<h2 id="center-spi配置-center"><center>SPI配置</center></h2>
<img src="https://s2.loli.net/2024/08/19/dgVC1DXIYscZvpW.webp" alt="SPI配置" style="zoom:50%;">
]]></content>
      <categories>
        <category>32单片机</category>
      </categories>
      <tags>
        <tag>32单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>1.GPIO</title>
    <url>/post/adb202b7.html</url>
    <content><![CDATA[<h1><center>理论说明</center></h1>
<h2 id="center-输入-center"><center>输入</center></h2>
<p>详细解析参考：<a href="https://blog.csdn.net/scarecrow_sun/article/details/120287852">网址</a></p>
<p>上拉输入：拉高电平</p>
<p>下拉输入：拉低电平</p>
<p>浮空输入：不拉高也不拉低电平</p>
<h2 id="center-输出-center"><center>输出</center></h2>
<p>开漏输出：不能输出高电平（P-MOS不可用，则只能低电平）</p>
<p>推挽输出：可输出高低电平</p>
<img src="https://s2.loli.net/2024/08/18/BU413suZEmPW5wD.png" alt="输入输出电路图" style="zoom:50%;">
<p>输出速率：Low：2MHz、Medium：10MHz、High：50MHz</p>
<p>Tips</p>
<ul>
<li>普通功能的IO，通常2M就可以了</li>
<li>如果一个IO用作I2C通信，速度通常就10K到400K，选10M就好了</li>
<li>如果是用作SPI功能，可能会到20M速度，那就要选50M了</li>
</ul>
<h1><center>代码编写</center></h1>
<p>LED灯闪烁、按键PE3控制蜂鸣器(PB8)开关、按键PE4控制 LED2(PE5) 亮灭、光敏传感器(PB11)控制 LED1(PB5) 亮灭</p>
<h2 id="center-实验一：led灯闪烁-center"><center>实验一：LED灯闪烁</center></h2>
<h3 id="center-led灯配置-center"><center>LED灯配置</center></h3>
<p>配置引脚功能：</p>
<p>GPIO Pull-up/Pull-down：因为LED灯初始化时就已经设置了高低电平，没有空闲状态，无论是上拉还是下拉都起不到作用</p>
<img src="https://s2.loli.net/2024/08/18/Pc7mJwYuqszMOaK.png" alt="GPIO配置" style="zoom: 33%;">
<h3 id="center-cube-ide代码-center"><center>Cube IDE代码</center></h3>
<p>在main.c文件，大概94行开始，代码必须写在 <code>/* USER CODE BEGIN WHILE */ </code> 和 <code>/* USER CODE END WHILE */</code>里面，否则在图形初始化设置后重新生成会把代码清除</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//参数1：GPIO口名字(PB)，参数2：GPIO数字(PB5中的5)，参数3：高低电平(0,1)</span></span><br><span class="line">    HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, <span class="number">0</span>);</span><br><span class="line">    HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">    HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);	//电平反转,无需设置高低电平</span></span><br><span class="line">    HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 3 */</span></span><br></pre></td></tr></table></figure>
<h2 id="center-实验二：按键控制蜂鸣器-led灯-center"><center>实验二：按键控制蜂鸣器、LED灯</center></h2>
<p>按键PE3控制蜂鸣器(PB8)开关、按键PE4控制 LED2(PE5) 亮灭、光敏传感器(PB11)控制 LED1(PB5) 亮灭</p>
<h3 id="按键-蜂鸣器配置">按键、蜂鸣器配置</h3>
<p>按键：设置成<code>上拉输入</code>，PE4则为高电平，当按键按下时，PE4为0(可用if判断是否按下)，则按键按下(其它按钮同理)</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/18/D3QdglUBk2FZyas.png" alt="按键电路图" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>LED灯、蜂鸣器(PB8)：输出高低电平，设置<code>推挽输出</code></p>
<p>光敏传感器(PB11)：高低电平由外界光照强度来决定，设置<code>浮空输入</code></p>
<p>按键配置：</p>
<img src="https://s2.loli.net/2024/08/18/QVP2hkXTLNJWC54.png" alt="按钮配置" style="zoom: 33%;">
<p>LED灯配置方面已经说明，直接配置</p>
<p>蜂鸣器配置(PB8)：</p>
<p>GPIO Pull-up/Pull-down：因为蜂鸣器初始化时就已经设置了高低电平，没有空闲状态，无论是上拉还是下拉都起不到作用</p>
<img src="https://s2.loli.net/2024/08/18/Ie3v5ysP7gM19cE.png" alt="蜂鸣器配置图" style="zoom:33%;">
<p>光敏传感器配置(PB11)：</p>
<img src="https://s2.loli.net/2024/08/18/8I6E1BvyN9m5ep4.png" alt="光敏传感器配置图" style="zoom:33%;">
<p>光敏传感器AO  DO有什么区别？</p>
<p>AO：输出模拟信号，DO：输出数字信号（高低电平）</p>
<h3 id="cube-ide代码">Cube IDE代码</h3>
<p>在main.c文件，大概94行开始</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == HAL_GPIO_ReadPin(Key1_GPIO_Port, Key1_Pin))	<span class="comment">//检测读取按键高低电平</span></span><br><span class="line">    &#123;</span><br><span class="line">        HAL_Delay(<span class="number">120</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == HAL_GPIO_ReadPin(Key1_GPIO_Port, Key1_Pin))	<span class="comment">//检测读取按键高低电平</span></span><br><span class="line">        &#123;</span><br><span class="line">            HAL_GPIO_TogglePin(BEEP_GPIO_Port, BEEP_Pin);	<span class="comment">//电平反转,无需设置高低电平</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == HAL_GPIO_ReadPin(Key2_GPIO_Port, Key2_Pin))	<span class="comment">//检测读取按键输入高低电平</span></span><br><span class="line">    &#123;</span><br><span class="line">        HAL_Delay(<span class="number">120</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == HAL_GPIO_ReadPin(Key2_GPIO_Port, Key2_Pin))	<span class="comment">//检测读取按键高低电平</span></span><br><span class="line">        &#123;</span><br><span class="line">            HAL_GPIO_TogglePin(LED2_GPIO_Port, LED2_Pin);	<span class="comment">//电平反转,无需设置高低电平</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == HAL_GPIO_ReadPin(SUN_GPIO_Port, SUN_Pin))	<span class="comment">//检测读取光敏传感器输入高低电平</span></span><br><span class="line">    &#123;</span><br><span class="line">        HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, <span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码过程">代码过程</h3>
<p>初始化时钟</p>
<ol>
<li>初始化时钟</li>
</ol>
<p>APB2ENR：外设时钟使能寄存器</p>
<img src="https://s2.loli.net/2024/08/18/5OcX7FfH1S63NWs.png" alt="外设时钟使能寄存器图" style="zoom:50%;">
<p>大概功能：将APB2ENR(外设时钟使能寄存器)初始化IO端口B时钟开启</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使能时钟初始化代码，在gpio.c中48行</span></span><br><span class="line">__HAL_RCC_GPIOE_CLK_ENABLE();</span><br><span class="line">__HAL_RCC_GPIOB_CLK_ENABLE();</span><br><span class="line">__HAL_RCC_GPIOA_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line"><span class="comment">//__HAL_RCC_GPIOB_CLK_ENABLE(); 如下过程</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAL_RCC_GPIOB_CLK_ENABLE()   do &#123; \</span></span><br><span class="line"><span class="meta">			 __IO uint32_t tmpreg;  <span class="comment">/*定义一个变量*/</span>\</span></span><br><span class="line"><span class="meta">                 SET_BIT(RCC-&gt;APB2ENR, RCC_APB2ENR_IOPBEN);\</span></span><br><span class="line"><span class="meta">                 <span class="comment">/* Delay after an RCC peripheral clock enabling(下方两个延时作用) */</span>\</span></span><br><span class="line"><span class="meta">                 tmpreg = READ_BIT(RCC-&gt;APB2ENR, RCC_APB2ENR_IOPBEN);\</span></span><br><span class="line"><span class="meta">                 UNUSED(tmpreg); \</span></span><br><span class="line"><span class="meta">&#125; while(0U)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SET_BIT(RCC-&gt;APB2ENR, RCC_APB2ENR_IOPBEN); 的解释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.RCC_APB2ENR_IOPBEN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_APB2ENR_IOPBEN_Pos		(3U)                              </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_APB2ENR_IOPBEN_Msk		(0x1UL &lt;&lt; RCC_APB2ENR_IOPBEN_Pos)	<span class="comment">/*RCC_APB2ENR_IOPBEN_Msk 等于0x1&lt;&lt; 3 结果：0x00000008 */</span></span></span><br><span class="line"><span class="comment">//0x1 = 0000 0001 &lt;&lt; 3 = 0000 1000(对应上图,位3为1) = 0x00000008 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_APB2ENR_IOPBEN			RCC_APB2ENR_IOPBEN_Msk		<span class="comment">/* RCC_APB2ENR_IOPBEN 等于0x00000008 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.RCC寄存器，RCC_BASE强转成这个RCC_TypeDef类型的结构体</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC                 ((RCC_TypeDef *)RCC_BASE)</span></span><br><span class="line"><span class="comment">//RCC_BASE = 由总线矩阵偏移到AHB系统总线再偏移到复位和时钟控制(RCC)(可看参考手册的系统结构)(下面三行从下往上看)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_BASE              (AHBPERIPH_BASE + 0x00001000UL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AHBPERIPH_BASE        (PERIPH_BASE + 0x00020000UL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERIPH_BASE           0x40000000UL</span></span><br><span class="line"><span class="comment">//RCC_TypeDef（结构体）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __IO <span class="type">uint32_t</span> CR;</span><br><span class="line">    __IO <span class="type">uint32_t</span> CFGR;</span><br><span class="line">    __IO <span class="type">uint32_t</span> CIR;</span><br><span class="line">    __IO <span class="type">uint32_t</span> APB2RSTR;</span><br><span class="line">    __IO <span class="type">uint32_t</span> APB1RSTR;</span><br><span class="line">    __IO <span class="type">uint32_t</span> AHBENR;</span><br><span class="line">    __IO <span class="type">uint32_t</span> APB2ENR;</span><br><span class="line">    __IO <span class="type">uint32_t</span> APB1ENR;</span><br><span class="line">    __IO <span class="type">uint32_t</span> BDCR;</span><br><span class="line">    __IO <span class="type">uint32_t</span> CSR;</span><br><span class="line">&#125; RCC_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.RCC-&gt;APB2ENR</span></span><br><span class="line">RCC指向APB2ENR，则就是结构体内的__IO <span class="type">uint32_t</span> APB2ENR;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将APB2ENR的位3置1</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>初始化引脚</li>
</ol>
<p>GPIOx_BSRR：端口位设置/清除寄存器</p>
<p>低16位中若有某一位 置1，则这个引脚为1(高电平)，若都为0，则不影响</p>
<p>高16位中若有某一位 置1，则这个引脚位0(低电平)，若都为0，则不影响</p>
<img src="https://s2.loli.net/2024/08/18/BAzmVLoDZ9qkR1a.png" alt="端口位设置/清除寄存器图" style="zoom: 50%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gpio.c中第53行</span></span><br><span class="line"><span class="comment">/*Configure GPIO pin Output Level */</span></span><br><span class="line">HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_SET);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_WritePin</span><span class="params">(GPIO_TypeDef *GPIOx, <span class="type">uint16_t</span> GPIO_Pin, GPIO_PinState PinState)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Check the parameters */</span></span><br><span class="line">    assert_param(IS_GPIO_PIN(GPIO_Pin));</span><br><span class="line">    assert_param(IS_GPIO_PIN_ACTION(PinState));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PinState != GPIO_PIN_RESET)	<span class="comment">//GPIO_PIN_RESET为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        GPIOx-&gt;BSRR = GPIO_Pin;	<span class="comment">//给BSRR寄存器 低16位赋值 置1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        GPIOx-&gt;BSRR = (<span class="type">uint32_t</span>)GPIO_Pin &lt;&lt; <span class="number">16u</span>;	<span class="comment">//给BSRR寄存器 高16位赋值 置0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GPIO_TypeDef *GPIOx 等于 LED2_GPIO_Port</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2_GPIO_Port GPIOE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE		((GPIO_TypeDef *)GPIOE_BASE)</span></span><br><span class="line"><span class="comment">//GPIO_TypeDef 强转</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __IO <span class="type">uint32_t</span> CRL;</span><br><span class="line">    __IO <span class="type">uint32_t</span> CRH;</span><br><span class="line">    __IO <span class="type">uint32_t</span> IDR;</span><br><span class="line">    __IO <span class="type">uint32_t</span> ODR;</span><br><span class="line">    __IO <span class="type">uint32_t</span> BSRR;</span><br><span class="line">    __IO <span class="type">uint32_t</span> BRR;</span><br><span class="line">    __IO <span class="type">uint32_t</span> LCKR;</span><br><span class="line">&#125; GPIO_TypeDef;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE_BASE            (APB2PERIPH_BASE + 0x00001800UL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APB2PERIPH_BASE       (PERIPH_BASE + 0x00010000UL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERIPH_BASE           0x40000000UL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//GPIO_Pin 等于 LED2_Pin</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2_Pin GPIO_PIN_5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_5		((uint16_t)0x0020)  <span class="comment">/* Pin 5 selected    */</span></span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>写实际需求（输入：read  判断，输出：write   0/1）</li>
</ol>
<h2 id="center-标准库-center"><center>标准库</center></h2>
<h3 id="led灯">LED灯</h3>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//bool stat = false;</span></span><br><span class="line">    <span class="comment">//使能时钟</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line">    <span class="comment">//初始化外设</span></span><br><span class="line">    led_init();</span><br><span class="line">    <span class="type">int</span> a1=<span class="number">0</span>,a2=<span class="number">0</span>,t=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a3=<span class="number">0</span>,a4=<span class="number">0</span>,t1=<span class="number">0</span>,n=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        stat = !stat;</span></span><br><span class="line"><span class="comment">//        led_set(stat);</span></span><br><span class="line"><span class="comment">//        delay(200);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//呼吸灯</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; <span class="number">2</span>; t++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(a1 = <span class="number">0</span>; a1 &lt; i; a1++);</span><br><span class="line">                led_on();</span><br><span class="line">                <span class="keyword">for</span>(a2 = <span class="number">5000</span>; a2 &gt; i; a2--);</span><br><span class="line">                led_off();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(n = <span class="number">5000</span>; n &gt; <span class="number">0</span>; n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(t1 = <span class="number">0</span>; t1 &lt; <span class="number">2</span>; t1++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(a3 = <span class="number">0</span>; a3 &lt; n; a3++);</span><br><span class="line">                led_on();</span><br><span class="line">                <span class="keyword">for</span>(a4 = <span class="number">5000</span>; a4 &gt; n; a4--);</span><br><span class="line">                led_off();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>led.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN GPIO_Pin_5	<span class="comment">//LED引脚</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;    <span class="comment">//定义一个GPIO_InitTypeDef结构体变量</span></span><br><span class="line">    <span class="comment">//设置输出模式</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;    <span class="comment">//推完输出</span></span><br><span class="line">    <span class="comment">//设置pin脚</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = PIN;</span><br><span class="line">    <span class="comment">//设置时钟频率</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    <span class="comment">//初始化GPIO口</span></span><br><span class="line">    GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">    <span class="comment">//设置引脚默认电平</span></span><br><span class="line">    GPIO_SetBits(GPIOB, PIN);   <span class="comment">//设置为高电平</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置LED灯状态函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_set</span><span class="params">(<span class="type">bool</span> on)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_WriteBit(GPIOB,PIN, on? Bit_RESET : Bit_SET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开灯</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_on</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    led_set(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关灯</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    led_set(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>utils.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">uint32_t</span> tickes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; tickes; t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(n = <span class="number">0</span>; n &lt; <span class="number">72000</span>; n++)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>led.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LED_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LED_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_set</span><span class="params">(<span class="type">bool</span> on)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">led_on</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">led_off</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __LED_H */</span></span></span><br></pre></td></tr></table></figure>
<p>main.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MAIN_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MAIN_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">uint32_t</span> tickes)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __MAIN_H */</span></span></span><br></pre></td></tr></table></figure>
<h3 id="按键控制led灯">按键控制LED灯</h3>
<p>mian.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使能时钟</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);   <span class="comment">//LED</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);   <span class="comment">//按键</span></span><br><span class="line">    <span class="comment">//初始化外设</span></span><br><span class="line">    key_init();</span><br><span class="line">    led_init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(key_pressed())</span><br><span class="line">        &#123;</span><br><span class="line">            delay(<span class="number">50</span>);</span><br><span class="line">            key_waite_release();</span><br><span class="line">            led_toogle();</span><br><span class="line">            <span class="comment">//delay(50);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>key.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN GPIO_Pin_4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Num GPIOE</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">key_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;    <span class="comment">//定义一个GPIO_InitTypeDef结构体变量</span></span><br><span class="line">    <span class="comment">//设置上拉输入模式</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">    <span class="comment">//设置pin脚</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = PIN;</span><br><span class="line">    <span class="comment">//设置时钟频率</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    <span class="comment">//初始化GPIO口</span></span><br><span class="line">    GPIO_Init(GPIO_Num,&amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">key_pressed</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> falg = (GPIO_ReadInputDataBit(GPIO_Num,PIN) == Bit_RESET);</span><br><span class="line">    <span class="keyword">return</span> falg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">key_waite_release</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(!key_pressed());  <span class="comment">//判断按键是否松开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>key.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KEY_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KEY_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">key_pressed</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">key_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">key_waite_release</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __KEY_H */</span></span></span><br></pre></td></tr></table></figure>
<p>led.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN GPIO_Pin_5</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> led_flagOF = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;    <span class="comment">//定义一个GPIO_InitTypeDef结构体变量</span></span><br><span class="line">    <span class="comment">//设置输出模式</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">    <span class="comment">//设置pin脚</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = PIN;</span><br><span class="line">    <span class="comment">//设置时钟频率</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    <span class="comment">//初始化GPIO口</span></span><br><span class="line">    GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">    <span class="comment">//设置引脚默认电平</span></span><br><span class="line">    GPIO_SetBits(GPIOB, PIN);   <span class="comment">//设置为高电平</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置LED灯状态函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_set</span><span class="params">(<span class="type">bool</span> on)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_WriteBit(GPIOB,PIN, on? Bit_RESET : Bit_SET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开灯</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_on</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    led_set(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关灯</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    led_set(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LED灯翻转</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_toogle</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    led_flagOF = !led_flagOF;</span><br><span class="line">    led_set(!led_flagOF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>led.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LED_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LED_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_set</span><span class="params">(<span class="type">bool</span> on)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">led_on</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">led_off</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">led_toogle</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __LED_H */</span></span></span><br></pre></td></tr></table></figure>
<p>utils.c、main.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span>#<span class="keyword">ifndef</span> __MAIN_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MAIN_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">uint32_t</span> tickes)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __MAIN_H */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">uint32_t</span> tickes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; tickes; t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(n = <span class="number">0</span>; n &lt; <span class="number">72000</span>; n++)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若烧录完成后，需要按复位按键才可正常，可尝试以下设置</p>
<p>第一步：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/18/wTmlgxfZBGdF7ao.png" alt="设置1" style="zoom: 40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>第二步：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/18/31OtqZ4TRHgIBAJ.png" alt="设置2" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
]]></content>
      <categories>
        <category>32单片机</category>
      </categories>
      <tags>
        <tag>32单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>2.外部中断(EXTI)</title>
    <url>/post/eb0bc4a3.html</url>
    <content><![CDATA[<h1><center>理论</center></h1>
<p>NVIC：嵌套向量中断控制器（<a href="https://blog.csdn.net/m0_74761015/article/details/136269042">解释教程</a>）</p>
<p>外部通用中断线(<code>EXTI0~EXTI15</code>)：每个GPIO设置成中断模式，与中断控制器连接的线</p>
<ul>
<li>**组配置：**配置中断控制器的中断优先级组，通常有5个组可以选择
<ul>
<li>组零：没有中断有优先级配置，基本不用</li>
<li>组一：中断优先级数字占用1个bit，可以描述2个优先级，即中断优先级只能是0或者1</li>
<li>组二：中断优先级数字占用2个bit，可以描述4个优先级，即中断优先级可以是0~3</li>
<li>组三：中断优先级数字占用3个bit，可以描述8个优先级，即中断优先级可以是0~7</li>
<li>组四：中断优先级数字占用4个bit，可以描述16个优先级，即中断优先级可以是0~15</li>
</ul>
</li>
<li>**触发源：**事件类型，即什么外设的什么事件</li>
<li>**中断号：**一个索引号，发生中断时，中断控制器会根据这个索引号查找对应的中断服务程序</li>
<li>**优先级：**根据组配置选择合适的中断优先级，数字越小优先级越高</li>
</ul>
<h2 id="中断控制">中断控制</h2>
<p>​    有3个条件是可以通过编程配置的：全局中断开关、外设中断开关、中断屏蔽。<strong>全局中断</strong>很好理解，就是控制整个芯片上所有的可屏蔽中断的使能；<strong>外设中断</strong>就是某个外设的某个事件的中断使能，比如GPIO这个外设的下降沿中断；但中断屏蔽是什么意思？</p>
<p>中断屏蔽，是中断控制器中的一个属性，可以配置低于某个优先级的中断是否被使能。举个例子，比如当前配置中断优先级组四，GPIO下降沿中断优先级7，配置中断屏蔽值为5，此时GPIO中断优先级小于5，则GPIO下降沿事件不会触发中断服务。那中断屏蔽有什么用呢，当某个任务在执行期间，希望不被高密度的低优先级的中断打扰，但低密度偶发的高优先级的紧急事件仍需要得到响应，则通过中断屏蔽可以实现此功能</p>
<h2 id="center-外部中断触发函数-center"><center>外部中断触发函数</center></h2>
<p>在stm32f1xx_it.c文件里(大概204行)</p>
<table>
<thead>
<tr>
<th style="text-align:center">中断触发函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">EXTI0_IRQHandler</td>
</tr>
<tr>
<td style="text-align:center">EXTI1_IRQHandler</td>
</tr>
<tr>
<td style="text-align:center">EXTI2_IRQHandler</td>
</tr>
<tr>
<td style="text-align:center">EXTI3_IRQHandler</td>
</tr>
<tr>
<td style="text-align:center">EXTI4_IRQHandler</td>
</tr>
<tr>
<td style="text-align:center">EXTI9_5_IRQHandler</td>
</tr>
<tr>
<td style="text-align:center">EXTI15_10_IRQHandler</td>
</tr>
</tbody>
</table>
<h2 id="center-解析-center"><center>解析</center></h2>
<p>解析初始化中断过程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gpio.c中58</span></span><br><span class="line"><span class="comment">/*Configure GPIO pins : PEPin PEPin */</span></span><br><span class="line">GPIO_InitStruct.Pin = EXTI_Key1_Pin|EXTI_Key2_Pin;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_PULLUP;</span><br><span class="line">HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStruct);	<span class="comment">//将上面三行代码的数据传入这个函数解析初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//stm32f1xx_hal_gpio.c中286</span></span><br><span class="line"><span class="comment">/*--------------------- EXTI Mode Configuration ------------------------*/</span></span><br><span class="line"><span class="comment">/* Configure the External Interrupt or event for the current IO */</span></span><br><span class="line"><span class="keyword">if</span> ((GPIO_Init-&gt;Mode &amp; EXTI_MODE) == EXTI_MODE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Enable AFIO Clock */</span></span><br><span class="line">    __HAL_RCC_AFIO_CLK_ENABLE();	<span class="comment">//打开复用时钟</span></span><br><span class="line">    temp = AFIO-&gt;EXTICR[position &gt;&gt; <span class="number">2u</span>];</span><br><span class="line">    CLEAR_BIT(temp, (<span class="number">0x0F</span>u) &lt;&lt; (<span class="number">4u</span> * (position &amp; <span class="number">0x03</span>u)));</span><br><span class="line">    SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) &lt;&lt; (<span class="number">4u</span> * (position &amp; <span class="number">0x03</span>u)));</span><br><span class="line">    AFIO-&gt;EXTICR[position &gt;&gt; <span class="number">2u</span>] = temp;	<span class="comment">//把固定引脚设置成复用模式(如复用成外部中断)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置上升沿还是下降沿</span></span><br><span class="line">    <span class="comment">/* Enable or disable the rising trigger */</span></span><br><span class="line">    <span class="keyword">if</span> ((GPIO_Init-&gt;Mode &amp; RISING_EDGE) == RISING_EDGE)</span><br><span class="line">    &#123;</span><br><span class="line">        SET_BIT(EXTI-&gt;RTSR, iocurrent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        CLEAR_BIT(EXTI-&gt;RTSR, iocurrent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Enable or disable the falling trigger */</span></span><br><span class="line">    <span class="keyword">if</span> ((GPIO_Init-&gt;Mode &amp; FALLING_EDGE) == FALLING_EDGE)</span><br><span class="line">    &#123;</span><br><span class="line">        SET_BIT(EXTI-&gt;FTSR, iocurrent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        CLEAR_BIT(EXTI-&gt;FTSR, iocurrent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Configure the event mask */</span></span><br><span class="line">    <span class="keyword">if</span> ((GPIO_Init-&gt;Mode &amp; GPIO_MODE_EVT) == GPIO_MODE_EVT)</span><br><span class="line">    &#123;</span><br><span class="line">        SET_BIT(EXTI-&gt;EMR, iocurrent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        CLEAR_BIT(EXTI-&gt;EMR, iocurrent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开或关闭中断</span></span><br><span class="line">    <span class="comment">/* Configure the interrupt mask */</span></span><br><span class="line">    <span class="keyword">if</span> ((GPIO_Init-&gt;Mode &amp; GPIO_MODE_IT) == GPIO_MODE_IT)</span><br><span class="line">    &#123;</span><br><span class="line">        SET_BIT(EXTI-&gt;IMR, iocurrent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        CLEAR_BIT(EXTI-&gt;IMR, iocurrent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EXTI 即是外部中断和事件控制器，它是由 20 个产生事件/中断请求的边沿检测器组成。</p>
<p>每一条输入线都可以独立地配置输入类型（脉冲或挂起）和对应的触发事件（上升沿或下降沿或者双边沿都触发）</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/cGwe9jfI5CtgXR3.png" alt="图示" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>EXTI 支持 19 个外部中断/事件请求，这些都是信息输入端，也就是上面提及到了输入线</p>
<p>具体如下：</p>
<ul>
<li>EXTI 线 0~15：对应外部 IO 口的输入中断</li>
<li>EXTI 线 16：连接到 PVD 输出</li>
<li>EXTI 线 17：连接到 RTC 闹钟事件</li>
<li>EXTI 线 18：连接到 USB 唤醒事件</li>
<li>EXTI 线 19：连接到以太网唤醒事件</li>
</ul>
<p>从上面可以看出，STM32F1 供给 IO 口使用的中断线只有 16 个，但是 STM32F1 的 IO 口却远远不止 16 个，所以 STM32 把 GPIO 管脚 GPIOx.0~GPIOx.15(x=A,B,C,D,E,F,G)分别对应中断线 0~15。这样子每个中断线对应了最多 9 个 IO 口，以线 0 为例：它对应了 GPIOA.0、GPIOB.0、GPIOC.0、GPIOD.0、GPIOE.0、GPIOF.0 和 GPIOG.0。而中断线每次只能连接到 1个 IO 口上，这样就需要通过配置决定对应的中断线配置到哪个 GPIO 上了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//stm32f1xx_it.：大概204行</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI3_IRQHandler</span><span class="params">(<span class="type">void</span>)</span>		<span class="comment">//中断入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* USER CODE BEGIN EXTI3_IRQn 0 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE END EXTI3_IRQn 0 */</span></span><br><span class="line">    HAL_GPIO_EXTI_IRQHandler(EXTI_Key1_Pin);	<span class="comment">//在库函数不能写</span></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN EXTI3_IRQn 1 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE END EXTI3_IRQn 1 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_IRQHandler</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span>	<span class="comment">//stm32f1xx_hal_gpio.c：大概546行</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* EXTI line interrupt detected */</span></span><br><span class="line">    <span class="keyword">if</span> (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != <span class="number">0x00</span>u)	<span class="comment">//判断有没有中断触发(有:1,没:0)</span></span><br><span class="line">    &#123;</span><br><span class="line">        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);		<span class="comment">//若进来则为1，为1则清除中断标志位</span></span><br><span class="line">        HAL_GPIO_EXTI_Callback(GPIO_Pin);	<span class="comment">//回调函数(Callback)，执行函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stm32f1xx_hal_gpio.h中190</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAL_GPIO_EXTI_GET_IT(__EXTI_LINE__) (EXTI-&gt;PR &amp; (__EXTI_LINE__))	<span class="comment">//挂起寄存器(EXTI_PR)(参考手册140) 有没有中断触发</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//stm32f1xx_hal_gpio.h中198</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAL_GPIO_EXTI_CLEAR_IT(__EXTI_LINE__) (EXTI-&gt;PR = (__EXTI_LINE__))	<span class="comment">//赋值，(参考手册140)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用这个函数，__weak：弱声明，若别文件也有相同的函数，优先调用没有弱声明</span></span><br><span class="line">__weak <span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span>	<span class="comment">//stm32f1xx_hal_gpio.c：大概561行</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Prevent unused argument(s) compilation warning */</span></span><br><span class="line">    UNUSED(GPIO_Pin);</span><br><span class="line">    <span class="comment">/* <span class="doctag">NOTE:</span> This function Should not be modified, when the callback is needed,</span></span><br><span class="line"><span class="comment">           the HAL_GPIO_EXTI_Callback could be implemented in the user file</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若相同有一个PA0设置了中断，别的PB0等等都不能设置成中断</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/19/7RmikXrcqnvBgKs.png" alt="解析图" style="zoom: 50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h1><center>代码编写</center></h1>
<p>实验：按键PE3控制蜂鸣器(PB8)、按键PE4控制LED灯(PB5)</p>
<h2 id="center-led灯-蜂鸣器-按键配置-center"><center>LED灯、蜂鸣器、按键配置</center></h2>
<p>LED灯、蜂鸣器配置，上一篇已经说过，<a href="https://68565200.xyz/post/adb202b7.html">地址</a></p>
<p>按键设置<code>下降沿触发</code>(也可上升沿触发)，GPIO Pull-up/Pull-down：设置上拉，空闲状态为高电平</p>
<p>按键没按下时高电平，按下时有下降沿和上升沿，所以两个触发都可，按键这里是中断触发功能，不是GPIO输入功能</p>
<img src="https://s2.loli.net/2024/08/19/MlziWawDkUVYgQX.png" alt="按键设置图" style="zoom: 45%;">
<p>配置NVIC(嵌套向量中断控制器)</p>
<img src="https://s2.loli.net/2024/08/19/58IR4kTWyzZQ3Hb.png" alt="配置NVIC" style="zoom:50%;">
<p>调节不同中断优先级(数字越小优先级越高)</p>
<p>若抢占优先级相同，比较子优先级</p>
<img src="https://s2.loli.net/2024/08/19/cVDHdAL9rNEYSjW.png" alt="中断优先级" style="zoom: 50%;">
<p>调节多少bit对应代码在：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_Init();	<span class="comment">//main.c(74)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//HAL_StatusTypeDef HAL_Init(void)中的</span></span><br><span class="line">HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);	<span class="comment">//stm32f1xx_hal.c(157)</span></span><br></pre></td></tr></table></figure>
<h2 id="center-cube-ide代码-center"><center>Cube IDE代码</center></h2>
<p>main.c：144行（在mian函数外任意一个 /* USER CODE BEGIN  <em>/  /</em> USER CODE END  */中）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//若需要延时需要将延时中断优先级比外部中断优先级高，优先级高才可以打断低优先级</span></span><br><span class="line">    HAL_Delay(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(HAL_GPIO_ReadPin(EXTI_Key1_GPIO_Port, EXTI_Key1_Pin) == <span class="number">0</span>)	<span class="comment">//读引脚，相同=0,不同=1</span></span><br><span class="line">    &#123;</span><br><span class="line">        HAL_GPIO_TogglePin(BEEP_GPIO_Port, BEEP_Pin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(HAL_GPIO_ReadPin(EXTI_Key2_GPIO_Port, EXTI_Key2_Pin) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>中断处理程序要少用延时的原因<br>
中断处理的要求是即时处理，尽快退出。如果在中断中使用延时函数或者使用IO阻塞函数，会影响到系统的实时性。如果下次中断来临，延时或者阻塞还没结束，那么就永远在中断里死循环了。<br>
因此，对于中断处理程序的要求是：<br>
    短小精悍，不要处理过多任务<br>
    不使用延时函数或者IO阻塞的函数</p>
</blockquote>
<h2 id="center-标准库-center"><center>标准库</center></h2>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key_exti.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">clock_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    RCC_APB2PeriphClockCmd()：控制APB2总线上外设时钟的开启或关闭</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);   <span class="comment">//LED</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);   <span class="comment">//按键</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    RCC_APB2Periph_AFIO：复用功能I/O端口的时钟</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">on_key_pressed</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    led_toogle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//时钟初始化</span></span><br><span class="line">    clock_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化外设</span></span><br><span class="line">    led_init();</span><br><span class="line">    key_exti_init();</span><br><span class="line"></span><br><span class="line">    key_exti_register(on_key_pressed);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>key_exti.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key_exti.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义按键使用的GPIO引脚为GPIOE.4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN GPIO_Pin_4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Num GPIOE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EXTI配置，指定外部中断来源的端口和引脚</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_EXTI_PORT_SRC   GPIO_PortSourceGPIOE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_EXTI_PIN_SRC    GPIO_PinSource4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定使用EXTI线4作为外部中断线</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_EXTI_LINE       EXTI_Line4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个全局变量用于存储按键按下时的回调函数指针</span></span><br><span class="line"><span class="type">static</span> <span class="type">key_press_callback_t</span> key_press_callback;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查按键是否被按下的函数</span></span><br><span class="line"><span class="comment">// 返回值：true表示按键被按下，false表示按键未被按下</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">key_pressed</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 读取引脚电平状态，如果是低电平（即接地），则返回true，表示按键被按下</span></span><br><span class="line">    <span class="type">bool</span> flag = (GPIO_ReadInputDataBit(GPIO_Num, PIN) == Bit_RESET);</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待按键释放的函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_waite_release</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当按键被按下时循环等待，直到按键被释放</span></span><br><span class="line">    <span class="keyword">while</span>(!key_pressed());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化按键外部中断的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">key_exti_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置GPIOE.4引脚为浮空输入 */</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = PIN;                          <span class="comment">// 设置引脚编号</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;           <span class="comment">// 设置最大输出速度（对于输入模式无关紧要）</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;               <span class="comment">// 设置为上拉输入模式</span></span><br><span class="line">    GPIO_Init(GPIO_Num, &amp;GPIO_InitStructure);                   <span class="comment">// 应用上述配置到GPIOE.4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将EXTI Line 4连接到GPIOE.4引脚 */</span></span><br><span class="line">    GPIO_EXTILineConfig(KEY_EXTI_PORT_SRC, KEY_EXTI_PIN_SRC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置EXTI Line 4 */</span></span><br><span class="line">    EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">    EXTI_InitStructure.EXTI_Line = KEY_EXTI_LINE;               <span class="comment">// 设置EXTI线</span></span><br><span class="line">    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;         <span class="comment">// 设置为中断模式</span></span><br><span class="line">    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;      <span class="comment">// 设置触发条件为下降沿触发</span></span><br><span class="line">    EXTI_InitStructure.EXTI_LineCmd = ENABLE;                   <span class="comment">// 使能EXTI线</span></span><br><span class="line">    EXTI_Init(&amp;EXTI_InitStructure);                             <span class="comment">// 应用EXTI配置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 使能并设置EXTI4中断优先级 */</span></span><br><span class="line">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQn;            <span class="comment">// 设置NVIC中断通道为EXTI4</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">5</span>;   <span class="comment">// 设置抢占优先级为5</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">0</span>;          <span class="comment">// 设置子优先级为0</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;             <span class="comment">// 使能中断通道</span></span><br><span class="line">    NVIC_Init(&amp;NVIC_InitStructure);                             <span class="comment">// 应用NVIC配置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册按键按下时调用的回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">key_exti_register</span><span class="params">(<span class="type">key_press_callback_t</span> callback)</span></span><br><span class="line">&#123;</span><br><span class="line">    key_press_callback = callback; <span class="comment">// 存储回调函数指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EXTI4中断服务程序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI4_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查按键是否真的被按下（防抖动处理）</span></span><br><span class="line">    <span class="keyword">if</span> (key_pressed())</span><br><span class="line">    &#123;</span><br><span class="line">        delay(<span class="number">10</span>); <span class="comment">// 延时10ms，用于去抖</span></span><br><span class="line">        <span class="keyword">if</span> (key_pressed()) <span class="comment">// 再次检查按键是否仍然被按下</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果key_press_callback指向不为null，则为真</span></span><br><span class="line">            <span class="keyword">if</span> (key_press_callback)</span><br><span class="line">                key_press_callback();</span><br><span class="line">            <span class="comment">// 等待按键释放</span></span><br><span class="line">            key_waite_release();</span><br><span class="line">            delay(<span class="number">10</span>); <span class="comment">// 确保按键已经完全释放</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清除EXTI线上的挂起位，以允许下次中断</span></span><br><span class="line">    EXTI_ClearITPendingBit(KEY_EXTI_LINE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>key_exti.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KEY_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KEY_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="comment">//声明一个函数指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">key_press_callback_t</span>)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">key_exti_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">key_exti_register</span><span class="params">(<span class="type">key_press_callback_t</span> callback)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __KEY_H */</span></span></span><br></pre></td></tr></table></figure>
<p>led.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN GPIO_Pin_5</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> led_flagOF = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;    <span class="comment">//定义一个GPIO_InitTypeDef结构体变量</span></span><br><span class="line">    <span class="comment">//设置输出模式</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">    <span class="comment">//设置pin脚</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = PIN;</span><br><span class="line">    <span class="comment">//设置时钟频率</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    <span class="comment">//初始化GPIO口</span></span><br><span class="line">    GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">    <span class="comment">//设置引脚默认电平</span></span><br><span class="line">    GPIO_SetBits(GPIOB, PIN);   <span class="comment">//设置为高电平</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置LED灯状态函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_set</span><span class="params">(<span class="type">bool</span> on)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_WriteBit(GPIOB,PIN, on? Bit_RESET : Bit_SET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开灯</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_on</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    led_set(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关灯</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    led_set(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LED灯翻转</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_toogle</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    led_flagOF = !led_flagOF;</span><br><span class="line">    led_set(!led_flagOF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>led.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LED_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LED_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_set</span><span class="params">(<span class="type">bool</span> on)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">led_on</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">led_off</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">led_toogle</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __LED_H */</span></span></span><br></pre></td></tr></table></figure>
<p>utils.c、main.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//utils.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">uint32_t</span> tickes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; tickes; t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(n = <span class="number">0</span>; n &lt; <span class="number">72000</span>; n++)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MAIN_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MAIN_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">uint32_t</span> tickes)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __MAIN_H */</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>32单片机</category>
      </categories>
      <tags>
        <tag>32单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>4.定时器(TIMER)</title>
    <url>/post/f71d0ad2.html</url>
    <content><![CDATA[<h1><center>理论</center></h1>
<p>预分频寄存器(TIMx_PSC)：由于时钟源为：72MHz，T = 1/f = 1/72MHz，由于不好计算周期时间，则需要分频，若分72则T = 1/1MHz = 1us(1MHz = 一百万秒)</p>
<p>计数方式：向上(递增到某个数触发中断)、向下(递减到某一个数触发中断)、中心计数(递增到某一个数触发中断，再递减到某一个数触发中断)</p>
<p>比较值(参考：<a href="https://blog.csdn.net/qq_36553707/article/details/109527645">链接</a>)：</p>
<p>    PWM1模式：若计数值小于有效值则高电平，计数值大于有效值则低电平，可以控制比较值来调节占空比</p>
<p>    PWM2模式：与PWM1模式相反，计数值小于有效值则低电平，大于有效值则高电平</p>
<p>复用：Pin脚本身除了支持普通GPIO功能之外，还支持别的功能(使用别的功能就叫复用)</p>
<p>重映射：Pin脚本身不支持这些功能，配置重映射寄存器，使其具备别的功能</p>
<h2 id="center-定时器分类-center"><center>定时器分类</center></h2>
<p>型号：STM32F103ZET6</p>
<p>基本定时器：TIM6、TIM7</p>
<img src="https://s2.loli.net/2024/08/19/BGfugU9cvzQj4Dy.png" alt="基本定时器功能" style="zoom:50%;">
<p>通用定时器：TIM2~TIM5</p>
<img src="https://s2.loli.net/2024/08/19/Ks6JF3gDBmVedzS.png" alt="通用定时器功能" style="zoom: 50%;">
<p>高级定时器：TIM1、TIM8</p>
<img src="https://s2.loli.net/2024/08/19/ZOeUplvX8mNVPky.png" alt="高级定时器功能" style="zoom:50%;">
<h1><center>代码编写</center></h1>
<p>定时器中断实验：LED灯一秒闪烁一次、LED灯两秒闪烁一次、计算单片机运行时间、串口5秒返回单片机运行时间</p>
<p>PWM信号输出：呼吸灯、电机(由慢到快)、舵机</p>
<p>输入捕获：检测信号脉冲宽度(舵机脉冲宽度)</p>
<h2 id="center-led灯-uart-定时器-pwm配置-center"><center>LED灯、UART、定时器、PWM配置</center></h2>
<p>LED灯配置请看：<a href="https://68565200.xyz/post/adb202b7.html">链接</a></p>
<p>串口配置请看：<a href="https://68565200.xyz/post/2c4c3bc3.html">链接</a></p>
<h3 id="配置定时器：">配置定时器：</h3>
<p>72/7200 = 0.01，T = 1/f = 1/0.01MHz = 100us，计数10000，触发中断，100us * 10000 = 1s，1s = 1000000us，但单片机都是以0开始，所以分频值以及计数值都 -1</p>
<img src="https://s2.loli.net/2024/08/19/uJqVb7cEptMsTCD.png" alt="定时器配置" style="zoom:50%;">
<h3 id="配置定时器向上计数溢出中断nvic-嵌套向量中断控制器">配置定时器向上计数溢出中断NVIC(嵌套向量中断控制器)</h3>
<img src="https://s2.loli.net/2024/08/19/XAbRjiVIgShLuO2.png" alt="配置定时器NVIC" style="zoom:50%;">
<h3 id="定时器-pwm-控制led灯配置">定时器(PWM)控制LED灯配置</h3>
<p>LED(PB5)引脚说明：</p>
<img src="https://s2.loli.net/2024/08/19/rVg2EduWfx3D5Ah.png" alt="PWMLED灯配置" style="zoom:50%;">
<p>所以配置定时器3，通道二，但配置完发现图中不符，需手动修改</p>
<img src="https://s2.loli.net/2024/08/19/TR6QPs4hiO1yAmw.png" alt="定时器配置LED灯" style="zoom: 33%;">
<h3 id="定时器-pwm-控制电机配置">定时器(PWM)控制电机配置</h3>
<p>配置PB4引脚PWM控制电机速度</p>
<img src="https://s2.loli.net/2024/08/19/gz5AvYuDaMSEfIn.png" alt="配置PWM控制电机速度" style="zoom:33%;">
<h3 id="定时器-pwm-控制舵机配置">定时器(PWM)控制舵机配置</h3>
<p>舵机脉冲周期：20ms</p>
<img src="https://s2.loli.net/2024/08/19/8tF2HPfO3cj7xSu.png" alt="PWM控制舵机配置" style="zoom: 33%;">
<h3 id="输入捕获定时器配置">输入捕获定时器配置</h3>
<img src="https://s2.loli.net/2024/08/19/cUVrwZYbG96LDlJ.png" alt="输入捕获定时器配置" style="zoom:33%;">
<img src="https://s2.loli.net/2024/08/19/5UltjiM1z4xuOaL.png" alt="输入捕获定时器配置" style="zoom:50%;">
<h3 id="配置定时器全局中断nvic">配置定时器全局中断NVIC</h3>
<img src="https://s2.loli.net/2024/08/19/NGgBUP3d4LcIfEs.png" alt="开启中断" style="zoom:50%;">
<h3 id="dht11-温湿度传感器-配置">DHT11(温湿度传感器)配置</h3>
<img src="https://s2.loli.net/2024/08/19/4R7KvoQTPs8Mf6A.png" alt="DHT11(温湿度传感器)配置" style="zoom:33%;">
<h2 id="center-led灯闪烁-串口输出运行时间-center"><center>LED灯闪烁、串口输出运行时间</center></h2>
<p>LED1每隔一秒电平翻转一次，LED2每隔两秒电平翻转一次，串口输出单片机运行时间</p>
<h3 id="center-cube-ide代码-center"><center>Cube IDE代码</center></h3>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>	<span class="comment">//27行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>	<span class="comment">//28行</span></span></span><br><span class="line"><span class="comment">/* USER CODE END Includes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="type">uint32_t</span> G_Timer_Count = <span class="number">0</span>;	<span class="comment">//59行</span></span><br><span class="line"><span class="type">uint8_t</span> UART_Count[<span class="number">200</span>];	</span><br><span class="line"><span class="type">uint8_t</span> UART_Flag = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim1);	<span class="comment">//开启定时器，97行</span></span><br><span class="line"><span class="comment">/* USER CODE END 2 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(UART_Flag)	<span class="comment">//104行</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(UART_Count,<span class="string">&quot;MCU run time is %lus&quot;</span>,G_Timer_Count);</span><br><span class="line">    HAL_UART_Transmit(&amp;huart1, UART_Count, <span class="built_in">strlen</span>(UART_Count), <span class="number">1000</span>);</span><br><span class="line">    UART_Flag = <span class="number">0</span>;	<span class="comment">//打印一次后标志=0，等中断五次(5s)后</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 4 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span>	<span class="comment">//定时器触发函数,157行</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(htim == &amp;htim1)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);</span><br><span class="line">        G_Timer_Count++;</span><br><span class="line">        <span class="keyword">if</span>((G_Timer_Count % <span class="number">5</span>) == <span class="number">0</span>)</span><br><span class="line">            UART_Flag = <span class="number">1</span>;	<span class="comment">//每隔五秒，让标志=1</span></span><br><span class="line">        <span class="keyword">if</span>((G_Timer_Count % <span class="number">2</span>) == <span class="number">0</span>)	<span class="comment">//LED2每隔两秒翻转电平</span></span><br><span class="line">            HAL_GPIO_TogglePin(LED2_GPIO_Port, LED2_Pin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 4 */</span></span><br></pre></td></tr></table></figure>
<h2 id="center-pwm信号led呼吸灯-电机-舵机-center"><center>PWM信号LED呼吸灯、电机、舵机</center></h2>
<p>理论参考：<a href="https://68565200.xyz/post/93c966f3.html">链接</a></p>
<p>PWM信号控制LED，产生一个呼吸灯效果，以及对电机控制，控制速度由慢到快</p>
<h3 id="center-cube-ide代码-center"><center>Cube IDE代码</center></h3>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN PV */</span></span><br><span class="line"><span class="type">uint8_t</span> PWM_Value = <span class="number">0</span>,LED_PWM_Value = <span class="number">0</span>,SG_PWM = <span class="number">5</span>;	<span class="comment">//47行</span></span><br><span class="line"><span class="comment">/* USER CODE END PV */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line"><span class="comment">//参数1：定时器句柄(指向配置好的定时器结构体的指针)，参数2：定时器通道,93行</span></span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_2);	<span class="comment">//开启定时器3，通道2 PWM</span></span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_1);	<span class="comment">//开启定时器3，通道1 PWM</span></span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim4, TIM_CHANNEL_1);	<span class="comment">//开启定时器4，通道1 PWM</span></span><br><span class="line"><span class="comment">/* USER CODE END 2 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//103行</span></span><br><span class="line">PWM_Value++;</span><br><span class="line">PWM_Value = PWM_Value % <span class="number">200</span>;</span><br><span class="line"><span class="keyword">if</span>(PWM_Value &gt; <span class="number">99</span>)</span><br><span class="line">    LED_PWM_Value = <span class="number">200</span> - PWM_Value;	<span class="comment">//大于99时，从大到小(100,99...)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    LED_PWM_Value = PWM_Value;</span><br><span class="line">HAL_Delay(<span class="number">25</span>);</span><br><span class="line"><span class="comment">//参数1：定时器句柄，参数2：定时器通道,参数3：比较值</span></span><br><span class="line">__HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_2, LED_PWM_Value);	<span class="comment">//设置LED比较值</span></span><br><span class="line">__HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_1, LED_PWM_Value);	<span class="comment">//设置电机比较值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(PWM_Value % <span class="number">30</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//每0.1ms计数值+1则0.5ms，比较值模式1，则占空比(高电平)0.5ms</span></span><br><span class="line">    SG_PWM += <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span>(SG_PWM &gt; <span class="number">25</span>)</span><br><span class="line">        SG_PWM = <span class="number">5</span>;</span><br><span class="line">    __HAL_TIM_SET_COMPARE(&amp;htim4, TIM_CHANNEL_1, SG_PWM);	<span class="comment">//设置舵机比较值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-输入捕获-ic-center"><center>输入捕获(IC)</center></h2>
<p>捕获高电平持续时间</p>
<h3 id="center-cube-ide代码-center"><center>Cube IDE代码</center></h3>
<p>捕获PWM高电平的时间</p>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN PTD */</span></span><br><span class="line"><span class="type">uint32_t</span> ic_state=<span class="number">0</span>,period_count=<span class="number">0</span>,ic_count=<span class="number">0</span>,us_count;	<span class="comment">//32行</span></span><br><span class="line"><span class="comment">/* USER CODE END PTD */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim2);	<span class="comment">//开启普通定时器中断</span></span><br><span class="line">HAL_TIM_IC_Start_IT(&amp;htim2, TIM_CHANNEL_2);	<span class="comment">//开启捕获定时器中断</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please connect MCU51 P2.0,and let SG90 run to detect signal!\n&quot;</span>);	<span class="comment">//串口输出捕获的时间(记得配置串口重定向)</span></span><br><span class="line"><span class="comment">/* USER CODE END 2 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ic_state== <span class="number">2</span> )	<span class="comment">//103行(while里)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 始终设置的是1us触发计数值加1</span></span><br><span class="line"><span class="comment">	* 一个周期大概65ms，若大于65只有捕获中断函数不好使</span></span><br><span class="line"><span class="comment">	* 若period_count为1，则代表过了一个中断周期，时间(1*65535)us</span></span><br><span class="line"><span class="comment">	* 若没有到整个中断周期时间则剩下的为：ic_count</span></span><br><span class="line"><span class="comment">	* 所以两个相加等于整个高电平时间*/</span></span><br><span class="line">    us_count = ic_count + period_count * <span class="number">0xFFFF</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;High level duration:  %ldus \n&quot;</span>,us_count);	<span class="comment">//(float)(us_count)/1000.000</span></span><br><span class="line">    ic_state = <span class="number">0</span>;	<span class="comment">//再将中间键恢复0，方便下次上升沿触发中断计时</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 4 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_IC_CaptureCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span>	<span class="comment">//输入捕获触发函数,161行</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(TIM2 == htim-&gt;Instance)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( ic_state == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            __HAL_TIM_SET_COUNTER(htim,<span class="number">0</span>);	<span class="comment">//将定时器从零开始计时</span></span><br><span class="line">            __HAL_TIM_SET_CAPTUREPOLARITY(&amp;htim2, TIM_CHANNEL_2, TIM_INPUTCHANNELPOLARITY_FALLING);		<span class="comment">//设置成下降沿触发</span></span><br><span class="line">            ic_state = <span class="number">1</span>;	<span class="comment">//下次触发中断时(下降沿)则运行else</span></span><br><span class="line">            period_count = <span class="number">0</span>;</span><br><span class="line">            ic_count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ic_count = HAL_TIM_ReadCapturedValue(&amp;htim2,TIM_CHANNEL_2);	<span class="comment">//读取定时器计数值</span></span><br><span class="line">            __HAL_TIM_SET_CAPTUREPOLARITY(&amp;htim2, TIM_CHANNEL_2,   TIM_INPUTCHANNELPOLARITY_RISING);	<span class="comment">//设置成上降沿触发</span></span><br><span class="line">            ic_state = <span class="number">2</span>;	<span class="comment">//进入while里面的判断</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span>	<span class="comment">//普通定时器中断触发函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(TIM2 == htim-&gt;Instance)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ic_state==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(period_count==<span class="number">0XFFFF</span>)	<span class="comment">//一次周期大约65ms，若进入这个需要(65*65535)ms</span></span><br><span class="line">            &#123;</span><br><span class="line">                ic_state=<span class="number">2</span>;</span><br><span class="line">                ic_count=<span class="number">0XFFFF</span>;	<span class="comment">//返回一个超大数显示错误</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                period_count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 4 */</span></span><br></pre></td></tr></table></figure>
<h2 id="center-dht11-center"><center>DHT11</center></h2>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dht11.h&quot;</span>	<span class="comment">//27行</span></span></span><br><span class="line"><span class="comment">/* USER CODE END Includes */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(DHT_Read())	<span class="comment">//while里,101行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; H:%u  T:%u \r\n&quot;</span>,Data[<span class="number">0</span>],Data[<span class="number">2</span>]);</span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>dht11.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dht11.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Data[<span class="number">5</span>]=&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_us</span><span class="params">(<span class="type">uint16_t</span> us)</span>	<span class="comment">//微秒延迟</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> differ = <span class="number">0xffff</span>-us;</span><br><span class="line">    __HAL_TIM_SET_COUNTER(&amp;htim1,differ);</span><br><span class="line">    HAL_TIM_Base_Start(&amp;htim1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(differ &lt; <span class="number">0xffff</span>)&#123;</span><br><span class="line">        differ = __HAL_TIM_GET_COUNTER(&amp;htim1);</span><br><span class="line">    &#125;</span><br><span class="line">    HAL_TIM_Base_Stop(&amp;htim1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DHT_GPIO_SET_OUTPUT</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.Pin=GPIO_PIN_5;</span><br><span class="line">    GPIO_InitStructure.Mode=GPIO_MODE_OUTPUT_PP;	<span class="comment">//PA5设置输出</span></span><br><span class="line">    <span class="comment">//	GPIO_InitStructure.Pull=;</span></span><br><span class="line">    GPIO_InitStructure.Speed=GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">    HAL_GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DHT_GPIO_SET_INPUT</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.Pin=GPIO_PIN_5;</span><br><span class="line">    GPIO_InitStructure.Mode=GPIO_MODE_INPUT;	<span class="comment">//PA5设置输入</span></span><br><span class="line">    GPIO_InitStructure.Speed=GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">    HAL_GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">DHT_Read_Byte</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> ReadData=<span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> temp;</span><br><span class="line">    <span class="type">uint8_t</span> retry=<span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> i;    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_5)==<span class="number">0</span> &amp;&amp; retry&lt;<span class="number">100</span>)  </span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            Delay_us(<span class="number">1</span>);</span><br><span class="line">            retry++;</span><br><span class="line">        &#125;</span><br><span class="line">        retry=<span class="number">0</span>;</span><br><span class="line">        Delay_us(<span class="number">40</span>);</span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_5)==<span class="number">1</span>)   temp=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>   temp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_5)==<span class="number">1</span> &amp;&amp; retry&lt;<span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Delay_us(<span class="number">1</span>);</span><br><span class="line">            retry++;</span><br><span class="line">        &#125;</span><br><span class="line">        retry=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ReadData&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        ReadData |= temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ReadData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">DHT_Read</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> retry=<span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> i;</span><br><span class="line"></span><br><span class="line">    DHT_GPIO_SET_OUTPUT();</span><br><span class="line">    HAL_GPIO_WritePin(GPIOA,GPIO_PIN_5,GPIO_PIN_RESET);</span><br><span class="line">    HAL_Delay(<span class="number">18</span>);</span><br><span class="line">    HAL_GPIO_WritePin(GPIOA,GPIO_PIN_5,GPIO_PIN_SET);</span><br><span class="line">    Delay_us(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    DHT_GPIO_SET_INPUT();</span><br><span class="line">    Delay_us(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_5)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_5)==<span class="number">0</span> &amp;&amp; retry&lt;<span class="number">100</span>)  </span><br><span class="line">        &#123;</span><br><span class="line">            Delay_us(<span class="number">1</span>);</span><br><span class="line">            retry++;</span><br><span class="line">        &#125;</span><br><span class="line">        retry=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_5)==<span class="number">1</span> &amp;&amp; retry&lt;<span class="number">100</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            Delay_us(<span class="number">1</span>);</span><br><span class="line">            retry++;</span><br><span class="line">        &#125;</span><br><span class="line">        retry=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Data[i] = DHT_Read_Byte();</span><br><span class="line">        &#125;</span><br><span class="line">        Delay_us(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uint32_t</span> sum=Data[<span class="number">0</span>]+Data[<span class="number">1</span>]+Data[<span class="number">2</span>]+Data[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">if</span>((sum)==Data[<span class="number">4</span>])    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">else</span>   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dht11.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DHT11_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DHT11_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx_hal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> Data[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> TIM_HandleTypeDef htim1;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_us</span><span class="params">(<span class="type">uint16_t</span> us)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DHT_GPIO_SET_OUTPUT</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DHT_GPIO_SET_INPUT</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">DHT_Read_Byte</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">DHT_Read</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>32单片机</category>
      </categories>
      <tags>
        <tag>32单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>3.串口(UART)</title>
    <url>/post/2c4c3bc3.html</url>
    <content><![CDATA[<h1><center>理论</center></h1>
<p>串口理论部分可看51部分：<a href="https://68565200.xyz/post/f736596e">链接</a></p>
<p>数据帧 = 帧头(2字节，例如AA、BB) + 数据长度（2字节）+ 数据 + CRC16校验（2字节） + 帧尾（2字节）</p>
<p>回调函数在：stm32f1xx_it.c里找对应的函数转进入里面找</p>
<p>中断函数：stm32f1xx_hal_uart.c（别的只是uart不同）</p>
<h1><center>代码编写</center></h1>
<p>串口一发送命令控制LED灯(PB5、PE5)</p>
<h2 id="center-led灯-串口-串口打印浮点数据-串口重定向配置-center"><center>LED灯、串口、串口打印浮点数据、串口重定向配置</center></h2>
<p>LED灯配置请看：<a href="https://68565200.xyz/post/adb202b7.html">链接</a></p>
<p>串口配置：</p>
<img src="https://s2.loli.net/2024/08/19/8WslO2PSbvQZaHG.png" alt="串口配置" style="zoom: 33%;">
<p>配置串口中断NVIC(嵌套向量中断控制器)</p>
<img src="https://s2.loli.net/2024/08/19/vnKglqby6ahNCDs.png" alt="配置中断NVIC" style="zoom:33%;">
<p>配置DMA：</p>
<img src="https://s2.loli.net/2024/08/19/zYQw9NlP3GXsjmU.png" alt="配置DMA" style="zoom: 33%;">
<p>Cube IDE中串口打印浮点数据配置方法(<a href="https://blog.csdn.net/caihaitao2000/article/details/112469098">参考</a>)：进入“Project→Properties”；显示界面如下。按照图片中的设置完成即可！</p>
<img src="https://s2.loli.net/2024/08/19/8YatcRMreEN2A7X.png" alt="打印浮点数配置" style="zoom: 33%;">
<p>串口重定向配置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> u_buf[<span class="number">256</span>];	<span class="comment">//usart.c,24行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>	<span class="comment">//usart.h,32行</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> u_buf[<span class="number">256</span>];	<span class="comment">//usart.h，38行</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> printf(...)  HAL_UART_Transmit(&amp;huart1, (uint8_t *)u_buf, sprintf((char*)u_buf, __VA_ARGS__), 0xffff)	<span class="comment">//usart.h，39行</span></span></span><br></pre></td></tr></table></figure>
<h2 id="center-轮询方式-center"><center>轮询方式</center></h2>
<p>缺点：</p>
<p>    必须要等待数据发送完或者等待时间超时，代码才会往下走</p>
<p>    必须要等待数据接收到固定的字节长度，超时，代码才往下走</p>
<h3 id="center-cube-ide代码-center"><center>Cube IDE代码</center></h3>
<p>mian.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>	<span class="comment">//26行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>	<span class="comment">//27</span></span></span><br><span class="line"><span class="comment">/* USER CODE END Includes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PV */</span></span><br><span class="line"><span class="type">uint8_t</span> UART_Recv[<span class="number">5</span>];	<span class="comment">//48行</span></span><br><span class="line"><span class="type">char</span> UART_Str[<span class="number">30</span>];		<span class="comment">//49行</span></span><br><span class="line"><span class="comment">/* USER CODE END PV */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数1：UART 模块的配置信息的指针,参数2：数据缓冲区的指针，参数3：接收字节长度，参数4：接收超时时间(单位为毫秒)</span></span><br><span class="line">HAL_UART_Receive(&amp;huart1, UART_Recv, <span class="number">4</span>, <span class="number">1000</span>);	<span class="comment">//接收数据函数</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">&quot;LED1&quot;</span>, (<span class="type">char</span> *)UART_Recv) == <span class="number">0</span>)	<span class="comment">//字符串比较函数</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);</span><br><span class="line">    <span class="built_in">memset</span>(UART_Recv,<span class="string">&#x27;\0&#x27;</span>,<span class="number">5</span>);	<span class="comment">//替换字符函数，常用于清除指定空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">&quot;LED2&quot;</span>, (<span class="type">char</span> *)UART_Recv))	<span class="comment">//字符串比较函数</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_GPIO_TogglePin(LED2_GPIO_Port, LED2_Pin);</span><br><span class="line">    <span class="built_in">memset</span>(UART_Recv,<span class="string">&#x27;\0&#x27;</span>,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(UART_Str, <span class="string">&quot;%f\n&quot;</span>, <span class="number">666.6</span>);</span><br><span class="line"><span class="comment">//参数1：UART 模块的配置信息的指针,参数2：发送的字符串或字符数组，参数3：发送字节长度，参数4：接收超时时间(单位为毫秒)</span></span><br><span class="line">HAL_UART_Transmit(&amp;huart1, (<span class="type">char</span> *)UART_Str, <span class="built_in">strlen</span>(UART_Str), <span class="number">1000</span>);	<span class="comment">//发送数据</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;xinzai\n&quot;</span>);	<span class="comment">//配置串口重定向后才可使用</span></span><br></pre></td></tr></table></figure>
<h2 id="center-中断-it-方式-center"><center>中断(IT)方式</center></h2>
<h3 id="center-cube-ide代码-center"><center>Cube IDE代码</center></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_UART_RxCpltCallback(huart);	<span class="comment">//stm32f1xx_hal_uart.c,3660行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//stm32f1xx_hal_uart.c,2619行</span></span><br><span class="line">__weak <span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span>	<span class="comment">//中断回调函数</span></span><br></pre></td></tr></table></figure>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>	<span class="comment">//26行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>	<span class="comment">//27行</span></span></span><br><span class="line"><span class="comment">/* USER CODE END Includes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PV */</span></span><br><span class="line"><span class="type">uint8_t</span> UART_Recv_IT[<span class="number">5</span>];	<span class="comment">//48行</span></span><br><span class="line"><span class="type">char</span> UART_Str[<span class="number">30</span>];	<span class="comment">//49行</span></span><br><span class="line"><span class="comment">/* USER CODE END PV */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line"><span class="comment">//参数1：UART 模块的配置信息的指针,参数2：数据缓冲区的指针，参数3：接收字节长度</span></span><br><span class="line">HAL_UART_Receive_IT(&amp;huart1, UART_Recv_IT, <span class="number">4</span>);	<span class="comment">//串口中断接收函数，95行</span></span><br><span class="line"><span class="comment">/* USER CODE END 2 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//while函数里</span></span><br><span class="line"><span class="built_in">sprintf</span>(UART_Str, <span class="string">&quot;%d\n&quot;</span>, <span class="number">666</span>);	<span class="comment">//102</span></span><br><span class="line">HAL_UART_Transmit_IT(&amp;huart1, UART_Str, <span class="built_in">strlen</span>(UART_Str));	<span class="comment">//串口中断发送函数,103</span></span><br><span class="line">HAL_Delay(<span class="number">1000</span>);	<span class="comment">//104</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//151行开始</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 4 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span>	<span class="comment">//串口中断接收触发函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(huart == &amp;huart1)	<span class="comment">//判断传进来的串口是哪个</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">&quot;LED1&quot;</span>, (<span class="type">char</span> *)UART_Recv_IT) == <span class="number">0</span>)	<span class="comment">//字符串比较函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);</span><br><span class="line">            <span class="built_in">memset</span>(UART_Recv_IT,<span class="string">&#x27;\0&#x27;</span>,<span class="number">5</span>);	<span class="comment">//替换字符函数，常用于清除指定空间</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">&quot;LED2&quot;</span>, (<span class="type">char</span> *)UART_Recv_IT))	<span class="comment">//字符串比较函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            HAL_GPIO_TogglePin(LED2_GPIO_Port, LED2_Pin);</span><br><span class="line">            <span class="built_in">memset</span>(UART_Recv_IT,<span class="string">&#x27;\0&#x27;</span>,<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为只能接受一次串口中断，所以在串口中断触发函数需要重新调用</span></span><br><span class="line">        HAL_UART_Receive_IT(&amp;huart1, UART_Recv_IT, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 4 */</span></span><br></pre></td></tr></table></figure>
<h2 id="center-空闲中断-idle-dma-center"><center>空闲中断(IDLE) + DMA</center></h2>
<p>不受接收字符长度影响，可以随意接收字符长度并判断，DMA会触发中断</p>
<p>空闲状态：在多个字节传输结束后，通信线路将会维持高电平，这个状态称为空闲状态（没有数据传输时的空闲状态，数据传输刚结束的空闲状态）</p>
<p>空闲中断产生条件：在数据传输过程中，当CPU检测到通信线路处于空闲状态时，且空闲状态的持续时间大于一个字节传输时间时，空闲状态标志IDLE将由硬件置1，产生空闲中断</p>
<h3 id="center-cube-ide代码-center"><center>Cube IDE代码</center></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//stm32f1xx_hal_uart.h,2710行</span></span><br><span class="line">__weak <span class="type">void</span> <span class="title function_">HAL_UARTEx_RxEventCallback</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span>	<span class="comment">//空闲中断接收回调函数</span></span><br></pre></td></tr></table></figure>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>		<span class="comment">//27行</span></span></span><br><span class="line"><span class="comment">/* USER CODE END Includes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PD */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RECV_Size 100	<span class="comment">//37行</span></span></span><br><span class="line"><span class="comment">/* USER CODE END PD */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart1, UART_Recv_IDLE, RECV_Size);	<span class="comment">//空闲中断接收函数,94行</span></span><br><span class="line"><span class="comment">//数据接收RECV_Size一半时会重新触发中断，需要关闭DMA接收中断使能</span></span><br><span class="line">HAL_NVIC_DisableIRQ(DMA1_Channel5_IRQn);	<span class="comment">//96行</span></span><br><span class="line"><span class="comment">/* USER CODE END 2 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//150行</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UARTEx_RxEventCallback</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span>	<span class="comment">//空闲中断接收触发函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(huart == &amp;huart1)	<span class="comment">//判断传进来的串口是哪个</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">&quot;LED1&quot;</span>, (<span class="type">char</span> *)UART_Recv_IDLE) == <span class="number">0</span>)	<span class="comment">//字符串比较函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);</span><br><span class="line">            <span class="built_in">memset</span>(UART_Recv_IDLE,<span class="string">&#x27;\0&#x27;</span>,Size);	<span class="comment">//替换字符函数，常用于清除指定空间</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">&quot;LED2ON&quot;</span>, (<span class="type">char</span> *)UART_Recv_IDLE))	<span class="comment">//字符串比较函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//HAL_GPIO_TogglePin(LED2_GPIO_Port, LED2_Pin);</span></span><br><span class="line">            HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">memset</span>(UART_Recv_IDLE,<span class="string">&#x27;\0&#x27;</span>,Size);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">&quot;LED2OFF&quot;</span>, (<span class="type">char</span> *)UART_Recv_IDLE))</span><br><span class="line">        &#123;</span><br><span class="line">            HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">memset</span>(UART_Recv_IDLE,<span class="string">&#x27;\0&#x27;</span>,Size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为只能接受一次串口中断，所以在串口中断触发函数需要重新调用</span></span><br><span class="line">        HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart1, UART_Recv_IDLE, RECV_Size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>32单片机</category>
      </categories>
      <tags>
        <tag>32单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>5.ADC(模拟信号转数字信号)</title>
    <url>/post/bfd038f5.html</url>
    <content><![CDATA[<h1><center>理论</center></h1>
<p>3个ADC控制器</p>
<img src="https://s2.loli.net/2024/08/19/XtaODvFlnRsrWQi.png" alt="3个ADC控制器" style="zoom: 67%;">
<p>转换：单次转换模式、 连续转换模式</p>
<p>转换时间 = 采样时间 + 12.5周期</p>
<p>    当ADCCLK(时钟) = 14MHz，采样时间为1.5周期，TcoNv(转换时间) = 1.5 + 12.5 = 14 周期 = 1us</p>
<p>采样精度：12位(2^12 = 4096)/16位</p>
<p>实际电压值 = <code>(通道采集的ADC值 * 3.3) / 4096</code></p>
<p>数据对齐：左对齐、右对齐</p>
<h1><center>代码编写</center></h1>
<p>电压采集</p>
<h2 id="center-adc-串口一配置-center"><center>ADC、串口一配置</center></h2>
<h3 id="adc-阻塞模式-配置">ADC(阻塞模式)配置</h3>
<img src="https://s2.loli.net/2024/08/19/NpfabjEqwe6Qs8c.png" alt="配置ADC" style="zoom:33%;">
<hr>
<p>多个通道时，自动扫描会自动打开使能</p>
<img src="https://s2.loli.net/2024/08/19/VMxF9S6RaDu1npj.png" alt="配置ADC" style="zoom:50%;">
<hr>
<p>修改时钟分频：</p>
<img src="https://s2.loli.net/2024/08/19/pIbkCX84RT3clqL.png" alt="修改时钟配置" style="zoom: 33%;">
<p>配置串口一打印采集到的电压值，配置方法参考：<a href="https://68565200.xyz/post/2c4c3bc3.html">链接</a></p>
<h3 id="adc-dma模式-配置">ADC(DMA模式)配置</h3>
<img src="https://s2.loli.net/2024/08/19/pCFsM1iTgOjbq56.png" alt="ADC配置" style="zoom: 50%;">
<p>配置串口一打印采集到的电压值，配置方法参考：<a href="https://68565200.xyz/post/2c4c3bc3.html">链接</a></p>
<p>修改时钟分频（和上面相同）</p>
<p>配置DMA：</p>
<img src="https://s2.loli.net/2024/08/19/T9DWyeva63oEzrG.png" alt="配置DMA" style="zoom:50%;">
<h3 id="adc-中断模式-配置">ADC(中断模式)配置</h3>
<img src="https://s2.loli.net/2024/08/19/nlB3Arm1PpLQFqo.png" alt="配置ADC" style="zoom:33%;">
<p>配置串口一打印采集到的电压值，配置方法参考：<a href="https://68565200.xyz/post/2c4c3bc3.html">链接</a></p>
<p>修改时钟分频（和上面相同）</p>
<img src="https://s2.loli.net/2024/08/19/pKQoObuImcF4V3Y.png" alt="配置ADC中断" style="zoom:50%;">
<h2 id="center-阻塞模式-center"><center>阻塞模式</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_ADCEx_Calibration_Start(&amp;hadc1);	<span class="comment">//校准，adc.c,94行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>	<span class="comment">//27行</span></span></span><br><span class="line"><span class="comment">/* USER CODE END Includes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PV */</span></span><br><span class="line"><span class="type">uint16_t</span> AD_Buf[<span class="number">4</span>];	<span class="comment">//48行</span></span><br><span class="line"><span class="type">uint8_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> Send_Buf[<span class="number">50</span>];</span><br><span class="line"><span class="comment">/* USER CODE END PV */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//while里,103行</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)	<span class="comment">//4个通道一次采集采集一个通道for4</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_ADC_Start(&amp;hadc1);	<span class="comment">//手动使能开始转换</span></span><br><span class="line">    HAL_ADC_PollForConversion(&amp;hadc1,<span class="number">10</span>);	<span class="comment">//等待转换完成，等待时间10ms，超时结束</span></span><br><span class="line">    AD_Buf[i] = HAL_ADC_GetValue(&amp;hadc1);	<span class="comment">//获取转换后的值</span></span><br><span class="line">    <span class="built_in">sprintf</span>(Send_Buf,<span class="string">&quot;Channel:%d:  V:%1.2f  Value:%d\n\r&quot;</span>, i+<span class="number">1</span>, (<span class="type">float</span>)(AD_Buf[i])*<span class="number">3.3f</span>/<span class="number">4096.0</span>, AD_Buf[i]);</span><br><span class="line">    HAL_UART_Transmit(&amp;huart1,Send_Buf, <span class="built_in">strlen</span>(Send_Buf), <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h2 id="center-dma模式-center"><center>DMA模式</center></h2>
<p>DMA会触发中断</p>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN PV */</span></span><br><span class="line"><span class="type">uint16_t</span> AD_Buf[<span class="number">4</span>];	<span class="comment">//49行</span></span><br><span class="line"><span class="comment">/* USER CODE END PV */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">HAL_ADCEx_Calibration_Start(&amp;hadc1);	<span class="comment">//校准，96行</span></span><br><span class="line"><span class="comment">//参数1：ADC句柄,参数2：目标缓冲区地址,参数3：从 ADC 外设传输到存储器的数据长度(两个通道)</span></span><br><span class="line">HAL_ADC_Start_DMA(&amp;hadc1,(<span class="type">uint32_t</span> *)&amp;AD_Buf,<span class="number">2</span>);</span><br><span class="line"><span class="comment">/* USER CODE END 2 */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;AD1= V:%1.2f  Value:%d\n\r&quot;</span>, AD_Buf[<span class="number">0</span>]*<span class="number">3.3</span>/<span class="number">4096.0</span>, AD_Buf[<span class="number">0</span>]);	<span class="comment">//105行</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;AD2= V:%1.2f  Value:%d\n\r&quot;</span>, AD_Buf[<span class="number">1</span>]*<span class="number">3.3</span>/<span class="number">4096.0</span>, AD_Buf[<span class="number">1</span>]);	<span class="comment">//106行</span></span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h2 id="center-中断模式-center"><center>中断模式</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN ADC1_Init 2 */</span></span><br><span class="line">HAL_ADCEx_Calibration_Start(&amp;hadc1);	<span class="comment">//校准，adc.c,67行</span></span><br><span class="line">HAL_ADC_Start_IT(&amp;hadc1);	<span class="comment">//开启中断模式，即开始采集</span></span><br><span class="line"><span class="comment">/* USER CODE END ADC1_Init 2 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PV */</span></span><br><span class="line"><span class="type">uint16_t</span> Send_Buf[<span class="number">20</span>];	<span class="comment">//48行</span></span><br><span class="line"><span class="type">uint16_t</span> AD_Value;</span><br><span class="line"><span class="comment">/* USER CODE END PV */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//while,102行</span></span><br><span class="line"><span class="built_in">sprintf</span>(Send_Buf,<span class="string">&quot;V:%1.2f  Value:%d\n\r&quot;</span>,(<span class="type">float</span>)(AD_Value)*<span class="number">3.3f</span>/<span class="number">4096.0</span>,AD_Value);</span><br><span class="line">HAL_UART_Transmit(&amp;huart1,Send_Buf, <span class="built_in">strlen</span>(Send_Buf), <span class="number">10</span>);</span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 4 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_ADC_ConvCpltCallback</span><span class="params">(ADC_HandleTypeDef* hadc)</span>	<span class="comment">//159行</span></span><br><span class="line">&#123;</span><br><span class="line">    AD_Value = HAL_ADC_GetValue(&amp;hadc1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 4 */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>32单片机</category>
      </categories>
      <tags>
        <tag>32单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>6.IIC通信</title>
    <url>/post/f5fba2c3.html</url>
    <content><![CDATA[<h1><center>理论</center></h1>
<p>参考51单片机IIC理论：<a href="https://68565200.xyz/post/f5fba2c3.html">链接</a></p>
<p>在起始信号后必须发送一个7位从机地址 + 1位方向位，用“0”表示主机发送数据，“1”表示主机接收数据</p>
<h1><center>代码编写</center></h1>
<h2 id="center-iic三个模式配置-center"><center>IIC三个模式配置</center></h2>
<h3 id="iic-阻塞模式-配置">IIC(阻塞模式)配置</h3>
<p>主要方式</p>
<img src="https://s2.loli.net/2024/08/19/vDus7OLdKPtS9hJ.png" alt="IIC(阻塞模式)配置" style="zoom: 50%;">
<h3 id="iic-中断模式-配置">IIC(中断模式)配置</h3>
<img src="https://s2.loli.net/2024/08/19/IPnXbZ9ARN2TEKC.png" alt="IIC(中断模式)配置" style="zoom:50%;">
<h3 id="iic-dma模式-配置">IIC(DMA模式)配置</h3>
<img src="https://s2.loli.net/2024/08/19/eoE7LNwh5fmAczH.png" alt="IIC(DMA模式)配置" style="zoom: 50%;">
<h2 id="center-阻塞模式-center"><center>阻塞模式</center></h2>
<p>mian.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span></span><br><span class="line">HAL_Init();	<span class="comment">//75行</span></span><br><span class="line">MX_I2C1_Init();</span><br><span class="line"><span class="comment">/* USER CODE BEGIN Init */</span></span><br><span class="line">OLED_Init();			<span class="comment">//初始化OLED</span></span><br><span class="line">OLED_Clear();</span><br><span class="line">OLED_ShowCHinese(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);	<span class="comment">//�?</span></span><br><span class="line">OLED_ShowCHinese(<span class="number">18</span>,<span class="number">0</span>,<span class="number">1</span>);	<span class="comment">//�?</span></span><br><span class="line">OLED_ShowCHinese(<span class="number">36</span>,<span class="number">0</span>,<span class="number">2</span>);	<span class="comment">//�?</span></span><br><span class="line">OLED_ShowCHinese(<span class="number">54</span>,<span class="number">0</span>,<span class="number">3</span>);	<span class="comment">//�?</span></span><br><span class="line">OLED_ShowCHinese(<span class="number">72</span>,<span class="number">0</span>,<span class="number">4</span>);	<span class="comment">//�?</span></span><br><span class="line">OLED_ShowCHinese(<span class="number">90</span>,<span class="number">0</span>,<span class="number">5</span>);	<span class="comment">//�?</span></span><br><span class="line">OLED_ShowCHinese(<span class="number">108</span>,<span class="number">0</span>,<span class="number">6</span>);	<span class="comment">//�?</span></span><br><span class="line">OLED_ShowCHinese(<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>);	<span class="comment">//�?</span></span><br><span class="line"><span class="comment">/* USER CODE END Init */</span></span><br></pre></td></tr></table></figure>
<p>olde.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">// IIC Write Command命令</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_IIC_Command</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> IIC_Command)</span>	<span class="comment">//10行</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//   IIC_Start();</span></span><br><span class="line">    <span class="comment">//   IIC_Write_Byte(0x78);            //Slave address,SA0=0</span></span><br><span class="line">    <span class="comment">//   IIC_Write_Byte(0x00);			//write command</span></span><br><span class="line">    <span class="comment">//   IIC_Write_Byte(IIC_Command);</span></span><br><span class="line">    <span class="comment">//   IIC_Stop();</span></span><br><span class="line">    <span class="type">uint8_t</span> IIC_Send_Cmd[]=&#123;<span class="number">0x00</span>,IIC_Command&#125;;	<span class="comment">//将两个数据放进数组</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    *参数1：指向 I2C_HandleTypeDef 结构的指针，该结构包含指定 I2C 的配置信息</span></span><br><span class="line"><span class="comment">    * 参数2：设备地址，参数3：</span></span><br><span class="line"><span class="comment">    * 参数4：要发送的数据量，参数5：超时持续时间</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    HAL_I2C_Master_Transmit(&amp;hi2c1, <span class="number">0x78</span>, IIC_Send_Cmd, <span class="number">2</span>, <span class="number">100</span>);	<span class="comment">//调用库函数阻塞发送IIC</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">// IIC Write Data数据</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_IIC_Data</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> IIC_Data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//   IIC_Start();</span></span><br><span class="line">    <span class="comment">//   IIC_Write_Byte(0x78);			//D/C#=0; R/W#=0</span></span><br><span class="line">    <span class="comment">//   IIC_Write_Byte(0x40);			//write data</span></span><br><span class="line">    <span class="comment">//   IIC_Write_Byte(IIC_Data);</span></span><br><span class="line">    <span class="comment">//   IIC_Stop();</span></span><br><span class="line">    <span class="type">uint8_t</span> IIC_Send_Data[]=&#123;<span class="number">0x40</span>,IIC_Data&#125;;	<span class="comment">//将两个数据放进数组</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 参数1：指向 I2C_HandleTypeDef 结构的指针，该结构包含指定 I2C 的配置信息</span></span><br><span class="line"><span class="comment">    * 参数2：设备地址，参数3：</span></span><br><span class="line"><span class="comment">    * 参数4：要发送的数据量，参数5：超时持续时间</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    HAL_I2C_Master_Transmit(&amp;hi2c1, <span class="number">0x78</span>, IIC_Send_Data, <span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-中断模式-center"><center>中断模式</center></h2>
<p>mian.c与阻塞相同</p>
<p>oled.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">// IIC Write Command命令</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_IIC_Command</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> IIC_Command)</span>	<span class="comment">//10行</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//   IIC_Start();</span></span><br><span class="line">    <span class="comment">//   IIC_Write_Byte(0x78);            //Slave address,SA0=0</span></span><br><span class="line">    <span class="comment">//   IIC_Write_Byte(0x00);			//write command</span></span><br><span class="line">    <span class="comment">//   IIC_Write_Byte(IIC_Command);</span></span><br><span class="line">    <span class="comment">//   IIC_Stop();</span></span><br><span class="line">    <span class="type">uint8_t</span> IIC_Send_Cmd[]=&#123;<span class="number">0x00</span>,IIC_Command&#125;;	<span class="comment">//将两个数据放进数组</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 参数1：指向 I2C_HandleTypeDef 结构的指针，该结构包含指定 I2C 的配置信息</span></span><br><span class="line"><span class="comment">    * 参数2：设备地址，参数3：</span></span><br><span class="line"><span class="comment">    * 参数4：要发送的数据量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    HAL_I2C_Master_Transmit_IT(&amp;hi2c1, <span class="number">0x78</span>, IIC_Send_Cmd, <span class="number">2</span>);</span><br><span class="line">    HAL_Delay(<span class="number">1</span>);	<span class="comment">//如果不延时发太快不显示,但OLED显示太慢</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">// IIC Write Data数据</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_IIC_Data</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> IIC_Data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//   IIC_Start();</span></span><br><span class="line">    <span class="comment">//   IIC_Write_Byte(0x78);			//D/C#=0; R/W#=0</span></span><br><span class="line">    <span class="comment">//   IIC_Write_Byte(0x40);			//write data</span></span><br><span class="line">    <span class="comment">//   IIC_Write_Byte(IIC_Data);</span></span><br><span class="line">    <span class="comment">//   IIC_Stop();</span></span><br><span class="line">    <span class="type">uint8_t</span> IIC_Send_Data[]=&#123;<span class="number">0x40</span>,IIC_Data&#125;;	<span class="comment">//将两个数据放进数组</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 参数1：指向 I2C_HandleTypeDef 结构的指针，该结构包含指定 I2C 的配置信息</span></span><br><span class="line"><span class="comment">    * 参数2：设备地址，参数3：</span></span><br><span class="line"><span class="comment">    * 参数4：要发送的数据量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    HAL_I2C_Master_Transmit_IT(&amp;hi2c1, <span class="number">0x78</span>, IIC_Send_Data, <span class="number">2</span>);</span><br><span class="line">    HAL_Delay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>32单片机</category>
      </categories>
      <tags>
        <tag>32单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>7.实时时钟(RTC)</title>
    <url>/post/e8bc8f26.html</url>
    <content><![CDATA[<h1><center>理论</center></h1>
<p>使用时钟晶振：32.768KHz(2^{15}^)</p>
<h1><center>代码编写</center></h1>
<p>OLED显示实时时间，串口打印</p>
<h2 id="center-晶体-rtc配置-center"><center>晶体、RTC配置</center></h2>
<h3 id="晶体配置">晶体配置</h3>
<img src="https://s2.loli.net/2024/08/19/dAcUyOsvEVHBJfD.png" alt="晶体配置" style="zoom:50%;">
<hr>
<img src="https://s2.loli.net/2024/08/19/piDWUw5mf8oCsVq.png" alt="配置时钟" style="zoom:50%;">
<h3 id="rtc配置">RTC配置</h3>
<img src="https://s2.loli.net/2024/08/19/gk3tWjnTpeoOFma.png" alt="RTC配置" style="zoom:50%;">
<p>串口配置参考：<a href="https://68565200.xyz/post/2c4c3bc3">链接</a></p>
<h2 id="center-cube-ide代码-center"><center>Cube IDE代码</center></h2>
<p>mian.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span>	<span class="comment">//27行</span></span></span><br><span class="line"><span class="comment">/* USER CODE END Includes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PV */</span></span><br><span class="line">RTC_TimeTypeDef RTC_Time;	<span class="comment">//48行</span></span><br><span class="line">RTC_DateTypeDef RTC_Date;</span><br><span class="line"><span class="type">uint8_t</span> RTC_Buff[<span class="number">200</span>];</span><br><span class="line"><span class="type">uint8_t</span> RTC_Buff1[<span class="number">200</span>];</span><br><span class="line"><span class="comment">/* USER CODE END PV */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//while里，108行</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 参数1：指向 RTC_HandleTypeDef 结构的指针，该结构包含RTC 的配置信息</span></span><br><span class="line"><span class="comment">* 参数2：指向时间结构的指针，参数3：RTC_FORMAT_BIN:二进制数据格式，RTC_FORMAT_BCD:十六进制数据格式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">HAL_RTC_GetTime(&amp;hrtc, &amp;RTC_Time, RTC_FORMAT_BIN);	<span class="comment">//获取时分秒</span></span><br><span class="line"><span class="built_in">sprintf</span>(RTC_Buff,<span class="string">&quot;Time:%d:%d:%d\r\n&quot;</span>, RTC_Time.Hours, RTC_Time.Minutes, RTC_Time.Seconds);</span><br><span class="line">HAL_UART_Transmit(&amp;huart1, RTC_Buff, <span class="built_in">strlen</span>(RTC_Buff), <span class="number">100</span>);</span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">HAL_RTC_GetDate(&amp;hrtc, &amp;RTC_Date, RTC_FORMAT_BIN);	<span class="comment">//获取年月日星期</span></span><br><span class="line"><span class="built_in">sprintf</span>(RTC_Buff1,<span class="string">&quot;Date:%d:%d:%d,WeekDay:%d\r\n&quot;</span>, RTC_Date.Year, RTC_Date.Month, RTC_Date.Date, RTC_Date.WeekDay);</span><br><span class="line">HAL_UART_Transmit(&amp;huart1, RTC_Buff1, <span class="built_in">strlen</span>(RTC_Buff1), <span class="number">100</span>);</span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>32单片机</category>
      </categories>
      <tags>
        <tag>32单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>0.单片机工作原理</title>
    <url>/post/c6b2a2fd.html</url>
    <content><![CDATA[<h1><center>最小系统</center></h1>
<h2 id="center-单片机芯片-center"><center>单片机芯片</center></h2>
<p>本次51单片机的芯片为：STC89C52</p>
<img src="https://s2.loli.net/2024/08/19/69Fn5YbrSxZUD2s.png" alt="芯片类型" style="zoom:50%;">
<p>Flash(闪存)程序存储器：存储程序的空间</p>
<p>SRAM：数据存储器，可用于存放程序执行的中间结果和过程数据</p>
<p>DPTR：16位的寄存器（两个8位寄存器组成），用于间接寻址，DPH存储地址的高8位，而DPL存储地址的低8位</p>
<p>EEPROM：带电可擦可编程只读存储器。是一种掉电后数据不丢失的存储芯片</p>
<p>看门狗：用于监控单片机程序运行状态的机制。它通过一个定时器电路实现，能够在程序运行失控或遇到硬件错误时对单片机进行复位操作，以确保程序能够重新开始执行</p>
<p>A/D：模拟信号到数字信号的转换（模拟/数字）</p>
<p>I/O：输入和输出，输入（Input）是指数据或信号从外部设备或用户传输到计算机系统内部的过程，而输出（Output）则是指数据或信号从计算机系统传输到外部设备或用户的过程</p>
<h2 id="center-时钟电路-center"><center>时钟电路</center></h2>
<p>产生固定频率的交流信号，晶振是产生信号的元器件（由晶振频率计算产生）</p>
<p>若晶振为12Mhz时：</p>
<p>    时钟周期：1/12Mhz，单位是秒，12Mhz要转为秒为12000000hz，1/12000000 ≈ 0.00000008s</p>
<p>    机器周期：12 × 时钟周期 = 0.00000008s × 12 = 0.000001s，转为us就是1us</p>
<h2 id="center-复位电路-center"><center>复位电路</center></h2>
<p>按键复位和上电复位</p>
<h2 id="center-电源-center"><center>电源</center></h2>
<p>供电，51单片机一般5v，smt32单片机一般3.3v</p>
<h1><center>什么是寄存器</center></h1>
<p>单片机寄存器是一组特定的存储单元，每个存储单元可以存储一个特定的数据值，对寄存器赋不同特定值，起到配置和控制各种功能的作用</p>
<h1><center>寄存器分类</center></h1>
<h2 id="center-特殊功能寄存器-center"><center>特殊功能寄存器</center></h2>
<p>8位单片机则一个寄存器有8位：P1：P1_0 ~ P1_7，单片机可能还有P0、P1等等</p>
<p>TCON、TMOD、IE…</p>
<h2 id="center-通用寄存器-center"><center>通用寄存器</center></h2>
<p>51单片机包括：R0、R1、R3、R4…（）</p>
<p>作用：存储临时数据、提高数据访问速度、传递函数参数、存储程序状态</p>
<img src="https://s2.loli.net/2024/08/19/9waWuBdXH4PsOFt.png" alt="通用寄存器" style="zoom:50%;">
<h1><center>寄存器操作方式</center></h1>
<p>位寻址：一个位对应单片机一个引脚，这个引脚连接对应的器件    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">如：P0_1连接LED灯</span><br><span class="line">sbit LED1 = P0^<span class="number">1</span>;</span><br><span class="line">LED1 = <span class="number">1</span>;	<span class="comment">//则LED灯亮</span></span><br></pre></td></tr></table></figure>
<p>如果没有位寻址，则整个寄存器赋值(十六进制0x00 ~ 0xff)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P0=<span class="number">0XFF</span>;	<span class="comment">//P0=0XA5;</span></span><br></pre></td></tr></table></figure>
<p><code>如何知道寄存器对应的位以及芯片对应引脚功能，查看数据手册</code></p>
]]></content>
      <categories>
        <category>51单片机</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>9.DAC(数字信号转模拟信号)</title>
    <url>/post/52772f76.html</url>
    <content><![CDATA[<h1><center>代码编写</center></h1>
<h2 id="center-dac配置-center"><center>DAC配置</center></h2>
<img src="https://s2.loli.net/2024/08/19/VNsyS4Aea7MQJDb.png" alt="DAC配置" style="zoom:50%;">
<h2 id="center-cube-ide代码-center"><center>Cube IDE代码</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN PV */</span></span><br><span class="line"><span class="type">uint16_t</span> DAC_Value = <span class="number">0</span>;	<span class="comment">//47行</span></span><br><span class="line"><span class="comment">/* USER CODE END PV */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//while里，99行</span></span><br><span class="line">DAC_Value++;</span><br><span class="line">DAC_Value = DAC_Value % <span class="number">4095</span>;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 参数1：指向包含 DAC_HandleTypeDef 结构的指针指定DAC的配置信息</span></span><br><span class="line"><span class="comment">* 参数2：选定的 DAC 通道</span></span><br><span class="line"><span class="comment">* 参数3：数据对齐方式，参数4：要加载到选定数据保持寄存器中的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">HAL_DAC_SetValue(&amp;hdac, DAC_CHANNEL_1, DAC_ALIGN_12B_R, DAC_Value);</span><br><span class="line">HAL_DAC_Start(&amp;hdac,DAC_CHANNEL_1);	<span class="comment">//开始DAC</span></span><br><span class="line">HAL_Delay(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>32单片机</category>
      </categories>
      <tags>
        <tag>32单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>8.看门狗(WDG)</title>
    <url>/post/f0812160.html</url>
    <content><![CDATA[<h1><center>理论</center></h1>
<p>防止系统跑飞</p>
<p>喂狗：让值为0</p>
<p>分类：独立看门狗(IWDG,0到100喂狗)、窗口看门狗(60到100喂狗)，值(60)，顶值(100)</p>
<h1><center>代码编写</center></h1>
<p>按键喂狗，在规定时间内按按键不会系统复位，超过时间系统复位LED闪烁一下</p>
<h2 id="center-独立看门狗配置-center"><center>独立看门狗配置</center></h2>
<p>超过10s，复位</p>
<img src="https://s2.loli.net/2024/08/19/CMYoHKkySmgj1BR.png" alt="看门狗配置" style="zoom:50%;">
<hr>
<p>注意时钟：</p>
<img src="https://s2.loli.net/2024/08/19/5DqnIGtPxkmBw86.png" alt="看门狗时钟" style="zoom:50%;">
<p>按键、LED灯配置参考：<a href="https://68565200.xyz/post/adb202b7">链接</a></p>
<h2 id="center-cube-ide代码-center"><center>Cube IDE代码</center></h2>
<p>mian.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line"><span class="comment">//超过时间看门狗触发复位闪灯</span></span><br><span class="line">HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, <span class="number">0</span>);	<span class="comment">//93行</span></span><br><span class="line">HAL_Delay(<span class="number">500</span>);</span><br><span class="line">HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* USER CODE END 2 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(HAL_GPIO_ReadPin(Key1_GPIO_Port, Key1_Pin) == <span class="number">0</span>)	<span class="comment">//102行,while里</span></span><br><span class="line">    HAL_IWDG_Refresh(&amp;hiwdg);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>32单片机</category>
      </categories>
      <tags>
        <tag>32单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>2.外部中断</title>
    <url>/post/81b224e1.html</url>
    <content><![CDATA[<h1><center>中断原理</center></h1>
<p>你在打游戏，水开了，水壶发出响声，你停止打游戏，去倒水，倒完水接着打游戏</p>
<p>打游戏：就相当于While(1){}里面执行的代码</p>
<p>水壶响：就是中断源</p>
<p>倒水：触发中断后要去做的事情，中断处理函数</p>
<h1><center>代码实现过程</center></h1>
<h2 id="center-中断源-center"><center>中断源</center></h2>
<p>INT0(外部中断源)、Timer0(定时器中断源)、INT1、Timer1、UART(串口中断源)、Timer2、INT2、INT3</p>
<p>中断触发方式：</p>
<p>    外部中断：下降沿或者低电平</p>
<p>    定时器中断：定时器计数溢出</p>
<p>    串口中断：串口发送或者接收完成</p>
<h2 id="center-中断处理函数-center"><center>中断处理函数</center></h2>
<p>与中断源对应的中断处理函数，直接使用对应的函数</p>
<table>
<thead>
<tr>
<th style="text-align:center">中断源</th>
<th style="text-align:center">外部中断处理函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">INT0</td>
<td style="text-align:center">Int0_Routine(void)              interrupt 0</td>
</tr>
<tr>
<td style="text-align:center">INT1</td>
<td style="text-align:center">Int1_Routine(void)              interrupt 2</td>
</tr>
<tr>
<td style="text-align:center">INT2</td>
<td style="text-align:center">Int2_Routine(void)             interrupt 6</td>
</tr>
<tr>
<td style="text-align:center">INT3</td>
<td style="text-align:center">Int3_Routine(void)              interrupt 7</td>
</tr>
</tbody>
</table>
<h2 id="center-中断寄存器-center"><center>中断寄存器</center></h2>
<p>保存中断源的中断请求信息的专用寄存器</p>
<h3 id="中断控制寄存器">中断控制寄存器</h3>
<p>外部中断只需用到：IT0、IT1、IE0、IE1</p>
<img src="https://s2.loli.net/2024/08/19/Sgl5EvhowV1GsjU.png" alt="中断寄存器功能" style="zoom:50%;">
<p><code>外部中断触发方式控制位</code>(代码)：IT0、IT1，中断触发标志位(内部)：IE0、IE1</p>
<p><code>下降沿触发</code>：IT0 = 1，<code>低电平触发</code>：IT0 = 0（IT1同理）</p>
<img src="https://s2.loli.net/2024/08/19/SaohMV5zPktwuNO.png" alt="外部中断分析" style="zoom:50%;">
<p>定时器、串口(后续讲)</p>
<h3 id="中断优先级寄存器-暂不学">中断优先级寄存器（暂不学）</h3>
<h3 id="中断允许寄存器">中断允许寄存器</h3>
<p>在外部中断只需要（置1为打开）：</p>
<ol>
<li>总中断允许控制位：EA</li>
<li>EX0：外部中断0中断允许位、EX1：外部中断1中断允许位</li>
</ol>
<img src="https://s2.loli.net/2024/08/19/L2yJSt4aEYwHNen.png" alt="允许寄存器分析" style="zoom: 67%;">
<h1><center>中断代码</center></h1>
<ol>
<li>配置外部中断0为下降沿触发（为1则低电平触发）</li>
<li>打开外部中断0中断允许位</li>
<li>打开总中断允许控制位</li>
<li>当有中断源发出，触发中断，执行中断函数，执行完之后，回到主函数继续执行</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit LED1 = P1^<span class="number">0</span>;	<span class="comment">//引脚初始化：P1^0：对应引脚的LED灯，定义LED1代表P1^0这个引脚的LED灯</span></span><br><span class="line"><span class="comment">//延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay120ms</span><span class="params">()</span>		<span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data i, j;</span><br><span class="line">    i = <span class="number">216</span>;</span><br><span class="line">    j = <span class="number">37</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(--j);</span><br><span class="line">    &#125; <span class="keyword">while</span>(--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//电路图知：中断源INT0、INT1引脚与按键P3^2、P3^3同一个，则按键为中断源，无需定义按键</span></span><br><span class="line">    IT0 = <span class="number">1</span>;	<span class="comment">//配置外部中断0为下降沿触发（为1则低电平触发）</span></span><br><span class="line">    EX0 = <span class="number">1</span>;	<span class="comment">//打开外部中断0中断允许位</span></span><br><span class="line">    EA = <span class="number">1</span>;	<span class="comment">//打开总中断允许控制位</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Delay120ms();</span><br><span class="line">        Delay120ms();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Int0_Routine(<span class="type">void</span>)        interrupt <span class="number">0</span>	<span class="comment">//中断处理函数</span></span><br><span class="line">&#123;</span><br><span class="line">    Delay120ms();</span><br><span class="line">    LED1 = ~LED1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>51单片机</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>1.I/O</title>
    <url>/post/74750b31.html</url>
    <content><![CDATA[<h1><center>I/O输出(点灯)</center></h1>
<h2 id="center-分析电路-center"><center>分析电路</center></h2>
<p>看电路图，元器件形成电压差，即可点亮LED灯</p>
<img src="https://s2.loli.net/2024/08/19/ayAi45PjTBhkR3M.png" alt="LED电路图" style="zoom:50%;">
<h2 id="center-代码编写-center"><center>代码编写</center></h2>
<p>使用不同操作进行LED控制</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span>	<span class="comment">//51单片机头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line">sbit LED1 = P1^<span class="number">0</span>;	<span class="comment">//引脚初始化：P1^0：对应引脚的LED灯，定义LED1代表P1^0这个引脚的LED灯</span></span><br><span class="line">sbit LED2 = P1^<span class="number">1</span>;</span><br><span class="line">sbit LED3 = P1^<span class="number">2</span>;</span><br><span class="line">sbit LED4 = P1^<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="comment">//延时1000ms的延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay1000ms</span><span class="params">()</span>    <span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data i, j, k;</span><br><span class="line">    _nop_();</span><br><span class="line">    i = <span class="number">8</span>;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    k = <span class="number">243</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (--k);</span><br><span class="line">        &#125; <span class="keyword">while</span> (--j);</span><br><span class="line">    &#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//方法一：对位操作，P1^0为0，接通</span></span><br><span class="line">        LED1 = <span class="number">0</span>;	<span class="comment">//电路图得知，LED为0时，接通LED灯</span></span><br><span class="line">        LED2 = <span class="number">1</span>;</span><br><span class="line">        LED3 = <span class="number">1</span>;</span><br><span class="line">        LED4 = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//方法二：P1寄存器直接赋值，两种效果相同</span></span><br><span class="line">        <span class="comment">//P1 = 0xfe;   //11111110，LED灯为P1^0~P1^3，则为最低位3位</span></span><br><span class="line">        Delay1000ms();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法一：对位操作，P1^1为0，接通</span></span><br><span class="line">        LED1 = <span class="number">1</span>;</span><br><span class="line">        LED2 = <span class="number">0</span>;</span><br><span class="line">        LED3 = <span class="number">1</span>;</span><br><span class="line">        LED4 = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//P1 = 0xfd; //11111101</span></span><br><span class="line">        Delay1000ms(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法一：对位操作，P1^2为0，接通</span></span><br><span class="line">        LED1 = <span class="number">1</span>;</span><br><span class="line">        LED2 = <span class="number">1</span>;</span><br><span class="line">        LED3 = <span class="number">0</span>;</span><br><span class="line">        LED4 = <span class="number">1</span>; </span><br><span class="line">        <span class="comment">//P1 = 0xfb; //11111011</span></span><br><span class="line">        Delay1000ms(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法一：对位操作，P1^3为0，接通</span></span><br><span class="line">        LED1 = <span class="number">1</span>;</span><br><span class="line">        LED2 = <span class="number">1</span>;</span><br><span class="line">        LED3 = <span class="number">1</span>;</span><br><span class="line">        LED4 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//P1 = 0xf7; //11110111</span></span><br><span class="line">        Delay1000ms();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对方法三分析</span></span><br><span class="line">        <span class="comment">//P1 = 0xff; //11111111</span></span><br><span class="line">        <span class="comment">//Delay1000ms();</span></span><br><span class="line">        <span class="comment">//P1 = P1&lt;&lt;1;  //11111110</span></span><br><span class="line">        <span class="comment">//Delay1000ms();</span></span><br><span class="line">        <span class="comment">//P1 = P1&lt;&lt;1; //11111100</span></span><br><span class="line">        <span class="comment">//Delay1000ms();	</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法三：位移实现对LED灯控制</span></span><br><span class="line">        P1 = <span class="number">0xff</span>; <span class="comment">//11111111，将LED灯初始为灭</span></span><br><span class="line">        Delay1000ms();</span><br><span class="line">        <span class="comment">//通过4次循环左移，实现对LED灯的控制</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            P1 = P1&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            Delay1000ms();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>I/O输入(电平检测)</center></h1>
<p>输入是检测输入的电平的高低，与输出不同</p>
<p>电路图知，按键按下为低电平，则判断按键引脚为低电平则按键按下</p>
<img src="https://s2.loli.net/2024/08/19/1XW9uwzDbUNY5yj.png" alt="按键电路图" style="zoom:50%;">
<p>注意：按键会有抖动。消除方法：按键并联一个电容 或 代码延时</p>
<h2 id="center-代码编写-center"><center>代码编写</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span>	<span class="comment">//51单片机头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line">sbit LED1 = P1^<span class="number">0</span>;</span><br><span class="line">sbit KEY1 = P3^<span class="number">2</span>;	<span class="comment">//第一个按键位引脚</span></span><br><span class="line">sbit KEY2 = P3^<span class="number">3</span>;	<span class="comment">//第二个按键位引脚</span></span><br><span class="line">sbit BEEP = P1^<span class="number">6</span>;	<span class="comment">//蜂鸣器位引脚</span></span><br><span class="line"><span class="comment">//延时函数，用来消除按键抖动</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay120ms</span><span class="params">()</span>		<span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data i, j;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">216</span>;</span><br><span class="line">    j = <span class="number">37</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (--j);</span><br><span class="line">    &#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(KEY1 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Delay120ms();</span><br><span class="line">            <span class="comment">//双重判断且加延时函数，消除按键抖动</span></span><br><span class="line">            <span class="keyword">if</span>(KEY1 == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                LED1 = ~LED1;	<span class="comment">//对LED取反，则实现LED开关</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(KEY2 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Delay120ms();</span><br><span class="line">            <span class="keyword">if</span>(KEY2 == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                BEEP = ~BEEP;	<span class="comment">//对蜂鸣器取反，则实现蜂鸣器开关</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>I/O内部电路分析</center></h1>
<h2 id="center-51单片机-center"><center>51单片机</center></h2>
<p>准双向口/弱上拉：可用作输出和输入功能而不需要配置口线输出状态</p>
<p>开漏输出(P0)：当P0管脚做I/O时，需要外加<code>上拉电阻</code>，若作为地址/数据总线时，不需要加上拉电阻</p>
<h2 id="center-stm32单片机-center"><center>STM32单片机</center></h2>
<h3 id="输入">输入</h3>
<p>浮空输入：从IO引脚入，VDD(上拉电阻)打开和Vss(下拉电阻)打开，经过输入数据寄存器，读出</p>
<p>上拉输入：从IO引脚入，VDD(上拉电阻)闭合和Vss(下拉电阻)打开，经过输入数据寄存器，读出</p>
<p>下拉输入：从IO引脚入，VDD(上拉电阻)打开和Vss(下拉电阻)闭合，经过输入数据寄存器，读出</p>
<p>模拟输入：从IO引脚入，VDD(上拉电阻)打开和Vss(下拉电阻)打开，经过模拟输入</p>
<img src="https://s2.loli.net/2024/08/19/xoDRgQuklde2i4s.png" alt="分析图" style="zoom:50%;">
<h3 id="输出">输出</h3>
<p>开漏输出：在开漏输出模式下，P-MOS(上拉)管不工作，只有N-MOS(下拉)管起作用。若输出数据寄存器的值为0，则N-MOS导通，IO口输出低电平；若输出数据寄存器的值为1，则N-MOS截止；由于P-MOS不工作，此时IO口既不是高电平，也不是低电平，这种状态被称为高阻态</p>
<p>推挽输出：在推挽输出模式下，若输出数据寄存器的值为0，则N-MOS(下拉)导通，P-MOS(上拉)截止，IO口输出低电平；若输出数据寄存器的值为1，则N-MOS截止，P-MOS导通，IO口输出高电平</p>
<p>复用：使别引脚也具备原本引脚功能</p>
<p>推挽复用输出、开漏复用输出</p>
]]></content>
      <categories>
        <category>51单片机</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>3.定时器/计数器</title>
    <url>/post/2e5216dd.html</url>
    <content><![CDATA[<h1><center>原理</center></h1>
<ol>
<li>时钟源：定时器是内部时钟源（晶振），计数器是外部</li>
<li>计时长度：对应TH  TL计数器初值寄存器(高八位,低八位)</li>
<li>对应的中断触发函数</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">中断源</th>
<th style="text-align:center">定时中断处理函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Timer0</td>
<td style="text-align:center">Timer0_Routine(void)      interrupt 1</td>
</tr>
<tr>
<td style="text-align:center">Timer1</td>
<td style="text-align:center">Timer1_Routine(void)       interrupt 3</td>
</tr>
<tr>
<td style="text-align:center">Timer2</td>
<td style="text-align:center">Timer2_Routine(void)      interrupt 5</td>
</tr>
</tbody>
</table>
<h1><center>相关寄存器</center></h1>
<h2 id="center-tcon：定时器控制寄存器-center"><center>TCON：定时器控制寄存器</center></h2>
<p>只需用到：TF0、TF1、TR0、TR1</p>
<img src="https://s2.loli.net/2024/08/19/StZGcsq9QeMOTn6.png" alt="定时器/计数器" style="zoom:50%;">
<p>定时器/计数器运行控制位(代码)：TR0、TR1</p>
<p>中断触发标志位(内部)：TF0、TF1</p>
<img src="https://s2.loli.net/2024/08/19/WQiH3LXkTDegpF1.png" alt="定时器中断分析" style="zoom:50%;">
<h2 id="center-tmod：定时器模式寄存器-center"><center>TMOD：定时器模式寄存器</center></h2>
<p>两个定时器/计数器（任选一个即可）：<code>T0(TL0\TH0)</code>、<code>T1(TL1\TH1)</code></p>
<p>工作模式：</p>
<ul>
<li>模式0（13位定时器/计数器）</li>
<li>模式1（16位定时器/计数器）</li>
<li>模式2（8位自动重装初值）</li>
<li>模式3（两个8位定时器/计数器）</li>
</ul>
<p>0.7、0.3地址用于控制定时器的启动是否受外部中断引脚（INT1或INT0）的影响。当GATE位设置为1时，定时器的启动不仅取决于定时器的使能位（例如TR1或TR0），还取决于相应的中断引脚电平</p>
<p>C/T：置0为定时器</p>
<p>模式（M1、M0）这里我们选01（16位定时器，不自动重装初值）如果不会自动重装载寄存器（不会自动赋初值）则要触发中断处理函数时重新<code>手动赋初值</code></p>
<img src="https://s2.loli.net/2024/08/19/Q2PTWE5RxOHmUB7.png" alt="工作模式" style="zoom: 67%;">
<h2 id="center-定时器计算初值-center"><center>定时器计算初值</center></h2>
<p>需要定时的时间带入公式，求出x</p>
<img src="https://s2.loli.net/2024/08/19/SnTYf4wKilv8sRd.png" alt="初值计算方式" style="zoom:50%;">
<h2 id="center-中断允许寄存器-center"><center>中断允许寄存器</center></h2>
<p>    总中断允许控制位：EA</p>
<p>    ET0：定时/计数器T0的溢出中断允许位，ET1：定时/计数器T1的溢出中断允许位，ET2：定时/计数器T2的溢出中断允许位</p>
<p>    需要外部、定时器、串口那个则赋值那个为1</p>
<img src="https://s2.loli.net/2024/08/19/L2yJSt4aEYwHNen.png" alt="允许寄存器分析" style="zoom:50%;">
<h1><center>代码编写</center></h1>
<p>每1s翻转LED灯状态</p>
<blockquote>
<p>[!NOTE]</p>
<p>设置哪个定时器控制(TR0、TR1)</p>
<p>多久溢出触发定时中断函数(初始值)</p>
<p>设置定时模式(TMOD)</p>
<p>开启定时器中断允许控制位及总中断允许控制位</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit LED1 = P1^<span class="number">0</span>;		<span class="comment">//定义LED灯</span></span><br><span class="line"><span class="type">int</span> count;			<span class="comment">//由于51单片机没办法定时1s，只能通过计数达到效果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    TMOD = <span class="number">0x01</span>;	<span class="comment">//配置定时器工作模式：使用定时器0，使用16位定时器模式(不自动重装初值)</span></span><br><span class="line">    <span class="comment">//定时10ms，给寄存器赋初值</span></span><br><span class="line">    TL0 = <span class="number">0x00</span>;</span><br><span class="line">    TH0 = <span class="number">0xDC</span>;</span><br><span class="line">    TR0 = <span class="number">1</span>;	<span class="comment">//打开定时器T0运行控制位</span></span><br><span class="line">    ET0 = <span class="number">1</span>;	<span class="comment">//打开定时器0中断允许位</span></span><br><span class="line">    EA = <span class="number">1</span>;		<span class="comment">//打开总中断允许控制位</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//大于99时则取反LED状态</span></span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">99</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            LED1 = ~LED1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定时中断处理函数</span></span><br><span class="line">Timer0_Routine(<span class="type">void</span>)      interrupt <span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//触发中断函数，需要重新给定时器赋初值</span></span><br><span class="line">    TL0 = <span class="number">0x00</span>;</span><br><span class="line">    TH0 = <span class="number">0xDC</span>;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>51单片机</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>4.串口</title>
    <url>/post/f736596e.html</url>
    <content><![CDATA[<h1><center>串口的介绍</center></h1>
<p>UART（通用异步收发器）是一种双向、串行、异步的通信总线，仅用一根数据接收线（RX）和一根数据发送线（TX）就能实现全双工通信</p>
<p>USART：通用同步/异步串行接收/发送器</p>
<p>R：Receiver(接收)，T：Transmit(发送)</p>
<img src="https://s2.loli.net/2024/08/19/qElbYZe57LsmMCF.png" alt="数据组成" style="zoom: 33%;">
<p>UART 在发送或接收过程中的一帧数据由4部分组成，起始位、数据位、奇偶校验位和停止位</p>
<p>如图所示。其中，起始位标志着一帧数据的开始，停止位标志着一帧数据的结束，数据位是一帧数据中的有效数据，校验位分为奇校验和偶校验，用于检验数据在传输过程中是否出错。（奇校验时，发送方应使数据位中1的个数与校验位中1的个数之和为奇数；接收方在接收数据时， 对1的个数进行检查，若不为奇数，则说明数据在传输过程中出了差错。同样，偶校验则检查1的个数是否为偶数）</p>
<p>UART通信过程中的数据格式及传输速率是可设置的，为了正确的通信，收发双方应约定并遵循同样的设置。数据位可选择为5、6、7、8位，其中8位数据位是最常用的，在实际应用中一般都选择8位数据位；校验位可选择奇校验、偶校验或者无校验位；停止位可选择1位（默认）， 1.5或2位</p>
<p>串口通信的速率用波特率表示，它表示每秒传输二进制数据的位数，单位是bps（位 /秒），常用的波特率有9600、19200、38400、57600以及115200等</p>
<p>如波特率9600则代表每秒传输9600bit数据，以串口发送1个字节10bit算（起始位1bit+数据8bit+停止位1bit+NO校验位），则传输1个字节需要的时间是1*10/9600秒</p>
<h2 id="center-串口相关的硬件信号-center"><center>串口相关的硬件信号</center></h2>
<p>可参考：<a href="https://blog.csdn.net/CSDN_PBB/article/details/131012186?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172059516616800227423682%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=172059516616800227423682&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-131012186-null-null.142%5Ev100%5Epc_search_result_base3&amp;utm_term=ttl%20232%20485&amp;spm=1018.2226.3001.4187">链接</a></p>
<h3 id="center-ttl-center"><center>TTL</center></h3>
<p>一般单片机产生的都是<code>TTL电平</code>。无论是51、32、还是各种跑Linux的ARM芯片，TTL满足绝大多数调试需求</p>
<p>TTL串口采用的是单一的信号线 (TX线和RX线) 进行数据传输，其中TX线用于单片机发送数据，RX线用于单片机接收数据。数据传输速率通常可以达到几-kbps至上百kbps的速率，<font color="red">传输距离较短，一般不超过数十米</font></p>
<p>TTL转USB(<a href="https://baike.baidu.com/item/%E5%B7%AE%E5%88%86%E4%BF%A1%E5%8F%B7/8536623?fr=ge_ala">差分信号</a>)</p>
<img src="https://s2.loli.net/2024/08/19/aTRMDsf2y4BIqu9.png" alt="例图" style="zoom: 33%;">
<img src="https://s2.loli.net/2024/08/19/UMdHAmxIRCzeVNE.png" alt="传输方向" style="zoom:50%;">
<p>TTL的逻辑电平通常是0V和5V，其中0V表示逻辑“0”，5V表示逻辑“1”</p>
<h3 id="center-rs-232-center"><center>RS-232</center></h3>
<p>RS-232转USB</p>
<p>规定逻辑“1”的电平为-5V~-15 V，逻辑“0”的电平为+5 V～+15 V</p>
<p>由于RS -232采用串行传送方式，并且将TTL电平(某芯片)转换为RS-232C电平，其传送距离一般可达30 m。若采用光电隔离20 mA的电流环进行传送，其传送距离可以达到1000 m</p>
<img src="https://s2.loli.net/2024/08/19/DGXhmkTgYatRHc6.png" alt="公母头接法" style="zoom:50%;">
<h3 id="center-rs-485-center"><center>RS-485</center></h3>
<p>传输速度可以达到10Mb/s以上，传输距离可以达到3000米左右</p>
<p>传输方式为：<code>差分方式</code></p>
<h1><center>分类方式</center></h1>
<h2 id="center-串口并口-center"><center>串口并口</center></h2>
<p>详细教程：<a href="https://blog.csdn.net/Gao068465/article/details/124242629?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172059483916800188555556%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=172059483916800188555556&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-124242629-null-null.142%5Ev100%5Epc_search_result_base3&amp;utm_term=%E4%B8%B2%E8%A1%8C%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB&amp;spm=1018.2226.3001.4187">地址</a></p>
<img src="https://s2.loli.net/2024/08/19/2oMTYqLn7iHPg1F.png" alt="图解" style="zoom: 33%;">
<h2 id="center-同步异步-center"><center>同步异步</center></h2>
<p>异步：通信双方各自约定通信速率</p>
<p>UART：TX、RX（波特率9600,115200）</p>
<p>同步：通信双方靠一根时钟线来约定通信速率</p>
<p>    IIC：SDA、SCL</p>
<p>    SPI：MOSI、MISO、SCK、CS</p>
<h2 id="center-方向与时间-center"><center>方向与时间</center></h2>
<p>单工：指消息只能单方向传输的工作方式</p>
<p>半双工(IIC)：指信息即可从A到B，也可以从B到A，任一时刻只能有一个方向上的传输存在</p>
<p>全双工(UART、SPI)：指在任意时刻线路上存在A到B和B到A的双向信号传输</p>
<h1><center>相关寄存器</center></h1>
<h2 id="center-scon-center"><center>SCON</center></h2>
<p>工作模式：01（8位UART波特率可变）其他不用为0</p>
<img src="https://s2.loli.net/2024/08/19/6ZdufOxKJhg9wqb.png" alt="SCON详细1" style="zoom:50%;">
<p>REN = 1，接收信息，一开始发送中断标志位、接收中断标志位置0</p>
<p>TB8：发送校验位，RB8：接收校验位，TI：发送中断，RI：接收中断</p>
<img src="https://s2.loli.net/2024/08/19/iMF1NbGchkYwmIu.png" alt="SCON详细2" style="zoom:50%;">
<p>则SCON = 0x50</p>
<img src="https://s2.loli.net/2024/08/19/LsaGlxk6XOnwFZz.png" alt="SCON详细3" style="zoom: 67%;">
<h2 id="center-pcon-center"><center>PCON</center></h2>
<img src="https://s2.loli.net/2024/08/19/L9ITO8wySXRgfGW.png" alt="PCON解释图" style="zoom: 67%;">
<h2 id="center-tmod-center"><center>TMOD</center></h2>
<p>模式(M1、M0)：这里选10（8位自动重装载定时器），其他在定时器有讲解</p>
<img src="https://s2.loli.net/2024/08/19/Q2PTWE5RxOHmUB7.png" alt="TMOD解释图" style="zoom: 67%;">
<h2 id="center-sbuf-center"><center>SBUF</center></h2>
<p>接收和发送的数据都存在SBUF</p>
<img src="https://s2.loli.net/2024/08/19/HuO36TJWNRbqMwf.png" alt="SBUF图解" style="zoom: 67%;">
<h2 id="center-ie-center"><center>IE</center></h2>
<p>中断允许寄存器</p>
<img src="https://s2.loli.net/2024/08/19/L2yJSt4aEYwHNen.png" alt="允许寄存器分析" style="zoom: 67%;">
<h1><center>中断处理函数</center></h1>
<table>
<thead>
<tr>
<th style="text-align:center">中断源</th>
<th style="text-align:center">串口中断处理函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">UART</td>
<td style="text-align:center">UART_Routine(void)         interrupt 4</td>
</tr>
</tbody>
</table>
<h1><center>代码编写</center></h1>
<p>为何需要使用定时器观看链接讲解(9.34)：<a href="https://www.bilibili.com/video/BV1Bg4y1M7vi/?spm_id_from=333.788&amp;vd_source=1c838941386ee32c4501615c317f75e0">波特率发生器</a></p>
<h2 id="main-c">main.c</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span>	<span class="comment">//声明头文件，可在此文件使用头文件声明的函数、变量等</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Uart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">uchar recv;	<span class="comment">//全局变量用于接收数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    UART_Init();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Delay1000ms();</span><br><span class="line">        UART_send_str(<span class="string">&quot;i am xingzai&quot;</span>);	<span class="comment">//发送字符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//串口中断处理函数</span></span><br><span class="line">UART_Routine(<span class="type">void</span>)         interrupt <span class="number">4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == RI)</span><br><span class="line">    &#123;</span><br><span class="line">        RI = <span class="number">0</span>;	<span class="comment">//接收中断请求标志位软件复位</span></span><br><span class="line">        recv = SBUF;	<span class="comment">//接收数据赋值给变量</span></span><br><span class="line">        <span class="keyword">switch</span>(recv)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x1</span>: LED1 = <span class="number">0</span>;<span class="keyword">break</span>;   </span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x2</span>: LED2 = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x3</span>: LED3 = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x4</span>: LED4 = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x5</span>: P1  |= <span class="number">0x0F</span>;<span class="keyword">break</span>;	<span class="comment">//这里采用或等于，目的不让P1.6蜂鸣器为0，保留高位原数据</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x6</span>: BEEP = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x7</span>: BEEP = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8</span>: JDQ1 = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x9</span>: JDQ1 = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="delay-c">delay.c</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span>	<span class="comment">//声明对应头文件，用于声明里面此文件函数、变量等</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="comment">//延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay1000ms</span><span class="params">()</span>		<span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">    uchar data i, j, k;</span><br><span class="line"></span><br><span class="line">    _nop_();</span><br><span class="line">    i = <span class="number">8</span>;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    k = <span class="number">243</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (--k);</span><br><span class="line">        &#125; <span class="keyword">while</span> (--j);</span><br><span class="line">    &#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="delay-h">delay.h</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件固定格式，防止头文件重复包含</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DELAY_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DELAY_H__</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay1000ms</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="uart-c">Uart.c</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Uart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//配置相关寄存器</span></span><br><span class="line">    SCON = <span class="number">0x50</span>;	<span class="comment">//配置串口寄存器</span></span><br><span class="line">    PCON=<span class="number">0x00</span>;</span><br><span class="line">    TMOD |= <span class="number">0x20</span>;	<span class="comment">//配置时间寄存器定时器1</span></span><br><span class="line">    <span class="comment">//定时器初值</span></span><br><span class="line">    TH1 = <span class="number">0xFD</span>;</span><br><span class="line">    TL1 = <span class="number">0xFD</span>;</span><br><span class="line">    EA = <span class="number">1</span>;	<span class="comment">//打开中断总允许位</span></span><br><span class="line">    ES = <span class="number">1</span>;	<span class="comment">//打开串口中断允许位</span></span><br><span class="line">    TR1 = <span class="number">1</span>;	<span class="comment">//打开定时器1运行控制位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符发送函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_send_char</span><span class="params">(uchar send_char)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//将字符赋值给数据缓存寄存器</span></span><br><span class="line">    SBUF = send_char;</span><br><span class="line">    <span class="keyword">while</span>(!TI);	<span class="comment">//发送时为0，发送完触发发送中断时为1，为1时则数据发送完</span></span><br><span class="line">    TI = <span class="number">0</span>;	<span class="comment">//发送中断请求标志位软件复位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收传过来的字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_send_str</span><span class="params">(uchar *send_str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断字符到最后&#x27;\0&#x27;则停止发送</span></span><br><span class="line">    <span class="keyword">while</span>(*send_str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        UART_send_char(*send_str++);	<span class="comment">//将字符逐个传给这个函数发送</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="uart-h">Uart.h</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __UART_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __UART_H__</span></span><br><span class="line"><span class="comment">//因为main.c中已经声明了Uart.h，在Uart.h声明了main.h则main.c中也可以使用mian.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span>		</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_send_char</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> send_char)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_send_str</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *send_str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="main-h">main.h</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MAIN_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MAIN_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> uchar;	<span class="comment">//给unsigned char取别名uchar</span></span><br><span class="line"><span class="comment">//定义对应元器件引脚</span></span><br><span class="line">sbit LED1 = P1^<span class="number">0</span>;</span><br><span class="line">sbit LED2 = P1^<span class="number">1</span>;</span><br><span class="line">sbit LED3 = P1^<span class="number">2</span>;</span><br><span class="line">sbit LED4 = P1^<span class="number">3</span>;</span><br><span class="line">sbit BEEP = P1^<span class="number">6</span>;</span><br><span class="line">sbit JDQ1 = P1^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="回环">回环</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> recv;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> send_buf[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">sbit LED1 = P1^<span class="number">0</span>;</span><br><span class="line">sbit LED2 = P1^<span class="number">1</span>;</span><br><span class="line">sbit LED3 = P1^<span class="number">2</span>;</span><br><span class="line">sbit LED4 = P1^<span class="number">3</span>;</span><br><span class="line">sbit BEEP = P1^<span class="number">6</span>;</span><br><span class="line">sbit JDQ1 = P1^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay1000ms</span><span class="params">()</span>    <span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data i, j, k;</span><br><span class="line"></span><br><span class="line">    _nop_();</span><br><span class="line">    i = <span class="number">8</span>;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    k = <span class="number">243</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (--k);</span><br><span class="line">        &#125; <span class="keyword">while</span> (--j);</span><br><span class="line">    &#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_send_byte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> send_byte)</span></span><br><span class="line">&#123;</span><br><span class="line">    SBUF = send_byte;</span><br><span class="line">    <span class="keyword">while</span>(!TI);</span><br><span class="line">    TI=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_send_str</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *send_str)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="keyword">while</span>(*send_str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        UART_send_byte(*send_str++);	</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SCON = <span class="number">0x50</span>;</span><br><span class="line">    PCON=<span class="number">0x00</span>;</span><br><span class="line">    TMOD |= <span class="number">0x20</span>;</span><br><span class="line">    TH1 = <span class="number">0xFD</span>;</span><br><span class="line">    TL1 = <span class="number">0xFD</span>;</span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    ES = <span class="number">1</span>;</span><br><span class="line">    TR1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Delay1000ms();</span><br><span class="line">        <span class="comment">//		UART_send_str(&quot;i am wfeng!\r\n&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UART_Routine(<span class="type">void</span>)    interrupt <span class="number">4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == RI) <span class="comment">//if(RI)</span></span><br><span class="line">    &#123;</span><br><span class="line">        RI=<span class="number">0</span>;</span><br><span class="line">        recv = SBUF;</span><br><span class="line">        SBUF = recv;</span><br><span class="line">        <span class="keyword">while</span>(!TI);</span><br><span class="line">        TI=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>继电器</center></h1>
<p><img src="https://s2.loli.net/2024/08/19/8GUOuEIVxTXvftR.gif" alt="继电器动态原理图"></p>
<p>继电器模块的基本工作原理：</p>
<p>电磁线圈： 继电器内部包含一个电磁线圈，通常由绕制在绝缘芯片上的细导线组成。当通过线圈通电时，产生电磁场。</p>
<p>磁性吸引： 电磁场会使继电器中的铁芯（或磁性材料）受到磁性吸引，导致铁芯在电磁力的作用下移动。</p>
<p>触点操作： 铁芯的移动会导致机械部分的运动，最终使触点（开关）发生动作。继电器通常有常开（Normally Open，NO）和常闭（Normally Closed，NC）两组触点。</p>
<p>常开触点： 在继电器未通电时处于闭合状态，当电磁线圈通电时，触点打开。</p>
<p>常闭触点： 在继电器未通电时处于打开状态，当电磁线圈通电时，触点闭合。</p>
<p>电气隔离： 继电器的主要作用之一是提供电气隔离。通过电磁原理，可以在控制信号与被控制电路之间提供隔离，从而使得不同电路之间的电流不会相互影响。继电器模块常用于控制高电流或高电压的电路。</p>
<h1><center>ESP8266</center></h1>
<p>AP模式：无线接入点，它是一个无线网络的中心节点，可以看成是一个服务器。它作为一个网络的中心节点，提供无线接入服务，其他的无线设备允许接入该节点，所有接入该节点设备的无线信号数据都要通过它才能进行交换和互相访问。一般的无线路由器、网关、热点就是工作在AP模式下，AP节点和AP节点之间允许相互连接。</p>
<p>STA模式：无线网络中的一个终端站点设备，可以看成是一个客户端，一般来说，处在STA模式下的设备本身不接受无线的接入，该设备连接到AP节点进行网络访问，STA模式下的设备之间的通信可以通过AP进行转发实现</p>
<h2 id="center-at指令-center"><center>AT指令</center></h2>
<p>可在官网寻找对应的指令集：<a href="https://docs.ai-thinker.com/esp8266/docs">安信可科技</a></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">配置 WiFi 模式：AT+CWMODE=3	//模式3：STA+AP</span><br><span class="line">连接路由器：AT+CWJAP=&quot;wfeng&quot;,&quot;wf05430543&quot;</span><br><span class="line">查询 ESP8266的IP 地址： AT+CIFSR</span><br><span class="line">//PC端使用网络调试工具，建⽴一个 TCP 服务器器</span><br><span class="line">ESP8266 作为Client 连接到服务器：AT+CIPSTART=&quot;TCP&quot;,&quot;192.168.31.118&quot;,8090</span><br><span class="line">发送数据：AT+CIPSEND=4</span><br></pre></td></tr></table></figure>
<h2 id="center-代码编写-center"><center>代码编写</center></h2>
<p>电脑当服务端，单片机当客户端，电脑发指令控制单片机(接收)，单片机发送字符给电脑</p>
<h3 id="main-c">main.c</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;define.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;send.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    define_bl();</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        send_str(<span class="string">&quot;AT+CWMODE=3\r\n&quot;</span>);	<span class="comment">//发送AT指令配置ESP8266模块，选择模式3</span></span><br><span class="line">        Delay1000ms();</span><br><span class="line">    &#125;<span class="keyword">while</span>(Esp_Ok_flag);</span><br><span class="line"></span><br><span class="line">    Esp_Ok_flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        send_str(<span class="string">&quot;AT+CWJAP=\&quot;qiji\&quot;,\&quot;12345678\&quot;\r\n&quot;</span>);	<span class="comment">//连接WiFi</span></span><br><span class="line">        Delay1000ms();</span><br><span class="line">    &#125;<span class="keyword">while</span>(Esp_Ok_flag);</span><br><span class="line"></span><br><span class="line">    Esp_Ok_flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        send_str(<span class="string">&quot;AT+CIPSTART=\&quot;TCP\&quot;,\&quot;192.168.43.10\&quot;,8085\r\n&quot;</span>);	<span class="comment">//连接服务器</span></span><br><span class="line">        Delay1000ms();</span><br><span class="line">    &#125;<span class="keyword">while</span>(Esp_Ok_flag);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        send_str(<span class="string">&quot;AT+CIPSEND=4\r\n&quot;</span>);	<span class="comment">//发送4个字节数据</span></span><br><span class="line">        Delay1000ms();</span><br><span class="line">    &#125;<span class="keyword">while</span>(Esp_Ok_flag);</span><br><span class="line"></span><br><span class="line">    send_str(<span class="string">&quot;xinz\r\n&quot;</span>);	<span class="comment">//发送的数据</span></span><br><span class="line">    Esp_Ok_flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Delay1000ms();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="define-c">define.c</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;define.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> Esp_Ok_flag = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">define_bl</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    SCON = <span class="number">0x50</span>;</span><br><span class="line">    PCON = <span class="number">0x00</span>;</span><br><span class="line">    TMOD = <span class="number">0x20</span>;</span><br><span class="line">    TH1 = <span class="number">0xFD</span>;</span><br><span class="line">    TL1 = <span class="number">0xFD</span>;</span><br><span class="line">    TR1 = <span class="number">1</span>;</span><br><span class="line">    ES = <span class="number">1</span>;</span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="define-h">define.h</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DELAY_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DELAY_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">define_bl</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> uchar;	<span class="comment">//取别名</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> Esp_Ok_flag;	<span class="comment">//定义一个全局变量方便不同.c文件使用</span></span><br><span class="line"><span class="comment">//定义对应元器件引脚</span></span><br><span class="line">sbit LED1 = P1^<span class="number">0</span>;</span><br><span class="line">sbit LED2 = P1^<span class="number">1</span>;</span><br><span class="line">sbit LED3 = P1^<span class="number">2</span>;</span><br><span class="line">sbit LED4 = P1^<span class="number">3</span>;</span><br><span class="line">sbit BEEP = P1^<span class="number">6</span>;</span><br><span class="line">sbit JDQ1 = P1^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="send-c">send.c</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;send.h&gt;</span></span></span><br><span class="line"><span class="comment">//接收需要发送的字符</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_str</span><span class="params">(uchar *send_s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(*send_s != <span class="string">&#x27;\0&#x27;</span>)	<span class="comment">//当字符串!=&#x27;\0&#x27;时把字符一个个传给send_char函数发送</span></span><br><span class="line">    &#123;</span><br><span class="line">        send_char(*send_s++);	<span class="comment">//将每个字符逐一发送</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_char</span><span class="params">(uchar send_c)</span></span><br><span class="line">&#123;</span><br><span class="line">    SBUF = send_c;	<span class="comment">//将单个字符赋值给SBUF则发送</span></span><br><span class="line">    <span class="keyword">while</span>(!TI);	<span class="comment">//当TI为0，则发送未完成，当发送完成为1，取反为0跳出循环</span></span><br><span class="line">    TI = <span class="number">0</span>;	<span class="comment">//复位，发送请求中断标志位为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="send-h">send.h</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SEND_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SEND_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;define.h&quot;</span></span></span><br><span class="line"><span class="comment">//声明两个发送函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_str</span><span class="params">(uchar *send_s)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">send_char</span><span class="params">(uchar send_c)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="receive-c">receive.c</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;define.h&gt;</span></span></span><br><span class="line">uchar Recv_Buf[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> recv;</span><br><span class="line"><span class="comment">//串口中断函数</span></span><br><span class="line">UART_Routine(<span class="type">void</span>) interrupt <span class="number">4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;  <span class="comment">//static：全局使用不重新</span></span><br><span class="line">    <span class="type">char</span> Recv;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == RI) <span class="comment">//if(RI)</span></span><br><span class="line">    &#123;</span><br><span class="line">        RI=<span class="number">0</span>;</span><br><span class="line">        Recv=SBUF;</span><br><span class="line">        <span class="keyword">if</span>(Recv == <span class="string">&#x27;O&#x27;</span>|| Recv == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            Recv_Buf[i] = Recv;</span><br><span class="line">            Recv_Buf[i+<span class="number">1</span>] = Recv;			</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">            Recv_Buf[i] = Recv;		</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Recv_Buf[<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">1</span>] == <span class="string">&#x27;K&#x27;</span>)	<span class="comment">//收到回复OK则说明指令执行成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            Esp_Ok_flag = <span class="number">0</span>;	<span class="comment">//让标志为0跳出循环，执行下一个指令</span></span><br><span class="line">            i = <span class="number">0</span>;	<span class="comment">//重置数组指向位数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//接收到服务器，接收到的指令会以　+IPD　开头，以及第七个是接收的指令开始，判断接收到哪个指令执行下方的操作</span></span><br><span class="line">        <span class="keyword">if</span>(Recv_Buf[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">1</span>] == <span class="string">&#x27;I&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">2</span>] == <span class="string">&#x27;P&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">3</span>] == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Recv_Buf[<span class="number">7</span>] == <span class="string">&#x27;L&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">8</span>] == <span class="string">&#x27;E&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">9</span>] == <span class="string">&#x27;D&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">10</span>] == <span class="string">&#x27;1&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">11</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                LED1 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(Recv_Buf[<span class="number">7</span>] == <span class="string">&#x27;L&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">8</span>] == <span class="string">&#x27;E&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">9</span>] == <span class="string">&#x27;D&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">10</span>] == <span class="string">&#x27;1&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">11</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                LED1 = <span class="number">0</span>;			</span><br><span class="line">            <span class="keyword">if</span>(Recv_Buf[<span class="number">7</span>] == <span class="string">&#x27;L&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">8</span>] == <span class="string">&#x27;E&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">9</span>] == <span class="string">&#x27;D&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">10</span>] == <span class="string">&#x27;2&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">11</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                LED2 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(Recv_Buf[<span class="number">7</span>] == <span class="string">&#x27;L&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">8</span>] == <span class="string">&#x27;E&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">9</span>] == <span class="string">&#x27;D&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">10</span>] == <span class="string">&#x27;2&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">11</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                LED2 = <span class="number">0</span>;				</span><br><span class="line">            <span class="keyword">if</span>(Recv_Buf[<span class="number">7</span>] == <span class="string">&#x27;L&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">8</span>] == <span class="string">&#x27;E&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">9</span>] == <span class="string">&#x27;D&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">10</span>] == <span class="string">&#x27;3&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">11</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                LED3 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(Recv_Buf[<span class="number">7</span>] == <span class="string">&#x27;L&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">8</span>] == <span class="string">&#x27;E&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">9</span>] == <span class="string">&#x27;D&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">10</span>] == <span class="string">&#x27;3&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">11</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                LED3 = <span class="number">0</span>;				</span><br><span class="line">            <span class="keyword">if</span>(Recv_Buf[<span class="number">7</span>] == <span class="string">&#x27;L&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">8</span>] == <span class="string">&#x27;E&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">9</span>] == <span class="string">&#x27;D&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">10</span>] == <span class="string">&#x27;4&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">11</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                LED4 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(Recv_Buf[<span class="number">7</span>] == <span class="string">&#x27;L&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">8</span>] == <span class="string">&#x27;E&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">9</span>] == <span class="string">&#x27;D&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">10</span>] == <span class="string">&#x27;4&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">11</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                LED4 = <span class="number">0</span>;				</span><br><span class="line">            <span class="keyword">if</span>(Recv_Buf[<span class="number">7</span>] == <span class="string">&#x27;B&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">8</span>] == <span class="string">&#x27;E&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">9</span>] == <span class="string">&#x27;E&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">10</span>] == <span class="string">&#x27;P&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">11</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                BEEP = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(Recv_Buf[<span class="number">7</span>] == <span class="string">&#x27;B&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">8</span>] == <span class="string">&#x27;E&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">9</span>] == <span class="string">&#x27;E&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">10</span>] == <span class="string">&#x27;P&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">11</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                BEEP = <span class="number">0</span>;			</span><br><span class="line">            <span class="keyword">if</span>(Recv_Buf[<span class="number">7</span>] == <span class="string">&#x27;J&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">8</span>] == <span class="string">&#x27;D&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">9</span>] == <span class="string">&#x27;Q&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">10</span>] == <span class="string">&#x27;1&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">11</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                JDQ1 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(Recv_Buf[<span class="number">7</span>] == <span class="string">&#x27;J&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">8</span>] == <span class="string">&#x27;D&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">9</span>] == <span class="string">&#x27;Q&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">10</span>] == <span class="string">&#x27;1&#x27;</span>&amp;&amp;Recv_Buf[<span class="number">11</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                JDQ1 = <span class="number">0</span>;								</span><br><span class="line">        &#125;	</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">18</span>)</span><br><span class="line">            i=<span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="delay-c">delay.c</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="comment">//延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay1000ms</span><span class="params">()</span>    <span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data i, j, k;</span><br><span class="line"></span><br><span class="line">    _nop_();</span><br><span class="line">    i = <span class="number">8</span>;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    k = <span class="number">243</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(--k);</span><br><span class="line">        &#125; <span class="keyword">while</span>(--j);</span><br><span class="line">    &#125; <span class="keyword">while</span>(--i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="delay-h">delay.h</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DELAY_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DELAY_H__</span></span><br><span class="line"><span class="comment">//声明延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay1000ms</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>51单片机</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>5.IIC通信</title>
    <url>/post/f5fba2c3.html</url>
    <content><![CDATA[<h1><center>IIC理论</center></h1>
<h2 id="center-实现方式-center"><center>实现方式</center></h2>
<p>软件IIC：流程清楚、占用时间、速度慢</p>
<p>硬件IIC ：用法复杂、速度快、可以用DMA</p>
<h2 id="center-电路-center"><center>电路</center></h2>
<p>SCL：时钟线，SDA：数据线</p>
<p>上拉电阻：4.7k-10k</p>
<h2 id="center-速率-center"><center>速率</center></h2>
<p>标准模式：100Kb/s、快速模式：400Kb/s、高速模式：3.4Mb/s</p>
<p>100kbit/s 是指1秒钟传输100kbit。1个时钟脉冲只能传输1bit数据。1秒中内要传输100kbit数据，则需要100k个时钟脉冲。每个时钟脉冲的周期 T=1/100 000 = 10us</p>
<p>HZ和bit/s是一个相同的概念。时钟周期为1HZ，则传输数据的速率为1bit/s；时钟周期为100KHZ，则传输数据的速率为100kbit/s</p>
<h2 id="center-时序-center"><center>时序</center></h2>
<img src="https://s2.loli.net/2024/08/19/2jsb3vImS5w8oEA.png" alt="时钟信号图" style="zoom:50%;">
<h3 id="空闲状态">空闲状态</h3>
<p>SDA和SCL全为高电平</p>
<h3 id="开始信号">开始信号</h3>
<p>当SCL为高电平时，SDA<code>由高到低</code>的跳变：表示数据传输的开始</p>
<h3 id="停止信号">停止信号</h3>
<p>当SCL为高电平时，SDA<code>由低到高</code>的跳变：表示数据的结束</p>
<h3 id="读写操作">读写操作</h3>
<ul>
<li>发送从机地址
<ul>
<li>每个 I2C 器件都有一个设备地址
<ul>
<li>先发送设备地址来决定访问哪个 I2C 器件</li>
</ul>
</li>
<li>发送8位数据
<ul>
<li>高 7 位是设备地址，后 1 位是读写位
<ul>
<li>1 表示读操作，0 表示写操作</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>应答信号
<ul>
<li>发端在SDA上每发送一个字节的数据，在SCL第9个时钟期间释放该数据线SDA</li>
<li>接收端反馈一个应答信号
<ul>
<li>应答信号为低电平时：规定为有效应答（ACK），表示已地接收了</li>
<li>该字节应答信号为高电平时，规定为非应答（NACK），表示没有成功接收该字节</li>
<li>有时候简单的软件IIC不校验ACK</li>
</ul>
</li>
</ul>
</li>
<li>读写数据
<ul>
<li>根据前一个字节的读写位，确定读写</li>
</ul>
</li>
</ul>
<h2 id="center-总线设备相关-center"><center>总线设备相关</center></h2>
<p>总线最多挂载2^7-1=127个设备（0地址不算）</p>
<p>设备枚举（for）</p>
<h1><center>代码编写</center></h1>
<p>OLED屏的使用</p>
<h2 id="iic-c-主要">iic.c（主要）</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iic.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="comment">//参考上面时序图理解（按时间先为主判断）</span></span><br><span class="line"><span class="comment">//开始</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    IIC_SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_SDA = <span class="number">1</span>;</span><br><span class="line">    Delay5us();</span><br><span class="line">    IIC_SDA = <span class="number">0</span>;</span><br><span class="line">    Delay5us();</span><br><span class="line">    IIC_SCL = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结束</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    IIC_SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_SDA = <span class="number">0</span>;</span><br><span class="line">    Delay5us();</span><br><span class="line">    IIC_SDA = <span class="number">1</span>;</span><br><span class="line">    Delay5us();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Write_Byte</span><span class="params">(uchar wbyte)</span></span><br><span class="line">&#123;</span><br><span class="line">    uchar i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        wbyte &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        IIC_SDA = CY;	<span class="comment">//进位标志位，左移溢出的保存在CY里</span></span><br><span class="line">        IIC_SCL = <span class="number">1</span>;</span><br><span class="line">        Delay5us();</span><br><span class="line">        IIC_SCL = <span class="number">0</span>;</span><br><span class="line">        Delay5us();</span><br><span class="line">    &#125;</span><br><span class="line">    IIC_SCL = <span class="number">1</span>;</span><br><span class="line">    Delay5us();</span><br><span class="line">    IIC_SCL = <span class="number">0</span>;</span><br><span class="line">    Delay5us();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="iic-h">iic.h</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __IIC_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __IIC_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;main.h&gt;</span></span></span><br><span class="line"><span class="comment">//声明三个函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Start</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Stop</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Write_Byte</span><span class="params">(uchar wbyte)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="main-c">main.c</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iic.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bmp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 t;</span><br><span class="line">    OLED_Init();	<span class="comment">//初始化OLED</span></span><br><span class="line">    OLED_Clear();</span><br><span class="line">    OLED_ShowCHinese(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);	<span class="comment">//星</span></span><br><span class="line">    OLED_ShowCHinese(<span class="number">18</span>,<span class="number">0</span>,<span class="number">1</span>);	<span class="comment">//仔</span></span><br><span class="line">    OLED_ShowCHinese(<span class="number">36</span>,<span class="number">0</span>,<span class="number">2</span>);	<span class="comment">//爱</span></span><br><span class="line">    OLED_ShowCHinese(<span class="number">54</span>,<span class="number">0</span>,<span class="number">3</span>);	<span class="comment">//分</span></span><br><span class="line">    OLED_ShowCHinese(<span class="number">72</span>,<span class="number">0</span>,<span class="number">4</span>);	<span class="comment">//享</span></span><br><span class="line">    OLED_ShowCHinese(<span class="number">90</span>,<span class="number">0</span>,<span class="number">5</span>);	<span class="comment">//抖</span></span><br><span class="line">    OLED_ShowCHinese(<span class="number">108</span>,<span class="number">0</span>,<span class="number">6</span>);	<span class="comment">//音</span></span><br><span class="line">    OLED_ShowCHinese(<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>);	<span class="comment">//音</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    OLED_Clear();	</span><br><span class="line">    OLED_ShowString(<span class="number">6</span>,<span class="number">3</span>,<span class="string">&quot;0.96&#x27; OLED TEST&quot;</span>,<span class="number">16</span>);	<span class="comment">//显示字符串（x,y,字符串,字号）</span></span><br><span class="line">    OLED_Clear();</span><br><span class="line">    OLED_ShowNum(<span class="number">103</span>,<span class="number">6</span>,<span class="number">224</span>,<span class="number">3</span>,<span class="number">16</span>);	<span class="comment">//显示数字（x,y,数字,数字个数,字号）</span></span><br><span class="line">    OLED_Clear();</span><br><span class="line">    OLED_DrawBMP(<span class="number">0</span>,<span class="number">0</span>,<span class="number">128</span>,<span class="number">8</span>,BMP1);	<span class="comment">//（1,2：左上角坐标，3,4：右下角坐标，图片字模）</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main-h">main.h</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MAIN_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MAIN_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> uchar;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义时间线和数据线</span></span><br><span class="line">sbit IIC_SCL = P1^<span class="number">5</span>;</span><br><span class="line">sbit IIC_SDA = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="oled-c">oled.c</h2>
<img src="https://s2.loli.net/2024/10/02/jJ2uOwn7GYEmI8h.webp" alt="代码解析1" style="zoom:40%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oledfont.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iic.h&quot;</span></span></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">// IIC Write Command(命令)</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_IIC_Command</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> IIC_Command)</span></span><br><span class="line">&#123;</span><br><span class="line">    IIC_Start();</span><br><span class="line">    IIC_Write_Byte(<span class="number">0x78</span>);	<span class="comment">//从机地址,SA0=0	</span></span><br><span class="line">    IIC_Write_Byte(<span class="number">0x00</span>);	<span class="comment">//write command</span></span><br><span class="line">    IIC_Write_Byte(IIC_Command); </span><br><span class="line">    IIC_Stop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">// IIC Write Data(数据)</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_IIC_Data</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> IIC_Data)</span></span><br><span class="line">&#123;</span><br><span class="line">    IIC_Start();</span><br><span class="line">    IIC_Write_Byte(<span class="number">0x78</span>);	<span class="comment">//D/C#=0; R/W#=0</span></span><br><span class="line">    IIC_Write_Byte(<span class="number">0x40</span>);	<span class="comment">//write data</span></span><br><span class="line">    IIC_Write_Byte(IIC_Data);</span><br><span class="line">    IIC_Stop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_WR_Byte</span><span class="params">(<span class="type">unsigned</span> dat,<span class="type">unsigned</span> cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(cmd)</span><br><span class="line">    &#123;</span><br><span class="line">        Write_IIC_Data(dat);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Write_IIC_Command(dat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************</span></span><br><span class="line"><span class="comment">// fill_Picture</span></span><br><span class="line"><span class="comment">********************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fill_picture</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> fill_Data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> m,n;</span><br><span class="line">    <span class="keyword">for</span>(m=<span class="number">0</span>;m&lt;<span class="number">8</span>;m++)</span><br><span class="line">    &#123;</span><br><span class="line">        OLED_WR_Byte(<span class="number">0xb0</span>+m,<span class="number">0</span>);		<span class="comment">//page0-page1</span></span><br><span class="line">        OLED_WR_Byte(<span class="number">0x00</span>,<span class="number">0</span>);		<span class="comment">//low column start address</span></span><br><span class="line">        OLED_WR_Byte(<span class="number">0x10</span>,<span class="number">0</span>);		<span class="comment">//high column start address</span></span><br><span class="line">        <span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">128</span>;n++)</span><br><span class="line">        &#123;</span><br><span class="line">            OLED_WR_Byte(fill_Data,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************Delay****************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_50ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> Del_50ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m;</span><br><span class="line">    <span class="keyword">for</span>(;Del_50ms&gt;<span class="number">0</span>;Del_50ms--)</span><br><span class="line">        <span class="keyword">for</span>(m=<span class="number">6245</span>;m&gt;<span class="number">0</span>;m--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_1ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> Del_1ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> j;</span><br><span class="line">    <span class="keyword">while</span>(Del_1ms--)</span><br><span class="line">    &#123;	</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">123</span>;j++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//坐标设置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Set_Pos</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y)</span> </span><br><span class="line">&#123;</span><br><span class="line">    OLED_WR_Byte(<span class="number">0xb0</span>+y,OLED_CMD);</span><br><span class="line">    OLED_WR_Byte(((x&amp;<span class="number">0xf0</span>)&gt;&gt;<span class="number">4</span>)|<span class="number">0x10</span>,OLED_CMD);</span><br><span class="line">    OLED_WR_Byte((x&amp;<span class="number">0x0f</span>),OLED_CMD); </span><br><span class="line">&#125;   	  </span><br><span class="line"><span class="comment">//开启OLED显示    </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Display_On</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    OLED_WR_Byte(<span class="number">0X8D</span>,OLED_CMD);  <span class="comment">//SET DCDC命令</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0X14</span>,OLED_CMD);  <span class="comment">//DCDC ON</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0XAF</span>,OLED_CMD);  <span class="comment">//DISPLAY ON</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭OLED显示     </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Display_Off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    OLED_WR_Byte(<span class="number">0X8D</span>,OLED_CMD);  <span class="comment">//SET DCDC命令</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0X10</span>,OLED_CMD);  <span class="comment">//DCDC OFF</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0XAE</span>,OLED_CMD);  <span class="comment">//DISPLAY OFF</span></span><br><span class="line">&#125;		   			 </span><br><span class="line"><span class="comment">//清屏函数,清完屏,整个屏幕是黑色的!和没点亮一样!!!	  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Clear</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    u8 i,n;		    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        OLED_WR_Byte (<span class="number">0xb0</span>+i,OLED_CMD);    <span class="comment">//设置页地址（0~7）</span></span><br><span class="line">        OLED_WR_Byte (<span class="number">0x00</span>,OLED_CMD);      <span class="comment">//设置显示位置—列低地址</span></span><br><span class="line">        OLED_WR_Byte (<span class="number">0x10</span>,OLED_CMD);      <span class="comment">//设置显示位置—列高地址   </span></span><br><span class="line">        <span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">128</span>;n++)OLED_WR_Byte(<span class="number">0</span>,OLED_DATA); </span><br><span class="line">    &#125; <span class="comment">//更新显示</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_On</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    u8 i,n;		    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        OLED_WR_Byte (<span class="number">0xb0</span>+i,OLED_CMD);	<span class="comment">//设置页地址（0~7）</span></span><br><span class="line">        OLED_WR_Byte (<span class="number">0x00</span>,OLED_CMD);	<span class="comment">//设置显示位置—列低地址</span></span><br><span class="line">        OLED_WR_Byte (<span class="number">0x10</span>,OLED_CMD);	<span class="comment">//设置显示位置—列高地址   </span></span><br><span class="line">        <span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">128</span>;n++)OLED_WR_Byte(<span class="number">1</span>,OLED_DATA); </span><br><span class="line">    &#125; <span class="comment">//更新显示</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在指定位置显示一个字符,包括部分字符</span></span><br><span class="line"><span class="comment">//x:0~127</span></span><br><span class="line"><span class="comment">//y:0~63</span></span><br><span class="line"><span class="comment">//mode:0,反白显示;1,正常显示				 </span></span><br><span class="line"><span class="comment">//size:选择字体 16/12 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowChar</span><span class="params">(u8 x,u8 y,u8 chr,u8 Char_Size)</span></span><br><span class="line">&#123;      	</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c=<span class="number">0</span>,i=<span class="number">0</span>;	</span><br><span class="line">    c=chr-<span class="string">&#x27; &#x27;</span>;	<span class="comment">//得到偏移后的值			</span></span><br><span class="line">    <span class="keyword">if</span>(x&gt;Max_Column<span class="number">-1</span>)&#123;x=<span class="number">0</span>;y=y+<span class="number">2</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(Char_Size ==<span class="number">16</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        OLED_Set_Pos(x,y);	</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">            OLED_WR_Byte(F8X16[c*<span class="number">16</span>+i],OLED_DATA);</span><br><span class="line">        OLED_Set_Pos(x,y+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">            OLED_WR_Byte(F8X16[c*<span class="number">16</span>+i+<span class="number">8</span>],OLED_DATA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;	</span><br><span class="line">        OLED_Set_Pos(x,y);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">            OLED_WR_Byte(F6x8[c][i],OLED_DATA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//m^n函数</span></span><br><span class="line">u32 <span class="title function_">oled_pow</span><span class="params">(u8 m,u8 n)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 result=<span class="number">1</span>;	 </span><br><span class="line">    <span class="keyword">while</span>(n--)result*=m;    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;				  </span><br><span class="line"><span class="comment">//显示2个数字</span></span><br><span class="line"><span class="comment">//x,y :起点坐标	 </span></span><br><span class="line"><span class="comment">//len :数字的位数</span></span><br><span class="line"><span class="comment">//size:字体大小</span></span><br><span class="line"><span class="comment">//mode:模式	0,填充模式;1,叠加模式</span></span><br><span class="line"><span class="comment">//num:数值(0~4294967295);	 		  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowNum</span><span class="params">(u8 x,u8 y,u32 num,u8 len,u8 size2)</span></span><br><span class="line">&#123;         	</span><br><span class="line">    u8 t,temp;</span><br><span class="line">    u8 enshow=<span class="number">0</span>;						   </span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;len;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=(num/oled_pow(<span class="number">10</span>,len-t<span class="number">-1</span>))%<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(enshow==<span class="number">0</span>&amp;&amp;t&lt;(len<span class="number">-1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                OLED_ShowChar(x+(size2/<span class="number">2</span>)*t,y,<span class="string">&#x27; &#x27;</span>,size2);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> enshow=<span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        OLED_ShowChar(x+(size2/<span class="number">2</span>)*t,y,temp+<span class="string">&#x27;0&#x27;</span>,size2); </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//显示一个字符号串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowString</span><span class="params">(u8 x,u8 y,u8 *chr,u8 Char_Size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (chr[j]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;		</span><br><span class="line">        OLED_ShowChar(x,y,chr[j],Char_Size);</span><br><span class="line">        x+=<span class="number">8</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">120</span>)&#123;x=<span class="number">0</span>;y+=<span class="number">2</span>;&#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示汉字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowCHinese</span><span class="params">(u8 x,u8 y,u8 no)</span></span><br><span class="line">&#123;      			    </span><br><span class="line">    u8 t,adder=<span class="number">0</span>;</span><br><span class="line">    OLED_Set_Pos(x,y);	</span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;<span class="number">16</span>;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        OLED_WR_Byte(Hzk[<span class="number">2</span>*no][t],OLED_DATA);</span><br><span class="line">        adder+=<span class="number">1</span>;</span><br><span class="line">    &#125;	</span><br><span class="line">    OLED_Set_Pos(x,y+<span class="number">1</span>);	</span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;<span class="number">16</span>;t++)</span><br><span class="line">    &#123;	</span><br><span class="line">        OLED_WR_Byte(Hzk[<span class="number">2</span>*no+<span class="number">1</span>][t],OLED_DATA);</span><br><span class="line">        adder += <span class="number">1</span>;</span><br><span class="line">    &#125;					</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********功能描述：显示显示BMP图片128×64起始点坐标(x,y),x的范围0～127，y为页的范围0～7*****************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DrawBMP</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x0, <span class="type">unsigned</span> <span class="type">char</span> y0,<span class="type">unsigned</span> <span class="type">char</span> x1, <span class="type">unsigned</span> <span class="type">char</span> y1,<span class="type">unsigned</span> <span class="type">char</span> BMP[])</span></span><br><span class="line">&#123; 	</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> x,y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(y1%<span class="number">8</span>==<span class="number">0</span>) y=y1/<span class="number">8</span>;      </span><br><span class="line">    <span class="keyword">else</span> y=y1/<span class="number">8</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(y=y0;y&lt;y1;y++)</span><br><span class="line">    &#123;</span><br><span class="line">        OLED_Set_Pos(x0,y);</span><br><span class="line">        <span class="keyword">for</span>(x=x0;x&lt;x1;x++)</span><br><span class="line">        &#123;      </span><br><span class="line">            OLED_WR_Byte(BMP[j++],OLED_DATA);	    	</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化SSD1306					    </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; 	</span><br><span class="line"></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xAE</span>,OLED_CMD);<span class="comment">//--display off</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0x00</span>,OLED_CMD);<span class="comment">//---set low column address</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0x10</span>,OLED_CMD);<span class="comment">//---set high column address</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0x40</span>,OLED_CMD);<span class="comment">//--set start line address  </span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xB0</span>,OLED_CMD);<span class="comment">//--set page address</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0x81</span>,OLED_CMD); <span class="comment">// contract control</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xFF</span>,OLED_CMD);<span class="comment">//--128   </span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xA1</span>,OLED_CMD);<span class="comment">//set segment remap </span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xA6</span>,OLED_CMD);<span class="comment">//--normal / reverse</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xA8</span>,OLED_CMD);<span class="comment">//--set multiplex ratio(1 to 64)</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0x3F</span>,OLED_CMD);<span class="comment">//--1/32 duty</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xC8</span>,OLED_CMD);<span class="comment">//Com scan direction</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xD3</span>,OLED_CMD);<span class="comment">//-set display offset</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0x00</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xD5</span>,OLED_CMD);<span class="comment">//set osc division</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0x80</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xD8</span>,OLED_CMD);<span class="comment">//set area color mode off</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0x05</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xD9</span>,OLED_CMD);<span class="comment">//Set Pre-Charge Period</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xF1</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xDA</span>,OLED_CMD);<span class="comment">//set com pin configuartion</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0x12</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xDB</span>,OLED_CMD);<span class="comment">//set Vcomh</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0x30</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    OLED_WR_Byte(<span class="number">0x8D</span>,OLED_CMD);<span class="comment">//set charge pump enable</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0x14</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xAF</span>,OLED_CMD);<span class="comment">//--turn on oled panel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="oled-h">oled.h</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __OLED_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __OLED_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  u8 unsigned char </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  u32 unsigned int </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_CMD  0	<span class="comment">//写命令</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_DATA 1	<span class="comment">//写数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_MODE 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//OLED模式设置</span></span><br><span class="line"><span class="comment">//0:4线串行模式</span></span><br><span class="line"><span class="comment">//1:并行8080模式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XLevelL		0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XLevelH		0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Max_Column	128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Max_Row		64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	Brightness	0xFF </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_WIDTH 	128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Y_WIDTH 	64	    						  </span></span><br><span class="line"><span class="comment">//-----------------OLED端口定义----------------  					   </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//OLED控制用函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_WR_Byte</span><span class="params">(<span class="type">unsigned</span> dat,<span class="type">unsigned</span> cmd)</span>;  </span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Display_On</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Display_Off</span><span class="params">(<span class="type">void</span>)</span>;	   							   		    </span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Clear</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DrawPoint</span><span class="params">(u8 x,u8 y,u8 t)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Fill</span><span class="params">(u8 x1,u8 y1,u8 x2,u8 y2,u8 dot)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowChar</span><span class="params">(u8 x,u8 y,u8 chr,u8 Char_Size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowNum</span><span class="params">(u8 x,u8 y,u32 num,u8 len,u8 size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowString</span><span class="params">(u8 x,u8 y, u8 *p,u8 Char_Size)</span>;	 </span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Set_Pos</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowCHinese</span><span class="params">(u8 x,u8 y,u8 no)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DrawBMP</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x0, <span class="type">unsigned</span> <span class="type">char</span> y0,<span class="type">unsigned</span> <span class="type">char</span> x1, <span class="type">unsigned</span> <span class="type">char</span> y1,<span class="type">unsigned</span> <span class="type">char</span> BMP[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_50ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> Del_50ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_1ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> Del_1ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fill_picture</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> fill_Data)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Picture</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_IIC_Command</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> IIC_Command)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_IIC_Data</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> IIC_Data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>oledfont.h、bmp.h为字符字模、图片字模</p>
<h2 id="delay-c">delay.c</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay5us</span><span class="params">()</span>		<span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="delay-h">delay.h</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DELAY_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DELAY_H__</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay5us</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>51单片机</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>0.Linux基础命令</title>
    <url>/post/288a7e13.html</url>
    <content><![CDATA[<blockquote>
<p>终端打开：一个窗口打开第二个：<code>Ctrl+Shift+t</code>，不同串口打开：<code>Ctrl+Alt+t</code></p>
<p>虚拟机Ubuntu安装参考：<a href="https://blog.csdn.net/weixin_48728769/article/details/126989849?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170693530616800182141076%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170693530616800182141076&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-126989849-null-null.142%5Ev99%5Epc_search_result_base9&amp;utm_term=Ubuntu20.04%E4%B8%8B%E8%BD%BD&amp;spm=1018.2226.3001.4187">链接</a></p>
</blockquote>
<h1><center>文件和目录操作</center></h1>
<p>参考：<a href="https://blog.csdn.net/weixin_45908488/article/details/123703179?spm=1001.2014.3001.5502">链接</a></p>
<blockquote>
<p>查看文件</p>
</blockquote>
<ul>
<li>查看当前目录里面内容：<code>ls</code></li>
<li>查看当前目录里面内容(详细信息)：<code>ls -l</code></li>
<li>查看当前目录里面内容(包括隐藏)：<code>ls -a</code></li>
<li>查看系统加载哪些驱动：<code>lsmod</code></li>
<li>查看系统有哪些usb设备：<code>lsusb</code></li>
</ul>
<blockquote>
<p>文件夹操作</p>
</blockquote>
<ul>
<li>进入哪个文件夹(不知道有哪些需先查看)：<code>cd 文件夹名</code>，连续进入：<code>cd 文件夹名1/文件夹名2</code></li>
<li>返回上一级：<code>cd ..</code></li>
<li>切换到系统根目录：<code>cd /</code></li>
<li>切换用户主目录：：<code>cd ~</code></li>
<li>返回当前文件夹所在路径：<code>pwd</code></li>
<li>创建文件夹：<code>mkdir 文件夹名</code></li>
</ul>
<blockquote>
<p>文件操作</p>
</blockquote>
<ul>
<li>新建文件：<code>touch 文件.后缀名</code></li>
<li>删除文件：<code>rm 文件.后缀名</code>，删除文件夹中后缀名全部文件：<code>rm *.后缀名</code></li>
<li>删除文件夹：<code>rm -R 文件夹名</code></li>
<li>复制文件：<code>cp 文件名.后缀名 路径</code></li>
<li>移动文件：<code>mv 文件名.后缀名 路径</code></li>
<li>查看文件中内容：<code>cat 文件名.后缀名</code></li>
</ul>
<h1><center>管理员</center></h1>
<p>管理员权限：<code>sudo 操作</code></p>
<p>创建root用户：<code>sudo passwd root</code>，进入root用户：<code>su root</code></p>
<p>切换用户：<code>su 用户名</code></p>
<h1><center>安装应用</center></h1>
<blockquote>
<p>查看IP：ifconfig</p>
</blockquote>
<h2 id="apt">apt</h2>
<p>参考：<a href="https://blog.csdn.net/m0_46278037/article/details/120232679?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171212013516800182718297%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171212013516800182718297&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-120232679-null-null.142%5Ev100%5Epc_search_result_base9&amp;utm_term=apt%20Linux&amp;spm=1018.2226.3001.4187">链接</a></p>
<p>安装：<code>sudo apt install &lt;package_name&gt;</code></p>
<p>使用 apt 更新包数据库：<code>sudo apt update</code></p>
<p>使用 apt 升级已安装的软件包：<code>sudo apt upgrade</code></p>
<h2 id="换源">换源</h2>
<p>根据图示更改为国内镜像源，参考：<a href="https://blog.csdn.net/qq_45878098/article/details/126037838">链接</a></p>
<img src="https://s2.loli.net/2024/09/30/4knXvK1C96LgJwj.webp" alt="更换镜像源" style="zoom:40%;">
<h1><center>文本处理</center></h1>
<h2 id="vim">vim</h2>
<p>参考：<a href="https://blog.csdn.net/qq_29689343/article/details/116162089?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=Linux%E6%96%87%E6%9C%AC&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-116162089.142%5Ev100%5Epc_search_result_base9&amp;spm=1018.2226.3001.4187">链接</a></p>
<p>安装：<code>sudo apt install vim</code>，创建一个.c文件：<code>vim 文件名.c</code></p>
<p>当编辑文件完成后按 Esc 键即可返回命令模式</p>
<p>在命令模式状态下按<code>:</code>键，Vim 窗口的左下方出现一个<code>:</code>符号</p>
<blockquote>
<p><code>wq</code>：保存并退出，<code>wq!</code>：强制保存并推出，<code>q</code>：不保存退出，<code>q!</code>：不保存强制退出</p>
<p><code>set nu</code>：文本编辑显示行号，<code>/需要搜索的文本</code>：搜索文本（n查看下一个，N查看上一个）</p>
</blockquote>
<p>gedit：文本编辑器</p>
<h1><center>压缩与解压</center></h1>
<blockquote>
<p>通用形式</p>
</blockquote>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">tar [选项] [文件]</span><br><span class="line"></span><br><span class="line">文件：指定要处理的文件或目录列表</span><br><span class="line">选项：</span><br><span class="line">    -c: 创建一个新的归档文件。</span><br><span class="line">    -r: 向已存在的归档文件中添加文件。</span><br><span class="line">    -t: 列出归档文件的内容。</span><br><span class="line">    -u: 更新归档文件，即添加比归档文件中副本更新的文件。</span><br><span class="line">    -x: 从归档文件中提取文件。</span><br><span class="line">    -v: 在处理文件时显示详细信息。</span><br><span class="line">    -f: 指定归档文件的名称。</span><br><span class="line">    -z: 通过gzip进行压缩或解压缩。</span><br><span class="line">    -j: 通过bzip2进行压缩或解压缩。</span><br><span class="line">    -W: 确认归档文件的正确性</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tar压缩：tar -cvf test.tar *.c</p>
<p>tar解压：tar -xvf test.tar</p>
</blockquote>
<h1><center>查找</center></h1>
<blockquote>
<p><code>find</code>：查找文件，sudo find  /home/wfeng  -name  “*.c”</p>
</blockquote>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">find</span> [起始目录] [表达式]</span><br><span class="line"></span><br><span class="line"> 起始目录：<span class="built_in">find</span> 命令开始搜索的目录</span><br><span class="line"> 表达式：</span><br><span class="line">	-name：匹配文件名。</span><br><span class="line">	-<span class="built_in">type</span>：匹配文件类型（例如，f 表示普通文件，d 表示目录）。</span><br><span class="line">	-size：根据文件大小匹配文件。</span><br><span class="line">	-mtime：根据文件最后修改时间匹配文件。</span><br><span class="line">	-exec：对匹配搜索条件的文件执行命令</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>grep</code>：查找文件中的字符，grep “d” a.c</p>
</blockquote>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">grep [选项] [搜索模式] [文件…]</span><br><span class="line"></span><br><span class="line">[选项]：可选，用于定制grep的行为，例如是否忽略大小写（-i），是否显示行号（-n）等</span><br><span class="line">[搜索模式]：想要搜索的文本或正则表达式。</span><br><span class="line">[文件…]：要搜索的文件。如果省略文件名，grep会从标准输入读取数据</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>dmesg</code>：系统内核打印，特定搜索：dmesg | grep usb</p>
</blockquote>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">dmesg | grep [选项] “搜索字符串”</span><br><span class="line"></span><br><span class="line">dmesg：用于获取内核消息</span><br><span class="line">|：管道符，将 dmesg 的输出传递给 grep</span><br><span class="line">grep：文本搜索命令</span><br><span class="line">[选项]：可选参数，用于定制 grep 的行为，例如忽略大小写（-i），显示行号（-n）等</span><br><span class="line">“搜索字符串”：要搜索的文本字符串</span><br></pre></td></tr></table></figure>
<h1><center>基础编译测试</center></h1>
<p>安装gcc：<code>sudo apt install gcc</code></p>
<p>编译 .c：<code>gcc 文件名.c -o 生成文件名</code>，再运行编译生成的可执行文件：<code>./可执行文件名.后缀名</code></p>
<p>查看文件属性：<code>file 文件名.后缀名</code>，例：file mian.c</p>
<p>修改权限：<code>sudo chmod 777 文件名.后缀名</code>，例：sudo chmod 777 test.c</p>
<h1><center>其他命令</center></h1>
<ul>
<li>查看网络信息(IP地址等)：<code>ifconfig</code>(<a href="https://blog.csdn.net/AnChenliang_1002/article/details/131466890">参考</a>)</li>
<li>echo：输出指定的字符串信息或显示变量的值的命令(<a href="https://blog.csdn.net/rhn_111/article/details/128954511">参考</a>)</li>
<li>显示应用运行的进程：<code>ps</code>，显示系统全部进程：<code>top</code>(<a href="https://blog.csdn.net/Y1730008223CONG/article/details/126533853">参考</a>)，退出：<code>ctrl c/z</code></li>
<li>杀死进程：kill -9 进程号</li>
<li>发送信号到进程：<code>kill</code>(<a href="https://www.runoob.com/linux/linux-comm-kill.html?source=1">参考</a>)</li>
<li>关机：<code>shutdown</code>(默认一分钟后关)，重启：<code>reboot</code></li>
</ul>
<h1><center>环境搭建</center></h1>
<p>通过SSH，Windows可以连接到Linux，在MobaXterm中操作Linux</p>
<p>安装SSH：Linux <code>sudo apt-get install openssh-server</code>，Windows <code>MobaXterm软件</code></p>
<p>MobaXterm连接Linux，按照图中填写IP，连接后输入Linux用户名以及密码</p>
<img src="https://s2.loli.net/2024/10/01/FKfOYW47Z2C6dGh.webp" alt="连接Linux" style="zoom:40%;">
<h2 id="传文件">传文件</h2>
<h3 id="ftp">FTP</h3>
<p>安装：<code>sudo apt-get install vsftpd</code></p>
<p><code>sudo vim /etc/vsftpd.conf</code>，找到 #write_enable=YES，把#删掉，然后<code>Esc</code>、<code>:</code>、<code>wq</code>、回车</p>
<img src="https://s2.loli.net/2024/10/01/VPhkeEY3Z5b2KrC.webp" alt="删除" style="zoom:40%;">
<p>重启FTP：<code>sudo /etc/init.d/vsftpd restart</code></p>
<p>Windows安装：<code>FileZilla</code>软件，输入Linux的IP、用户名、密码 连接Linux的FTP</p>
<p>本地站点则为Windows的文件，远程站点则为Linux文件，双击Windows中的文件自动传到Linux，在Linux右键下载则传到Windows</p>
<img src="https://s2.loli.net/2024/10/01/VDI6tEBbdcYaKSp.webp" alt="连接FTP" style="zoom:50%;">
<h3 id="samba">Samba</h3>
<p>Linux安装：运行以下命令</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get dist-upgrade</span><br><span class="line">sudo apt-get install samba samba-common</span><br><span class="line">samba -V	//如果出现下面版本号说明已经安装了samba服务器</span><br><span class="line">sudo <span class="built_in">mkdir</span> /home/share</span><br><span class="line">sudo chmod <span class="number">777</span> /home/用户名</span><br><span class="line">sudo smbpasswd -a 用户名	//需要确认输入两个相同的密码确认</span><br><span class="line">sudo cp /etc/samba/smb.conf /etc/samba/smb.conf.bak	//备份 smb.conf 配置文件</span><br></pre></td></tr></table></figure>
<p>修改文件：<code>sudo vim /etc/samba/smb.conf</code>，在最后添加下面的内容，里面名字(xinzai)要改成自己的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line"> </span><br><span class="line">    ; 创建工作组 设定 Samba Server 所要加入的工作组或者域  </span><br><span class="line">    workgroup = WORKGROUP </span><br><span class="line"> </span><br><span class="line">    ; 为了防止出现中文目录乱码的情况。其中根据你的local，UTF-8 有可能需要改成 cp936</span><br><span class="line">    ; display charset = UTF-8</span><br><span class="line">    unix charset = UTF-8</span><br><span class="line">    dos charset = cp936 </span><br><span class="line">  </span><br><span class="line">    ; 是否允许guest用户访问</span><br><span class="line">    guest ok = no</span><br><span class="line">    </span><br><span class="line">    ; 注：如果 #security 存在就直接修改，不存在就创建</span><br><span class="line">    ; security = user </span><br><span class="line"> </span><br><span class="line">    ; 安全模式  我们设置用户安全级别</span><br><span class="line">    security = user </span><br><span class="line">  </span><br><span class="line">  ; 说明：用来定义用户名映射，比如可以将root换成administrator、admin等。不过要事先在smbusers文件中定义好。</span><br><span class="line">  ; 比如：root = administrator admin，这样就可以用administrator或admin这两个用户来代替root登陆Samba Server，更贴近windows用户的习惯。</span><br><span class="line">    username map = /etc/Samba/smbusers </span><br><span class="line"> </span><br><span class="line">; 共享名，该共享标签，该名字为在电脑上看到的共享名 注意网络映射的路径是这标签名字不是共享路径的名字</span><br><span class="line">[share]</span><br><span class="line"> </span><br><span class="line">    ; 该共享描述</span><br><span class="line">    comment = Shared Folder with username and password </span><br><span class="line"> </span><br><span class="line">    ; 共享文件夹路径</span><br><span class="line">    path = /home/xinzai/</span><br><span class="line"> </span><br><span class="line">    ; 表示是否允许匿名访问该共享目录</span><br><span class="line">    public = no</span><br><span class="line"> </span><br><span class="line">    ; 配置的Samba访问账号 指明可以访问的用户</span><br><span class="line">    valid users = xinzai</span><br><span class="line"> </span><br><span class="line">    ; 表示是否可以在 Window Explorer中显示该目录</span><br><span class="line">    browsable = no</span><br><span class="line"> </span><br><span class="line">    ; 指明新建立的文件的属性</span><br><span class="line">    create mask = 777 </span><br><span class="line"> </span><br><span class="line">    ; 指明新建立的目录的属性</span><br><span class="line">    directory mask = 777</span><br><span class="line"> </span><br><span class="line">    ; force group 和force user 规定创建的文件或文件夹的拥有者和组拥有者是谁 </span><br><span class="line">    ; 一般这两个值来空，则表示拥有者和组拥有者为创建文件者。 如设定值，如force group=xinzai</span><br><span class="line">    ; Force user=yhq，则不管是谁创建的文件和文件夹，拥有者都为yhq和yhq组。</span><br><span class="line"> </span><br><span class="line">    ; force user强制把建立文件的属主是谁。如果我有一个目录，让guest可以写，那么guest就可以删除，</span><br><span class="line">    ; 如果我用force user=yhq强制建立文件的属主是yhq，同时限制create mask = 0755，</span><br><span class="line">    ; 这样guest就不能删除了。</span><br><span class="line"> </span><br><span class="line">    force user = xinzai </span><br><span class="line">    force group = xinzai</span><br><span class="line"> </span><br><span class="line">    ; available用来指定该共享资源是否可用</span><br><span class="line">    available = yes </span><br><span class="line"> </span><br><span class="line">    ; 共享路径读权限 设置共享是否可浏览，如果no则表示隐藏，需要通过&quot;//ip/共享目录&quot;进行访问</span><br><span class="line">    browseable = yes</span><br><span class="line"> </span><br><span class="line">    ; 共享路径写权限</span><br><span class="line">    writable = yes</span><br></pre></td></tr></table></figure>
<p>重启samba服务器：<code>sudo service smbd restart</code></p>
<p>Windows：安装图中所示，创建映射网络驱动器，文件夹填写：<code>\\虚拟机IP地址\share</code>，例：\\192.168.31.169\share，然后输入账号和密码，创建时一般都是与Linux账户设置一致</p>
<img src="https://s2.loli.net/2024/10/01/GfcUbgAt3YTM1Ks.webp" alt="创建" style="zoom:50%;">
<blockquote>
<p>scp：<a href="https://www.runoob.com/linux/linux-comm-scp.html">参考</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>6.单总线通信</title>
    <url>/post/8212ff63.html</url>
    <content><![CDATA[<h1><center>DHT11介绍分析</center></h1>
<p>HT11数字温湿度传感器</p>
<p>数据格式(在HDT11没有小数)：</p>
<p>    8bit湿度整数数据 + 8bit湿度小数数据 + 8bit温度整数数据 + 8bit温度小数数据 + 8bit校验和</p>
<p>校验方式将温湿度4个字节数据加起来 = 校验和，传送完成后重新加起来与校验和数据比较是否相同</p>
<h2 id="center-开始信号时序-center"><center>开始信号时序</center></h2>
<p>线空闲状态为高电平，单片机把总线拉低必须<code>大于18毫秒</code>，保证DHT11能检测到起始信号，单片机发送<code>开始信号</code>结束后，延时等待20-40us，DHT11接收到单片机开始信号后，等待单片机开始信号结束，然后发送80us低电平<code>响应信号</code></p>
<img src="https://s2.loli.net/2024/08/19/2fMCRY6sdu7piTG.png" alt="开始信号时序" style="zoom:50%;">
<p>HT11发送响应信号后,再把总线拉高80us，准备发送数据</p>
<h2 id="center-mcu接收数据时序-center"><center>MCU接收数据时序</center></h2>
<p>每一bit数据都以50us低电平时隙开始，<code>高电平长短</code>决定数据位是 0 还是 1</p>
<p><strong>数字0信号时序</strong></p>
<img src="https://s2.loli.net/2024/08/19/GAcQOX8N1h4tWFy.png" alt="数字0信号时序图" style="zoom:50%;">
<p><strong>数字1信号时序</strong></p>
<img src="https://s2.loli.net/2024/08/19/a6WCnkK21EzXmGO.png" alt="数字1信号时序图" style="zoom:50%;">
<h1><center>代码编写</center></h1>
<p>利用IIC协议和OLED模块，使用单总线通信和温湿度模块，在OLED屏上显示温湿度</p>
<h2 id="dht11-c">dht11.c</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dht11.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="type">char</span> <span class="title function_">DHT11_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    uchar delay_count = <span class="number">0</span>;	<span class="comment">//用于计数</span></span><br><span class="line">    DHT11_IO = <span class="number">1</span>;	<span class="comment">//一开始单片机时序高电平</span></span><br><span class="line">    Delay30us();</span><br><span class="line">    DHT11_IO = <span class="number">0</span>;	<span class="comment">//拉低电平至少18us</span></span><br><span class="line">    Delay25ms();</span><br><span class="line">    DHT11_IO = <span class="number">1</span>;	<span class="comment">//再拉高20-40us</span></span><br><span class="line">    Delay30us();</span><br><span class="line">    <span class="comment">//当DHT11响应信号开始时为低电平(80us)，等到结束时高电平，取反结束或大于80us时结束</span></span><br><span class="line">    <span class="keyword">while</span>(!DHT11_IO &amp;&amp; delay_count &lt; <span class="number">80</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        delay_count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(delay_count &gt;= <span class="number">80</span>)	<span class="comment">//大于80us结束</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    delay_count = <span class="number">0</span>;	<span class="comment">//重置计数值</span></span><br><span class="line">    <span class="comment">//响应信号结束拉高80us后拉低，代表数据开始传输，等拉低电平时或大于80us结束</span></span><br><span class="line">    <span class="keyword">while</span>(DHT11_IO &amp;&amp; delay_count &lt; <span class="number">80</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        delay_count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(delay_count &gt;= <span class="number">80</span>)	<span class="comment">//大于80us结束</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">DHT11_Write</span><span class="params">(<span class="type">int</span> *humi,<span class="type">int</span> *temp)</span></span><br><span class="line">&#123;</span><br><span class="line">    uchar delay_count = <span class="number">0</span>,data_byte,tmp,x,y;</span><br><span class="line">    uchar DHT11_Data[<span class="number">5</span>];	<span class="comment">//定义数组保存数据</span></span><br><span class="line">    DHT11_Start();	<span class="comment">//调用开始函数</span></span><br><span class="line">    <span class="comment">//发送40bit数据</span></span><br><span class="line">    <span class="keyword">for</span>(x = <span class="number">0</span>;x &lt; <span class="number">5</span>;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(y = <span class="number">0</span>;y &lt; <span class="number">8</span>;y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//数据发送前低电平，判断为高电平时则开始若有问题跳出(&gt;50)</span></span><br><span class="line">            <span class="keyword">while</span>(!DHT11_IO &amp;&amp; delay_count &lt; <span class="number">50</span>)</span><br><span class="line">                delay_count++;</span><br><span class="line">            <span class="keyword">if</span>(delay_count &gt;= <span class="number">50</span>)	<span class="comment">//大于80us结束</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            delay_count = <span class="number">0</span>;</span><br><span class="line">            tmp = <span class="number">0</span>;</span><br><span class="line">            Delay30us();</span><br><span class="line">            <span class="keyword">if</span>(DHT11_IO == <span class="number">1</span>)	<span class="comment">//若条件不成立发送数据0</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmp = <span class="number">1</span>;	<span class="comment">//发送数据1</span></span><br><span class="line">                <span class="keyword">while</span>(DHT11_IO &amp;&amp; delay_count &lt; <span class="number">50</span>)</span><br><span class="line">                    delay_count++;</span><br><span class="line">                <span class="keyword">if</span>(delay_count &gt;= <span class="number">50</span>)	<span class="comment">//大于80us结束</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            delay_count = <span class="number">0</span>;</span><br><span class="line">            data_byte &lt;&lt;= <span class="number">1</span>;	<span class="comment">//左移一位</span></span><br><span class="line">            data_byte |= tmp;	<span class="comment">//将每一位数据传给data_byte</span></span><br><span class="line">        &#125;</span><br><span class="line">        DHT11_Data[x]=data_byte;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若前四个数值加起来不等于校验位的数，则全部清零</span></span><br><span class="line">    <span class="keyword">if</span>(DHT11_Data[<span class="number">0</span>]+DHT11_Data[<span class="number">1</span>]+DHT11_Data[<span class="number">2</span>]+DHT11_Data[<span class="number">3</span>] != DHT11_Data[<span class="number">4</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        DHT11_Data[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        DHT11_Data[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        DHT11_Data[<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">        DHT11_Data[<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因为DHT11只有整数，所以是0，2</span></span><br><span class="line">    *humi = (<span class="type">int</span>)DHT11_Data[<span class="number">0</span>];	<span class="comment">//相同地址，值改变则另一个相同地址的变量也改变</span></span><br><span class="line">    *temp = (<span class="type">int</span>)DHT11_Data[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="dat11-h">dat11.h</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DHT11_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DHT11_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sbit DHT11_IO = P1^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">DHT11_Start</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">char</span> <span class="title function_">DHT11_Write</span><span class="params">(<span class="type">int</span> *humi,<span class="type">int</span> *temp)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="main-c">main.c</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iic.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bmp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dht11.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> H,T;</span><br><span class="line"><span class="type">char</span> DHT11_Buf[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    OLED_Init();	<span class="comment">//初始化OLED</span></span><br><span class="line">    OLED_Clear();</span><br><span class="line">    OLED_ShowCHinese(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);	<span class="comment">//星（x坐标,y坐标,字模第几个）</span></span><br><span class="line">    OLED_ShowCHinese(<span class="number">18</span>,<span class="number">0</span>,<span class="number">1</span>);	<span class="comment">//仔</span></span><br><span class="line">    OLED_ShowCHinese(<span class="number">36</span>,<span class="number">0</span>,<span class="number">2</span>);	<span class="comment">//爱</span></span><br><span class="line">    OLED_ShowCHinese(<span class="number">54</span>,<span class="number">0</span>,<span class="number">3</span>);	<span class="comment">//分</span></span><br><span class="line">    OLED_ShowCHinese(<span class="number">72</span>,<span class="number">0</span>,<span class="number">4</span>);	<span class="comment">//享</span></span><br><span class="line">    OLED_ShowCHinese(<span class="number">90</span>,<span class="number">0</span>,<span class="number">5</span>);	<span class="comment">//抖</span></span><br><span class="line">    OLED_ShowCHinese(<span class="number">108</span>,<span class="number">0</span>,<span class="number">6</span>);	<span class="comment">//音</span></span><br><span class="line">    OLED_ShowCHinese(<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>);	<span class="comment">//抖</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    OLED_Clear();	</span><br><span class="line">    OLED_ShowString(<span class="number">6</span>,<span class="number">3</span>,<span class="string">&quot;0.96&#x27; OLED TEST&quot;</span>,<span class="number">16</span>);	<span class="comment">//显示字符串（x,y,字符串,字号）</span></span><br><span class="line">    OLED_Clear();</span><br><span class="line">    OLED_ShowNum(<span class="number">103</span>,<span class="number">6</span>,<span class="number">224</span>,<span class="number">3</span>,<span class="number">16</span>);	<span class="comment">//显示数字（x,y,数字,数字个数,字号）</span></span><br><span class="line">    OLED_Clear();</span><br><span class="line">    OLED_DrawBMP(<span class="number">0</span>,<span class="number">0</span>,<span class="number">128</span>,<span class="number">8</span>,BMP1);	<span class="comment">//（1,2：左上角坐标，3,4：右下角坐标，图片字模）</span></span><br><span class="line">    OLED_Clear();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DHT11_Write(&amp;H, &amp;T);</span><br><span class="line">        <span class="built_in">sprintf</span>(DHT11_Buf,<span class="string">&quot;H2:%d T2:%d&quot;</span>,H,T);	<span class="comment">//将形式字符赋值给DHT11_Buf</span></span><br><span class="line">        OLED_ShowString(<span class="number">0</span>,<span class="number">4</span>,DHT11_Buf,<span class="number">16</span>);	<span class="comment">//发送字符串</span></span><br><span class="line">        Delay1000ms();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="main-h">main.h</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MAIN_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MAIN_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> uchar;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="iic-c">iic.c</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iic.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line">uchar i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//开始标志时序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//一开始SCL和SDA都为高电平</span></span><br><span class="line">    IIC_SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_SDA = <span class="number">1</span>;</span><br><span class="line">    Delay5us();	<span class="comment">//10us一个周期</span></span><br><span class="line">    IIC_SDA = <span class="number">0</span>;	<span class="comment">//大概一半周期SDA变低电平</span></span><br><span class="line">    Delay5us();	<span class="comment">//再过半个周期</span></span><br><span class="line">    IIC_SCL = <span class="number">0</span>;	<span class="comment">//SCL变低电平</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结束标志时序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//一开始SCL、SDA都为低电平</span></span><br><span class="line">    IIC_SCL = <span class="number">0</span>;</span><br><span class="line">    IIC_SDA = <span class="number">0</span>;</span><br><span class="line">    Delay5us();</span><br><span class="line">    IIC_SCL = <span class="number">1</span>;	<span class="comment">//过半个周期SCL变高电平</span></span><br><span class="line">    Delay5us();</span><br><span class="line">    IIC_SDA = <span class="number">1</span>;	<span class="comment">//过半个周期SDA变高电平</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_write</span><span class="params">(uchar a1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a1 &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        IIC_SDA = CY;	<span class="comment">//进位标志位，左移溢出的保存在CY里</span></span><br><span class="line">        IIC_SCL = <span class="number">0</span>;</span><br><span class="line">        Delay5us();</span><br><span class="line">        IIC_SCL = <span class="number">1</span>;</span><br><span class="line">        Delay5us();</span><br><span class="line">        IIC_SCL = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//应答</span></span><br><span class="line">    IIC_SDA = <span class="number">0</span>;</span><br><span class="line">    IIC_SCL = <span class="number">0</span>;</span><br><span class="line">    Delay5us();</span><br><span class="line">    IIC_SCL = <span class="number">1</span>;</span><br><span class="line">    Delay5us();</span><br><span class="line">    IIC_SCL = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="iic-h">iic.h</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __IIC_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __IIC_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_start</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_stop</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_write</span><span class="params">(uchar a1)</span>;</span><br><span class="line"><span class="comment">//定义时间线和数据线</span></span><br><span class="line">sbit IIC_SCL = P1^<span class="number">5</span>;</span><br><span class="line">sbit IIC_SDA = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="oled-c">oled.c</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oledfont.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iic.h&quot;</span></span></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">// IIC Write Command</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_IIC_Command</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> IIC_Command)</span></span><br><span class="line">&#123;</span><br><span class="line">    IIC_start();</span><br><span class="line">    IIC_write(<span class="number">0x78</span>);	<span class="comment">//Slave address,SA0=0	</span></span><br><span class="line">    IIC_write(<span class="number">0x00</span>);	<span class="comment">//write command</span></span><br><span class="line">    IIC_write(IIC_Command); </span><br><span class="line">    IIC_stop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">// IIC Write Data</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_IIC_Data</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> IIC_Data)</span></span><br><span class="line">&#123;</span><br><span class="line">    IIC_start();</span><br><span class="line">    IIC_write(<span class="number">0x78</span>);	<span class="comment">//D/C#=0; R/W#=0</span></span><br><span class="line">    IIC_write(<span class="number">0x40</span>);	<span class="comment">//write data</span></span><br><span class="line">    IIC_write(IIC_Data);</span><br><span class="line">    IIC_stop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_WR_Byte</span><span class="params">(<span class="type">unsigned</span> dat,<span class="type">unsigned</span> cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(cmd)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Write_IIC_Data(dat);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Write_IIC_Command(dat);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************</span></span><br><span class="line"><span class="comment">// fill_Picture</span></span><br><span class="line"><span class="comment">********************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fill_picture</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> fill_Data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> m,n;</span><br><span class="line">    <span class="keyword">for</span>(m=<span class="number">0</span>;m&lt;<span class="number">8</span>;m++)</span><br><span class="line">    &#123;</span><br><span class="line">        OLED_WR_Byte(<span class="number">0xb0</span>+m,<span class="number">0</span>);		<span class="comment">//page0-page1</span></span><br><span class="line">        OLED_WR_Byte(<span class="number">0x00</span>,<span class="number">0</span>);		<span class="comment">//low column start address</span></span><br><span class="line">        OLED_WR_Byte(<span class="number">0x10</span>,<span class="number">0</span>);		<span class="comment">//high column start address</span></span><br><span class="line">        <span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">128</span>;n++)</span><br><span class="line">        &#123;</span><br><span class="line">            OLED_WR_Byte(fill_Data,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************Delay****************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_50ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> Del_50ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m;</span><br><span class="line">    <span class="keyword">for</span>(;Del_50ms&gt;<span class="number">0</span>;Del_50ms--)</span><br><span class="line">        <span class="keyword">for</span>(m=<span class="number">6245</span>;m&gt;<span class="number">0</span>;m--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_1ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> Del_1ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> j;</span><br><span class="line">    <span class="keyword">while</span>(Del_1ms--)</span><br><span class="line">    &#123;	</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">123</span>;j++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//坐标设置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Set_Pos</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y)</span> </span><br><span class="line">&#123; 	OLED_WR_Byte(<span class="number">0xb0</span>+y,OLED_CMD);</span><br><span class="line"> OLED_WR_Byte(((x&amp;<span class="number">0xf0</span>)&gt;&gt;<span class="number">4</span>)|<span class="number">0x10</span>,OLED_CMD);</span><br><span class="line"> OLED_WR_Byte((x&amp;<span class="number">0x0f</span>),OLED_CMD); </span><br><span class="line">&#125;   	  </span><br><span class="line"><span class="comment">//开启OLED显示    </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Display_On</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    OLED_WR_Byte(<span class="number">0X8D</span>,OLED_CMD);  <span class="comment">//SET DCDC命令</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0X14</span>,OLED_CMD);  <span class="comment">//DCDC ON</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0XAF</span>,OLED_CMD);  <span class="comment">//DISPLAY ON</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭OLED显示     </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Display_Off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    OLED_WR_Byte(<span class="number">0X8D</span>,OLED_CMD);  <span class="comment">//SET DCDC命令</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0X10</span>,OLED_CMD);  <span class="comment">//DCDC OFF</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0XAE</span>,OLED_CMD);  <span class="comment">//DISPLAY OFF</span></span><br><span class="line">&#125;		   			 </span><br><span class="line"><span class="comment">//清屏函数,清完屏,整个屏幕是黑色的!和没点亮一样!!!	  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Clear</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    u8 i,n;		    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        OLED_WR_Byte (<span class="number">0xb0</span>+i,OLED_CMD);    <span class="comment">//设置页地址（0~7）</span></span><br><span class="line">        OLED_WR_Byte (<span class="number">0x00</span>,OLED_CMD);      <span class="comment">//设置显示位置—列低地址</span></span><br><span class="line">        OLED_WR_Byte (<span class="number">0x10</span>,OLED_CMD);      <span class="comment">//设置显示位置—列高地址   </span></span><br><span class="line">        <span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">128</span>;n++)OLED_WR_Byte(<span class="number">0</span>,OLED_DATA); </span><br><span class="line">    &#125; <span class="comment">//更新显示</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_On</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    u8 i,n;		    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        OLED_WR_Byte (<span class="number">0xb0</span>+i,OLED_CMD);    <span class="comment">//设置页地址（0~7）</span></span><br><span class="line">        OLED_WR_Byte (<span class="number">0x00</span>,OLED_CMD);      <span class="comment">//设置显示位置—列低地址</span></span><br><span class="line">        OLED_WR_Byte (<span class="number">0x10</span>,OLED_CMD);      <span class="comment">//设置显示位置—列高地址   </span></span><br><span class="line">        <span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">128</span>;n++)OLED_WR_Byte(<span class="number">1</span>,OLED_DATA); </span><br><span class="line">    &#125; <span class="comment">//更新显示</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在指定位置显示一个字符,包括部分字符</span></span><br><span class="line"><span class="comment">//x:0~127</span></span><br><span class="line"><span class="comment">//y:0~63</span></span><br><span class="line"><span class="comment">//mode:0,反白显示;1,正常显示				 </span></span><br><span class="line"><span class="comment">//size:选择字体 16/12 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowChar</span><span class="params">(u8 x,u8 y,u8 chr,u8 Char_Size)</span></span><br><span class="line">&#123;      	</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c=<span class="number">0</span>,i=<span class="number">0</span>;	</span><br><span class="line">    c=chr-<span class="string">&#x27; &#x27;</span>;<span class="comment">//得到偏移后的值			</span></span><br><span class="line">    <span class="keyword">if</span>(x&gt;Max_Column<span class="number">-1</span>)&#123;x=<span class="number">0</span>;y=y+<span class="number">2</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(Char_Size ==<span class="number">16</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        OLED_Set_Pos(x,y);	</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">            OLED_WR_Byte(F8X16[c*<span class="number">16</span>+i],OLED_DATA);</span><br><span class="line">        OLED_Set_Pos(x,y+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">            OLED_WR_Byte(F8X16[c*<span class="number">16</span>+i+<span class="number">8</span>],OLED_DATA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;	</span><br><span class="line">        OLED_Set_Pos(x,y);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">            OLED_WR_Byte(F6x8[c][i],OLED_DATA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//m^n函数</span></span><br><span class="line">u32 <span class="title function_">oled_pow</span><span class="params">(u8 m,u8 n)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 result=<span class="number">1</span>;	 </span><br><span class="line">    <span class="keyword">while</span>(n--)result*=m;    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;				  </span><br><span class="line"><span class="comment">//显示2个数字</span></span><br><span class="line"><span class="comment">//x,y :起点坐标	 </span></span><br><span class="line"><span class="comment">//len :数字的位数</span></span><br><span class="line"><span class="comment">//size:字体大小</span></span><br><span class="line"><span class="comment">//mode:模式	0,填充模式;1,叠加模式</span></span><br><span class="line"><span class="comment">//num:数值(0~4294967295);	 		  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowNum</span><span class="params">(u8 x,u8 y,u32 num,u8 len,u8 size2)</span></span><br><span class="line">&#123;         	</span><br><span class="line">    u8 t,temp;</span><br><span class="line">    u8 enshow=<span class="number">0</span>;						   </span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;len;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=(num/oled_pow(<span class="number">10</span>,len-t<span class="number">-1</span>))%<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(enshow==<span class="number">0</span>&amp;&amp;t&lt;(len<span class="number">-1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                OLED_ShowChar(x+(size2/<span class="number">2</span>)*t,y,<span class="string">&#x27; &#x27;</span>,size2);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> enshow=<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        OLED_ShowChar(x+(size2/<span class="number">2</span>)*t,y,temp+<span class="string">&#x27;0&#x27;</span>,size2); </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//显示一个字符号串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowString</span><span class="params">(u8 x,u8 y,u8 *chr,u8 Char_Size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (chr[j]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;		OLED_ShowChar(x,y,chr[j],Char_Size);</span><br><span class="line">     x+=<span class="number">8</span>;</span><br><span class="line">     <span class="keyword">if</span>(x&gt;<span class="number">120</span>)&#123;x=<span class="number">0</span>;y+=<span class="number">2</span>;&#125;</span><br><span class="line">     j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示汉字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowCHinese</span><span class="params">(u8 x,u8 y,u8 no)</span></span><br><span class="line">&#123;      			    </span><br><span class="line">    u8 t,adder=<span class="number">0</span>;</span><br><span class="line">    OLED_Set_Pos(x,y);	</span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;<span class="number">16</span>;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        OLED_WR_Byte(Hzk[<span class="number">2</span>*no][t],OLED_DATA);</span><br><span class="line">        adder+=<span class="number">1</span>;</span><br><span class="line">    &#125;	</span><br><span class="line">    OLED_Set_Pos(x,y+<span class="number">1</span>);	</span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;<span class="number">16</span>;t++)</span><br><span class="line">    &#123;	</span><br><span class="line">        OLED_WR_Byte(Hzk[<span class="number">2</span>*no+<span class="number">1</span>][t],OLED_DATA);</span><br><span class="line">        adder+=<span class="number">1</span>;</span><br><span class="line">    &#125;					</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********功能描述：显示显示BMP图片128×64起始点坐标(x,y),x的范围0～127，y为页的范围0～7*****************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DrawBMP</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x0, <span class="type">unsigned</span> <span class="type">char</span> y0,<span class="type">unsigned</span> <span class="type">char</span> x1, <span class="type">unsigned</span> <span class="type">char</span> y1,<span class="type">unsigned</span> <span class="type">char</span> BMP[])</span></span><br><span class="line">&#123; 	</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> x,y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(y1%<span class="number">8</span>==<span class="number">0</span>) y=y1/<span class="number">8</span>;      </span><br><span class="line">    <span class="keyword">else</span> y=y1/<span class="number">8</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(y=y0;y&lt;y1;y++)</span><br><span class="line">    &#123;</span><br><span class="line">        OLED_Set_Pos(x0,y);</span><br><span class="line">        <span class="keyword">for</span>(x=x0;x&lt;x1;x++)</span><br><span class="line">        &#123;      </span><br><span class="line">            OLED_WR_Byte(BMP[j++],OLED_DATA);	    	</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化SSD1306					    </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; 	</span><br><span class="line"></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xAE</span>,OLED_CMD);<span class="comment">//--display off</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0x00</span>,OLED_CMD);<span class="comment">//---set low column address</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0x10</span>,OLED_CMD);<span class="comment">//---set high column address</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0x40</span>,OLED_CMD);<span class="comment">//--set start line address  </span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xB0</span>,OLED_CMD);<span class="comment">//--set page address</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0x81</span>,OLED_CMD); <span class="comment">// contract control</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xFF</span>,OLED_CMD);<span class="comment">//--128   </span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xA1</span>,OLED_CMD);<span class="comment">//set segment remap </span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xA6</span>,OLED_CMD);<span class="comment">//--normal / reverse</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xA8</span>,OLED_CMD);<span class="comment">//--set multiplex ratio(1 to 64)</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0x3F</span>,OLED_CMD);<span class="comment">//--1/32 duty</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xC8</span>,OLED_CMD);<span class="comment">//Com scan direction</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xD3</span>,OLED_CMD);<span class="comment">//-set display offset</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0x00</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xD5</span>,OLED_CMD);<span class="comment">//set osc division</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0x80</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xD8</span>,OLED_CMD);<span class="comment">//set area color mode off</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0x05</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xD9</span>,OLED_CMD);<span class="comment">//Set Pre-Charge Period</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xF1</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xDA</span>,OLED_CMD);<span class="comment">//set com pin configuartion</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0x12</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xDB</span>,OLED_CMD);<span class="comment">//set Vcomh</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0x30</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    OLED_WR_Byte(<span class="number">0x8D</span>,OLED_CMD);<span class="comment">//set charge pump enable</span></span><br><span class="line">    OLED_WR_Byte(<span class="number">0x14</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    OLED_WR_Byte(<span class="number">0xAF</span>,OLED_CMD);<span class="comment">//--turn on oled panel</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="oled-h">oled.h</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __OLED_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __OLED_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  u8 unsigned char </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  u32 unsigned int </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_CMD  0	<span class="comment">//写命令</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_DATA 1	<span class="comment">//写数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_MODE 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//OLED模式设置</span></span><br><span class="line"><span class="comment">//0:4线串行模式</span></span><br><span class="line"><span class="comment">//1:并行8080模式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XLevelL		0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XLevelH		0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Max_Column	128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Max_Row		64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	Brightness	0xFF </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_WIDTH 	128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Y_WIDTH 	64	    						  </span></span><br><span class="line"><span class="comment">//-----------------OLED端口定义----------------  					   </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//OLED控制用函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_WR_Byte</span><span class="params">(<span class="type">unsigned</span> dat,<span class="type">unsigned</span> cmd)</span>;  </span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Display_On</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Display_Off</span><span class="params">(<span class="type">void</span>)</span>;	   							   		    </span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Clear</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DrawPoint</span><span class="params">(u8 x,u8 y,u8 t)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Fill</span><span class="params">(u8 x1,u8 y1,u8 x2,u8 y2,u8 dot)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowChar</span><span class="params">(u8 x,u8 y,u8 chr,u8 Char_Size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowNum</span><span class="params">(u8 x,u8 y,u32 num,u8 len,u8 size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowString</span><span class="params">(u8 x,u8 y, u8 *p,u8 Char_Size)</span>;	 </span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Set_Pos</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowCHinese</span><span class="params">(u8 x,u8 y,u8 no)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DrawBMP</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x0, <span class="type">unsigned</span> <span class="type">char</span> y0,<span class="type">unsigned</span> <span class="type">char</span> x1, <span class="type">unsigned</span> <span class="type">char</span> y1,<span class="type">unsigned</span> <span class="type">char</span> BMP[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_50ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> Del_50ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_1ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> Del_1ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fill_picture</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> fill_Data)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Picture</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_IIC_Command</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> IIC_Command)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_IIC_Data</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> IIC_Data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="delay-c">delay.c</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay5us</span><span class="params">()</span>		<span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay30us</span><span class="params">()</span>		<span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data i;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay25ms</span><span class="params">()</span>		<span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data i, j;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">45</span>;</span><br><span class="line">    j = <span class="number">208</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (--j);</span><br><span class="line">    &#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay1000ms</span><span class="params">()</span>    <span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data i, j, k;</span><br><span class="line">    _nop_();</span><br><span class="line">    i = <span class="number">8</span>;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    k = <span class="number">243</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (--k);</span><br><span class="line">        &#125; <span class="keyword">while</span> (--j);</span><br><span class="line">    &#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="delay-h">delay.h</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DELAY_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DELAY_H__</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay5us</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay30us</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay25ms</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay1000ms</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>51单片机</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>1.编译烧录调试</title>
    <url>/post/69f8b9de.html</url>
    <content><![CDATA[<h1><center>交叉编译器安装</center></h1>
<p>进入local，创建文件夹arm，修改arm文件夹权限，进入新创文件夹</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local</span><br><span class="line">sudo <span class="built_in">mkdir</span> arm</span><br><span class="line">sudo chmod <span class="number">777</span> arm</span><br><span class="line"><span class="built_in">cd</span> arm</span><br></pre></td></tr></table></figure>
<p>把交叉编译工具链拷贝到/usr/local/arm文件夹（FTP）</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/03/a9dceS7ovY58VnF.webp" alt="拷贝工具" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>解压压缩包，修改环境变量，重启，测试</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">//解压</span><br><span class="line">sudo tar -vxf gcc-linaro-<span class="number">4</span>.<span class="number">9</span>.<span class="number">4</span>-<span class="number">2017</span>.<span class="number">01</span>-x86_64_arm-linux-gnueabihf.tar.xz</span><br><span class="line"></span><br><span class="line">//修改环境变量</span><br><span class="line">sudo vim /etc/profile</span><br><span class="line">//最后面新一行添加</span><br><span class="line">export <span class="built_in">PATH</span>=$<span class="built_in">PATH</span>:/usr/local/arm/gcc-linaro-<span class="number">4</span>.<span class="number">9</span>.<span class="number">4</span>-<span class="number">2017</span>.<span class="number">01</span>-x86_64_arm-linux-gnueabihf/bin	</span><br><span class="line"></span><br><span class="line">//查看环境变量</span><br><span class="line">env</span><br><span class="line">printenv</span><br><span class="line"><span class="built_in">echo</span> $<span class="built_in">PATH</span></span><br><span class="line"></span><br><span class="line">//重启</span><br><span class="line">sudo reboot</span><br><span class="line">//测试</span><br><span class="line">arm-linux-gnueabihf-gcc -v</span><br><span class="line"></span><br><span class="line">//编译</span><br><span class="line">arm-linux-gnueabihf-gcc 文件名.后缀名 -o 编译后文件名</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/03/WJIy4Gu382DFwbL.webp" alt="成功图" style="zoom: 50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h1><center>烧录</center></h1>
<p>在烧录软件中(\mfgtools_for_6ULL\Profiles\Linux\OS Firmware\files\linux)，固件解析说明</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/13/B54RPCGdWgZtlSb.webp" alt="文件目录解析" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>将板子的拨码开关，设置为<code>USB串行启动</code>，数据线连接到板子上标有<code>OTG</code>的Mini USB口，另一端直接连接电脑USB口</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/13/X1PkZgzEFVLcSIA.png" alt="拨码模式" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>打开烧录软件<code>Mfgtools2</code>，看到烧录软件显示<code>符合 HID 标准的供应商定义设备</code>后，点start开始烧录，一直等待什么都不需要做，等全部变成绿色进度条即完成</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/13/uhKz8lvcWtBGDib.webp" alt="烧录界面" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>烧录完成之后，将板子断电，把拨码拨到<code>EMMC启动</code>，将数据线连接到板子上标有<code>USB-UART</code>的Mini USB口，另一端直接连接电脑USB口，打开串口软件<code>MobaXterm</code>，选择串口，点击<code>OK</code>连接</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/13/uCd7rLoJSeWpNf8.webp" alt="连接串口" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h1>调试</h1>
<blockquote>
<p>[!NOTE]</p>
<p>TFTP：客户端和服务器之间进行文件的传输，远程下载 内核、设备树（<a href="https://www.php.cn/faq/413642.html">参考</a>）</p>
<p>FTP和TFTP之间的区别：<a href="https://www.php.cn/faq/413642.html">链接</a></p>
<p>NFS：允许一个系统在网络上与他人共享目录和文件，挂载网络根文件系统（<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/9719420?fr=ge_ala">参考</a>）</p>
</blockquote>
<h2 id="tftp搭建">tftp搭建</h2>
<p>虚拟机Linux作为服务端，按照下面命令进行配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">//创建文件夹 tftpfile</span><br><span class="line">mkdir tftpfile</span><br><span class="line">sudo chmod 777 tftpfile</span><br><span class="line">sudo apt-get install tftp-hpa tftpd-hpa</span><br></pre></td></tr></table></figure>
<p>修改：<code>sudo vim /etc/default/tftpd-hpa</code>，按图片说明修改</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/20/dmL4kw7qhPAJM39.webp" alt="修改文件" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>重启服务：<code>sudo service tftpd-hpa restart</code></p>
<h2 id="nfs搭建">nfs搭建</h2>
<p>安装</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">//依次运行</span><br><span class="line">sudo apt-get install nfs-kernel-server rpcbind</span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">mkdir</span> nfs</span><br></pre></td></tr></table></figure>
<p>按照图片修改：<code>sudo vim /etc/exports</code>，在最后添加</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">//具体添加内容  路径(刚才创建nfs文件夹路径)</span><br><span class="line">/home/wfeng/nfs  *(rw,sync,no_root_squash)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/20/4Qe1L5kVbhyMADR.webp" alt="修改文件" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>重启nfs服务：<code>sudo /etc/init.d/nfs-kernel-server restart</code></p>
<h2 id="双网卡模式设置">双网卡模式设置</h2>
<h3 id="windows端">Windows端</h3>
<p>将网线接在Windows端和板子上(23/02)，找到Windows上虚拟机的网卡，进入ipv4设置成</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/23/yPDigjUKLICefox.webp" alt="进入设置修改ipv4" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>设置的IP如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/23/qPhGxBkSQJT19mO.webp" alt="IP地址" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<blockquote>
<p>虚拟机设置，记得新建的网卡需要选择板子的网卡</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/23/4gLJKudVIeFObcv.webp" alt="设置虚拟机网卡" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h3 id="ubuntu设置">Ubuntu设置</h3>
<p>在虚拟机界面，编辑虚拟机设置，添加网卡，选择刚创建的网卡</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/28/pOqhEd4cyv3NH6K.png" alt="添加网卡" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>设置完成之后，打开虚拟机，在终端输入<code>ifconfig</code>，查看是否有图片中的双网卡</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/28/c7z3MubCKfDjhBt.png" alt="查看双网卡" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>在虚拟机设置中，按照图片，将添加的网卡修改成手动的ip</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/28/F8ZSiQmvr6U3tyq.png" alt="修改IP" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>再重新<code>ifconfig</code>，查看一下网络，如图所示</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/28/93qhSN8G5UPozTB.png" alt="查看网络" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>使用<code>ping</code>命令，试试看是否主机与虚拟机能否互通</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/29/CfJvg9wn2SLBDoN.png" alt="ping" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>如果虚拟机ping不通主机，可能是主机的防火墙拦截了，需要关闭主机的防火墙，在任务栏放大镜搜索防火墙</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/29/dK6hHC2BxvSVUlW.png" alt="关闭防火墙" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h3 id="板子uboot网络设置">板子Uboot网络设置</h3>
<p>将板子串口连接电脑USB口，打开串口软件(MobaXterm)，波特率：115200，连接之后，重启板子，在倒计时三秒内按键盘任意键进入Uboot设置</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/29/4mYy3pONZh8AcvD.png" alt="进入Uboot" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>查看uboot当前环境变量：<code>printenv </code></p>
<p>修改网络相关环境变量，将下列命令一次配置</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">setenv serverip <span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">220</span>	//服务器IP，linux的IP</span><br><span class="line">setenv gatewayip <span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">1</span>	//网关</span><br><span class="line">setenv ipaddr <span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">120</span>	//开发板uboot的IP地址</span><br><span class="line">setenv netmask <span class="number">255</span>.<span class="number">255</span>.<span class="number">255</span>.<span class="number">0</span>	//子网掩码</span><br><span class="line">setenv ethaddr <span class="number">42</span>:<span class="number">03</span>:<span class="number">07</span>:<span class="number">3</span>B:<span class="number">15</span>:<span class="number">5</span>F	//设置网卡地址</span><br><span class="line">saveenv	//保存环境变量</span><br><span class="line">reset	//重启</span><br></pre></td></tr></table></figure>
<p>测试是否配置完成，重启板子，重新进入Uboot，使用ping虚拟机以及主机</p>
<blockquote>
<p>[!NOTE]</p>
<p>虚拟机和windows通过ping uboot 是不通的，因为uboot代码里面没有ping回复机制，或者说没有相关代码</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/29/O2ajFXDAY1qxsMH.png" alt="测试Uboot网络" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>恢复uboot默认环境变量</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">env default -a</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure>
<h2 id="修改uboot引导方式">修改uboot引导方式</h2>
<p>把 kernel 中的 zImage 放在 tftpfile 文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/home/xinzai/linux/kernel/linux-imx-rel_imx_4.1.15_2.1.0_ga/arch/arm/boot/</span><br></pre></td></tr></table></figure>
<p>把 设备树 文件夹中 topeet_emmc_hdmi.dtb 放在 tftpfile 文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/home/xinzai/linux/kernel/linux-imx-rel_imx_4.1.15_2.1.0_ga/arch/arm/boot/dts/</span><br></pre></td></tr></table></figure>
<p>修改bootcmd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试：</span><br><span class="line">tftp 80800000 zImage;	//下载内核</span><br><span class="line">tftp 83800000 topeet_emmc_hdmi.dtb;	//下载设备树</span><br><span class="line">bootz 80800000 - 83800000	//启动</span><br><span class="line"></span><br><span class="line">设置：</span><br><span class="line">setenv bootcmd &#x27;tftp 80800000 zImage; tftp 83800000 topeet_emmc_hdmi.dtb; bootz 80800000 - 83800000&#x27;</span><br></pre></td></tr></table></figure>
<p>修改bootargs，注意：<code>xinzai</code> 需要修改成自己的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/nfs rw nfsroot=192.168.2.220:/home/xinzai/nfs ip=192.168.2.120:192.168.2.220:192.168.2.1:255.255.255.0::eth0:off&#x27;</span><br></pre></td></tr></table></figure>
<p>保存：<code>saveenv</code></p>
<p>重启：<code>reset</code></p>
<p>出现nfs挂载失败问题</p>
<blockquote>
<p>[!WARNING]</p>
<p>Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(2,0) [  102.086444] —[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(2,0) [  102.984808] random: nonblocking pool is initialized</p>
</blockquote>
<p>在Ubuntu中输入命令，并在末尾添加内容（前面不要有#）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/default/nfs-kernel-server</span><br><span class="line"></span><br><span class="line">//添加</span><br><span class="line">RPCNFSDOPTS=&quot;--nfs-version 2,3,4 --debug --syslog&quot;</span><br></pre></td></tr></table></figure>
<p>重启nfs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/nfs-kernel-server restart</span><br></pre></td></tr></table></figure>
<p>挂载成功后，用户名：root，密码：topeet</p>
<h1>应用</h1>
<p>应用编译：用交叉编译将写好的.c文件编译出来（app文件夹）</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc app.c -o app -lm</span><br></pre></td></tr></table></figure>
<p>编译驱动（\app_drv\drv）</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">//编译，生成.o文件</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">//清除</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure>
<p>将编译后的文件拷贝到根文件系统目录下(nfs)</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">//创建文件夹存放</span><br><span class="line"><span class="built_in">mkdir</span> oled_6050</span><br><span class="line"></span><br><span class="line">//复制编译后文件</span><br><span class="line">cp app ~/nfs/oled_6050/</span><br><span class="line">//复制驱动</span><br><span class="line"> cp *.ko ~/nfs/oled_6050/</span><br></pre></td></tr></table></figure>
<p>加载驱动（在串口端）</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">insmod mpu6050_drv.ko</span><br><span class="line">insmod oled_drv.ko</span><br><span class="line"></span><br><span class="line">//卸载驱动</span><br><span class="line">rmmod mpu6050_drv.ko</span><br><span class="line"></span><br><span class="line">//查看驱动</span><br><span class="line">lsmod</span><br><span class="line"></span><br><span class="line">//运行</span><br><span class="line">./app</span><br></pre></td></tr></table></figure>
<p>修改设备树</p>
<p>在 <code>\linux\kernel\linux-imx-rel_imx_4.1.15_2.1.0_ga\arch\arm\boot\dts</code> 找到 <code>imx6ull-14x14-evk</code></p>
<p>添加oled设备树，oled地址原本是0x78，但这里只需要高7位，最低位是读写位，不需要，则为3c</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/11/08/WZIr4YNV31vnlbU.png" alt="修改设备树文件" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>虚拟文件系统(<a href="https://www.cnblogs.com/1441760655-Jansert/p/10800025.html">参考</a>)：提供一种统一的接口，使得用户空间程序可以通过文件系统的方式来访问各种设备和资源</p>
<h2 id="自启动">自启动</h2>
<p><a href="http://xn--run-th2el20d.sh">创建run.sh</a> (串口)，路径：/oled_6050</p>
<p>&amp;：后台执行程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建</span><br><span class="line">vi run.sh</span><br><span class="line"></span><br><span class="line">insmod /oled_6050/mpu6050_drv.ko</span><br><span class="line">insmod /oled_6050/oled_drv.ko</span><br><span class="line">./oled_6050/app&amp;</span><br></pre></td></tr></table></figure>
<p>自启动修改文件(<a href="https://blog.51cto.com/lwc0329/5064229">参考</a>)</p>
<p>在 /etc/init.d/rcS(串口端)，在最后一行添加（也可以在这/etc/rc.local）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./oled_6050/run.sh</span><br></pre></td></tr></table></figure>
<p>后续启动后，会自动运行 <a href="http://run.sh">run.sh</a> 但不会自动停止需要手动杀掉进程(不用管打印字节登陆即可)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//查看进程</span><br><span class="line">ps</span><br><span class="line"></span><br><span class="line">//杀死进程</span><br><span class="line">kill -9 进程号</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>7.电机控制</title>
    <url>/post/93c966f3.html</url>
    <content><![CDATA[<h1><center>直流电机</center></h1>
<p>原理：<a href="https://www.bilibili.com/video/BV1PM4y1w79m/?t=3.337014&amp;spm_id_from=333.1350.jump_directly&amp;vd_source=1c838941386ee32c4501615c317f75e0">链接</a></p>
<p>转速：脉冲宽度调制（Pulse width modulation，PWM）</p>
<p>周期（频率）、占空比</p>
<img src="https://s2.loli.net/2024/08/19/MmX4ZYH7wyogTUp.png" alt="电机变速解析图" style="zoom: 67%;">
<h2 id="center-电机驱动电路-center"><center>电机驱动电路</center></h2>
<img src="https://s2.loli.net/2024/08/19/V32t68Y1DOghCiI.png" alt="驱动实物图" style="zoom:50%;">
<h2 id="center-代码编写-center"><center>代码编写</center></h2>
<p>按键控制直流电机速度</p>
<h3 id="main-c">main.c</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>,level = <span class="number">7</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    TR0 = <span class="number">1</span>;</span><br><span class="line">    TH0 = <span class="number">0xDC</span>;</span><br><span class="line">    TL0 = <span class="number">0x00</span>;</span><br><span class="line">    TMOD = <span class="number">0x01</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;</span><br><span class="line">    EA =<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(KEY1 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Delay120ms();</span><br><span class="line">            <span class="keyword">if</span>(KEY1 == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                level++;</span><br><span class="line">                level = level % <span class="number">10</span>;	<span class="comment">//到10才清理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mian-h">mian.h</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MAIN_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MAIN_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="comment">//定义LED、按键</span></span><br><span class="line">sbit LED1 = P1^<span class="number">0</span>;</span><br><span class="line">sbit KEY1 = P3^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> count,level;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="time-c">time.c</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="comment">//定时中断</span></span><br><span class="line">Timer0_Routine(<span class="type">void</span>) interrupt <span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">    TH0 = <span class="number">0xDC</span>;</span><br><span class="line">    TL0 = <span class="number">0x00</span>;</span><br><span class="line">    count++;	<span class="comment">//每次定时中断加1</span></span><br><span class="line">    <span class="keyword">if</span>(count &gt; level)	<span class="comment">//level越大，占空比越小速度越慢</span></span><br><span class="line">        LED1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        LED1 = <span class="number">0</span>;</span><br><span class="line">    count = count % <span class="number">10</span>;	<span class="comment">//到10清零</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="delay-c">delay.c</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="comment">//延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay120ms</span><span class="params">()</span>	<span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data i, j;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">216</span>;</span><br><span class="line">    j = <span class="number">37</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (--j);</span><br><span class="line">    &#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="delay-h">delay.h</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DELAY_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DELAY_H__</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay120ms</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>练习：直流电机与iic通信连接oled屏，显示电机转速等级数字</p>
<h1><center>步进电机</center></h1>
<p>原理：<a href="https://www.bilibili.com/video/BV1nA4m1A7Ke/?t=93.445511&amp;spm_id_from=333.1350.jump_directly&amp;vd_source=1c838941386ee32c4501615c317f75e0">链接</a></p>
<h2 id="center-代码编写-center"><center>代码编写</center></h2>
<h3 id="main-c">main.c</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">uchar phasecw[<span class="number">4</span>] =&#123;<span class="number">0x08</span>,<span class="number">0x04</span>,<span class="number">0x02</span>,<span class="number">0x01</span>&#125;;	<span class="comment">//正向，四相电机对应四相通电</span></span><br><span class="line">uchar phaseccw[<span class="number">4</span>]=&#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>&#125;;	<span class="comment">//方向</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(x = <span class="number">0</span>;x &lt; <span class="number">100</span>;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(y = <span class="number">0</span>;y &lt; <span class="number">4</span>;y++)	<span class="comment">//四相通电转的角度</span></span><br><span class="line">        &#123;</span><br><span class="line">            P2 = phasecw[y];	<span class="comment">//电机连接P2口(低四位)</span></span><br><span class="line">            Delay5ms();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main-h">main.h</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MAIN_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MAIN_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> uchar;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="delay-c">delay.c</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay5ms</span><span class="params">()</span>		<span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data i, j;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">9</span>;</span><br><span class="line">    j = <span class="number">244</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (--j);</span><br><span class="line">    &#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="delay-h">delay.h</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DELAY_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DELAY_H__</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay5ms</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>练习：OLED屏显示步进电机前进还是后退(前进1，后退0)，按键控制步进电机前进还是后退</p>
<h1><center>舵机控制</center></h1>
<p>角度：180/360度（这里舵机180度）</p>
<p>模型图：</p>
<img src="https://s2.loli.net/2024/08/19/9VwGfBn6ckoaOgF.png" alt="展示接线图" style="zoom:50%;">
<p>信号说明：</p>
<p>舵机脉冲周期：20ms</p>
<img src="https://s2.loli.net/2024/08/19/TKDGAjsdvbJgBuz.png" alt="信号使用说明" style="zoom:50%;">
<h2 id="center-代码编写-center"><center>代码编写</center></h2>
<p>舵机180度控制旋转</p>
<h3 id="main-c">main.c</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> level = <span class="number">0</span>,count = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    TR0 = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//定时器时间：0.5ms</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>;</span><br><span class="line">    TL0 = <span class="number">0x33</span>;</span><br><span class="line">    TH0 = <span class="number">0xFE</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;</span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(KEY1 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Delay120ms();</span><br><span class="line">            <span class="keyword">if</span>(KEY1 == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                level++;</span><br><span class="line">                level = level % <span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Timer0_Routine(<span class="type">void</span>) interrupt <span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">    TL0 = <span class="number">0x33</span>;</span><br><span class="line">    TH0 = <span class="number">0xFE</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    level为1时，脉冲为1，持续时间0.5ms，转动角度为0，但按键延迟120ms，早过一个周期，</span></span><br><span class="line"><span class="comment">    则下次按键时count为0，则持续时间为1ms，转动角度为45，以此类推，下次转动90，</span></span><br><span class="line"><span class="comment">    但上一次已经转了45，所以实际再转45就到90度，当到达180度时，level为1时，转动0度，</span></span><br><span class="line"><span class="comment">    相当于回到原点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(count &lt; level)</span><br><span class="line">        SG90_PWM = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        SG90_PWM = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">//周期20ms，0.5ms一次定时中断触发，40次则20ms</span></span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">40</span>)</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main-h">main.h</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MAIN_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MAIN_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit SG90_PWM = P2^<span class="number">0</span>;</span><br><span class="line">sbit KEY1 = P3^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="delay-c">delay.c</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay120ms</span><span class="params">()</span>		<span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data i, j;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">216</span>;</span><br><span class="line">    j = <span class="number">37</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (--j);</span><br><span class="line">    &#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="delay-h">delay.h</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DELAY_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DELAY_H__</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay120ms</span><span class="params">()</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>练习：OLED屏显示数字代表舵机旋转角度，按键控制舵机角度</p>
]]></content>
      <categories>
        <category>51单片机</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>2.系统编译</title>
    <url>/post/dd99ee0d.html</url>
    <content><![CDATA[<h1>Uboot</h1>
<p>安装编译必用工具：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install lzop  libncurses5-dev u-boot-tools</span><br></pre></td></tr></table></figure>
<p>创建文件夹，创建完成之后，将Uboot源代码复制复制到Linux中(FTP)，解压文件，编译文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir linux</span><br><span class="line">cd linux</span><br><span class="line">mkdir uboot</span><br><span class="line"></span><br><span class="line">//解压</span><br><span class="line">tar -xvf uboot-imx-rel_imx_4.1.15_2.1.0_ga_20200512.tar.gz</span><br><span class="line"></span><br><span class="line">//编译文件</span><br><span class="line">./create.sh</span><br></pre></td></tr></table></figure>
<p>u-boot.bin和u-boot.imx的区别：<a href="https://www.cnblogs.com/fah936861121/articles/7248430.html">参考链接</a></p>
<h2 id="流程">流程</h2>
<blockquote>
<p>汇编部分</p>
</blockquote>
<p>关闭：中断、看门狗、cache、mmu… --&gt; 进入SVC模式 --&gt; 基本硬件初始化(时钟、串口、flash、内存) --&gt; 初始化堆栈 --&gt; 自搬移(将汇编中的C语言从flash中移到内存中)</p>
<blockquote>
<p>C语言部分</p>
</blockquote>
<p>大部分硬件初始化(网卡、USB、屏幕…) --&gt; 把内核搬到内存</p>
<h2 id="uboot源码简要分析">Uboot源码简要分析</h2>
<h3 id="汇编部分">汇编部分</h3>
<blockquote>
<p>在项目中arch/arm/lib/vectors.S，开始运行之后跳转到reset</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/13/2WPMVwXc39t5ZiH.png" alt="源码分析1" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<blockquote>
<p>arch/arm/cpu/armv7/start.S，找到开始文件(start.S)，跳转到<code>cpu_init_cp15</code>、<code>cpu_init_crit</code>、<code>_main</code></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/13/YuSVxEvk1qdBOAj.png" alt="源码分析2" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<blockquote>
<p>在start.S文件内，找到<code>cpu_init_cp15</code>、<code>cpu_init_crit</code>(跳转到cpu_init_crit)</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/13/ZhrOB1JWySUxwA6.webp" alt="源码分析3" style="zoom:50%;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="https://s2.loli.net/2024/10/13/lsMF6qYR23mBcfy.webp" alt="源码分析4" style="zoom:40%;"></td>
</tr>
</tbody>
</table>
<blockquote>
<p>arch/arm/cpu/armv7/lowlevel_init.S，<code>lowlevel_init.S</code>运行结束后再运行<code>_main</code></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/13/kazdBxF93uDiRnI.png" alt="源码分析5" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<blockquote>
<p><code>_main</code>在： arch/arm/lib/crt0.S，最后跳转到C语言部分的<code>board_init_f</code>和<code>board_init_r</code></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/13/uqLXJbPzl4naDy5.webp" alt="源码分析6"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h3 id="c语言部分">C语言部分</h3>
<blockquote>
<p>在项目中的common/board_f.c，看board_init_f</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/13/6BnIZWm8yV43dFi.png" alt="源码分析7" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<blockquote>
<p>在项目中的common/board_r.c，看board_init_r</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/13/ObKmMeBwgunHWqT.webp" alt="源码分析8" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<blockquote>
<p>在项目中的 common/main.c，看main.c的<code>main_loop</code></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/10/13/EPdT45JV6bxlrOs.png" alt="源码分析9" style="zoom:40%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="脚本分析-create-sh">脚本分析(<a href="http://create.sh">create.sh</a>)</h2>
<ul>
<li>
<p>.config：配置那些需要编译(-y)，如果注释了就不需要编译的</p>
</li>
<li>
<p>Makefile：根据.config文件中的配置进行编译，也就是哪些东西需要编译进去</p>
</li>
</ul>
<p>在Linux中修改.config方法(图形化配置)：<code>make menuconfig</code></p>
<p>增加或删除图形化配置选项：在drivers\rtc中的Kconfig修改，然后在进入，勾选需要编译的模块保存之后生效在.config文件，Makefile编译进去</p>
<h1>kernel(内核)</h1>
<p>将迅为内核源码拷贝进Linux虚拟机 ，然后解压并编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//解压</span><br><span class="line">tar -xvf linux-imx-rel_imx_4.1.15_2.1.0_ga_20200903.tar.gz</span><br><span class="line">//进入解压后的文件夹</span><br><span class="line">cd linux-imx-rel_imx_4.1.15_2.1.0_ga</span><br><span class="line">//编译</span><br><span class="line">./create.sh</span><br></pre></td></tr></table></figure>
<p>内核镜像：</p>
<ul>
<li>
<p>路径：<code>arch/arm/boot</code>，Image(非压缩文件)、uImage与zImage的区别：<a href="https://blog.csdn.net/xuxin314012316/article/details/82621002">参考</a>，这里使用uImage</p>
<ul>
<li>Image：原镜像文件</li>
<li>uImage：uboot专用的映像文件，在zImage之前加上一个长度为64字节的“头”，说明这个内核的版本、加载位置、生成时间、大小等信息</li>
<li>zImage：内核的一种映像压缩文件</li>
</ul>
</li>
<li>
<p>路径：arch/arm/boot/dts，设备树</p>
</li>
</ul>
<p>内核源码目录结构详细参考：<a href="https://blog.csdn.net/weixin_52622200/article/details/135411217">地址</a></p>
<p>drivers：包含了各种设备驱动程序的源代码，Linux 内核通过这些驱动程序与硬件设备进行交互和管理</p>
<p>net：与网络协议栈相关的目录，它包含了各种网络协议和网络设备驱动程序的实现</p>
<h2 id="脚本分析-create-sh">脚本分析(<a href="http://create.sh">create.sh</a>)</h2>
<p><code>#!/bin/bash</code> ：指定脚本使用 Bash 解释器的 shebang 语句。它出现在脚本的第一行，并告诉操作系统使用 Bash 解释器来执行该脚本。参考：<a href="https://www.jb51.net/jiaoben/307768w9h.htm">网址</a></p>
<p>make imx_v7_defconfig(arch\arm\configs)：预定义的配置文件，适用于i.MX6ULL EVK开发板的内核配置文件</p>
<p>.config(源码根目录)：配置哪些需要编译</p>
<p>Makefile：根据.config文件中的配置进行编译，也就是哪些东西需要编译进去</p>
<p>make modules命令：将驱动编译成模块（.ko 文件），然后加载到内核。<a href="https://blog.csdn.net/jinking01/article/details/132699750">参考</a></p>
<p>驱动编译两种方式</p>
<ul>
<li>驱动编译进内核(obj-y)</li>
<li>驱动编译成ko文件(obj-m)</li>
</ul>
<h1>设备树</h1>
<p>功能：包含芯片&amp;板子等外设信息，系统驱动会匹配设备树，匹配成功后加载驱动</p>
<p>文件路径：<code>arch/arm/boot/dts</code></p>
<p>dts(源代码)：</p>
<ul>
<li>dtsi：描述SoC(系统芯片)的内部外设信息，如CPU架构、主频、外设寄存器地址范围等</li>
<li>dts：板级配置文件，包含了特定硬件平台的详细配置信息</li>
<li>topeet_emmc_hdmi.dts(屏幕)(头文件包含下一个文件) -&gt; imx6ull-14x14-evk-emmc.dts -&gt; imx6ull-14x14-evk.dts -&gt; imx6ull.dtsi</li>
</ul>
<p>dtc(编译器)：编译，反编译(dtc -I dtb -O dts -o test001.dts topeet_emmc_hdmi.dtb)</p>
<p>dtb(设备树编译后的二进制文件)</p>
<h1>根文件系统</h1>
<p>含义：<a href="https://www.cnblogs.com/Wangzx000/p/16684484.html">参考</a></p>
<p>制作：<a href="https://blog.csdn.net/weixin_59665492/article/details/118681742">参考</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>0.线程创建与删除</title>
    <url>/post/520176db.html</url>
    <content><![CDATA[<h1><center>动态线程创建</center></h1>
<h2 id="创建">创建</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * name：线程名字，entry：线程的入口函数，parameter：函数参数</span></span><br><span class="line"><span class="comment"> * stack_size：线程堆栈的大小，priority：优先级，tick：时间片(运行长短)(相同优先级的线程)</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *		成功：线程控制块指针，失败：RT_NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_thread_t</span> <span class="title function_">rt_thread_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                             <span class="type">void</span> (*entry)(<span class="type">void</span> *parameter),</span></span><br><span class="line"><span class="params">                             <span class="type">void</span>       *parameter,</span></span><br><span class="line"><span class="params">                             <span class="type">rt_uint32_t</span> stack_size,</span></span><br><span class="line"><span class="params">                             <span class="type">rt_uint8_t</span>  priority,</span></span><br><span class="line"><span class="params">                             <span class="type">rt_uint32_t</span> tick)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个rt_thread_t类型指针变量接收返回值</span></span><br><span class="line"><span class="type">rt_thread_t</span> th1_ptr;</span><br><span class="line"><span class="comment">//创建一个线程入口函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">th1_printf</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//串口打印函数，__FILE__：打印所在目录及文件名</span></span><br><span class="line">        <span class="comment">//__FUNCTION__：打印函数名(th2_printf)，__LINE__：打印这个语句在第几行</span></span><br><span class="line">        rt_kprintf(<span class="string">&quot;In %s, the %s is runing the %d!\r\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);	</span><br><span class="line">        rt_thread_mdelay(<span class="number">1000</span>);	<span class="comment">//延时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line">th1_ptr = rt_thread_create(<span class="string">&quot;th1&quot;</span>, th1_printf, <span class="literal">NULL</span>, <span class="number">1024</span>, <span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断线程是否创建成功</span></span><br><span class="line"><span class="keyword">if</span>(th1_ptr == RT_NULL)</span><br><span class="line">&#123;</span><br><span class="line">    LOG_E(<span class="string">&quot;th1_printf rt_thread_create failed!\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -RT_ENOMEM;	<span class="comment">//RT_ENOMEM：12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">rt_thread_startup(th1_ptr);</span><br></pre></td></tr></table></figure>
<h2 id="启动线程">启动线程</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义 thread：要启动的线程</span></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_startup</span><span class="params">(<span class="type">rt_thread_t</span> thread)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="title function_">rt_thread_startup</span><span class="params">(th1_ptr)</span>;</span><br></pre></td></tr></table></figure>
<h1><center>静态线程创建</center></h1>
<h2 id="创建">创建</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * thread：线程控制块指针(struct rt_thread类型结构体指针)，name：线程名字</span></span><br><span class="line"><span class="comment"> * entry：线程的入口函数，parameter：函数参数，stack_start：线程栈的起始地址</span></span><br><span class="line"><span class="comment"> * stack_size：线程堆栈的大小，priority：优先级，tick：时间片(运行长短)(单位毫秒)</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_init</span><span class="params">(<span class="keyword">struct</span> rt_thread *thread,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span>       *name,</span></span><br><span class="line"><span class="params">                        <span class="type">void</span> (*entry)(<span class="type">void</span> *parameter),</span></span><br><span class="line"><span class="params">                        <span class="type">void</span>             *parameter,</span></span><br><span class="line"><span class="params">                        <span class="type">void</span>             *stack_start,</span></span><br><span class="line"><span class="params">                        <span class="type">rt_uint32_t</span>       stack_size,</span></span><br><span class="line"><span class="params">                        <span class="type">rt_uint8_t</span>        priority,</span></span><br><span class="line"><span class="params">                        <span class="type">rt_uint32_t</span>       tick)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建struct rt_thread类型的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> <span class="title">th2_ptr</span>;</span></span><br><span class="line"><span class="comment">//创建一个数组用于存放线程执行时需要的空间</span></span><br><span class="line"><span class="type">rt_uint8_t</span> th2_stack[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个线程入口函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">th2_printf</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//串口打印函数，__FILE__：打印所在目录及文件名</span></span><br><span class="line">        <span class="comment">//__FUNCTION__：打印函数名(th2_printf)，__LINE__：打印这个语句在第几行</span></span><br><span class="line">        rt_kprintf(<span class="string">&quot;In %s, the %s is runing the %d!\r\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        rt_thread_mdelay(<span class="number">1000</span>);	<span class="comment">//延时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line">rt_thread_init(&amp;th2_ptr, <span class="string">&quot;th2&quot;</span>, th2_printf, <span class="literal">NULL</span>, th2_stack, <span class="number">1024</span>, <span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断线程是否创建成功</span></span><br><span class="line"><span class="keyword">if</span>(ret == RT_EOK)</span><br><span class="line">&#123;</span><br><span class="line">    LOG_E(<span class="string">&quot;th2_printf rt_thread_create failed!\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行</span></span><br><span class="line">rt_thread_startup(&amp;th2_ptr);</span><br></pre></td></tr></table></figure>
<h1><center>动态、静态线程删除</center></h1>
<blockquote>
<p>动态删除</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义 thread：要删除的线程</span></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_delete</span><span class="params">(<span class="type">rt_thread_t</span> thread)</span></span><br><span class="line">    </span><br><span class="line"><span class="title function_">rt_thread_delete</span><span class="params">(th1_ptr)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态删除</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义 thread：要删除的线程</span></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_delete</span><span class="params">(<span class="type">rt_thread_t</span> thread)</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">rt_thread_detach</span><span class="params">(&amp;th2_ptr)</span>;  <span class="comment">//删除线程</span></span><br></pre></td></tr></table></figure>
<h1><center>线程基础知识</center></h1>
<blockquote>
<p>线程状态</p>
</blockquote>
<p><img src="https://s2.loli.net/2024/09/13/X1PbKpsGM5ioxyr.jpg" alt="线程状态"></p>
<blockquote>
<p>优先级</p>
</blockquote>
<p>RTOS通过线程的优先级来抢占调度线程</p>
<p>高优先级的任务先运行，低优先级任务会被高优先级任务打断，被抢占的任务会进入就绪态</p>
<p>线程中不能有死循环，必须有挂起操作(线程状态图中的1或延时)</p>
<blockquote>
<p>时间片</p>
</blockquote>
<p>在线程优先级相同的情况下，通过时间片来控制相同优先级线程执行时间</p>
]]></content>
      <categories>
        <category>RT-Thread</category>
      </categories>
      <tags>
        <tag>RT-Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>4.Linux应用编程</title>
    <url>/post/9d10e9f6.html</url>
    <content><![CDATA[<p>C语言各种版本发展史(<a href="https://www.cnblogs.com/god-of-death/p/8017414.html">参考</a>)，C89 和 C99 区别(<a href="https://www.cnblogs.com/xiaoyoucai/p/6146784.html">参考</a>)</p>
<p>查看编译器C版本方法： <code>gcc -E -dM - &lt;/dev/null | grep &quot;STDC_VERSION&quot;</code></p>
<p>Linux下编译C代码的指令：<code>gcc main.c -o 生成文件名</code></p>
<p>Linux下指定c版本编译指令：<code> gcc -std=c89 main.c -o main</code></p>
<p>查看C语言的语法说明：<code>man 查询的函数等</code></p>
<h1>编译器和编译脚本</h1>
<p>源代码(.c) --&gt;(预处理) 预处理文件(.i) --&gt;(编译) 汇编文件(.s) --&gt;(汇编) 目标文件(.o) --&gt;(链接) 可执行文件(.exe)</p>
<p>各个编译器的区别：<a href="https://cloud.tencent.com/developer/article/2032451">参考</a></p>
<p>GNU工具集：<a href="https://www.cnblogs.com/kele-dad/p/9394568.html">参考</a></p>
<p>GCC基本编译规则</p>
<ul>
<li>-c 预编译</li>
<li>-o 链接</li>
<li>-D define宏链接</li>
<li>-O 编译优化</li>
<li>-g Debug调试</li>
<li>-I 添加头文件遍历</li>
<li>-Wall 显示编译警告</li>
</ul>
<p>Makefile基本语法：<a href="https://blog.csdn.net/wohu1104/article/details/110905996">参考</a></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">targets : prerequisites</span><br><span class="line">    command</span><br><span class="line"><span class="comment">#targets：规则的目标，是必须要有的，可以是 Object File（一般称它为中间文件）也可以是可执行文件，还可以是一个标签</span></span><br><span class="line"><span class="comment">#prerequisites：是我们的依赖文件，要生成 targets 需要的文件或者是目标。可以是多个，用空格隔开，也可以是没有</span></span><br><span class="line"><span class="comment">#command：make 需要执行的命令（任意的 shell 命令）。可以有多条命令，每一条命令占一行，如果 command 太长, 可以用 \ 作为换行符 </span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置编译器为gcc</span></span><br><span class="line">CC = gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置生成的目标文件名为main</span></span><br><span class="line">TARGET = main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源代码文件列表，这里有两个源文件：main.c 和 hello_pr.c</span></span><br><span class="line">SRCS = main.c hello_pr.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从源代码文件名生成目标对象文件名（将 .c 替换为 .o）</span></span><br><span class="line">OBJS = $(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含头文件的目录路径</span></span><br><span class="line">INCS = -I ./Inc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认执行的任务是all，即编译程序</span></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个规则说明如何从目标对象文件生成最终可执行文件</span></span><br><span class="line"><span class="comment"># $^ 表示所有依赖项（这里是所有的 .o 文件）</span></span><br><span class="line"><span class="comment"># $@ 表示目标文件（这里是 main）</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line"><span class="comment"># 打印源代码文件列表</span></span><br><span class="line">	echo <span class="variable">$(SRCS)</span></span><br><span class="line"><span class="comment"># 打印目标对象文件列表</span></span><br><span class="line">	echo <span class="variable">$(OBJS)</span></span><br><span class="line"><span class="comment"># 使用编译器链接所有目标对象文件并生成可执行文件</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(INCS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个规则说明如何从单个源代码文件生成对应的目标文件(.o)</span></span><br><span class="line"><span class="comment"># $&lt; 表示第一个依赖项（这里是对应的 .c 文件）</span></span><br><span class="line"><span class="comment"># %.o:%.c 是一个模式匹配规则，表示任何 .c 文件都可以通过这个规则生成对应的 .o 文件</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">	<span class="comment"># 使用编译器将 .c 文件编译成 .o 文件</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(INCS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理任务，删除所有中间文件和生成的可执行文件</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 伪目标，makefile中存在的指令作为系统指令处理</span></span><br><span class="line"><span class="comment"># 防止工程中有同样名字的可执行文件，如果没有这个可能会执行可执行文件而不是执行命令</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all clean</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello_pr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    hello_print_func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hello_pr.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello_pr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hello_print_func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%s:%d]hello func\r\n&quot;</span>,__FUNCTION__,__LINE__);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hello_pr.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __HELLO_PR_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HELLO_PR_H__</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hello_print_func</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>优化版的Makefile</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#软件版本号</span></span><br><span class="line">VERSION	=	1.00</span><br><span class="line"><span class="comment">#生成的可执行的名字</span></span><br><span class="line">TARGET	=	app</span><br><span class="line"></span><br><span class="line"><span class="comment"># :=		//直接赋值 </span></span><br><span class="line"><span class="comment"># ?=		//判断环境变量或者makefile脚本中是否已经定义此变量，如果定义就直接使用原有的定义</span></span><br><span class="line"><span class="comment"># +=		//累加操作，将我们执行的命令 逐一添加在变量的后方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#交叉编译环境的定义</span></span><br><span class="line">CROSS_COMPILE = </span><br><span class="line"></span><br><span class="line"><span class="comment">#gcc</span></span><br><span class="line"><span class="comment">#GCC 指令的定义</span></span><br><span class="line">CC      := <span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line">CXX     := <span class="variable">$(CROSS_COMPILE)</span>g++</span><br><span class="line">LD      := <span class="variable">$(CROSS_COMPILE)</span>ld</span><br><span class="line">AR      := <span class="variable">$(CROSS_COMPILE)</span>ar</span><br><span class="line">AS      := <span class="variable">$(CROSS_COMPILE)</span>as</span><br><span class="line">NM      := <span class="variable">$(CROSS_COMPILE)</span>nm</span><br><span class="line">OBJDUMP := <span class="variable">$(CROSS_COMPILE)</span>objdump</span><br><span class="line">OBJCOPY := <span class="variable">$(CROSS_COMPILE)</span>objcopy</span><br><span class="line">SIZE    := <span class="variable">$(CROSS_COMPILE)</span>size</span><br><span class="line"></span><br><span class="line"><span class="comment">#DUSE_DEBUG 开启GDB调试功能</span></span><br><span class="line">DEBUG   =	-DUSE_DEBUG</span><br><span class="line"></span><br><span class="line"><span class="comment">#编译参数和编译宏的添加</span></span><br><span class="line"><span class="comment">#在编译时显示所有的警告信息</span></span><br><span class="line">CFLAGS  =	-Wall</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加源文件的路径</span></span><br><span class="line">SRC_C = .</span><br><span class="line">SRC_C += test</span><br><span class="line"></span><br><span class="line"><span class="comment">#引用头文件路径</span></span><br><span class="line">INCLUDES =	./Inc </span><br><span class="line">INCLUDES += ./test_Inc</span><br><span class="line"></span><br><span class="line"><span class="comment">#Lib 名</span></span><br><span class="line">LIB_NAMES  =			</span><br><span class="line"><span class="comment">#Lib 目录</span></span><br><span class="line">LIB_PATH  = ./SRC ./Pay_SRC</span><br><span class="line"></span><br><span class="line">SOURCES := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(SRC_C)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.c)</span>)</span><br><span class="line"><span class="comment">#-I./Inc -I./test_Inc</span></span><br><span class="line">INC_FLAGS = <span class="variable">$(<span class="built_in">addprefix</span> -I,<span class="variable">$(INCLUDES)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用单个Lib库</span></span><br><span class="line">LIB_NAME_FLAGS = <span class="variable">$(<span class="built_in">addprefix</span> -l,<span class="variable">$(LIB_NAMES)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用lib库路径下的多个lib库</span></span><br><span class="line"><span class="comment"># -L./SRC -L./Pay_SRC</span></span><br><span class="line">LIB_PATH_FLAGS = <span class="variable">$(<span class="built_in">addprefix</span> -L,<span class="variable">$(LIB_PATH)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#把对应的.c-&gt;.o</span></span><br><span class="line"><span class="comment">#OBJ = $(SOURCES:.c=.o)</span></span><br><span class="line">OBJ   =<span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(SOURCES)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#links 链接</span></span><br><span class="line"><span class="comment"># app:$(SOURCES:.c=.o)</span></span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJ)</span></span><br><span class="line"><span class="comment">#创建output目录</span></span><br><span class="line">	@mkdir -p output</span><br><span class="line"><span class="comment">#输出生成的.o文件	</span></span><br><span class="line">	@echo <span class="string">&quot;obj file:&quot;</span> <span class="variable">$(OBJ)</span></span><br><span class="line"><span class="comment">#输出生成的.c文件	</span></span><br><span class="line">	@echo <span class="string">&quot;.c file:&quot;</span> <span class="variable">$(SOURCES)</span></span><br><span class="line"><span class="comment">#执行链接过程	</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(OBJ)</span> <span class="variable">$(LIB_PATH_FLAGS)</span> <span class="variable">$(LIB_NAME_FLAGS)</span> -o output/<span class="variable">$(TARGET)</span><span class="variable">$(VERSION)</span></span><br><span class="line"><span class="comment">#删除过程.o文件	</span></span><br><span class="line">	@rm -rf <span class="variable">$(OBJ)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#compile 编译</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	@echo <span class="string">&quot;INC out:&quot;</span> <span class="variable">$(INC_FLAGS)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(INC_FLAGS)</span> <span class="variable">$(DEBUG)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#clean清理编译产物</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	@echo <span class="string">&quot;Remove linked and compiled files......&quot;</span></span><br><span class="line">	rm -rf <span class="variable">$(OBJ)</span> <span class="variable">$(TARGET)</span><span class="variable">$(VERSION)</span> output</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>1.线程相关函数</title>
    <url>/post/54659a9b.html</url>
    <content><![CDATA[<h1><center>线程休眠</center></h1>
<blockquote>
<p>rt_thread_mdelay、rt_thread_sleep、rt_thread_delay</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//thread.c 740行</span></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_mdelay</span><span class="params">(<span class="type">rt_int32_t</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rt_tick_t</span> tick;</span><br><span class="line"></span><br><span class="line">    tick = rt_tick_from_millisecond(ms);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _thread_sleep(tick);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tick = rt_tick_from_millisecond(ms);</span></span><br><span class="line"><span class="type">rt_tick_t</span> <span class="title function_">rt_tick_from_millisecond</span><span class="params">(<span class="type">rt_int32_t</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rt_tick_t</span> tick;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ms &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tick = (<span class="type">rt_tick_t</span>)RT_WAITING_FOREVER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//#define RT_TICK_PER_SECOND 1000</span></span><br><span class="line">        tick = RT_TICK_PER_SECOND * (ms / <span class="number">1000</span>);</span><br><span class="line">        tick += (RT_TICK_PER_SECOND * (ms % <span class="number">1000</span>) + <span class="number">999</span>) / <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* return the calculated tick */</span></span><br><span class="line">    <span class="keyword">return</span> tick;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其实 ms == tick</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//thread.c 664行</span></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_delay</span><span class="params">(<span class="type">rt_tick_t</span> tick)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _thread_sleep(tick);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rt_thread_mdelay(<span class="number">1000</span>); <span class="comment">//线程将暂停执行 1 秒</span></span><br></pre></td></tr></table></figure>
<h1><center>挂起和唤醒线程</center></h1>
<blockquote>
<p>挂起：rt_thread_suspend、唤醒：rt_thread_resume</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//挂起</span></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_suspend</span><span class="params">(<span class="type">rt_thread_t</span> thread)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rt_thread_suspend_with_flag(thread, RT_UNINTERRUPTIBLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒</span></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_resume</span><span class="params">(<span class="type">rt_thread_t</span> thread)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rt_sched_lock_level_t</span> slvl;</span><br><span class="line">    <span class="type">rt_err_t</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(thread != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type((<span class="type">rt_object_t</span>)thread) == RT_Object_Class_Thread);</span><br><span class="line"></span><br><span class="line">    LOG_D(<span class="string">&quot;thread resume: %s&quot;</span>, thread-&gt;parent.name);</span><br><span class="line"></span><br><span class="line">    rt_sched_lock(&amp;slvl);</span><br><span class="line"></span><br><span class="line">    error = rt_sched_thread_ready(thread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!error)</span><br><span class="line">    &#123;</span><br><span class="line">        error = rt_sched_unlock_n_resched(slvl);	<span class="comment">//插入就绪，转为运行时态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        rt_sched_unlock(slvl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_thread_resume_hook, (thread));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>获取当前线程</center></h1>
<blockquote>
<p>rt_thread_self：获取当前线程</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">rt_thread_t</span> current_ptr;</span><br><span class="line">current_ptr = rt_thread_self();</span><br><span class="line">rt_kprintf(<span class="string">&quot;this thread is %s\r\n&quot;</span>,current_ptr-&gt;parent.name);</span><br></pre></td></tr></table></figure>
<h1><center>线程切换</center></h1>
<blockquote>
<p>rt_thread_yield：调用此函数后，当前线程首先把自己从它所在的就绪优先级线程队列中删除，然后把自己挂到这个优先级队列链表的尾部，然后激活调度器进行线程上下文切换（如果当前优先级只有这一个线程，则这个线程继续执行，不进行上下文切换动作）</p>
<p>rt_schedule：让出CPU，但是不会重新去排队（通常不需要用户直接调用，而是由系统自动调用）</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_yield</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rt_sched_lock_level_t</span> slvl;</span><br><span class="line">    rt_sched_lock(&amp;slvl);</span><br><span class="line"></span><br><span class="line">    rt_sched_thread_yield(rt_thread_self());</span><br><span class="line"></span><br><span class="line">    rt_sched_unlock_n_resched(slvl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个rt_thread_t类型指针变量接收返回值</span></span><br><span class="line"><span class="type">rt_thread_t</span> th1_ptr, th2_ptr;</span><br><span class="line"><span class="comment">//创建一个线程入口函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">th1_printf</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rt_thread_t</span> current_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        current_ptr = rt_thread_self();</span><br><span class="line">        rt_kprintf(<span class="string">&quot;this thread is %s\r\n&quot;</span>, current_ptr-&gt;parent.name);</span><br><span class="line">        <span class="comment">//串口打印函数，__FILE__：打印所在目录及文件名</span></span><br><span class="line">        <span class="comment">//__FUNCTION__：打印函数名(th2_printf)，__LINE__：打印这个语句在第几行</span></span><br><span class="line">        rt_kprintf(<span class="string">&quot;In %s, the %s is runing the %d!\r\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        rt_thread_mdelay(<span class="number">1000</span>); <span class="comment">//延时</span></span><br><span class="line">        <span class="comment">//调用这个之后，线程th2_printf运行完之后再运行th1_printf</span></span><br><span class="line">        rt_thread_yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">th2_printf</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//串口打印函数，__FILE__：打印所在目录及文件名</span></span><br><span class="line">        <span class="comment">//__FUNCTION__：打印函数名(th2_printf)，__LINE__：打印这个语句在第几行</span></span><br><span class="line">        rt_kprintf(<span class="string">&quot;In %s, the %s is runing the %d!\r\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        rt_thread_mdelay(<span class="number">1000</span>); <span class="comment">//延时</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//rt_thread_yield();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>线程切换钩子函数</center></h1>
<blockquote>
<p>rt_scheduler_sethook：发生线程切换时将调用该钩子函数</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rt_scheduler_sethook</span><span class="params">(<span class="type">void</span> (*hook)(<span class="keyword">struct</span> rt_thread *from, <span class="keyword">struct</span> rt_thread *to))</span></span><br><span class="line">&#123;</span><br><span class="line">    rt_scheduler_hook = hook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个钩子函数，在线程切换时调用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">scheduler_sethook</span><span class="params">(<span class="keyword">struct</span> rt_thread *from, <span class="keyword">struct</span> rt_thread *to)</span></span><br><span class="line">&#123;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;the thread schedul from %s to %s\r\n&quot;</span>, from-&gt;parent.name, to-&gt;parent.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当线程发生切换时，调用钩子函数即运行scheduler_sethook</span></span><br><span class="line">rt_scheduler_sethook(scheduler_sethook);</span><br></pre></td></tr></table></figure>
<h1><center>空闲线程钩子函数</center></h1>
<blockquote>
<p>rt_thread_idle_sethook：系统运行空闲线程的时候会运行这个钩子函数</p>
<p>rt_thread_idle_delhook：从空闲钩子链表中删除指定的钩子函数</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_idle_sethook</span><span class="params">(<span class="type">void</span> (*hook)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rt_size_t</span> i;</span><br><span class="line">    <span class="type">rt_err_t</span> ret = -RT_EFULL;</span><br><span class="line">    <span class="type">rt_base_t</span> level;</span><br><span class="line"></span><br><span class="line">    level = rt_spin_lock_irqsave(&amp;_hook_spinlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; RT_IDLE_HOOK_LIST_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (idle_hook_list[i] == RT_NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            idle_hook_list[i] = hook;</span><br><span class="line">            ret = RT_EOK;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rt_spin_unlock_irqrestore(&amp;_hook_spinlock, level);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ret,count2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">idle_sethook</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rt_thread_t</span> current_ptr;</span><br><span class="line">    current_ptr = rt_thread_self();</span><br><span class="line">    <span class="keyword">if</span>(count2 &lt; <span class="number">1</span>)</span><br><span class="line">        rt_kprintf(<span class="string">&quot;name is %s\r\n&quot;</span>, current_ptr-&gt;parent.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空闲线程运行时会调用钩子函数即运行idle_sethook</span></span><br><span class="line">ret = rt_thread_idle_sethook(idle_sethook);</span><br><span class="line"><span class="comment">//判断空闲钩子函数是否成功</span></span><br><span class="line"><span class="keyword">if</span>(ret != RT_EOK)</span><br><span class="line">&#123;</span><br><span class="line">    LOG_E(<span class="string">&quot;thread_idle erro!\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(count2 == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 删除空闲钩子函数 */</span></span><br><span class="line">    rt_thread_idle_delhook(idle_sethook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>控制线程</center></h1>
<blockquote>
<p>用于控制线程的函数。该函数允许用户对线程进行一些特定的控制操作，例如动态更改线程的优先级、设置线程的时间片等</p>
<p>rt_thread_control</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_control</span><span class="params">(<span class="type">rt_thread_t</span> thread, <span class="type">int</span> cmd, <span class="type">void</span> *arg)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//thread：要控制的线程的句柄，cmd：控制命令(具体看函数说明)，arg：控制命令的参数</span></span><br><span class="line"><span class="comment">//返回值，表示操作是否成功</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">ret = rt_thread_control(th2_ptr, RT_THREAD_CTRL_STARTUP, <span class="literal">NULL</span>);	<span class="comment">//线程启动</span></span><br><span class="line"><span class="comment">//判断线程是否启动成功</span></span><br><span class="line"><span class="keyword">if</span>(ret != RT_EOK)</span><br><span class="line">&#123;</span><br><span class="line">    LOG_E(<span class="string">&quot;rt_thread_control erro!\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>RT-Thread</category>
      </categories>
      <tags>
        <tag>RT-Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>3.驱动和存储器</title>
    <url>/post/55a07e0f.html</url>
    <content><![CDATA[<h1>驱动</h1>
<h2 id="含义">含义</h2>
<p>物理驱动：电机驱动…</p>
<p>软件驱动：</p>
<ul>
<li>
<p>应用层</p>
</li>
<li>
<p>内核层</p>
<ul>
<li>
<p>系统调用（open、read、write、ioctrl、colse）</p>
</li>
<li>
<p>虚拟文件系统</p>
</li>
<li>
<p>驱动代码（字符设备、块设备、网络设备驱动）</p>
</li>
<li>
<p>设备接口</p>
</li>
</ul>
</li>
</ul>
<p>硬件层：各种硬件设备</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/11/12/TqmVLHQZsDtv4GU.png" alt="层级图" style="zoom:50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="驱动分类">驱动分类</h2>
<p>字符设备驱动：按照字节流顺序传输</p>
<p>块设备驱动：多个字节一块传输</p>
<p>网络设备驱动：基于TCP/IP协议栈、socket</p>
<p>内核模块三要素：</p>
<ol>
<li>入口（module_init   insmod）</li>
<li>出口（module_exit   rmmod）</li>
<li>许可证（MODULE_LICENSE(“GPL”);）</li>
</ol>
<h2 id="mpu6050驱动流程">MPU6050驱动流程</h2>
<p>查看主次设备号(串口dev中)：<code>ls -l</code></p>
<p>mpu6050_drv.c(Z:\app_drv\drv\mpu6050_drv.c)，需要结合内核源码查看原理(Z:\linux\kernel\linux-imx-rel_imx_4.1.15_2.1.0_ga)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*------------------字符设备内容----------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_NAME <span class="string">&quot;I2C1_mpu6050&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_CNT (1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义 led 资源结构体，保存获取得到的节点信息以及转换后的虚拟寄存器地址*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> mpu6050_devno;				 <span class="comment">//定义字符设备的设备号</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">mpu6050_chr_dev</span>;</span>		 <span class="comment">//定义字符设备结构体chr_dev</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_mpu6050</span>;</span>			 <span class="comment">//保存创建的类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device_mpu6050</span>;</span>			 <span class="comment">// 保存创建的设备</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">mpu6050_device_node</span>;</span> <span class="comment">//rgb_led的设备树节点结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------IIC设备内容----------------------*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">mpu6050_client</span> =</span> <span class="literal">NULL</span>; <span class="comment">//保存mpu6050设备对应的i2c_client结构体，匹配成功后由.prob函数带回。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMPLRT_DIV                                  0x19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG                                      0x1A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GYRO_CONFIG                                 0x1B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACCEL_CONFIG                                0x1C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACCEL_XOUT_H                                0x3B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACCEL_XOUT_L                                0x3C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACCEL_YOUT_H                                0x3D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACCEL_YOUT_L                                0x3E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACCEL_ZOUT_H                                0x3F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACCEL_ZOUT_L                                0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEMP_OUT_H                                  0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEMP_OUT_L                                  0x42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GYRO_XOUT_H                                 0x43</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GYRO_XOUT_L                                 0x44</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GYRO_YOUT_H                                 0x45</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GYRO_YOUT_L                                 0x46</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GYRO_ZOUT_H                                 0x47</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GYRO_ZOUT_L                                 0x48</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWR_MGMT_1                                  0x6B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WHO_AM_I                                    0x75</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SlaveAddress                                0xD0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Address                                     0x68                  <span class="comment">//MPU6050地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_RETRIES                                 0x0701</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_TIMEOUT                                 0x0702</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_SLAVE                                   0x0703       <span class="comment">//IIC从器件的地址设置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_BUS_MODE                                0x0780</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*通过i2c 向mpu6050写入数据</span></span><br><span class="line"><span class="comment">*mpu6050_client：mpu6050的i2c_client结构体。</span></span><br><span class="line"><span class="comment">*address, 数据要写入的地址，</span></span><br><span class="line"><span class="comment">*data, 要写入的数据</span></span><br><span class="line"><span class="comment">*返回值，错误，-1。成功，0  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_write_mpu6050</span><span class="params">(<span class="keyword">struct</span> i2c_client *mpu6050_client, u8 address, u8 data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line">    u8 write_data[<span class="number">2</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">send_msg</span>;</span> <span class="comment">//要发送的数据结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置要发送的数据*/</span></span><br><span class="line">    write_data[<span class="number">0</span>] = address;</span><br><span class="line">    write_data[<span class="number">1</span>] = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*发送 iic要写入的地址 reg*/</span></span><br><span class="line">    send_msg.addr = mpu6050_client-&gt;addr; <span class="comment">//mpu6050在 iic 总线上的地址</span></span><br><span class="line">    send_msg.flags = <span class="number">0</span>;					  <span class="comment">//标记为发送数据</span></span><br><span class="line">    send_msg.buf = write_data;			  <span class="comment">//写入的首地址</span></span><br><span class="line">    send_msg.len = <span class="number">2</span>;					  <span class="comment">//reg长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*执行发送*/</span></span><br><span class="line">    error = i2c_transfer(mpu6050_client-&gt;adapter, &amp;send_msg, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (error != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_DEBUG <span class="string">&quot;\n i2c_transfer error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*通过i2c 向mpu6050写入数据</span></span><br><span class="line"><span class="comment">*mpu6050_client：mpu6050的i2c_client结构体。</span></span><br><span class="line"><span class="comment">*address, 要读取的地址，</span></span><br><span class="line"><span class="comment">*data，保存读取得到的数据</span></span><br><span class="line"><span class="comment">*length，读长度</span></span><br><span class="line"><span class="comment">*返回值，错误，-1。成功，0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_read_mpu6050</span><span class="params">(<span class="keyword">struct</span> i2c_client *mpu6050_client, u8 address, <span class="type">void</span> *data, u32 length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line">    u8 address_data = address;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">mpu6050_msg</span>[2];</span></span><br><span class="line">    <span class="comment">/*设置读取位置msg*/</span></span><br><span class="line">    mpu6050_msg[<span class="number">0</span>].addr = mpu6050_client-&gt;addr; <span class="comment">//mpu6050在 iic 总线上的地址</span></span><br><span class="line">    mpu6050_msg[<span class="number">0</span>].flags = <span class="number">0</span>;					<span class="comment">//标记为发送数据</span></span><br><span class="line">    mpu6050_msg[<span class="number">0</span>].buf = &amp;address_data;			<span class="comment">//写入的首地址</span></span><br><span class="line">    mpu6050_msg[<span class="number">0</span>].len = <span class="number">1</span>;						<span class="comment">//写入长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置读取位置msg*/</span></span><br><span class="line">    mpu6050_msg[<span class="number">1</span>].addr = mpu6050_client-&gt;addr; <span class="comment">//mpu6050在 iic 总线上的地址</span></span><br><span class="line">    mpu6050_msg[<span class="number">1</span>].flags = I2C_M_RD;			<span class="comment">//标记为读取数据</span></span><br><span class="line">    mpu6050_msg[<span class="number">1</span>].buf = data;					<span class="comment">//读取得到的数据保存位置</span></span><br><span class="line">    mpu6050_msg[<span class="number">1</span>].len = length;				<span class="comment">//读取长度</span></span><br><span class="line"></span><br><span class="line">    error = i2c_transfer(mpu6050_client-&gt;adapter, mpu6050_msg, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_DEBUG <span class="string">&quot;\n i2c_read_mpu6050 error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化i2c</span></span><br><span class="line"><span class="comment">*返回值，成功，返回0。失败，返回 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mpu6050_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*配置mpu6050*/</span></span><br><span class="line">    error += i2c_write_mpu6050(mpu6050_client, PWR_MGMT_1, <span class="number">0X00</span>);</span><br><span class="line">    error += i2c_write_mpu6050(mpu6050_client, SMPLRT_DIV, <span class="number">0X07</span>);</span><br><span class="line">    error += i2c_write_mpu6050(mpu6050_client, CONFIG, <span class="number">0X06</span>);</span><br><span class="line">    error += i2c_write_mpu6050(mpu6050_client, ACCEL_CONFIG, <span class="number">0X01</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*初始化错误*/</span></span><br><span class="line">        printk(KERN_DEBUG <span class="string">&quot;\n mpu6050_init error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*字符设备操作函数集，open函数实现*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mpu6050_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;\n mpu6050_open \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*向 mpu6050 发送配置数据，让mpu6050处于正常工作状态*/</span></span><br><span class="line">    mpu6050_init();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*字符设备操作函数集，.read函数实现*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">mpu6050_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> data_H;</span><br><span class="line">    <span class="type">char</span> data_L;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="type">short</span> mpu6050_result[<span class="number">6</span>]; <span class="comment">//保存mpu6050转换得到的原始数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    i2c_read_mpu6050(mpu6050_client, ACCEL_XOUT_H, &amp;data_H, <span class="number">1</span>);</span><br><span class="line">    i2c_read_mpu6050(mpu6050_client, ACCEL_XOUT_L, &amp;data_L, <span class="number">1</span>);</span><br><span class="line">    mpu6050_result[<span class="number">0</span>] = data_H &lt;&lt; <span class="number">8</span>;</span><br><span class="line">    mpu6050_result[<span class="number">0</span>] += data_L;</span><br><span class="line"></span><br><span class="line">    i2c_read_mpu6050(mpu6050_client, ACCEL_YOUT_H, &amp;data_H, <span class="number">1</span>);</span><br><span class="line">    i2c_read_mpu6050(mpu6050_client, ACCEL_YOUT_L, &amp;data_L, <span class="number">1</span>);</span><br><span class="line">    mpu6050_result[<span class="number">1</span>] = data_H &lt;&lt; <span class="number">8</span>;</span><br><span class="line">    mpu6050_result[<span class="number">1</span>] += data_L;</span><br><span class="line"></span><br><span class="line">    i2c_read_mpu6050(mpu6050_client, ACCEL_ZOUT_H, &amp;data_H, <span class="number">1</span>);</span><br><span class="line">    i2c_read_mpu6050(mpu6050_client, ACCEL_ZOUT_L, &amp;data_L, <span class="number">1</span>);</span><br><span class="line">    mpu6050_result[<span class="number">2</span>] = data_H &lt;&lt; <span class="number">8</span>;</span><br><span class="line">    mpu6050_result[<span class="number">2</span>] += data_L;</span><br><span class="line"></span><br><span class="line">    i2c_read_mpu6050(mpu6050_client, GYRO_XOUT_H, &amp;data_H, <span class="number">1</span>);</span><br><span class="line">    i2c_read_mpu6050(mpu6050_client, GYRO_XOUT_L, &amp;data_L, <span class="number">1</span>);</span><br><span class="line">    mpu6050_result[<span class="number">3</span>] = data_H &lt;&lt; <span class="number">8</span>;</span><br><span class="line">    mpu6050_result[<span class="number">3</span>] += data_L;</span><br><span class="line"></span><br><span class="line">    i2c_read_mpu6050(mpu6050_client, GYRO_YOUT_H, &amp;data_H, <span class="number">1</span>);</span><br><span class="line">    i2c_read_mpu6050(mpu6050_client, GYRO_YOUT_L, &amp;data_L, <span class="number">1</span>);</span><br><span class="line">    mpu6050_result[<span class="number">4</span>] = data_H &lt;&lt; <span class="number">8</span>;</span><br><span class="line">    mpu6050_result[<span class="number">4</span>] += data_L;</span><br><span class="line"></span><br><span class="line">    i2c_read_mpu6050(mpu6050_client, GYRO_ZOUT_H, &amp;data_H, <span class="number">1</span>);</span><br><span class="line">    i2c_read_mpu6050(mpu6050_client, GYRO_ZOUT_L, &amp;data_L, <span class="number">1</span>);</span><br><span class="line">    mpu6050_result[<span class="number">5</span>] = data_H &lt;&lt; <span class="number">8</span>;</span><br><span class="line">    mpu6050_result[<span class="number">5</span>] += data_L;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*将读取得到的数据(内核)拷贝到用户空间*/</span></span><br><span class="line">    error = copy_to_user(buf, mpu6050_result, cnt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(error != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*字符设备操作函数集，.release函数实现*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mpu6050_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;\n mpu6050_release \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*字符设备操作函数集*/</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">mpu6050_chr_dev_fops</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = mpu6050_open,</span><br><span class="line">    .read = mpu6050_read,</span><br><span class="line">    .release = mpu6050_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------------4.平台驱动函数集-----------------*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mpu6050_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>; <span class="comment">//保存错误状态码</span></span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;mpu6050  match successed  \n&quot;</span>);</span><br><span class="line">    <span class="comment">/*---------------------注册 字符设备部分-----------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//采用动态分配的方式，获取设备编号，次设备号为0，</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;mpu6050_devno, <span class="number">0</span>, DEV_CNT, DEV_NAME);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;fail to alloc mpu6050_devno\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关联字符设备结构体cdev与文件操作结构体file_operations</span></span><br><span class="line">    mpu6050_chr_dev.owner = THIS_MODULE;</span><br><span class="line">    <span class="comment">//初始化字符设备，文件操作函数(mpu6050_chr_dev_fops)集赋值给 mpu6050_chr_dev</span></span><br><span class="line">    cdev_init(&amp;mpu6050_chr_dev, &amp;mpu6050_chr_dev_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加设备至cdev_map散列表中</span></span><br><span class="line">    ret = cdev_add(&amp;mpu6050_chr_dev, mpu6050_devno, DEV_CNT);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;fail to add cdev\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建类 在/sys/class(串口) 中可以看到创建的class_mpu6050*/</span></span><br><span class="line">    class_mpu6050 = class_create(THIS_MODULE, DEV_NAME);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建设备 DEV_NAME 指定设备名，*/</span></span><br><span class="line">    device_mpu6050 = device_create(class_mpu6050, <span class="literal">NULL</span>, mpu6050_devno, <span class="literal">NULL</span>, DEV_NAME);</span><br><span class="line">    mpu6050_client = client;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mpu6050_remove</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*删除设备*/</span></span><br><span class="line">    device_destroy(class_mpu6050, mpu6050_devno);	  <span class="comment">//清除设备</span></span><br><span class="line">    class_destroy(class_mpu6050);					  <span class="comment">//清除类</span></span><br><span class="line">    cdev_del(&amp;mpu6050_chr_dev);						  <span class="comment">//清除设备号</span></span><br><span class="line">    unregister_chrdev_region(mpu6050_devno, DEV_CNT); <span class="comment">//取消注册字符设备</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义ID 匹配表*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">gtp_device_id</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;mpu6050&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义设备树匹配表*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">mpu6050_of_match_table</span>[] =</span> &#123;</span><br><span class="line">    <span class="comment">//在设备树文件中中有与之对应的 mpu6050,INV_MPU6050</span></span><br><span class="line">    &#123;.compatible = <span class="string">&quot;mpu6050,INV_MPU6050&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="comment">/* sentinel */</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义i2c总线设备结构体*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">mpu6050_driver</span> =</span> &#123;</span><br><span class="line">    <span class="comment">//3.如果内核匹配设备树上的设备是否有与之对应的，则调用.probe(也就是上面的mpu6050_probe)</span></span><br><span class="line">    .probe = mpu6050_probe,</span><br><span class="line">    <span class="comment">//注销调用</span></span><br><span class="line">    .remove = mpu6050_remove,</span><br><span class="line">    <span class="comment">//与该驱动程序兼容的设备列表(上面有gtp_device_id函数)</span></span><br><span class="line">    .id_table = gtp_device_id,</span><br><span class="line">    <span class="comment">//提供了关于驱动程序的一般信息</span></span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;mpu6050&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        <span class="comment">//设备树匹配表(mpu6050_of_match_table上面有)与内核匹配</span></span><br><span class="line">        .of_match_table = mpu6050_of_match_table,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*驱动初始化函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mpu6050_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    pr_info(<span class="string">&quot;mpu6050_driver_init\n&quot;</span>);</span><br><span class="line">    <span class="comment">//2.将mpu6050_driver结构体注册到内核中，内核匹配设备树上的设备是否有与之对应的</span></span><br><span class="line">    ret = i2c_add_driver(&amp;mpu6050_driver);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*驱动注销函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">mpu6050_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;mpu6050_driver_exit\n&quot;</span>);</span><br><span class="line">    <span class="comment">//内核匹配设备树上的设备是否有与之对应的，有则调用注销 .remove</span></span><br><span class="line">    i2c_del_driver(&amp;mpu6050_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.加载驱动</span></span><br><span class="line">module_init(mpu6050_driver_init);</span><br><span class="line"><span class="comment">//卸载驱动</span></span><br><span class="line">module_exit(mpu6050_driver_exit);</span><br><span class="line"><span class="comment">//许可证</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>i2c_add_driver函数（mpu6050_drv.c中294行）（Z:\linux\kernel\linux-imx-rel_imx_4.1.15_2.1.0_ga\drivers\i2c\i2c-core.c）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> i2c_add_driver(driver) \</span></span><br><span class="line"><span class="meta">	i2c_register_driver(THIS_MODULE, driver)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_register_driver</span><span class="params">(<span class="keyword">struct</span> module *owner, <span class="keyword">struct</span> i2c_driver *driver)</span>	<span class="comment">//1719</span></span><br></pre></td></tr></table></figure>
<p>alloc_chrdev_region函数（mpu6050_drv.c中217行）（Z:\linux\kernel\linux-imx-rel_imx_4.1.15_2.1.0_ga\fs\char_dev.c）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *, <span class="type">unsigned</span>, <span class="type">unsigned</span>, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> baseminor, <span class="type">unsigned</span> count,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="type">char</span> *name)</span></span><br></pre></td></tr></table></figure>
<p>cdev_init函数（mpu6050_drv.c中227行）(Z:\linux\kernel\linux-imx-rel_imx_4.1.15_2.1.0_ga\fs\char_dev.c)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(cdev, <span class="number">0</span>, <span class="keyword">sizeof</span> *cdev);</span><br><span class="line">	INIT_LIST_HEAD(&amp;cdev-&gt;<span class="built_in">list</span>);</span><br><span class="line">	kobject_init(&amp;cdev-&gt;kobj, &amp;ktype_cdev_default);</span><br><span class="line">	cdev-&gt;ops = fops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cdev_add函数（mpu6050_drv.c中230行）(Z:\linux\kernel\linux-imx-rel_imx_4.1.15_2.1.0_ga\fs\char_dev.c)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(cdev, <span class="number">0</span>, <span class="keyword">sizeof</span> *cdev);</span><br><span class="line">	INIT_LIST_HEAD(&amp;cdev-&gt;<span class="built_in">list</span>);</span><br><span class="line">	kobject_init(&amp;cdev-&gt;kobj, &amp;ktype_cdev_default);</span><br><span class="line">	cdev-&gt;ops = fops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int cdev_add(struct cdev *p, dev_t dev, unsigned count)</span><br></pre></td></tr></table></figure>
<p>查看内核详细信息数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串口中的 /proc</span></span><br><span class="line"></span><br><span class="line">cat /proc/cpuinfo</span><br><span class="line">cat /proc/devices</span><br><span class="line">cat /proc/interrupts</span><br><span class="line">cat /proc/meminfo</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口中的 /sys</span></span><br></pre></td></tr></table></figure>
<h2 id="oled驱动流程">OLED驱动流程</h2>
<p>oled_drv.c(Z:\app_drv\drv\oled_drv.c)，需要结合内核源码查看原理(Z:\linux\kernel\linux-imx-rel_imx_4.1.15_2.1.0_ga)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* I2C设备驱动 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">oled_driver</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* I2C从设备 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">oled_client</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* i2c设备地址 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">short</span> addr = <span class="number">0x3C</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* i2c驱动需要探测的从设备地址 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">short</span> address_list[] = &#123; <span class="number">0x3c</span>,<span class="number">0xfffe</span>U &#125;;  <span class="comment">// 0xfffeU 结束标志</span></span><br><span class="line"><span class="comment">/* 设备编号 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> devid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备class */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">oled_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* oled字符设备哦 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">i2c_cdev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pos</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> x;</span><br><span class="line">    <span class="type">short</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pos</span> <span class="title">pos1</span>;</span></span><br><span class="line">    <span class="type">short</span> ax;</span><br><span class="line">    <span class="type">short</span> ay;</span><br><span class="line">    <span class="type">short</span> az;</span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> gx;</span><br><span class="line">    <span class="type">short</span> gy;</span><br><span class="line">    <span class="type">short</span> gz;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   MAGIC_NUMBER    <span class="string">&#x27;x&#x27;</span><span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   OLED_CLEAR    _IO(MAGIC_NUMBER    ,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   OLED_OPS   _IOWR(MAGIC_NUMBER    ,1, struct pos)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   OLED_DATA  _IOWR(MAGIC_NUMBER    ,2, unsigned char [200])</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Max_Column	128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  Function  : 通过I2C协议写命令</span></span><br><span class="line"><span class="comment">*  Input     : data 数据</span></span><br><span class="line"><span class="comment">*  Return    : 写入字节长度  负数写入失败</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">oled_write_cmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> cmd)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[1];</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> cmds[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    cmds[<span class="number">0</span>] = <span class="number">0x00</span>;</span><br><span class="line">    cmds[<span class="number">1</span>] = cmd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 数据传输三要素：源，目的，长度 */</span></span><br><span class="line">    msg[<span class="number">0</span>].addr = oled_client-&gt;addr;     <span class="comment">/* 目的 */</span></span><br><span class="line">    msg[<span class="number">0</span>].buf    = cmds;                       <span class="comment">/* 源 */</span></span><br><span class="line">    msg[<span class="number">0</span>].len    = <span class="number">2</span>;                    <span class="comment">/*  buf长度 */</span></span><br><span class="line">    msg[<span class="number">0</span>].flags = <span class="number">0</span>;                     <span class="comment">/* 0表示写 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i2c_transfer(oled_client-&gt;adapter,msg,<span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  Function  : 通过I2C协议写数据</span></span><br><span class="line"><span class="comment">*  Input     : data 数据</span></span><br><span class="line"><span class="comment">*  Return    : 写入字节长度  负数写入失败</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">oled_write_data</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[1];</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> datas[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    datas[<span class="number">0</span>] = <span class="number">0x40</span>;</span><br><span class="line">    datas[<span class="number">1</span>] = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 数据传输三要素：源，目的，长度 */</span></span><br><span class="line">    msg[<span class="number">0</span>].addr = oled_client-&gt;addr;  <span class="comment">/* 目的 */</span></span><br><span class="line">    msg[<span class="number">0</span>].buf    = datas;              <span class="comment">/* 源 */</span></span><br><span class="line">    msg[<span class="number">0</span>].len    = <span class="number">2</span>;                 <span class="comment">/*  buf长度 */</span></span><br><span class="line">    msg[<span class="number">0</span>].flags= <span class="number">0</span>;                   <span class="comment">/* 0表示写 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i2c_transfer(oled_client-&gt;adapter,msg,<span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  Function  : 坐标设定</span></span><br><span class="line"><span class="comment">*  Input     : x x坐标    0x00~0x7F</span></span><br><span class="line"><span class="comment">*              y y坐标    0~7</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">oled_pos</span><span class="params">(u8 x,u8 y)</span></span><br><span class="line">&#123;</span><br><span class="line">    oled_write_cmd(<span class="number">0xB0</span>+y);</span><br><span class="line">    oled_write_cmd(((x&amp;<span class="number">0xF0</span>)&gt;&gt;<span class="number">4</span>)|<span class="number">0x10</span>);            <span class="comment">/* 设置列地址高四位 */</span></span><br><span class="line">    oled_write_cmd(x&amp;<span class="number">0x0F</span>);                        <span class="comment">/* 设置列地址低四位 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  Function  : 清屏</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">oled_clear</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 x;</span><br><span class="line">    u8 y;</span><br><span class="line">    <span class="keyword">for</span>(y=<span class="number">0</span>;y&lt;<span class="number">8</span>;y++)</span><br><span class="line">    &#123;</span><br><span class="line">        oled_write_cmd(<span class="number">0xB0</span>+y);            <span class="comment">/* 选择页 */</span></span><br><span class="line">        oled_write_cmd(<span class="number">0x00</span>);              <span class="comment">/* 设置列地址低四位 */</span></span><br><span class="line">        oled_write_cmd(<span class="number">0x10</span>);              <span class="comment">/* 设置列地址高四位 */</span></span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;x&lt;<span class="number">0x80</span>;x++)</span><br><span class="line">            oled_write_data(<span class="number">0x00</span>);           <span class="comment">/* 每次清1列 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  Function  : 初始化</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">oled_hw_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    oled_write_cmd(<span class="number">0xAE</span>);<span class="comment">//--display off</span></span><br><span class="line">    oled_write_cmd(<span class="number">0x00</span>);<span class="comment">//---set low column address</span></span><br><span class="line">    oled_write_cmd(<span class="number">0x10</span>);<span class="comment">//---set high column address</span></span><br><span class="line">    oled_write_cmd(<span class="number">0x40</span>);<span class="comment">//--set start line address  </span></span><br><span class="line">    oled_write_cmd(<span class="number">0xB0</span>);<span class="comment">//--set page address</span></span><br><span class="line">    oled_write_cmd(<span class="number">0x81</span>); <span class="comment">// contract control</span></span><br><span class="line">    oled_write_cmd(<span class="number">0xFF</span>);<span class="comment">//--128   </span></span><br><span class="line">    oled_write_cmd(<span class="number">0xA1</span>);<span class="comment">//set segment remap </span></span><br><span class="line">    oled_write_cmd(<span class="number">0xA6</span>);<span class="comment">//--normal / reverse</span></span><br><span class="line">    oled_write_cmd(<span class="number">0xA8</span>);<span class="comment">//--set multiplex ratio(1 to 64)</span></span><br><span class="line">    oled_write_cmd(<span class="number">0x3F</span>);<span class="comment">//--1/32 duty</span></span><br><span class="line">    oled_write_cmd(<span class="number">0xC8</span>);<span class="comment">//Com scan direction</span></span><br><span class="line">    oled_write_cmd(<span class="number">0xD3</span>);<span class="comment">//-set display offset</span></span><br><span class="line">    oled_write_cmd(<span class="number">0x00</span>);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    oled_write_cmd(<span class="number">0xD5</span>);<span class="comment">//set osc division</span></span><br><span class="line">    oled_write_cmd(<span class="number">0x80</span>);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    oled_write_cmd(<span class="number">0xD8</span>);<span class="comment">//set area color mode off</span></span><br><span class="line">    oled_write_cmd(<span class="number">0x05</span>);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    oled_write_cmd(<span class="number">0xD9</span>);<span class="comment">//Set Pre-Charge Period</span></span><br><span class="line">    oled_write_cmd(<span class="number">0xF1</span>);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    oled_write_cmd(<span class="number">0xDA</span>);<span class="comment">//set com pin configuartion</span></span><br><span class="line">    oled_write_cmd(<span class="number">0x12</span>);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    oled_write_cmd(<span class="number">0xDB</span>);<span class="comment">//set Vcomh</span></span><br><span class="line">    oled_write_cmd(<span class="number">0x30</span>);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    oled_write_cmd(<span class="number">0x8D</span>);<span class="comment">//set charge pump enable</span></span><br><span class="line">    oled_write_cmd(<span class="number">0x14</span>);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    oled_write_cmd(<span class="number">0xAF</span>);<span class="comment">//--turn on oled panel</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在指定位置显示一个字符,包括部分字符</span></span><br><span class="line"><span class="comment">//x:0~127</span></span><br><span class="line"><span class="comment">//y:0~63</span></span><br><span class="line"><span class="comment">//mode:0,反白显示;1,正常显示				 </span></span><br><span class="line"><span class="comment">//size:选择字体 16/12 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowChar</span><span class="params">(u8 x,u8 y,u8 chr,u8 Char_Size)</span></span><br><span class="line">&#123;      	</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c = <span class="number">0</span>,i = <span class="number">0</span>;	</span><br><span class="line">    c = chr - <span class="string">&#x27; &#x27;</span>;<span class="comment">//得到偏移后的值			</span></span><br><span class="line">    <span class="keyword">if</span>(x &gt; Max_Column - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        y = y + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Char_Size == <span class="number">16</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        oled_pos(x,y);	</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">            oled_write_data(F8X16[c*<span class="number">16</span>+i]);</span><br><span class="line">        oled_pos(x,y+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">            oled_write_data(F8X16[c*<span class="number">16</span>+i+<span class="number">8</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;	</span><br><span class="line">        oled_pos(x,y);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">            oled_write_data(F6x8[c][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示一个字符号串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowString</span><span class="params">(u8 x,u8 y,u8 *chr,u8 Char_Size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (chr[j]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;		</span><br><span class="line">        OLED_ShowChar(x, y, chr[j], Char_Size);</span><br><span class="line">        x += <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">120</span>) &#123;</span><br><span class="line">            x = <span class="number">0</span>;</span><br><span class="line">            y += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************************************************************</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 打开设备</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> **************************************************************************************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">oled_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    oled_hw_init();</span><br><span class="line"></span><br><span class="line">    oled_clear();                     <span class="comment">/* 初始清屏 */</span></span><br><span class="line">    oled_pos(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;oled open\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************************************************************</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   Function:    oled写函数</span></span><br><span class="line"><span class="comment"> *   Input       : buffer 2个字节 第一个字节oled片内地址0~0xFF，第二个字节为要写入的数据</span></span><br><span class="line"><span class="comment"> *                 size  写数据的长度  两个字节</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> **************************************************************************************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">oled_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buffer, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一共可以显示168字</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">168</span>];</span><br><span class="line">    <span class="comment">//将数据从用户空间拷贝到内核(6050获取到到数据存在用户空间，将用户空间的数据传给内核用于屏幕显示)</span></span><br><span class="line">    copy_from_user(data,buffer,<span class="number">168</span>);</span><br><span class="line">    OLED_ShowString(<span class="number">0</span>, <span class="number">0</span>, data, <span class="number">16</span>);</span><br><span class="line">    <span class="comment">//oled_p6x8str(0, 0, data);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*字符设备操作函数集，.release函数实现*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">oled_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pos</span> <span class="title">pos_xy</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">oled_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filep, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pos</span> <span class="title">pos_temp</span> =</span> &#123;.x = <span class="number">0</span>, .y = <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">200</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(cmd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> OLED_CLEAR:</span><br><span class="line">            oled_clear();                     <span class="comment">/* 初始清屏 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OLED_OPS:</span><br><span class="line">            <span class="comment">//通过copy_to_user向用户空间传递数据</span></span><br><span class="line">            <span class="keyword">if</span>(copy_from_user(&amp;pos_temp, (<span class="type">void</span> *)arg, <span class="keyword">sizeof</span>(pos_temp)) != <span class="number">0</span>)&#123;</span><br><span class="line">                printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);	</span><br><span class="line">            &#125;</span><br><span class="line">            pos_xy.x = pos_temp.x;</span><br><span class="line">            pos_xy.y = pos_temp.y;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//用于处理需要显示在OLED屏幕上的数据</span></span><br><span class="line">        <span class="keyword">case</span> OLED_DATA:	<span class="comment">//暂时不要写入超过255的数值</span></span><br><span class="line">            ret = copy_from_user(buf, (<span class="type">void</span> *)arg, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>( ret != <span class="number">0</span>)&#123;<span class="comment">//通过copy_to_user向用户空间传递数据</span></span><br><span class="line">                printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);	</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//oled_p6x8str(pos_xy.x, pos_xy.y, buf);</span></span><br><span class="line">            OLED_ShowString(pos_xy.x, pos_xy.y, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span> :</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * oled操作集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">oled_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    <span class="comment">//将用户空间中的数据（6050传感器或其他源的数据）写入内核空间</span></span><br><span class="line">    .write = oled_write,</span><br><span class="line">    .open = oled_open,</span><br><span class="line">    .release = oled_release,</span><br><span class="line">    .unlocked_ioctl  = oled_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 当驱动和设备信息匹配成功之后，就会调用probe函数，驱动所有的资源的注册和初始化全部放在probe函数中；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">oled_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *i2c_device)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;oled match successed  \n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 动态分配字符设备编号: (major,0) */</span></span><br><span class="line">    <span class="keyword">if</span>(alloc_chrdev_region(&amp;devid, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;oled&quot;</span>) == OK)&#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;alloc device number : major:[%d], minor:[%d] succeed!\n&quot;</span>, MAJOR(devid), MINOR(devid));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;register device number error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 字符设备初始化以及注册 */</span></span><br><span class="line">    cdev_init(&amp;i2c_cdev, &amp;oled_fops);</span><br><span class="line">    cdev_add(&amp;i2c_cdev, devid, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建类,它会在sys目录下创建/sys/class/oled_class这个类  */</span></span><br><span class="line">    oled_class = class_create(THIS_MODULE, <span class="string">&quot;oled_class&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(oled_class))&#123;</span><br><span class="line">        printk(<span class="string">&quot;can&#x27;t create class\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*  在/sys/class/oled_class下创建oled设备，然后mdev通过这个自动创建/dev/oled这个设备节点 */</span></span><br><span class="line">    device_create(oled_class, <span class="literal">NULL</span>, devid, <span class="literal">NULL</span>, <span class="string">&quot;oled&quot;</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;create device file &#x27;oled&#x27; succeed!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 保存当前i2c_client */</span></span><br><span class="line">    oled_client = client;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;get i2c_client, client name = %s, addr = 0x%x\n&quot;</span>, oled_client-&gt;name, oled_client-&gt;addr);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;get i2c_adapter, adapter name = %s\n&quot;</span>, oled_client-&gt;adapter-&gt;name);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;oled probe\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设备被移除了，或者驱动被卸载了，全部要释放，释放资源的操作就放在该函数中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">oled_remove</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 注销类、以及类设备 /sys/class/oled_class会被移除*/</span></span><br><span class="line">    device_destroy(oled_class, devid);</span><br><span class="line">    class_destroy(oled_class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 移除字符设备 */</span></span><br><span class="line">    cdev_del(&amp;i2c_cdev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注销设备编号 */</span></span><br><span class="line">    unregister_chrdev_region(devid, <span class="number">1</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;oled remove\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义设备树匹配表*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">oled_of_match_table</span>[] =</span> &#123;</span><br><span class="line">    &#123;.compatible = <span class="string">&quot;i2c_oled&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="comment">/* sentinel */</span>&#125;&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * oled设备探测到的回调函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">oled_detect</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="keyword">struct</span> i2c_board_info *info)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;oled detect success\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置I2C从设备名称 必须要和i2c_driver.idtable里面名称匹配</span></span><br><span class="line">    <span class="built_in">strcpy</span>(info-&gt;type,<span class="string">&quot;oled&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* i2c设备id列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">oled_id</span>[] =</span> &#123;</span><br><span class="line">    &#123; <span class="string">&quot;oled&quot;</span>, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; &#125; <span class="comment">/* 最后一个必须为空,表示结束 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * i2c驱动入口函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">oled_driver</span> =</span> &#123;</span><br><span class="line">    .probe = oled_probe,</span><br><span class="line">    .remove = oled_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;oled&quot;</span>,      <span class="comment">/* 驱动名称 */</span></span><br><span class="line">            .owner = THIS_MODULE,</span><br><span class="line">        .of_match_table = oled_of_match_table,</span><br><span class="line">    &#125;,</span><br><span class="line">    .id_table = oled_id, <span class="comment">/* id列表 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *init入口函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">oled_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    i2c_add_driver(&amp;oled_driver); <span class="comment">/* 将i2c_driver注册到系统中去 */</span></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;oled i2c_driver was added into the system.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * exit出口函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">oled_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    i2c_del_driver(&amp;oled_driver);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;oled i2c_driver was deleted from the system.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(oled_init);</span><br><span class="line">module_exit(oled_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;oled device driver, 2023-02-21&quot;</span>);</span><br></pre></td></tr></table></figure>
<h1>存储器</h1>
<ul>
<li>寄存器</li>
<li>RAM(<a href="https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8/4099402?fr=ge_ala">参考</a>)：断电之后，数据消失，相当于手机运行内存
<ul>
<li>DRAM：电脑的内存条，靠电容存储信息</li>
<li>SRAM：CPU的多级缓存，cache</li>
</ul>
</li>
<li>ROM(<a href="https://baike.baidu.com/item/%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8/2399075?fr=ge_ala">参考</a>)：断电之后，数据长久保存
<ul>
<li>EEPROM：带电可擦可编程只读存储器
<ul>
<li>NorFlash：一次可以读取一个字节，每个bit都可以被寻址，可以直接运行程序代码</li>
<li>NandFlash：块访问，不适合直接运行程序代码</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>3.线程间通信</title>
    <url>/post/49f85af0.html</url>
    <content><![CDATA[<h1><center>邮箱</center></h1>
<blockquote>
<p>开销比较低，效率比较高，邮箱中的每一封邮件只能容纳固定的 4 字节内容(也可以是指针)</p>
<p>一个线程能够从任意一个邮箱接收和发送邮件</p>
<p>多个线程能够向同一个邮箱发送邮件和从中接收邮件</p>
</blockquote>
<h2 id="创建">创建</h2>
<blockquote>
<p>动态：rt_mb_create</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//name：邮箱名，size：邮箱能存的邮件数，flag：多个线程等待的排队方式</span></span><br><span class="line"><span class="comment">//(RT_IPC_FLAG_PRIO：挂起的线程按照优先级顺序排队，RT_IPC_FLAG_FIFO：挂起的线程线程先进入先运行)</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_mailbox_t</span> <span class="title function_">rt_mb_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">rt_size_t</span> size, <span class="type">rt_uint8_t</span> flag)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//返回值：</span></span><br><span class="line"><span class="comment">//    创建成功：邮箱控制块的指针</span></span><br><span class="line"><span class="comment">//    创建失败：返回RT_NULL</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">rt_mailbox_t</span> mb_ptr;</span><br><span class="line"></span><br><span class="line">mb_ptr = rt_mb_create(<span class="string">&quot;mb&quot;</span>, <span class="number">4</span>, RT_IPC_FLAG_FIFO);</span><br><span class="line"><span class="keyword">if</span>(mb_ptr == RT_NULL)</span><br><span class="line">&#123;</span><br><span class="line">    LOG_E(<span class="string">&quot;mb_ptr rt_mb_create failed!\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -RT_ENOMEM;  <span class="comment">//RT_ENOMEM：12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态：rt_mb_init</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mb：邮箱控制块的指针，name：邮箱名，邮箱缓冲区的指针，用于存放邮件的内存区域</span></span><br><span class="line"><span class="comment">//size：邮箱能存的邮件数，flag：多个线程等待的排队方式</span></span><br><span class="line"><span class="comment">//(RT_IPC_FLAG_PRIO：挂起的线程按照优先级顺序排队，RT_IPC_FLAG_FIFO：挂起的线程线程先进入先运行)</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mb_init</span><span class="params">(<span class="type">rt_mailbox_t</span> mb,</span></span><br><span class="line"><span class="params">                    <span class="type">const</span> <span class="type">char</span>  *name,</span></span><br><span class="line"><span class="params">                    <span class="type">void</span>        *msgpool,</span></span><br><span class="line"><span class="params">                    <span class="type">rt_size_t</span>    size,</span></span><br><span class="line"><span class="params">                    <span class="type">rt_uint8_t</span>   flag)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_mailbox</span> <span class="title">mb1_ptr</span>;</span></span><br><span class="line"><span class="type">rt_err_t</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *pool = <span class="built_in">malloc</span>(<span class="number">1024</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">ret = rt_mb_init(&amp;mb1_ptr, <span class="string">&quot;mb&quot;</span>, pool, <span class="number">4</span>, RT_IPC_FLAG_FIFO);</span><br><span class="line"><span class="keyword">if</span>(ret != RT_EOK)</span><br><span class="line">&#123;</span><br><span class="line">    LOG_E(<span class="string">&quot;mb1_ptr rt_mb_init failed!\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -RT_ENOMEM;  <span class="comment">//RT_ENOMEM：12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="发送">发送</h2>
<blockquote>
<p>rt_mb_send</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mb：要发送的邮箱对象的指针，value：要发送的邮件的内容</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mb_send</span><span class="params">(<span class="type">rt_mailbox_t</span> mb, <span class="type">rt_ubase_t</span> value)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="type">rt_err_t</span> ret;</span><br><span class="line"></span><br><span class="line">ret = rt_mb_send(mb_ptr, str1);</span><br><span class="line"><span class="keyword">if</span> (ret != RT_EOK) &#123;</span><br><span class="line">    LOG_E(<span class="string">&quot;ret rt_mb_send failed!\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = rt_mb_send(&amp;mb1_ptr, str1);	<span class="comment">//静态创建的发送</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>rt_mb_urgent：发送紧急邮件</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mb：要发送的邮箱对象的指针，value：要发送的邮件的内容</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mb_urgent</span><span class="params">(<span class="type">rt_mailbox_t</span> mb, <span class="type">rt_ubase_t</span> value)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="type">rt_err_t</span> ret;</span><br><span class="line"></span><br><span class="line">ret = rt_mb_urgent(mb_ptr, str1);</span><br><span class="line"><span class="keyword">if</span> (ret != RT_EOK) &#123;</span><br><span class="line">    LOG_E(<span class="string">&quot;ret rt_mb_send failed!\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = rt_mb_urgent(&amp;mb1_ptr, str1);	<span class="comment">//静态创建的发送</span></span><br></pre></td></tr></table></figure>
<h2 id="接收">接收</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mb：要发送的邮箱对象的指针，value：接收邮件数据的变量地址</span></span><br><span class="line"><span class="comment">//timeout：RT_WAITING_FOREVER(阻塞)、RT_WAITING_NO(非阻塞)</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mb_recv</span><span class="params">(<span class="type">rt_mailbox_t</span> mb, <span class="type">rt_ubase_t</span> *value, <span class="type">rt_int32_t</span> timeout)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> ret;</span><br><span class="line"><span class="type">char</span> *recv_str;</span><br><span class="line"></span><br><span class="line">ret = rt_mb_recv(mb_ptr, &amp;recv_str, RT_WAITING_FOREVER);</span><br><span class="line"><span class="keyword">if</span> (ret == RT_EOK) &#123;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;rt_mb_recv is %s\r\n&quot;</span>, recv_str);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    LOG_E(<span class="string">&quot;ret rt_mb_recv failed!\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = rt_mb_recv(&amp;mb1_ptr, &amp;recv_str, RT_WAITING_FOREVER);	<span class="comment">//静态创建的接收</span></span><br></pre></td></tr></table></figure>
<h2 id="删除">删除</h2>
<blockquote>
<p>动态：rt_mb_delete</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mb：邮箱控制块的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mb_delete</span><span class="params">(<span class="type">rt_mailbox_t</span> mb)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rt_mb_delete(mb_ptr);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态：rt_mb_detach</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mb：邮箱控制块的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mb_detach</span><span class="params">(<span class="type">rt_mailbox_t</span> mb)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rt_mb_detach(&amp;mb1_ptr);</span><br></pre></td></tr></table></figure>
<h1><center>消息队列</center></h1>
<blockquote>
<p>邮箱的扩展，比邮箱更方便，可传输不定长消息</p>
</blockquote>
<h2 id="创建">创建</h2>
<blockquote>
<p>动态：rt_mq_create</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//name：消息队列名，msg_size：每个消息的大小</span></span><br><span class="line"><span class="comment">//max_msgs：消息队列能容纳的最大消息数，flag：多个线程等待的排队方式</span></span><br><span class="line"><span class="comment">//(RT_IPC_FLAG_PRIO：挂起的线程按优先级顺序，RT_IPC_FLAG_FIFO：挂起的线程线程先进先出)</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_mq_t</span> <span class="title function_">rt_mq_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                     <span class="type">rt_size_t</span>   msg_size,</span></span><br><span class="line"><span class="params">                     <span class="type">rt_size_t</span>   max_msgs,</span></span><br><span class="line"><span class="params">                     <span class="type">rt_uint8_t</span>  flag)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">rt_mq_t</span> mq_ptr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="type">uint8_t</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line">mq_ptr = rt_mq_create(<span class="string">&quot;mq&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg), <span class="number">4</span>, RT_IPC_FLAG_FIFO);</span><br><span class="line"><span class="keyword">if</span>(mq_ptr == RT_NULL)</span><br><span class="line">&#123;</span><br><span class="line">    LOG_E(<span class="string">&quot;mq_ptr rt_mq_create failed!\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -RT_ENOMEM;  <span class="comment">//RT_ENOMEM：12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态：rt_mq_init</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mq：消息队列对象的指针，name：消息队列名，msgpool：指向存放消息的内存池的指针</span></span><br><span class="line"><span class="comment">//msg_size：每个消息的大小，pool_size：消息池的大小，即能容纳的消息数</span></span><br><span class="line"><span class="comment">//flag：多个线程等待的排队方式</span></span><br><span class="line"><span class="comment">//(RT_IPC_FLAG_PRIO：挂起的线程按照优先级顺序排队，RT_IPC_FLAG_FIFO：挂起的线程线程先进入先运行)</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mq_init</span><span class="params">(<span class="type">rt_mq_t</span>     mq,</span></span><br><span class="line"><span class="params">                    <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                    <span class="type">void</span>       *msgpool,</span></span><br><span class="line"><span class="params">                    <span class="type">rt_size_t</span>   msg_size,</span></span><br><span class="line"><span class="params">                    <span class="type">rt_size_t</span>   pool_size,</span></span><br><span class="line"><span class="params">                    <span class="type">rt_uint8_t</span>  flag)</span></span><br></pre></td></tr></table></figure>
<p>使用(个人实践不成功)</p>
<h2 id="发送">发送</h2>
<blockquote>
<p>rt_mq_send</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mq：消息队列对象的指针，buffer：消息的内容，size：消息的大小</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mq_send</span><span class="params">(<span class="type">rt_mq_t</span> mq, <span class="type">const</span> <span class="type">void</span> *buffer, <span class="type">rt_size_t</span> size)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">rt_ssize_t</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">mq_msg</span>;</span></span><br><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;12345qw&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(mq_msg.str, str1);</span><br><span class="line">mq_msg.len = <span class="built_in">strlen</span>(mq_msg.str);</span><br><span class="line">ret = rt_mq_send(mq_ptr, &amp;mq_msg, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg));</span><br><span class="line"><span class="keyword">if</span> (ret != RT_EOK) &#123;</span><br><span class="line">    LOG_E(<span class="string">&quot;ret rt_mb_send failed!\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>rt_mq_urgent</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mq：消息队列对象的指针，buffer：消息的内容，size：消息的大小</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mq_urgent</span><span class="params">(<span class="type">rt_mq_t</span> mq, <span class="type">const</span> <span class="type">void</span> *buffer, <span class="type">rt_size_t</span> size)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">rt_ssize_t</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">mq_msg</span>;</span></span><br><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;12345qw&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(mq_msg.str, str1);</span><br><span class="line">mq_msg.len = <span class="built_in">strlen</span>(mq_msg.str);</span><br><span class="line">ret = rt_mq_urgent(mq_ptr, &amp;mq_msg, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg));</span><br><span class="line"><span class="keyword">if</span> (ret != RT_EOK) &#123;</span><br><span class="line">    LOG_E(<span class="string">&quot;ret rt_mb_send failed!\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接收">接收</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mq：消息队列对象的指针，buffer：消息的内容</span></span><br><span class="line"><span class="comment">//size：消息的大小，timeout：RT_WAITING_FOREVER(阻塞)、RT_WAITING_NO(非阻塞)</span></span><br><span class="line"><span class="comment">//返回值：返回消息的实际长度大于零接收成功小于0接受失败</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_ssize_t</span> <span class="title function_">rt_mq_recv</span><span class="params">(<span class="type">rt_mq_t</span>    mq,</span></span><br><span class="line"><span class="params">                    <span class="type">void</span>      *buffer,</span></span><br><span class="line"><span class="params">                    <span class="type">rt_size_t</span>  size,</span></span><br><span class="line"><span class="params">                    <span class="type">rt_int32_t</span> timeout)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">rt_ssize_t</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">mq_msg</span>;</span></span><br><span class="line"></span><br><span class="line">ret = rt_mq_recv(mq_ptr, &amp;mq_msg, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg), RT_WAITING_FOREVER);</span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;rt_mq_recv is %s, the len is %d\r\n&quot;</span>, mq_msg.str, mq_msg.len);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    LOG_E(<span class="string">&quot;ret rt_mq_recv failed!\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除">删除</h2>
<blockquote>
<p>动态：rt_mq_delete</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mq：消息队列对象的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mq_delete</span><span class="params">(<span class="type">rt_mq_t</span> mq)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rt_mq_delete(mq_ptr);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态：rt_mq_detach</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mq_detach</span><span class="params">(<span class="type">rt_mq_t</span> mq)</span>;</span><br></pre></td></tr></table></figure>
<h1><center>信号</center></h1>
<blockquote>
<p>软中断信号，用来通知线程发生了异步事件,   异步通知(对硬件中断机制的一种模拟)</p>
<p>用做线程之间的异常通知、应急处理</p>
</blockquote>
<p>开启使能信号</p>
<img src="https://s2.loli.net/2024/09/21/LjNmXQTbc5oHZzq.webp" alt="开启步骤" style="zoom:50%;">
<h2 id="安装">安装</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//signo：信号值，handler	设置对信号值的处理方式</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_sighandler_t</span> <span class="title function_">rt_signal_install</span><span class="params">(<span class="type">int</span> signo, <span class="type">rt_sighandler_t</span> handler)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #define SIGUSR1 30	自带</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程 1 的信号处理函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1_signal_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;thread1 received signal %d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rt_signal_install(SIGUSR1, thread1_signal_handler);	<span class="comment">/* 安装信号 */</span></span><br></pre></td></tr></table></figure>
<h2 id="阻塞-解除阻塞">阻塞/解除阻塞</h2>
<blockquote>
<p>阻塞：rt_signal_mask</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//signo：信号值</span><br><span class="line"></span><br><span class="line">void rt_signal_mask(int signo);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解除阻塞：rt_signal_unmask</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//signo：信号值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rt_signal_unmask</span><span class="params">(<span class="type">int</span> signo)</span>;</span><br><span class="line"></span><br><span class="line">rt_signal_unmask(SIGUSR1);	<span class="comment">//解除阻塞</span></span><br></pre></td></tr></table></figure>
<h2 id="发送">发送</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建线程 1 */</span></span><br><span class="line">tid1 = rt_thread_create(<span class="string">&quot;thread1&quot;</span>,</span><br><span class="line">                        thread1_entry, RT_NULL,</span><br><span class="line">                        THREAD_STACK_SIZE,</span><br><span class="line">                        THREAD_PRIORITY, THREAD_TIMESLICE);</span><br><span class="line">                        </span><br><span class="line"><span class="comment">/* 发送信号 SIGUSR1 给线程 1 */</span></span><br><span class="line">rt_thread_kill(tid1, SIGUSR1);</span><br></pre></td></tr></table></figure>
<h2 id="等待">等待</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//set：指定等待的信号，si：指向存储等到信号信息的指针，timeout：指定的等待时间</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rt_signal_wait</span><span class="params">(<span class="type">const</span> <span class="type">rt_sigset_t</span> *<span class="built_in">set</span>, <span class="type">rt_siginfo_t</span> *si, <span class="type">rt_int32_t</span> timeout)</span></span><br></pre></td></tr></table></figure>
<h1><center>全局变量(不推荐)</center></h1>
<ul>
<li>
<p>多个线程使用同一个全局变量，如果不互斥，那么存在抢占</p>
</li>
<li>
<p>全局变量太多，代码很难维护，可读性变差，也可能存在未知问题</p>
</li>
<li>
<p>代码之间耦合度过高，不分层</p>
</li>
</ul>
]]></content>
      <categories>
        <category>RT-Thread</category>
      </categories>
      <tags>
        <tag>RT-Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>2.线程同步</title>
    <url>/post/a1db912f.html</url>
    <content><![CDATA[<h1><center>概念</center></h1>
<p>线程同步：指多个线程通过特定的机制来控制线程之间的执行顺序(线程间通过同步建立执行顺序的关系)，如果没有同步，线程之间将是无序的</p>
<p>临界区(CriticalSection)：指在多线程或多进程环境中，访问共享资源或共享数据的一段代码或代码块，需要保证在任意时刻只能有一个线程或进程访问该共享资源，以避免出现竞争条件（Race Condition）和数据不一致的问题</p>
<p>临界区保护方式</p>
<ul>
<li>关闭中断(rt_hw_interrupt_disable、rt_hw_interrupt_enable)</li>
<li>禁止调度(rt_enter_critical、rt_exit_critical)</li>
<li>互斥特性保护临界区
<ul>
<li>信号量
<ul>
<li>二值信号量</li>
<li>计数型信号量</li>
</ul>
</li>
<li>互斥量</li>
</ul>
</li>
</ul>
<h1><center>信号量</center></h1>
<h2 id="创建">创建</h2>
<blockquote>
<p>动态：rt_sem_create</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//name；信号量名字，value：信号量初始值</span></span><br><span class="line"><span class="comment">//flag：多个线程等待的排队方式</span></span><br><span class="line"><span class="comment">//(RT_IPC_FLAG_PRIO：挂起的线程按照优先级顺序排队，RT_IPC_FLAG_FIFO：挂起的线程线程先进入先运行)</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_sem_t</span> <span class="title function_">rt_sem_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">rt_uint32_t</span> value, <span class="type">rt_uint8_t</span> flag)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：</span></span><br><span class="line"><span class="comment">//    创建成功：指向信号量控制块的指针</span></span><br><span class="line"><span class="comment">//    创建失败：返回RT_NULL</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">rt_sem_t</span> sem1_ptr;</span><br><span class="line"></span><br><span class="line">sem1_ptr = rt_sem_create(<span class="string">&quot;sem1&quot;</span>, <span class="number">1</span>, RT_IPC_FLAG_PRIO);</span><br><span class="line"><span class="keyword">if</span> (sem1_ptr == RT_NULL) &#123;</span><br><span class="line">    LOG_E(<span class="string">&quot;sem1_ptr rt_sem_create failed!\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -RT_ENOMEM;  <span class="comment">//RT_ENOMEM：12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态：rt_sem_init</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sem：指向信号量控制块的指针，name：信号量名称，value：信号量初始值，flag：多个线程等待的排队方式</span></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_sem_init</span><span class="params">(<span class="type">rt_sem_t</span>    sem,</span></span><br><span class="line"><span class="params">                     <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                     <span class="type">rt_uint32_t</span> value,</span></span><br><span class="line"><span class="params">                     <span class="type">rt_uint8_t</span>  flag)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_semaphore</span> <span class="title">sem3_ptr</span>, <span class="title">sem4_ptr</span>;</span></span><br><span class="line"><span class="type">int</span> sem1_ptr, sem2_ptr;</span><br><span class="line"></span><br><span class="line">sem1_ptr = rt_sem_init(&amp;sem3_ptr, <span class="string">&quot;sem1&quot;</span>, <span class="number">1</span>, RT_IPC_FLAG_PRIO);</span><br><span class="line"><span class="keyword">if</span> (sem1_ptr != RT_EOK) &#123;</span><br><span class="line">    LOG_E(<span class="string">&quot;sem1_ptr rt_sem_create failed!\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -RT_ENOMEM;  <span class="comment">//RT_ENOMEM：12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取">获取</h2>
<p>定义：信号量初始值-1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sem：指向信号量控制块的指针，time：RT_WAITING_FOREVER(阻塞)、RT_WAITING_NO(非阻塞)</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_sem_take</span><span class="params">(<span class="type">rt_sem_t</span> sem, <span class="type">rt_int32_t</span> time)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rt_sem_take(sem1_ptr, RT_WAITING_FOREVER);	<span class="comment">//动态创建的获取</span></span><br><span class="line"></span><br><span class="line">rt_sem_take(&amp;sem3_ptr, RT_WAITING_FOREVER);	<span class="comment">//静态创建的获取</span></span><br></pre></td></tr></table></figure>
<h2 id="释放">释放</h2>
<p>定义：信号量+1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sem：指向信号量控制块的指针</span></span><br><span class="line"><span class="comment">//返回值：</span></span><br><span class="line"><span class="comment">//	成功：RT_EOK</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_sem_release</span><span class="params">(<span class="type">rt_sem_t</span> sem)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rt_sem_release(sem2_ptr);	<span class="comment">//动态创建的释放</span></span><br><span class="line"></span><br><span class="line">rt_sem_release(&amp;sem3_ptr);	<span class="comment">//静态创建的释放</span></span><br></pre></td></tr></table></figure>
<h2 id="删除">删除</h2>
<blockquote>
<p>动态：rt_sem_delete</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sem：指向信号量控制块的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_sem_delete</span><span class="params">(<span class="type">rt_sem_t</span> sem)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rt_sem_delete(sem1_ptr);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态：rt_sem_detach</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sem：指向信号量控制块的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sem：指向信号量控制块的指针rt_err_t rt_sem_detach(rt_sem_t sem)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rt_sem_detach(&amp;sem3_ptr);</span><br></pre></td></tr></table></figure>
<h1><center>互斥量</center></h1>
<blockquote>
<p>互斥量可以防止优先级反转</p>
<p>互斥量只能由持有线程释放，而信号量可由任何线程释放</p>
</blockquote>
<h2 id="创建">创建</h2>
<blockquote>
<p>动态：rt_mutex_create</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">rt_mutex_t</span> <span class="title function_">rt_mutex_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">rt_uint8_t</span> flag)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//name：互斥量名字</span></span><br><span class="line"><span class="comment">//flag：多个线程等待的排队方式</span></span><br><span class="line"><span class="comment">//(RT_IPC_FLAG_PRIO：挂起的线程按照优先级顺序排队，RT_IPC_FLAG_FIFO：挂起的线程线程先进入先运行)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">rt_mutex_t</span> mutex1_prt;</span><br><span class="line"></span><br><span class="line">mutex1_prt = rt_mutex_create(<span class="string">&quot;mutex1&quot;</span>, RT_IPC_FLAG_PRIO);</span><br><span class="line"><span class="keyword">if</span>(mutex1_prt == RT_NULL)</span><br><span class="line">&#123;</span><br><span class="line">    LOG_E(<span class="string">&quot;mutex1 rt_mutex_create failed!\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -RT_ENOMEM;  <span class="comment">//RT_ENOMEM：12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态：rt_mutex_init</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mutex：指向互斥量控制块的指针，name：互斥量名字</span></span><br><span class="line"><span class="comment">//flag：多个线程等待的排队方式</span></span><br><span class="line"><span class="comment">//(RT_IPC_FLAG_PRIO：挂起的线程按照优先级顺序排队，RT_IPC_FLAG_FIFO：挂起的线程线程先进入先运行)</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mutex_init</span><span class="params">(<span class="type">rt_mutex_t</span> mutex, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">rt_uint8_t</span> flag)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">mutex2_prt</span>;</span></span><br><span class="line"><span class="type">int</span> mutex_flag;</span><br><span class="line"></span><br><span class="line">mutex_flag = rt_mutex_init(&amp;mutex2_prt, <span class="string">&quot;mutex2&quot;</span>, RT_IPC_FLAG_PRIO);</span><br><span class="line"><span class="keyword">if</span>(mutex_flag != RT_EOK)</span><br><span class="line">&#123;</span><br><span class="line">    LOG_E(<span class="string">&quot;mutex1 rt_mutex_init failed!\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -RT_ENOMEM;  <span class="comment">//RT_ENOMEM：12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取">获取</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mutex：指向互斥量控制块的指针，time：RT_WAITING_FOREVER(阻塞)、RT_WAITING_NO(非阻塞)</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mutex_take</span><span class="params">(<span class="type">rt_mutex_t</span> mutex, <span class="type">rt_int32_t</span> time)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rt_mutex_take(mutex1_prt, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line">rt_mutex_take(&amp;mutex2_prt, RT_WAITING_FOREVER);	<span class="comment">//静态创建的获取</span></span><br></pre></td></tr></table></figure>
<h2 id="释放">释放</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mutex：指向互斥量控制块的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mutex_release</span><span class="params">(<span class="type">rt_mutex_t</span> mutex)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rt_mutex_release(mutex1_prt);</span><br><span class="line"></span><br><span class="line">rt_mutex_release(&amp;mutex2_prt);	<span class="comment">//静态创建的释放</span></span><br></pre></td></tr></table></figure>
<h2 id="删除">删除</h2>
<blockquote>
<p>动态：rt_event_delete</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mutex：指向互斥量控制块的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mutex_delete</span><span class="params">(<span class="type">rt_mutex_t</span> mutex)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rt_mutex_delete(mutex1_prt);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态：rt_mutex_detach</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mutex：指向互斥量控制块的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mutex_detach</span><span class="params">(<span class="type">rt_mutex_t</span> mutex)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rt_mutex_detach(&amp;mutex2_prt);</span><br></pre></td></tr></table></figure>
<h1><center>事件集</center></h1>
<blockquote>
<p>工作机制</p>
</blockquote>
<ul>
<li>事件只与线程相关，事件间相互独立：每个线程可拥有 32 个事件标志，采用一个 32 bit 无符号整型数进行记录，每一个 bit 代表一个事件</li>
<li>事件仅用于同步，不提供数据传输功能</li>
<li>事件无排队性，即多次向线程发送同一事件 (如果线程还未来得及读走)，其效果等同于只发送一次</li>
</ul>
<blockquote>
<p>每个线程都拥有一个事件信息标记</p>
</blockquote>
<img src="https://s2.loli.net/2024/09/17/qpD53UL2PVMvctl.jpg" alt="时间信息标记分析" style="zoom:67%;">
<blockquote>
<p>接收方式：</p>
</blockquote>
<ul>
<li>逻辑与：<code>RT_EVENT_FLAG_AND</code></li>
<li>逻辑或：<code>RT_EVENT_FLAG_OR</code></li>
<li>清除标记：<code>RT_EVENT_FLAG_CLEAR</code></li>
</ul>
<h2 id="创建">创建</h2>
<blockquote>
<p>动态：rt_event_create</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//name：事件集名字，flag：多个线程等待的排队方式</span></span><br><span class="line"><span class="comment">//(RT_IPC_FLAG_PRIO：挂起的线程按照优先级顺序排队，RT_IPC_FLAG_FIFO：挂起的线程线程先进入先运行)</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_event_t</span> <span class="title function_">rt_event_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">rt_uint8_t</span> flag)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">rt_event_t</span> event;</span><br><span class="line"></span><br><span class="line">event = rt_event_create(<span class="string">&quot;event&quot;</span>, RT_IPC_FLAG_PRIO);</span><br><span class="line"><span class="keyword">if</span> (event == RT_NULL) &#123;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;init event failed.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态：rt_event_init</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//event：指向事件集控制块的指针，name：事件集名字</span></span><br><span class="line"><span class="comment">//flag：多个线程等待的排队方式</span></span><br><span class="line"><span class="comment">//(RT_IPC_FLAG_PRIO：挂起的线程按照优先级顺序排队，RT_IPC_FLAG_FIFO：挂起的线程线程先进入先运行)</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_event_init</span><span class="params">(<span class="type">rt_event_t</span> event, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">rt_uint8_t</span> flag)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> result;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化事件对象 */</span></span><br><span class="line">result = rt_event_init(&amp;event, <span class="string">&quot;event&quot;</span>, RT_IPC_FLAG_PRIO);</span><br><span class="line"><span class="keyword">if</span> (result != RT_EOK)</span><br><span class="line">&#123;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;init event failed.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="发送">发送</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//event：指向事件集控制块的指针，set：事件的标志</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_event_send</span><span class="params">(<span class="type">rt_event_t</span> event, <span class="type">rt_uint32_t</span> <span class="built_in">set</span>)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//事件标志位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_FLAG3 (1 &lt;&lt; 3)	<span class="comment">//1000 == 0x8</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_FLAG5 (1 &lt;&lt; 5)	<span class="comment">//10 0000 == 0x20</span></span></span><br><span class="line"></span><br><span class="line">rt_event_send(&amp;event, EVENT_FLAG3);	<span class="comment">//静态创建的发送</span></span><br></pre></td></tr></table></figure>
<h2 id="接收">接收</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//event：指向事件集控制块的指针，set：事件的标志，option：接收选项，用于指定接收事件的逻辑操作和是否清除事件标志</span></span><br><span class="line"><span class="comment">//timeout：RT_WAITING_FOREVER(阻塞)、RT_WAITING_NO(非阻塞)，recved：存储实际接收到的事件标志位</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_event_recv</span><span class="params">(<span class="type">rt_event_t</span>   event,</span></span><br><span class="line"><span class="params">                       <span class="type">rt_uint32_t</span>  <span class="built_in">set</span>,</span></span><br><span class="line"><span class="params">                       <span class="type">rt_uint8_t</span>   option,</span></span><br><span class="line"><span class="params">                       <span class="type">rt_int32_t</span>   timeout,</span></span><br><span class="line"><span class="params">                       <span class="type">rt_uint32_t</span> *recved)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rt_event_recv(&amp;event, (EVENT_FLAG3 | EVENT_FLAG5),</span><br><span class="line">                      RT_EVENT_FLAG_OR | RT_EVENT_FLAG_CLEAR,</span><br><span class="line">                      RT_WAITING_FOREVER, &amp;e)</span><br><span class="line">    </span><br><span class="line">rt_event_recv(&amp;event, (EVENT_FLAG3 | EVENT_FLAG5),</span><br><span class="line">                      RT_EVENT_FLAG_AND | RT_EVENT_FLAG_CLEAR,</span><br><span class="line">                      RT_WAITING_FOREVER, &amp;e)</span><br></pre></td></tr></table></figure>
<h2 id="删除">删除</h2>
<blockquote>
<p>静态：rt_event_delete</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//event：指向事件集控制块的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_event_delete</span><span class="params">(<span class="type">rt_event_t</span> event)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>动态：rt_event_detach</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//event：指向事件集控制块的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_event_detach</span><span class="params">(<span class="type">rt_event_t</span> event)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>RT-Thread</category>
      </categories>
      <tags>
        <tag>RT-Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>4.时钟</title>
    <url>/post/e5f15f94.html</url>
    <content><![CDATA[<h1><center>时钟源修改</center></h1>
<p>进入CubeMx设置</p>
<img src="https://s2.loli.net/2024/09/21/uk7vCIMsmXBld53.webp" alt="进入CubeMx" style="zoom:40%;">
<p>按照循序进行时钟源修改，修改完成后按<code>GENERATE CODE</code></p>
<img src="https://s2.loli.net/2024/09/21/AZrbiLB4m2aFuSC.webp" alt="修改" style="zoom:40%;">
<p>重新配置串口1（不然报错）</p>
<img src="https://s2.loli.net/2024/09/21/8zYOCZk7ijGrARB.webp" alt="配置串口1" style="zoom:40%;">
<h1><center>时钟节拍</center></h1>
<blockquote>
<p>获取方法</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义，返回：当前时钟节拍值</span></span><br><span class="line"><span class="type">rt_tick_t</span> <span class="title function_">rt_tick_get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="title function_">rt_kprintf</span><span class="params">(<span class="string">&quot;rt_tick is %u\r\n&quot;</span>, rt_tick_get())</span>;</span><br></pre></td></tr></table></figure>
<h1><center>定时器</center></h1>
<h2 id="创建">创建</h2>
<blockquote>
<p>动态：rt_timer_create</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//name：定时器名称，void *parameter：定时器超时后调用的回调函数的指针</span></span><br><span class="line"><span class="comment">//parameter：超时后调用的函数的参数，time：定时器的超时时间，单位是时钟节拍</span></span><br><span class="line"><span class="comment">//flag：定时器创建时的参数(可以用 “或” 关系取多个值)</span></span><br><span class="line"><span class="comment">//RT_TIMER_FLAG_ONE_SHOT：单次定时，RT_TIMER_FLAG_PERIODIC：循环定时</span></span><br><span class="line"><span class="comment">//RT_TIMER_FLAG_HARD_TIMER：硬件定时器，RT_TIMER_FLAG_SOFT_TIMER：软件定时器</span></span><br><span class="line"><span class="comment">//RT_TIMER_FLAG_THREAD_TIMER：线程定时器</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_timer_t</span> <span class="title function_">rt_timer_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                           <span class="type">void</span> (*timeout)(<span class="type">void</span> *parameter),</span></span><br><span class="line"><span class="params">                           <span class="type">void</span>       *parameter,</span></span><br><span class="line"><span class="params">                           <span class="type">rt_tick_t</span>   time,</span></span><br><span class="line"><span class="params">                           <span class="type">rt_uint8_t</span>  flag)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">rt_timer_t</span> timer_ptr;</span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_callback</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    LOG_D(<span class="string">&quot;time runing\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line">timer_ptr = rt_timer_create(<span class="string">&quot;timer&quot;</span>,</span><br><span class="line">                            timer_callback,</span><br><span class="line">                            RT_NULL, <span class="number">1000</span>,</span><br><span class="line">                            RT_TIMER_FLAG_PERIODIC|RT_TIMER_FLAG_SOFT_TIMER);</span><br><span class="line"><span class="keyword">if</span>(timer_ptr == RT_NULL)</span><br><span class="line">&#123;</span><br><span class="line">    LOG_E(<span class="string">&quot;timer_ptr rt_timer_create failed!\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -RT_ENOMEM;  <span class="comment">//RT_ENOMEM：12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态：rt_timer_init</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//timer：定时器句柄，指向要删除的定时器，void *parameter：定时器超时后调用的回调函数的指针</span></span><br><span class="line"><span class="comment">//parameter：超时后调用的函数的参数，time：定时器的超时时间，单位是时钟节拍</span></span><br><span class="line"><span class="comment">//flag：定时器创建时的参数(可以用 “或” 关系取多个值)</span></span><br><span class="line"><span class="comment">//RT_TIMER_FLAG_ONE_SHOT：单次定时，RT_TIMER_FLAG_PERIODIC：循环定时</span></span><br><span class="line"><span class="comment">//RT_TIMER_FLAG_HARD_TIMER：硬件定时器，RT_TIMER_FLAG_SOFT_TIMER：软件定时器</span></span><br><span class="line"><span class="comment">//RT_TIMER_FLAG_THREAD_TIMER：线程定时器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rt_timer_init</span><span class="params">(<span class="type">rt_timer_t</span>  timer,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> (*timeout)(<span class="type">void</span> *parameter),</span></span><br><span class="line"><span class="params">                   <span class="type">void</span>       *parameter,</span></span><br><span class="line"><span class="params">                   <span class="type">rt_tick_t</span>   time,</span></span><br><span class="line"><span class="params">                   <span class="type">rt_uint8_t</span>  flag)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_timer</span> <span class="title">timer_ptr</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_callback</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;rt_tick is %u\r\n&quot;</span>, rt_tick_get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rt_timer_init(&amp;timer_ptr,<span class="string">&quot;timer&quot;</span>,timer_callback,RT_NULL, <span class="number">400</span>,RT_TIMER_FLAG_PERIODIC|RT_TIMER_FLAG_SOFT_TIMER);</span><br></pre></td></tr></table></figure>
<h2 id="删除">删除</h2>
<blockquote>
<p>动态：rt_timer_delete</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//timer：定时器句柄，指向要删除的定时器</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_timer_delete</span><span class="params">(<span class="type">rt_timer_t</span> timer)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rt_timer_delete(timer_ptr);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态：rt_timer_detach</p>
</blockquote>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//timer：定时器句柄，指向要删除的定时器</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_timer_detach</span><span class="params">(<span class="type">rt_timer_t</span> timer)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rt_timer_detach(&amp;timer_ptr);</span><br></pre></td></tr></table></figure>
<h2 id="启动">启动</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//timer：定时器句柄，指向要启动的定时器</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_timer_start</span><span class="params">(<span class="type">rt_timer_t</span> timer)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rt_timer_start(timer_ptr);</span><br></pre></td></tr></table></figure>
<h2 id="停止">停止</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//timer：定时器句柄，指向要停止的定时器</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_timer_stop</span><span class="params">(<span class="type">rt_timer_t</span> timer)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rt_timer_stop(&amp;timer_ptr);</span><br></pre></td></tr></table></figure>
<h2 id="定时器控制">定时器控制</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//timer：定时器句柄，指向要控制的定时器，cmd：用于控制定时器的命令，arg：cmd控制命令参数</span></span><br><span class="line"><span class="comment">//RT_TIMER_CTRL_GET_TIME：获取定时器超时时间，RT_TIMER_CTRL_SET_TIME：设置定时器超时时间</span></span><br><span class="line"><span class="comment">//RT_TIMER_CTRL_SET_ONESHOT：设置定时器为单次触发模式，RT_TIMER_CTRL_SET_PERIODIC：设置定时器为周期触发模式</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_timer_control</span><span class="params">(<span class="type">rt_timer_t</span> timer, <span class="type">int</span> cmd, <span class="type">void</span> *arg)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> timeout_value=<span class="number">0</span>;</span><br><span class="line">rt_timer_control(timer_ptr, RT_TIMER_CTRL_SET_TIME, &amp;timeout_value);</span><br></pre></td></tr></table></figure>
<h2 id="高精度延时">高精度延时</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//us：需要延迟的时间(us)</span></span><br><span class="line"><span class="comment">//时间长度要小于一个tick(1ms==1000)，不会挂起，不会让出CPU</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rt_hw_us_delay</span><span class="params">(<span class="type">rt_uint32_t</span> us)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rt_hw_us_delay(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>RT-Thread</category>
      </categories>
      <tags>
        <tag>RT-Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>0.C语言概述</title>
    <url>/post/6ac19130.html</url>
    <content><![CDATA[<p>C语言编写通过学习：<a href="https://www.bilibili.com/list/watchlater?oid=582948598&amp;bvid=BV1s64y1M7ZV&amp;spm_id_from=333.1007.top_right_bar_window_view_later.content.click">链接</a>后，总结得出</p>
<h1><center>写代码过程</center></h1>
<p>编辑器：程序员写代码的过程</p>
<p>编译器：查看代码的语法错误，生成汇编语言</p>
<p>汇编语言：将生成好汇编语言生成二进制语言（目标文件）</p>
<p>连接器：将生成好的二进制语言+用到的库+启动代码==&gt;可执行代码</p>
<h1><center>完整代码分析</center></h1>
<blockquote>
<p>行注释：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注释内容，行注释</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>块注释：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	意思：块注释（不能嵌套）</span></span><br><span class="line"><span class="comment">	内容</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>符号： <mark>; </mark>        意思：C语言语句结束标志</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//行注释:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span><span class="comment">//std 标准 i输入 o输出（标准的输入输出头文件）</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 块注释 不能嵌套</span></span><br><span class="line"><span class="comment">    main 是程序的入口 有且仅有一个</span></span><br><span class="line"><span class="comment">    main左边的int 代表的是函数的返回值类型</span></span><br><span class="line"><span class="comment">    ()里面函数的形参（函数外部将数据传递到函数内部的桥梁）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//函数的功能都在&#123;&#125;里面实现</span></span><br><span class="line">    <span class="comment">//使用任何东西 必先存在</span></span><br><span class="line">    <span class="comment">//printf:将&quot;&quot;中的字符串 输出到 终端上</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello iot\n&quot;</span>);<span class="comment">//来至系统库文件</span></span><br><span class="line">    <span class="comment">//;c语言的语句结束标记</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果你的代码 一闪而过 可以用带阻塞的代码</span></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>变量、函数在不同.c文件中使用</center></h1>
<blockquote>
<p>extern本质：告诉编译器 变量、函数 来至其他源文件</p>
<p>注意：static用于全局变量或函数前时，它将该变量或函数的可见性限制在定义它的文件内部</p>
</blockquote>
<p>如果.c文件中的变量或函数，在对应的.h文件中声明了变量或函数，在别的 .c 文件中只需要生命对应的头文件，即可访问别的.C文件中的函数或变量，若不生命对应的头文件，则需要时候外加extern 来声明变量或函数</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>5.RT-Thread设备模型框架</title>
    <url>/post/de55e8eb.html</url>
    <content><![CDATA[<h1><center>I/O设备模型框架</center></h1>
<p>RT-Thread 提供了一套简单的 I/O 设备模型框架，如下图所示，它位于硬件和应用程序之间，共分成三层，从上到下分别是 I/O 设备管理层、设备驱动框架层、设备驱动层</p>
<img src="https://s2.loli.net/2024/09/22/G8HqSykte3pIzRo.jpg" alt="模型框架图" style="zoom:25%;">
<h1><center>UART</center></h1>
<p>设备打开，在<code>drivers</code>中的<code>board.h</code>中寻找，这里打开串口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_USING_UART2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_UART2_TX_PIN       <span class="string">&quot;PA2&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_UART2_RX_PIN       <span class="string">&quot;PA3&quot;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="查找设备">查找设备</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//name：设备名称，查找成功返回设备句柄</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_device_t</span> <span class="title function_">rt_device_find</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//#define RT_NAME_MAX 8</span></span><br><span class="line"><span class="type">char</span> uart_name[RT_NAME_MAX];</span><br><span class="line"></span><br><span class="line">serial = rt_device_find(uart_name);</span><br></pre></td></tr></table></figure>
<h2 id="初始化设备">初始化设备</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dev：设备句柄</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_device_init</span><span class="params">(<span class="type">rt_device_t</span> dev)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="打开设备">打开设备</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dev：设备句柄，oflags：设备打开模式标志</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_device_open</span><span class="params">(<span class="type">rt_device_t</span> dev, <span class="type">rt_uint16_t</span> oflag)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//oflags 支持以下的参数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_DEVICE_OFLAG_CLOSE 0x000   <span class="comment">/* 设备已经关闭（内部使用）*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_DEVICE_OFLAG_RDONLY 0x001  <span class="comment">/* 以只读方式打开设备 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_DEVICE_OFLAG_WRONLY 0x002  <span class="comment">/* 以只写方式打开设备 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_DEVICE_OFLAG_RDWR 0x003    <span class="comment">/* 以读写方式打开设备 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_DEVICE_OFLAG_OPEN 0x008    <span class="comment">/* 设备已经打开（内部使用）*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_DEVICE_FLAG_STREAM 0x040   <span class="comment">/* 设备以流模式打开 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_DEVICE_FLAG_INT_RX 0x100   <span class="comment">/* 设备以中断接收模式打开 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_DEVICE_FLAG_DMA_RX 0x200   <span class="comment">/* 设备以 DMA 接收模式打开 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_DEVICE_FLAG_INT_TX 0x400   <span class="comment">/* 设备以中断发送模式打开 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_DEVICE_FLAG_DMA_TX 0x800   <span class="comment">/* 设备以 DMA 发送模式打开 */</span></span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 以中断接收及轮询发送模式打开串口设备 */</span></span><br><span class="line">rt_device_open(serial, RT_DEVICE_FLAG_INT_RX);</span><br></pre></td></tr></table></figure>
<h2 id="数据收发回调">数据收发回调</h2>
<blockquote>
<p>定义：当硬件设备收到数据时，可以通过如下函数回调另一个函数来设置数据接收指示，通知上层应用线程有数据到达</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dev：设备句柄，rx_ind：回调函数的指针(参数由底层传参)</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_device_set_rx_indicate</span><span class="params">(<span class="type">rt_device_t</span> dev,</span></span><br><span class="line"><span class="params">                                   <span class="type">rt_err_t</span> (*rx_ind)(<span class="type">rt_device_t</span> dev,</span></span><br><span class="line"><span class="params">                                   <span class="type">rt_size_t</span> size))</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 接收数据回调函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">rt_err_t</span> <span class="title function_">uart_input</span><span class="params">(<span class="type">rt_device_t</span> dev, <span class="type">rt_size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 串口接收到数据后产生中断，调用此回调函数，然后发送接收信号量 */</span></span><br><span class="line">    rt_sem_release(&amp;rx_sem);</span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rt_device_set_rx_indicate(serial, uart_input);</span><br></pre></td></tr></table></figure>
<h2 id="关闭设备">关闭设备</h2>
<blockquote>
<p>定义：应用程序打开设备完成读写等操作后，如果不需要再对设备进行操作则可以关闭设备，通过如下函数完成</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dev：设备句柄</span></span><br><span class="line"><span class="comment">//返回值：RT_EOK：关闭设备成功</span></span><br><span class="line"><span class="comment">//	-RT_ERROR：设备已经完全关闭，不能重复关闭设备，其他错误码：关闭设备失败</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_device_close</span><span class="params">(<span class="type">rt_device_t</span> dev)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="控制设备">控制设备</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dev：设备句柄，指向要控制的定时器，cmd：用于控制设备命令，arg：cmd控制命令参数</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_device_control</span><span class="params">(<span class="type">rt_device_t</span> dev, <span class="type">rt_uint8_t</span> cmd, <span class="type">void</span>* arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_DEVICE_CTRL_RESUME           0x01   <span class="comment">/* 恢复设备 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_DEVICE_CTRL_SUSPEND          0x02   <span class="comment">/* 挂起设备 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_DEVICE_CTRL_CONFIG           0x03   <span class="comment">/* 配置设备 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_DEVICE_CTRL_SET_INT          0x10   <span class="comment">/* 设置中断 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_DEVICE_CTRL_CLR_INT          0x11   <span class="comment">/* 清中断 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_DEVICE_CTRL_GET_INT          0x12   <span class="comment">/* 获取中断状态 */</span></span></span><br></pre></td></tr></table></figure>
<h2 id="读写设备">读写设备</h2>
<p>读定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dev：设备句柄，pos：读取数据偏移量，size	读取数据的大小</span></span><br><span class="line"><span class="comment">//buffer：内存缓冲区指针，读取的数据将会被保存在缓冲区中</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_size_t</span> <span class="title function_">rt_device_read</span><span class="params">(<span class="type">rt_device_t</span> dev, <span class="type">rt_off_t</span> pos,<span class="type">void</span>* buffer, <span class="type">rt_size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>
<p>读使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">rt_device_read(serial, <span class="number">-1</span>, &amp;ch, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>写定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dev：设备句柄，pos：写入数据偏移量</span></span><br><span class="line"><span class="comment">//buffer：内存缓冲区指针，放置要写入的数据，size：写入数据的大小</span></span><br><span class="line"><span class="comment">//返回：写入数据的实际大小(如果是字符设备，返回大小以字节为单位；如果是块设备，返回的大小以块为单位)</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_ssize_t</span> <span class="title function_">rt_device_write</span><span class="params">(<span class="type">rt_device_t</span> dev,</span></span><br><span class="line"><span class="params">                          <span class="type">rt_off_t</span>    pos,</span></span><br><span class="line"><span class="params">                          <span class="type">const</span> <span class="type">void</span> *buffer,</span></span><br><span class="line"><span class="params">                          <span class="type">rt_size_t</span>   size)</span></span><br></pre></td></tr></table></figure>
<p>写使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;hello RT-Thread!\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">rt_device_write(serial, <span class="number">0</span>, str, (<span class="keyword">sizeof</span>(str) - <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<hr>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序清单：这是一个 串口 设备使用例程</span></span><br><span class="line"><span class="comment"> * 例程导出了 uart_sample 命令到控制终端</span></span><br><span class="line"><span class="comment"> * 命令调用格式：uart_sample uart2</span></span><br><span class="line"><span class="comment"> * 命令解释：命令第二个参数是要使用的串口设备名称，为空则使用默认的串口设备</span></span><br><span class="line"><span class="comment"> * 程序功能：通过串口输出字符串&quot;hello RT-Thread!&quot;，然后错位输出输入的字符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAMPLE_UART_NAME       <span class="string">&quot;uart2&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用于接收消息的信号量 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_semaphore</span> <span class="title">rx_sem</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">rt_device_t</span> serial;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 接收数据回调函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">rt_err_t</span> <span class="title function_">uart_input</span><span class="params">(<span class="type">rt_device_t</span> dev, <span class="type">rt_size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 串口接收到数据后产生中断，调用此回调函数，然后发送接收信号量 */</span></span><br><span class="line">    rt_sem_release(&amp;rx_sem);</span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">serial_thread_entry</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 从串口读取一个字节的数据，没有读取到则等待接收信号量 */</span></span><br><span class="line">        <span class="keyword">while</span> (rt_device_read(serial, <span class="number">-1</span>, &amp;ch, <span class="number">1</span>) != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 阻塞等待接收信号量，等到信号量后再次读取数据 */</span></span><br><span class="line">            rt_sem_take(&amp;rx_sem, RT_WAITING_FOREVER);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 读取到的数据通过串口错位输出 */</span></span><br><span class="line">        ch = ch + <span class="number">1</span>;</span><br><span class="line">        rt_device_write(serial, <span class="number">0</span>, &amp;ch, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">uart_sample</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rt_err_t</span> ret = RT_EOK;</span><br><span class="line">    <span class="type">char</span> uart_name[RT_NAME_MAX];</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;hello RT-Thread!\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_strncpy(uart_name, argv[<span class="number">1</span>], RT_NAME_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        rt_strncpy(uart_name, SAMPLE_UART_NAME, RT_NAME_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查找系统中的串口设备 */</span></span><br><span class="line">    serial = rt_device_find(uart_name);</span><br><span class="line">    <span class="keyword">if</span> (!serial)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;find %s failed!\n&quot;</span>, uart_name);</span><br><span class="line">        <span class="keyword">return</span> RT_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化信号量 */</span></span><br><span class="line">    rt_sem_init(&amp;rx_sem, <span class="string">&quot;rx_sem&quot;</span>, <span class="number">0</span>, RT_IPC_FLAG_FIFO);</span><br><span class="line">    <span class="comment">/* 以中断接收及轮询发送模式打开串口设备 */</span></span><br><span class="line">    rt_device_open(serial, RT_DEVICE_FLAG_INT_RX);</span><br><span class="line">    <span class="comment">/* 设置接收回调函数 */</span></span><br><span class="line">    rt_device_set_rx_indicate(serial, uart_input);</span><br><span class="line">    <span class="comment">/* 发送字符串 */</span></span><br><span class="line">    rt_device_write(serial, <span class="number">0</span>, str, (<span class="keyword">sizeof</span>(str) - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建 serial 线程 */</span></span><br><span class="line">    <span class="type">rt_thread_t</span> thread = rt_thread_create(<span class="string">&quot;serial&quot;</span>, serial_thread_entry, RT_NULL, <span class="number">1024</span>, <span class="number">25</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">/* 创建成功则启动线程 */</span></span><br><span class="line">    <span class="keyword">if</span> (thread != RT_NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_thread_startup(thread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ret = RT_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 导出到 msh 命令列表中 */</span></span><br><span class="line">MSH_CMD_EXPORT(uart_sample, uart device sample);</span><br></pre></td></tr></table></figure>
<h2 id="uart-dma">UART_DMA</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_USING_UART3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_UART3_TX_PIN       <span class="string">&quot;PA10&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_UART3_RX_PIN       <span class="string">&quot;PA11&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_UART3_RX_USING_DMA</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序清单：这是一个串口设备 DMA 接收使用例程</span></span><br><span class="line"><span class="comment"> * 例程导出了 uart_dma_sample 命令到控制终端</span></span><br><span class="line"><span class="comment"> * 命令调用格式：uart_dma_sample uart3</span></span><br><span class="line"><span class="comment"> * 命令解释：命令第二个参数是要使用的串口设备名称，为空则使用默认的串口设备</span></span><br><span class="line"><span class="comment"> * 程序功能：通过串口输出字符串&quot;hello RT-Thread!&quot;，并通过串口输出接收到的数据，然后打印接收到的数据。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAMPLE_UART_NAME       <span class="string">&quot;uart3&quot;</span>      <span class="comment">/* 串口设备名称 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口接收消息结构*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rx_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">rt_device_t</span> dev;</span><br><span class="line">    <span class="type">rt_size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 串口设备句柄 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">rt_device_t</span> serial;</span><br><span class="line"><span class="comment">/* 消息队列控制块 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_messagequeue</span> <span class="title">rx_mq</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 接收数据回调函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">rt_err_t</span> <span class="title function_">uart_input</span><span class="params">(<span class="type">rt_device_t</span> dev, <span class="type">rt_size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rx_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">rt_err_t</span> result;</span><br><span class="line">    msg.dev = dev;</span><br><span class="line">    msg.size = size;</span><br><span class="line"></span><br><span class="line">    result = rt_mq_send(&amp;rx_mq, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> ( result == -RT_EFULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 消息队列满 */</span></span><br><span class="line">        rt_kprintf(<span class="string">&quot;message queue full！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">serial_thread_entry</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rx_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">rt_err_t</span> result;</span><br><span class="line">    <span class="type">rt_uint32_t</span> rx_length;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> rx_buffer[RT_SERIAL_RB_BUFSZ + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_memset(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="comment">/* 从消息队列中读取消息*/</span></span><br><span class="line">        result = rt_mq_recv(&amp;rx_mq, &amp;msg, <span class="keyword">sizeof</span>(msg), RT_WAITING_FOREVER);</span><br><span class="line">        <span class="keyword">if</span> (result &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 从串口读取数据*/</span></span><br><span class="line">            rx_length = rt_device_read(msg.dev, <span class="number">0</span>, rx_buffer, msg.size);</span><br><span class="line">            rx_buffer[rx_length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="comment">/* 通过串口设备 serial 输出读取到的消息 */</span></span><br><span class="line">            rt_device_write(serial, <span class="number">0</span>, rx_buffer, rx_length);</span><br><span class="line">            <span class="comment">/* 打印数据 */</span></span><br><span class="line">            rt_kprintf(<span class="string">&quot;%s\n&quot;</span>,rx_buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">uart_dma_sample</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rt_err_t</span> ret = RT_EOK;</span><br><span class="line">    <span class="type">char</span> uart_name[RT_NAME_MAX];</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> msg_pool[<span class="number">256</span>];</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;hello RT-Thread!\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_strncpy(uart_name, argv[<span class="number">1</span>], RT_NAME_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        rt_strncpy(uart_name, SAMPLE_UART_NAME, RT_NAME_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查找串口设备 */</span></span><br><span class="line">    serial = rt_device_find(uart_name);</span><br><span class="line">    <span class="keyword">if</span> (!serial)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;find %s failed!\n&quot;</span>, uart_name);</span><br><span class="line">        <span class="keyword">return</span> RT_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化消息队列 */</span></span><br><span class="line">    rt_mq_init(&amp;rx_mq, <span class="string">&quot;rx_mq&quot;</span>,</span><br><span class="line">               msg_pool,                 <span class="comment">/* 存放消息的缓冲区 */</span></span><br><span class="line">               <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rx_msg),    <span class="comment">/* 一条消息的最大长度 */</span></span><br><span class="line">               <span class="keyword">sizeof</span>(msg_pool),         <span class="comment">/* 存放消息的缓冲区大小 */</span></span><br><span class="line">               RT_IPC_FLAG_FIFO);        <span class="comment">/* 如果有多个线程等待，按照先来先得到的方法分配消息 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 以 DMA 接收及轮询发送方式打开串口设备 */</span></span><br><span class="line">    rt_device_open(serial, RT_DEVICE_FLAG_DMA_RX);</span><br><span class="line">    <span class="comment">/* 设置接收回调函数 */</span></span><br><span class="line">    rt_device_set_rx_indicate(serial, uart_input);</span><br><span class="line">    <span class="comment">/* 发送字符串 */</span></span><br><span class="line">    rt_device_write(serial, <span class="number">0</span>, str, (<span class="keyword">sizeof</span>(str) - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建 serial 线程 */</span></span><br><span class="line">    <span class="type">rt_thread_t</span> thread = rt_thread_create(<span class="string">&quot;serial&quot;</span>, serial_thread_entry, RT_NULL, <span class="number">1024</span>, <span class="number">25</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">/* 创建成功则启动线程 */</span></span><br><span class="line">    <span class="keyword">if</span> (thread != RT_NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_thread_startup(thread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ret = RT_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 导出到 msh 命令列表中 */</span></span><br><span class="line">MSH_CMD_EXPORT(uart_dma_sample, uart device dma sample);</span><br></pre></td></tr></table></figure>
<h1><center>PIN</center></h1>
<h2 id="获取引脚编号">获取引脚编号</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">rt_base_t</span> <span class="title function_">rt_pin_get</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pin_number = rt_pin_get(<span class="string">&quot;PF.9&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="设置引脚模式">设置引脚模式</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pin：引脚编号，mode：引脚工作模式</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rt_pin_mode</span><span class="params">(<span class="type">rt_base_t</span> pin, <span class="type">rt_uint8_t</span> mode)</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN_MODE_OUTPUT 0x00            <span class="comment">/* 输出 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN_MODE_INPUT 0x01             <span class="comment">/* 输入 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN_MODE_INPUT_PULLUP 0x02      <span class="comment">/* 上拉输入 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN_MODE_INPUT_PULLDOWN 0x03    <span class="comment">/* 下拉输入 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN_MODE_OUTPUT_OD 0x04         <span class="comment">/* 开漏输出 */</span></span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BEEP_PIN_NUM</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> BEEP_PIN_NUM            24  <span class="comment">/* PB8 */</span></span></span><br><span class="line"></span><br><span class="line">rt_pin_mode(BEEP_PIN_NUM, PIN_MODE_OUTPUT);</span><br></pre></td></tr></table></figure>
<h2 id="设置引脚电平">设置引脚电平</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pin：引脚编号，value：电平逻辑值，PIN_LOW 低电平，PIN_HIGH 高电平</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rt_pin_write</span><span class="params">(<span class="type">rt_base_t</span> pin, <span class="type">rt_base_t</span> value)</span>;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BEEP_PIN_NUM</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> BEEP_PIN_NUM            24  <span class="comment">/* PB8 */</span></span></span><br><span class="line"></span><br><span class="line">rt_pin_write(BEEP_PIN_NUM, PIN_LOW);</span><br></pre></td></tr></table></figure>
<h2 id="读取引脚电平">读取引脚电平</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pin：引脚编号</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_ssize_t</span> <span class="title function_">rt_pin_read</span><span class="params">(<span class="type">rt_base_t</span> pin)</span>;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BEEP_PIN_NUM</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> BEEP_PIN_NUM            24  <span class="comment">/* PB8 */</span></span></span><br><span class="line"><span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">status = rt_pin_read(BEEP_PIN_NUM);</span><br></pre></td></tr></table></figure>
<h2 id="绑定引脚中断回调函数">绑定引脚中断回调函数</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pin：引脚编号，mode：中断触发模式，hdr：中断回调函数</span></span><br><span class="line"><span class="comment">//args：中断回调函数的参数，不需要时设置为 RT_NULL</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_pin_attach_irq</span><span class="params">(<span class="type">rt_int32_t</span> pin, <span class="type">rt_uint32_t</span> mode,</span></span><br><span class="line"><span class="params">                           <span class="type">void</span> (*hdr)(<span class="type">void</span> *args), <span class="type">void</span> *args)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN_IRQ_MODE_RISING 0x00         <span class="comment">/* 上升沿触发 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN_IRQ_MODE_FALLING 0x01        <span class="comment">/* 下降沿触发 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN_IRQ_MODE_RISING_FALLING 0x02 <span class="comment">/* 边沿触发（上升沿和下降沿都触发）*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN_IRQ_MODE_HIGH_LEVEL 0x03     <span class="comment">/* 高电平触发 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN_IRQ_MODE_LOW_LEVEL 0x04      <span class="comment">/* 低电平触发 */</span></span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KEY0_PIN_NUM</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0_PIN_NUM            66  <span class="comment">/* PE2 */</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">beep_on</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;turn on beep!\n&quot;</span>);</span><br><span class="line">    rt_pin_write(BEEP_PIN_NUM, PIN_HIGH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rt_pin_attach_irq(KEY0_PIN_NUM, PIN_IRQ_MODE_FALLING, beep_on, RT_NULL);</span><br></pre></td></tr></table></figure>
<h2 id="使能引脚中断">使能引脚中断</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pin：引脚编号，enabled：状态，PIN_IRQ_ENABLE（开启）PIN_IRQ_DISABLE（关闭）</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_pin_irq_enable</span><span class="params">(<span class="type">rt_base_t</span> pin, <span class="type">rt_uint8_t</span> enabled)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KEY0_PIN_NUM</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KEY0_PIN_NUM            66  <span class="comment">/* PE2 */</span></span></span><br><span class="line"></span><br><span class="line">rt_pin_irq_enable(KEY0_PIN_NUM, PIN_IRQ_ENABLE);</span><br></pre></td></tr></table></figure>
<h2 id="脱离引脚中断回调函数">脱离引脚中断回调函数</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pin：引脚编号</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_pin_detach_irq</span><span class="params">(<span class="type">rt_int32_t</span> pin)</span>;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KEY0_PIN_NUM</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KEY0_PIN_NUM            66  <span class="comment">/* PE2 */</span></span></span><br><span class="line"></span><br><span class="line">rt_pin_detach_irq(KEY0_PIN_NUM);</span><br></pre></td></tr></table></figure>
<hr>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序清单：这是一个 PIN 设备使用例程</span></span><br><span class="line"><span class="comment"> * 例程导出了 pin_beep_sample 命令到控制终端</span></span><br><span class="line"><span class="comment"> * 命令调用格式：pin_beep_sample</span></span><br><span class="line"><span class="comment"> * 程序功能：通过按键控制蜂鸣器对应引脚的电平状态控制蜂鸣器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtdevice.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 引脚编号，通过查看设备驱动文件drv_gpio.c确定 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BEEP_PIN_NUM</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> BEEP_PIN_NUM            24  <span class="comment">/* PB8 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KEY0_PIN_NUM</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KEY0_PIN_NUM            66  <span class="comment">/* PE2 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KEY1_PIN_NUM</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KEY1_PIN_NUM            67  <span class="comment">/* PE3 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">beep_on</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;turn on beep!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    rt_pin_write(BEEP_PIN_NUM, PIN_HIGH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">beep_off</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;turn off beep!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    rt_pin_write(BEEP_PIN_NUM, PIN_LOW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pin_beep_sample</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 蜂鸣器引脚为输出模式 */</span></span><br><span class="line">    rt_pin_mode(BEEP_PIN_NUM, PIN_MODE_OUTPUT);</span><br><span class="line">    <span class="comment">/* 默认低电平 */</span></span><br><span class="line">    rt_pin_write(BEEP_PIN_NUM, PIN_LOW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 按键0引脚为输入模式 */</span></span><br><span class="line">    rt_pin_mode(KEY0_PIN_NUM, PIN_MODE_INPUT_PULLUP);</span><br><span class="line">    <span class="comment">/* 绑定中断，下降沿模式，回调函数名为beep_on */</span></span><br><span class="line">    rt_pin_attach_irq(KEY0_PIN_NUM, PIN_IRQ_MODE_FALLING, beep_on, RT_NULL);</span><br><span class="line">    <span class="comment">/* 使能中断 */</span></span><br><span class="line">    rt_pin_irq_enable(KEY0_PIN_NUM, PIN_IRQ_ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 按键1引脚为输入模式 */</span></span><br><span class="line">    rt_pin_mode(KEY1_PIN_NUM, PIN_MODE_INPUT_PULLUP);</span><br><span class="line">    <span class="comment">/* 绑定中断，下降沿模式，回调函数名为beep_off */</span></span><br><span class="line">    rt_pin_attach_irq(KEY1_PIN_NUM, PIN_IRQ_MODE_FALLING, beep_off, RT_NULL);</span><br><span class="line">    <span class="comment">/* 使能中断 */</span></span><br><span class="line">    rt_pin_irq_enable(KEY1_PIN_NUM, PIN_IRQ_ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 导出到 msh 命令列表中 */</span></span><br><span class="line">MSH_CMD_EXPORT(pin_beep_sample, pin beep sample);</span><br></pre></td></tr></table></figure>
<h1><center>ADC</center></h1>
<p>模拟信号转换为数字信号</p>
<p>按照图中指示开启ADC，按<code>ctrl+s</code>保存</p>
<img src="https://s2.loli.net/2024/09/27/fAgwIQcXm8VHz2x.webp" alt="开启ADC" style="zoom:40%;">
<p>在<code>board.h</code>文件中寻找ADC配置(182)，按照注释给出的步骤进行配置</p>
<img src="https://s2.loli.net/2024/09/27/exARaK6l4IqFUTJ.webp" alt="CubeMx配置ADC" style="zoom:40%;">
<h2 id="查找adc设备">查找ADC设备</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//name：ADC 设备名称，返回值：设备句柄</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_device_t</span> <span class="title function_">rt_device_find</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">rt_adc_device_t</span> adc_dev;</span><br><span class="line"></span><br><span class="line">adc_dev = (<span class="type">rt_adc_device_t</span>)rt_device_find(ADC_DEV_NAME);</span><br></pre></td></tr></table></figure>
<h2 id="使能adc通道">使能ADC通道</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dev：ADC 设备句柄，channel：ADC 通道</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_adc_enable</span><span class="params">(<span class="type">rt_adc_device_t</span> dev, <span class="type">rt_uint32_t</span> channel)</span>;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_DEV_CHANNEL     5           <span class="comment">/* ADC 通道 */</span></span></span><br><span class="line"><span class="type">rt_err_t</span> ret = RT_EOK;</span><br><span class="line"></span><br><span class="line">ret = rt_adc_enable(adc_dev, ADC_DEV_CHANNEL);</span><br></pre></td></tr></table></figure>
<h2 id="读取adc通道采样值">读取ADC通道采样值</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dev：ADC 设备句柄，channel：ADC 通道</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_uint32_t</span> <span class="title function_">rt_adc_read</span><span class="params">(<span class="type">rt_adc_device_t</span> dev, <span class="type">rt_uint32_t</span> channel)</span>;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">rt_uint32_t</span> value;</span><br><span class="line"></span><br><span class="line">value = rt_adc_read(adc_dev, ADC_DEV_CHANNEL);</span><br></pre></td></tr></table></figure>
<h2 id="关闭adc通道">关闭ADC通道</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dev：ADC 设备句柄，channel：ADC 通道</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_adc_disable</span><span class="params">(<span class="type">rt_adc_device_t</span> dev, <span class="type">rt_uint32_t</span> channel)</span>;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_DEV_CHANNEL     5           <span class="comment">/* ADC 通道 */</span></span></span><br><span class="line"><span class="type">rt_err_t</span> ret = RT_EOK;</span><br><span class="line"></span><br><span class="line">ret = rt_adc_disable(adc_dev, ADC_DEV_CHANNEL);</span><br></pre></td></tr></table></figure>
<hr>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序清单： ADC 设备使用例程</span></span><br><span class="line"><span class="comment"> * 例程导出了 adc_sample 命令到控制终端</span></span><br><span class="line"><span class="comment"> * 命令调用格式：adc_sample</span></span><br><span class="line"><span class="comment"> * 程序功能：通过 ADC 设备采样电压值并转换为数值。</span></span><br><span class="line"><span class="comment"> *           示例代码参考电压为3.3V,转换位数为12位。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtdevice.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_DEV_NAME        <span class="string">&quot;adc1&quot;</span>      <span class="comment">/* ADC 设备名称 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_DEV_CHANNEL     5           <span class="comment">/* ADC 通道 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REFER_VOLTAGE       330         <span class="comment">/* 参考电压 3.3V,数据精度乘以100保留2位小数*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONVERT_BITS        (1 &lt;&lt; 12)   <span class="comment">/* 转换位数为12位 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">adc_vol_sample</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rt_adc_device_t</span> adc_dev;</span><br><span class="line">    <span class="type">rt_uint32_t</span> value, vol;</span><br><span class="line">    <span class="type">rt_err_t</span> ret = RT_EOK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查找设备 */</span></span><br><span class="line">    adc_dev = (<span class="type">rt_adc_device_t</span>)rt_device_find(ADC_DEV_NAME);</span><br><span class="line">    <span class="keyword">if</span> (adc_dev == RT_NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;adc sample run failed! can&#x27;t find %s device!\n&quot;</span>, ADC_DEV_NAME);</span><br><span class="line">        <span class="keyword">return</span> RT_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 使能设备 */</span></span><br><span class="line">    ret = rt_adc_enable(adc_dev, ADC_DEV_CHANNEL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读取采样值 */</span></span><br><span class="line">    value = rt_adc_read(adc_dev, ADC_DEV_CHANNEL);</span><br><span class="line">    rt_kprintf(<span class="string">&quot;the value is :%d \n&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 转换为对应电压值 */</span></span><br><span class="line">    vol = value * REFER_VOLTAGE / CONVERT_BITS;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;the voltage is :%d.%02d \n&quot;</span>, vol / <span class="number">100</span>, vol % <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关闭通道 */</span></span><br><span class="line">    ret = rt_adc_disable(adc_dev, ADC_DEV_CHANNEL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 导出到 msh 命令列表中 */</span></span><br><span class="line">MSH_CMD_EXPORT(adc_vol_sample, adc voltage convert sample);</span><br></pre></td></tr></table></figure>
<h1><center>PWM</center></h1>
<p>按照图中指示开启PWM，按<code>ctrl+s</code>保存</p>
<img src="https://s2.loli.net/2024/09/27/wsQNnuLSI4Z3WPi.webp" alt="开启PWM" style="zoom:40%;">
<p>在<code>board.h</code>文件中寻找PWM配置(158)，按照注释给出的步骤进行配置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_USING_PWM3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_USING_PWM3_CH4	<span class="comment">//没说说明但要添加,通道4</span></span></span><br></pre></td></tr></table></figure>
<h2 id="查找pwm设备">查找PWM设备</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//name：设备名称，返回：查找到对应设备将返回相应的设备句柄</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_device_t</span> <span class="title function_">rt_device_find</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_DEV_NAME        <span class="string">&quot;pwm3&quot;</span>  <span class="comment">/* PWM设备名称 */</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_device_pwm</span> *<span class="title">pwm_dev</span>;</span>      <span class="comment">/* PWM设备句柄 */</span></span><br><span class="line"></span><br><span class="line">pwm_dev = (<span class="keyword">struct</span> rt_device_pwm *)rt_device_find(PWM_DEV_NAME);</span><br><span class="line"><span class="keyword">if</span> (pwm_dev == RT_NULL)</span><br><span class="line">&#123;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;pwm sample run failed! can&#x27;t find %s device!\n&quot;</span>, PWM_DEV_NAME);</span><br><span class="line">    <span class="keyword">return</span> RT_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="设置-pwm-周期和脉冲宽度">设置 PWM 周期和脉冲宽度</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//device：PWM 设备句柄，channel：PWM 通道</span></span><br><span class="line"><span class="comment">//period：PWM 周期时间 (单位纳秒 ns)，pulse：PWM 脉冲宽度时间 (单位纳秒 ns)</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_pwm_set</span><span class="params">(<span class="keyword">struct</span> rt_device_pwm *device,</span></span><br><span class="line"><span class="params">                    <span class="type">int</span> channel,</span></span><br><span class="line"><span class="params">                    <span class="type">rt_uint32_t</span> period,</span></span><br><span class="line"><span class="params">                    <span class="type">rt_uint32_t</span> pulse)</span>;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_DEV_CHANNEL     4       <span class="comment">/* PWM通道 */</span></span></span><br><span class="line">period = <span class="number">500000</span>;    <span class="comment">/* 周期为0.5ms，单位为纳秒ns */</span></span><br><span class="line">pulse = <span class="number">0</span>;          <span class="comment">/* PWM脉冲宽度值，单位为纳秒ns */</span></span><br><span class="line"></span><br><span class="line">rt_pwm_set(pwm_dev, PWM_DEV_CHANNEL, period, pulse);</span><br></pre></td></tr></table></figure>
<h2 id="使能-pwm-设备">使能 PWM 设备</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//device：PWM 设备句柄，channel：PWM 通道 -channel代表互补通道</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_pwm_enable</span><span class="params">(<span class="keyword">struct</span> rt_device_pwm *device, <span class="type">int</span> channel)</span>;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_DEV_CHANNEL     4       <span class="comment">/* PWM通道 */</span></span></span><br><span class="line"></span><br><span class="line">rt_pwm_enable(pwm_dev, PWM_DEV_CHANNEL);</span><br></pre></td></tr></table></figure>
<h2 id="关闭-pwm-设备">关闭 PWM 设备</h2>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//device：PWM 设备句柄，channel：PWM 通道</span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_pwm_disable</span><span class="params">(<span class="keyword">struct</span> rt_device_pwm *device, <span class="type">int</span> channel)</span>;</span><br></pre></td></tr></table></figure>
<hr>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序清单：这是一个 PWM 设备使用例程</span></span><br><span class="line"><span class="comment"> * 例程导出了 pwm_led_sample 命令到控制终端</span></span><br><span class="line"><span class="comment"> * 命令调用格式：pwm_led_sample</span></span><br><span class="line"><span class="comment"> * 程序功能：通过 PWM 设备控制 LED 灯的亮度，可以看到LED不停的由暗变到亮，然后又从亮变到暗。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtdevice.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_DEV_NAME        <span class="string">&quot;pwm3&quot;</span>  <span class="comment">/* PWM设备名称 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_DEV_CHANNEL     4       <span class="comment">/* PWM通道 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_device_pwm</span> *<span class="title">pwm_dev</span>;</span>      <span class="comment">/* PWM设备句柄 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pwm_led_sample</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rt_uint32_t</span> period, pulse, dir;</span><br><span class="line"></span><br><span class="line">    period = <span class="number">500000</span>;    <span class="comment">/* 周期为0.5ms，单位为纳秒ns */</span></span><br><span class="line">    dir = <span class="number">1</span>;            <span class="comment">/* PWM脉冲宽度值的增减方向 */</span></span><br><span class="line">    pulse = <span class="number">0</span>;          <span class="comment">/* PWM脉冲宽度值，单位为纳秒ns */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查找设备 */</span></span><br><span class="line">    pwm_dev = (<span class="keyword">struct</span> rt_device_pwm *)rt_device_find(PWM_DEV_NAME);</span><br><span class="line">    <span class="keyword">if</span> (pwm_dev == RT_NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;pwm sample run failed! can&#x27;t find %s device!\n&quot;</span>, PWM_DEV_NAME);</span><br><span class="line">        <span class="keyword">return</span> RT_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置PWM周期和脉冲宽度默认值 */</span></span><br><span class="line">    rt_pwm_set(pwm_dev, PWM_DEV_CHANNEL, period, pulse);</span><br><span class="line">    <span class="comment">/* 使能设备 */</span></span><br><span class="line">    rt_pwm_enable(pwm_dev, PWM_DEV_CHANNEL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_thread_mdelay(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">if</span> (dir)</span><br><span class="line">        &#123;</span><br><span class="line">            pulse += <span class="number">5000</span>;      <span class="comment">/* 从0值开始每次增加5000ns */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pulse -= <span class="number">5000</span>;      <span class="comment">/* 从最大值开始每次减少5000ns */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pulse &gt;= period)</span><br><span class="line">        &#123;</span><br><span class="line">            dir = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == pulse)</span><br><span class="line">        &#123;</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 设置PWM周期和脉冲宽度 */</span></span><br><span class="line">        rt_pwm_set(pwm_dev, PWM_DEV_CHANNEL, period, pulse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 导出到 msh 命令列表中 */</span></span><br><span class="line">MSH_CMD_EXPORT(pwm_led_sample, pwm sample);</span><br></pre></td></tr></table></figure>
<h1><center>IIC</center></h1>
<p>添加软件包，按<code>ctrl+s</code>保存</p>
<img src="https://s2.loli.net/2024/09/27/jgexEfpCWMaDPto.webp" alt="添加软件包" style="zoom:35%;">
<p>添加文件：GY906.c、GY906.h、oled_config.c、oled_config.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改main.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_TAG <span class="string">&quot;main&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_LVL DBG_LOG</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtdbg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled_config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GY906.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个变量保存温度值</span></span><br><span class="line">    <span class="type">float</span> temp;</span><br><span class="line">    DisplayCfg_Init();  <span class="comment">//oled初始化</span></span><br><span class="line">    GY906_Init();   <span class="comment">//温度模块初始化</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = SMBus_ReadTemp();</span><br><span class="line">        Display_normal(temp); <span class="comment">//显示温度</span></span><br><span class="line">        rt_thread_mdelay(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>RT-Thread</category>
      </categories>
      <tags>
        <tag>RT-Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>10.结构体、共用体、枚举</title>
    <url>/post/5bdb5548.html</url>
    <content><![CDATA[<h1><center>知识点一：结构体定义</center></h1>
<blockquote>
<p>头文件：<font color="red"><code>#include&lt;string.h&gt;</code></font></p>
<p>结构体中的成员拥有<code>独立</code>的空间</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;	<span class="comment">//一定要记得有;号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//struct：结构体关键字</span></span><br><span class="line"><span class="comment">//stu：结构体类型名，指定一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用结构体类型必须是struct stu</span></span><br><span class="line"><span class="comment">//num name age叫做结构体中的成员</span></span><br><span class="line"><span class="comment">//定义结构体类型的时候不要给成员赋值（重要）</span></span><br><span class="line"><span class="comment">//定义结构体类型的时候 并没有分配空间 所以不能给成员赋值</span></span><br></pre></td></tr></table></figure>
<h2 id="center-结构体定义形式-center"><center>结构体定义形式</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先定义类型再定义变量（推荐）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">lucy</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义类型的同时定义变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;lucy;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">bob</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一次性结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;lucy;</span><br><span class="line"><span class="comment">//不能定义其他变量</span></span><br></pre></td></tr></table></figure>
<h2 id="center-结构体变量定义和初始化-center"><center>结构体变量定义和初始化</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;	<span class="comment">//4B</span></span><br><span class="line">    <span class="type">char</span> name [<span class="number">32</span>];<span class="comment">//32B</span></span><br><span class="line">    <span class="type">int</span> age;	<span class="comment">//4B</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//用结构体类型定义一个变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">lucy</span>;</span>	<span class="comment">//lucy 是局部变量 lucy的成员内容不确定</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//结构体变量初始化，初始化顺序必须和结构体成员的顺序一致</span></span><br><span class="line">    <span class="comment">//struct stu lucy = &#123;100,&quot;德玛西亚&quot;,18&#125;;</span></span><br><span class="line">    <span class="comment">//printf(&quot; num = %d,name = %s,age = %d\n&quot;, lucy.num,lucy.name,lucy.age);</span></span><br><span class="line">    <span class="comment">//清空结构体变量</span></span><br><span class="line">    <span class="comment">//memset(&amp;lucy,0,sizeof(lucy));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过结构体变量访问结构体中的成员(访问时一定要遵循成员自身的类型)</span></span><br><span class="line">    lucy.num = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">strcpy</span> (lucy.name,<span class="string">&quot;德玛西亚&quot;</span>);</span><br><span class="line">    lucy.age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>,lucy.num);	<span class="comment">//100</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name = %s\n&quot;</span>,lucy.name);	<span class="comment">//德玛西亚</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;age = %d\n&quot;</span>,lucy.age);	<span class="comment">//18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点二：结构体变量获取键盘输入</center></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;		<span class="comment">//4B</span></span><br><span class="line">    <span class="type">char</span> name [<span class="number">32</span>];	<span class="comment">//32B</span></span><br><span class="line">    <span class="type">int</span> age;		<span class="comment">//4B</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">lucy</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;lucy,<span class="number">0</span>,<span class="keyword">sizeof</span>(lucy));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入num name_age:&quot;</span>) ;</span><br><span class="line">    <span class="comment">//&amp;lucy.num取的是num成员地址</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %s %d&quot;</span>,&amp;lucy.num,&amp;lucy.name,&amp;lucy.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d,name = %s,age = %d\n&quot;</span>,lucy.num,lucy.name,lucy.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点三：结构体变量之间的赋值</center></h1>
<blockquote>
<p>memcpy：内存块中的数据从一个地方复制到另一个地方</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(<span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">size_t</span> n);</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">    str1：指向用于存储复制内容的目标数组，类型强制转换为 <span class="type">void</span>* 指针</span><br><span class="line">    str2：指向要复制的数据源，类型强制转换为 <span class="type">void</span>* 指针</span><br><span class="line">    n：要被复制的字节数</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;		<span class="comment">//4B</span></span><br><span class="line">    <span class="type">char</span> name [<span class="number">32</span>];	<span class="comment">//32B</span></span><br><span class="line">    <span class="type">int</span> age;		<span class="comment">//4B</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">lucy</span> =</span> &#123;<span class="number">100</span>,<span class="string">&quot;小法&quot;</span>,<span class="number">18</span>&#125; ;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">bob</span>;</span></span><br><span class="line">    <span class="comment">//需求将lucy的值赋值bob</span></span><br><span class="line">    <span class="comment">//方式一：逐个成员赋值</span></span><br><span class="line">    <span class="comment">//bob.num = lucy.num;</span></span><br><span class="line">    <span class="comment">//strcpy(bob.name,lucy.name);</span></span><br><span class="line">    <span class="comment">//bob.age = lucy.age;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式二：相同类型的结构体变量 可以直接赋值(推荐)</span></span><br><span class="line">    <span class="comment">//bob = lucy;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法三：方法二的底层实现</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;bob, &amp;lucy,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> stu));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d,name = %s,age = %d\n&quot;</span>,bob.num,bob.name,bob.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点四：结构体数组</center></h1>
<img src="https://s2.loli.net/2024/09/03/jVJsuW4GkD9P3lL.webp" alt="结构体数组分析" style="zoom:50%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;		<span class="comment">//4B</span></span><br><span class="line">    <span class="type">char</span> name [<span class="number">32</span>];	<span class="comment">//32B</span></span><br><span class="line">    <span class="type">int</span> age;		<span class="comment">//4B</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">arr</span>[5]=</span>&#123;</span><br><span class="line">        &#123;<span class="number">100</span>,<span class="string">&quot;小法&quot;</span>,<span class="number">18</span>&#125;,</span><br><span class="line">        &#123;<span class="number">101</span>,<span class="string">&quot;德玛西亚&quot;</span>,<span class="number">19</span>&#125;,</span><br><span class="line">        &#123;<span class="number">102</span>,<span class="string">&quot;盲僧&quot;</span>,<span class="number">20</span>&#125;,</span><br><span class="line">        &#123;<span class="number">103</span>,<span class="string">&quot;快乐风男&quot;</span>,<span class="number">30</span>&#125;,&#123;<span class="number">104</span>,<span class="string">&quot;提莫&quot;</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;num = %d,name = %s,age = %d\n&quot;</span>,arr[i].num, arr[i].name,arr[i].age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点五：typedef 给已有的类型取个别名</center></h1>
<h2 id="1-给int取个别名int32">1、给int取个别名INT32</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INT32;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    INT32 num = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>,num);	<span class="comment">//10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-给数组取个别名">2、给数组取个别名</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ARR_TYPE 就是数组类型,该数组必须有5个元素 每个元素为int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ARR_TYPE[<span class="number">5</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ARR_TYPE arr = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;; <span class="comment">//arr就是一个拥有5个元素每个元素为int的数</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-给指针取别名">3、给指针取别名</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> *P_TYPE;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    P_TYPE p = &amp;num;    <span class="comment">//P_TYPE p == int *p</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);	<span class="comment">//10 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-给函数指针取别名">4、给函数指针取别名</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//FUN_P是一个函数指针类型 该函数必须有两个int形参以及一个int返回值</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*FUN_P)</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FUN_P p = my_add;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p(<span class="number">100</span>,<span class="number">200</span>));    <span class="comment">//300;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-给结构体类型取个别名">5、给结构体类型取个别名</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;STU;    <span class="comment">//STU == struct stu</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    STU lucy = &#123;<span class="number">100</span>,<span class="string">&quot;lucy&quot;</span>,<span class="number">18</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点六：结构体指针</center></h1>
<img src="https://s2.loli.net/2024/09/03/86ZNxAKG42UtaD5.webp" alt="结构体指针分析" style="zoom:50%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;STU;    <span class="comment">//STU是结构体类型</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    STU lucy = &#123;<span class="number">100</span>,<span class="string">&quot;lucy&quot;</span>,<span class="number">18</span>&#125;;</span><br><span class="line">    STU *p = &amp;lucy;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d,name = %s,age = %d\n&quot;</span>,lucy.num,lucy.name,lucy.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d,name = %s,age = %d\n&quot;</span>,(*p).num,(*p).name,(*p).age);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d,name = %s,age = %d\n&quot;</span>, p-&gt;num, p-&gt;name, p-&gt;age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, (&amp;lucy)-&gt;num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点七：结构体指针作为函数参数</center></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;STU;    <span class="comment">//STU是结构体类型</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mySetSTUData</span><span class="params">(STU *p)</span>	<span class="comment">//p=&amp;lucy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个学生的信息num name age\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %s %d&quot;</span>,&amp;p-&gt;num,p-&gt;name,&amp;p-&gt;age);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myPrintSTUData</span><span class="params">(<span class="type">const</span> STU *p)</span>	<span class="comment">//tmp =lucy    *p只读 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//constSTU*p不允许用户借助p修改 p所指向的空间内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d,name = %s,age = %d\n&quot;</span>,p-&gt;num,p-&gt;name,p-&gt;age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    STU lucy;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;lucy,<span class="number">0</span>,<span class="keyword">sizeof</span>(lucy));</span><br><span class="line">    <span class="comment">//定义一个函数给lucy的成员获取键盘输入</span></span><br><span class="line">    mySetSTUData(&amp;lucy);</span><br><span class="line">    <span class="comment">//定义一个函数 打印lucy的成员信息</span></span><br><span class="line">    myPrintSTUData(&amp;lucy);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点八：结构体内存对齐</center></h1>
<img src="https://s2.loli.net/2024/09/03/kcvnPChKOmNdxVa.webp" alt="对齐规则" style="zoom:50%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">    <span class="type">char</span> d;</span><br><span class="line">&#125;DATA;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test06</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DATA d;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(DATA));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, &amp;d.a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, &amp;d.b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, &amp;d.c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, &amp;d.d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点九：结构体嵌套结构体</center></h1>
<img src="https://s2.loli.net/2024/09/03/a85fWFnQlEk7BTD.webp" alt="结构体嵌套结构体分析" style="zoom:50%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;DATA2;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    DATA2 c;	<span class="comment">//结构体变量c作为了DATA3的成员叫结构体嵌套结构体</span></span><br><span class="line">&#125;DATA3;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">//DATA3 data = &#123;10, 20, 30, 40&#125;;</span></span><br><span class="line">    DATA3 data = &#123;<span class="number">10</span>,<span class="number">20</span>, &#123;<span class="number">30</span>,<span class="number">40</span>&#125;&#125;;	<span class="comment">//推荐</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>,data.a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>,data.b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d\n&quot;</span>,data.c.x);    <span class="comment">//访问最底层 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;y = %d\n&quot;</span>,data.c.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十：嵌套结构体内存对齐</center></h1>
<img src="https://s2.loli.net/2024/09/03/Svb6TuLGm3KqP4e.webp" alt="嵌套结构体内存对齐" style="zoom:50%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">short</span> d;</span><br><span class="line">    <span class="type">char</span> e;</span><br><span class="line">&#125;DATA2;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">short</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    DATA2 c;</span><br><span class="line">    <span class="type">char</span> f;</span><br><span class="line">&#125;DATA;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(DATA));	<span class="comment">//16</span></span><br><span class="line">    DATA data;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;a：%u\n&quot;</span>, &amp;data.a);	<span class="comment">//1703628</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b：%u\n&quot;</span>, &amp;data.b);	<span class="comment">//1703632</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c中d: %u\n&quot;</span>,&amp;data.c.d);	<span class="comment">//1703636</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c中e: %u\n&quot;</span>, &amp;data.c.e);	<span class="comment">//1703638</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f：%u\n&quot;</span>,&amp;data.f);	<span class="comment">//1703640</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十一：强制类型对齐</center></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> pack (value)	<span class="comment">//value：指定对齐值</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//value只能是：1 2 4 8...(指定对齐值与数据类型对齐值相比取较小值)</span></span><br><span class="line"><span class="comment">//设为1：则short、 int、 float等均为1，设为2：则char仍为1，short为2，int变为2</span></span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2024/09/03/5yjODESxKZNV36P.webp" alt="强制类型对齐分析" style="zoom:50%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定对齐规则</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(2)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">short</span> C;</span><br><span class="line">&#125;DATA1;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(DATA1));    <span class="comment">//8</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十二：结构的浅拷贝和深拷贝</center></h1>
<p><strong>1、指针变量作为结构体的成员</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> *name;	<span class="comment">//指针变量作为结构体的成员</span></span><br><span class="line">&#125;DATA;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DATA data = &#123;<span class="number">100</span>, <span class="string">&quot;hehehehaha&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(DATA));	<span class="comment">//8字节</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span> ,data.num);</span><br><span class="line">    <span class="comment">//指针变量作为结构体的成员保存的是空间的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name = %s\n&quot;</span>, data.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、指针变量作为结构体的成员 操作前 必须有合法空间</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test02</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DATA data;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(DATA));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, data.num);</span><br><span class="line">    <span class="comment">//指针变量作为结构体的成员操作前必须有合法的空间</span></span><br><span class="line">    <span class="comment">//data.name = &quot;hehe&quot;;</span></span><br><span class="line">    <span class="comment">//给name事先申请一块堆区空间</span></span><br><span class="line">    data.name = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(data.name,<span class="string">&quot;hahaha&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name = %s\n&quot;</span>, data.name );</span><br><span class="line">    <span class="comment">//如果name指向堆区空间一定要记得释放</span></span><br><span class="line">    <span class="keyword">if</span>(data. name != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(data. name);</span><br><span class="line">        data. name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3、指针变量作为结构体成员，结构体变量间的赋值操作容易导致“浅拷贝”发生</strong></p>
<img src="https://s2.loli.net/2024/08/27/SVdqARZw5eLEDiv.webp" alt="浅拷贝" style="zoom:50%;">
<p>两个结构体变量中的指针成员指向同一块堆区空间。运行结果：出现段错误</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test03</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DATA data1;</span><br><span class="line">    DATA data2;</span><br><span class="line">    data1.num = <span class="number">100</span>;</span><br><span class="line">    data1.name = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(data1.name,<span class="string">&quot;my data&quot;</span>);</span><br><span class="line">    <span class="comment">//指针变量作为结构体的成员结构体变量间的赋值操作容易导致&quot;浅拷贝”发生</span></span><br><span class="line">    data2 = data1;    <span class="comment">//&quot;浅拷贝”</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data2: num = %d,name = %s\n&quot;</span>, data2.num,data2.name); </span><br><span class="line">    <span class="keyword">if</span>(datal.name != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(data1.name);</span><br><span class="line">        data1.name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( data2.name != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(data2.name);</span><br><span class="line">        data2.name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4、深拷贝</strong></p>
<p>前提：是指针变量作为结构体的成员</p>
<p>两个结构体变量中的指针成员指向各自的堆区空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">&#125;DATA;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DATA datal ;</span><br><span class="line">    DATA data2 ;</span><br><span class="line">    datal.num = <span class="number">100</span>;</span><br><span class="line">    datal.name = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">strcpy</span> (datal.name,<span class="string">&quot;my data&quot;</span>);</span><br><span class="line">    data2.num = datal.num;</span><br><span class="line">    <span class="comment">//为结构体变量 申请 独立空间 </span></span><br><span class="line">    data2.name = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(data2.name,datal.name) ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data1:num = %d,name = %s\n&quot;</span>,datal.num,datal.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data2:num = %d,name = %s\n&quot;</span>,data2.num,data2.name);</span><br><span class="line">    <span class="keyword">if</span> (datal.name!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(datal.name);</span><br><span class="line">        datal.name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (data2.name!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(data2.name);</span><br><span class="line">        data2.name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十三：位段</center></h1>
<blockquote>
<p>结构体中以位为单位来指定其成员所占内存长度，以位为单位的成员称为“位段”或称“位域”</p>
</blockquote>
<h2 id="center-位段定义与使用-center"><center>位段定义与使用</center></h2>
<img src="https://s2.loli.net/2024/09/03/jo3Abns2Mxeirh6.webp" alt="位段定义与使用" style="zoom:50%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位段 一般只考虑unsigned int类型也可以考虑unsigned char</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a:<span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b:<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//相邻位域可以压缩(压缩的位数 不能超过成员自身大小)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> :<span class="number">4</span>;	<span class="comment">//无意义的位段</span></span><br><span class="line">&#125;DATA3;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(DATA3));	<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    DATA3 data;</span><br><span class="line">    <span class="built_in">memset</span> (&amp;data,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//位段不能取地址</span></span><br><span class="line">    <span class="comment">//printf(&quot;%p\n&quot;,&amp;data.a);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//位段的赋值不要操作位段的大小a:2</span></span><br><span class="line">    data.a = <span class="number">6</span>;    <span class="comment">//0110</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>,data.a);    <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    data.a = <span class="number">0</span>;    <span class="comment">//00</span></span><br><span class="line">    data.b = <span class="number">3</span>;    <span class="comment">//11</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(DATA3));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#x\n&quot;</span>,*(<span class="type">unsigned</span> <span class="type">char</span> *)&amp;data);    <span class="comment">//1100 0000/ /0xc0  a是高位，b是低位</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>另起一个位段</strong></p>
<img src="https://s2.loli.net/2024/08/24/5M3yDkcsqTJ4x28.png" alt="另起一个位段" style="zoom:67%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a:<span class="number">2</span>;   <span class="comment">//00</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> :<span class="number">0</span>;    <span class="comment">//另起一个位段</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b:<span class="number">2</span>;   <span class="comment">//11</span></span><br><span class="line">&#125;DATA4;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(DATA4));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十四：共用体</center></h1>
<blockquote>
<p>所有的成员<code>共享</code>同一份空间，从空间读取的字节数由成员自身类型决定</p>
</blockquote>
<img src="https://s2.loli.net/2024/09/04/BHmeNEQxDC75v4J.webp" alt="共用体分析" style="zoom:50%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">short</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">union</span> data));	<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">data</span> <span class="title">A</span>;</span></span><br><span class="line">    A.a = <span class="number">10</span>;</span><br><span class="line">    A.b = <span class="number">20</span>;</span><br><span class="line">    A.c = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//共用体是最后一次 赋值有效（不严谨）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, A.a + A.b + A.c);    <span class="comment">//90</span></span><br><span class="line"></span><br><span class="line">    A.c = <span class="number">0x01020304</span>;</span><br><span class="line">    A.b = <span class="number">0x0102</span>;</span><br><span class="line">    A.a = <span class="number">0x01</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#x\n&quot;</span>,A.a + A.b + A.c);    <span class="comment">//0x01020203</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十五：枚举</center></h1>
<blockquote>
<p>将变量的值一一列举出来，在枚举值表中应列出所有可用值，也称为枚举元素</p>
<p>枚举变量的值(默认从零开始顺序加1)只能取枚举值所列元素</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//枚举类型定义:</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> 枚举名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    枚举值表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//枚举列表的值:默认从0开始</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">POKER</span> &#123;</span>HONGTAO,HEITAO=<span class="number">30</span>,MEIHUA=<span class="number">40</span>,FANGKUAI&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">//poker_ color的取值为HONGTAO，HEITAO， MEIHUA， FANGKUAI中某一个</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">POKER</span> <span class="title">poker_color</span> =</span> HEITAO;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;poker_ olor = %d\n&quot;</span>,poker_color);    <span class="comment">//30</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;HONGTAO = %d\n&quot;</span>,HONGTAO);   <span class="comment">//0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;HEITAO = %d\n&quot;</span>,HEITAO);    	<span class="comment">//30</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MEIHUA = %d\n&quot;</span>,MEIHUA);    	<span class="comment">//40</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FANGKUAI = %d\n&quot;</span>,FANGKUAI); <span class="comment">//41</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>1.数据类型</title>
    <url>/post/6f76074c.html</url>
    <content><![CDATA[<p>使用数据的不同类型的目的：合理利用空间</p>
<p>计算机存储的是<mark>二进制</mark>，是一位二进制只能存放0或1，内存：1bit</p>
<p>1字节 == 8b（八位二进制），范围：0000 0000 ~1111 1111</p>
<p>4B等于4个字节</p>
<h1><center>知识点一：常用关键字</center></h1>
<p>----------------------------------------在32位平台下---------------------------------------</p>
<table>
<thead>
<tr>
<th style="text-align:center">关键字</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">所占的空间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">字符串类型</td>
<td style="text-align:center">占1字节空间（8位二进制位）</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">短整型</td>
<td style="text-align:center">占2字节空间（16位二进制位）</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">整型</td>
<td style="text-align:center">占4个字节空间（32位二进制）</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">长整型</td>
<td style="text-align:center">占4个字节空间（32位二进制）（在64为平台下占8个字节）</td>
</tr>
<tr>
<td style="text-align:center">long long</td>
<td style="text-align:center">长长整型</td>
<td style="text-align:center">占8字节</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">单精度浮点数</td>
<td style="text-align:center">占4个字节空间（32位二进制）（6-7位有效位，指数-37到38）</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">双精度浮点数</td>
<td style="text-align:center">占8个字节空间（64位二进制）（15-16位有效位，指数-307到308）</td>
</tr>
</tbody>
</table>
<h2 id="center-字符型-center"><center>字符型</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>	<span class="comment">//输出函数等需要的头文件</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="string">&#x27;aaaaa&#x27;</span>;   <span class="comment">//定义字符  //字符单引号，字符串双引号，字符串需要借助数组实现</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);   <span class="comment">//字符%d输出，按照ASCII码表输入对应字符整数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,a);   <span class="comment">//字符%c输出，则输出字符，%s，输入字符串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-整型-center"><center>整型</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;	<span class="comment">//定义整型</span></span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> b = <span class="number">456</span>;	<span class="comment">//定义短整型</span></span><br><span class="line">    <span class="type">long</span> c = <span class="number">789</span>;		<span class="comment">//定义长整型</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> d = <span class="number">1243543511111111</span>;	<span class="comment">//定义长长整型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%hd,%lu,%lld&quot;</span>,a,b,c,d);	<span class="comment">//输出数据，123,456,789,1243543511111111</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-实型-浮点型-center"><center>实型(浮点型)</center></h2>
<p>赋值语句中若涉及到<mark>浮点数</mark>时注意<mark>两边类型尽量保持一致</mark></p>
<p>浮点数赋值，若赋值<mark>右边</mark>没有加<font color="red"> f </font>默认是<font color="red"> double </font>类型（占8个字节）</p>
<p><mark>指数</mark>形式：123e3(123*10的三次方)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//赋值语句的 = 两边的类型尽量保持一致</span></span><br><span class="line">    <span class="type">float</span> f = <span class="number">3.14f</span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">3.14</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(3.14) = %d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="number">3.14</span>));		<span class="comment">//8</span></span><br><span class="line">    <span class="comment">//不以f结尾的 实型常量 为double类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(3.14) = %d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="number">3.14f</span>));	<span class="comment">//4</span></span><br><span class="line">    <span class="comment">//以f结尾的 实型常量 为float类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f = %f\n&quot;</span>,f);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d = %lf\n&quot;</span>,d);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;f);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> a = <span class="number">3.14</span>;  <span class="comment">//定义float类型</span></span><br><span class="line">    <span class="type">double</span> b = <span class="number">4.311111123456789</span>;   <span class="comment">//定义double类型</span></span><br><span class="line">    <span class="comment">//在输出时%f可以输出float和double，但scanf输入时不能通用</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f,%f\n&quot;</span>,a,b);  <span class="comment">//3.140000,4.311111</span></span><br><span class="line">    <span class="comment">//如果输出位数较多，得限制位数才可以输出完整</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6f,%.15lf&quot;</span>,a,b);   <span class="comment">//3.140000,4.311111123456789</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果越界，越界的数字是随机数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-测试类型所占空间-center"><center>测试类型所占空间</center></h2>
<blockquote>
<p><code>sizeof</code>：测试类型的长度（所占的空间）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>	<span class="comment">//输出函数等需要的头文件</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(int) = %d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>));	<span class="comment">//4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(float) = %d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="type">float</span>));	<span class="comment">//4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(doublt) = %d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="type">double</span>));	<span class="comment">//8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(long) = %d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="type">long</span>));		<span class="comment">//4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(short) = %d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="type">short</span>));	<span class="comment">//2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(char) = %d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="type">char</span>));		<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-布尔型-center"><center>布尔型</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>	<span class="comment">//输出函数等需要的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span>	<span class="comment">//布尔类型头文件</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> a = <span class="number">1</span>;	<span class="comment">//定义布尔类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);	<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点二：unsigned 和 signed</center></h1>
<h2 id="center-1-无符号数：unsigned-center"><center>1、无符号数：unsigned</center></h2>
<blockquote>
<p>数据没有符号位，自身所有二进制位都是数据位</p>
<p>例：unsigned char       0000 0000 ~ 1111 1111</p>
</blockquote>
<h2 id="center-2-有符号数：signed-默认省略-center"><center>2、有符号数：signed（默认省略）</center></h2>
<p>    二进制最<font color="red">高</font>位为 <mark>1</mark> 表示<font color="red">负</font>数，最<font color="red">高</font>位为 <mark>0</mark> 表示<font color="red">正</font>数，其他位为数据位</p>
<p>    负数：1xxx xxxx       正数：0xxx xxxx（x：0或1）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个有符号int</span></span><br><span class="line">    <span class="comment">//signed int num1 = 10;</span></span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">10</span>;	<span class="comment">//有符号(signed)默认省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//unsigned 表示无符号数 不能省略</span></span><br><span class="line">    <span class="type">unsigned</span> num3 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点三：结构体 struct 和 共用体 union</center></h1>
<h2 id="1-struct：结构体中成员拥有独立空间">1、struct：结构体中成员拥有<code>独立</code>空间</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    shuot c;</span><br><span class="line">&#125;;</span><br><span class="line">a,b,c就是结构体dat1中的成员</span><br></pre></td></tr></table></figure>
<h2 id="2-union：共用体中成员共享同一部分空间">2、union：共用体中成员<code>共享</code>同一部分空间</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">short</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<h1><center>知识点四：enum 和 void</center></h1>
<h2 id="1-enum：枚举">1、enum：枚举</h2>
<blockquote>
<p>将<font color="red">变量要赋值的值</font>一一列举出来</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">BOOL</span>&#123;</span><span class="literal">false</span>，ture&#125;;</span><br><span class="line"><span class="comment">//括号里面的是可以赋给变量的值，赋的值只能括号里面有的</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">BOOL</span> <span class="title">bool</span> =</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<h2 id="2-void：无类型">2、void：无类型</h2>
<blockquote>
<p>不能用void定义变量</p>
</blockquote>
<h1><center>知识点五：其他关键字</center></h1>
<table>
<thead>
<tr>
<th>关键字</th>
<th>含义</th>
<th>关键字</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>auto</td>
<td>自动类型</td>
<td>register</td>
<td>寄存器变量</td>
</tr>
<tr>
<td>static</td>
<td>静态变量</td>
<td>const</td>
<td>只读</td>
</tr>
<tr>
<td><code>sizeof</code></td>
<td>测类型大小</td>
<td>typedef</td>
<td>为已有的类型重新取别名</td>
</tr>
<tr>
<td>volatile</td>
<td>防止编译器优化</td>
<td><code>extern</code></td>
<td>外部的意思，一般用于函数和全局变量的声明</td>
</tr>
</tbody>
</table>
<h2 id="1-register：寄存器变量">1、register：寄存器变量</h2>
<img src="https://s2.loli.net/2024/08/28/FtlO9SfUA2IEoC7.webp" alt="寄存器内存图" style="zoom:40%;">
<p>总结：</p>
<ol>
<li>
<p>如果没有显示表明 register ，类似 int num，如果被<mark>高频</mark>使用系统也会放入寄存器中</p>
</li>
<li>
<p>register int num;     //显示表明将num放入寄存器</p>
</li>
<li>
<p><font color="red">寄存器的变量不能取地址</font></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//%p输出地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;num);	<span class="comment">//错误 不能对寄存器变量取地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-typedef：为-mark-已有-mark-类型取别名">2、typedef：为<mark>已有</mark>类型取别名</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INT32;	<span class="comment">//取别名</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    INT32 num2 = <span class="number">34</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num1 = %d\n&quot;</span>,num1);	<span class="comment">//20</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num2 = %d\n&quot;</span>,num2);	<span class="comment">//34</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-volatile：防止编译器优化">3、volatile：防止编译器优化</h2>
<blockquote>
<p>作用：强制访问内存操作</p>
<p>这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a = i;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 其他代码，并未明确告诉编译器，对 i 进行过操作</span></span><br><span class="line"><span class="type">int</span> b = i;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中</p>
<p>优化做法(禁止)：由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读</p>
</blockquote>
<h1><center>知识点六：常量与变量</center></h1>
<h2 id="1-常量">1、常量</h2>
<blockquote>
<p>值不能被修改（但不能反过来说：值不能被修改是常量）</p>
<p>例：10、20、4.14、‘a’、“abcd”</p>
</blockquote>
<h2 id="2-变量">2、变量</h2>
<ul>
<li>
<p>系统根据变量的类型开辟对应的空间，其值可以被修改</p>
</li>
<li>
<p><code>变量名</code>  代表  <code>空间的内容</code></p>
</li>
<li>
<p>操作变量 就是对 空间内容的操作</p>
</li>
<li>
<p>变量的命名规制：由数值、字符、下划线组成但是不能以数字开头</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;	<span class="comment">//变量名 num 代表空间内容 10，4B字节空间</span></span><br></pre></td></tr></table></figure>
<h1><center>知识点七：进制</center></h1>
<h2 id="center-进制类型及输出方法-center"><center>进制类型及输出方法</center></h2>
<blockquote>
<p>输出时在  %  后加 # 表示输出进制的前缀</p>
<p>不同进制仅仅只是数据的表现形式不会修改数据本身</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//加个#号就是输出进制的前缀</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;十进制：num = %d\n&quot;</span>,num);	<span class="comment">//十进制输出  %d  %u  %ld  %lu</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;八进制：num = %#o\n&quot;</span>,num);	<span class="comment">//八进制输出  %o   以0开头</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;十六进制：num = %#x\n&quot;</span>,num);	<span class="comment">//十六进制输出  %x  以0x开头</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;十六进制：num = %#X\n&quot;</span>,num);	<span class="comment">//十六进制输出，但输出的十六进制字母X为大写</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//十进制：num = 100</span></span><br><span class="line"><span class="comment">//八进制：num = 0144</span></span><br><span class="line"><span class="comment">//十六进制：num = 0x64</span></span><br></pre></td></tr></table></figure>
<h2 id="center-进制转换-center"><center>进制转换</center></h2>
<p>需要分组的只有八进制和十六进制，八进制3个数字为一组，十六进制4个数字为一组</p>
<p>对于整数， 有四种表示方式：</p>
<p>    二进制：0,1 ，满 2 进 1，以 0b 或 0B 开头</p>
<p>    十进制：0-9 ，满 10 进 1</p>
<p>    八进制：0-7 ，满 8 进 1，以数字 0 开头表示</p>
<p>    十六进制：0-9 及 A(10) - F(15)，满 16 进 1，以 0x 或 0X 开头表示。此处的 A-F 不区分大小写</p>
<p>方法：8421法</p>
<h3 id="center-二进制转八进制-center"><center>二进制转八进制</center></h3>
<p>三位为一组，一组按1，2，4分</p>
<p>0 0 1 1  0 1 0 0</p>
<p>​      4 2  1 4 2 1</p>
<p>————————————</p>
<p>从左往右，三位一组，第一组三位中二进制为1的相加得八进制的个位，第二组三位中二进制为1的相加得八进制的十位，如果有第三组三位数则为1相加则为八进制的百位，以此类推</p>
<p>第一个三位二进制，1 0 0 则 421，为1的只有4，则八进制个位数为4</p>
<p>第二个三位二进制，1 1 0 则 421，为1的有4 和 2，则八进制十位数为4 + 2 = 6</p>
<p>则八进制为：(0)64</p>
<h3 id="center-八进制转二进制-center"><center>八进制转二进制</center></h3>
<p>八进制拆开单独数字，一个数字对应三位 再按1，2，4分解</p>
<p>64 --》分为两组(三位一组)，从左到右，第一组为4，第二组为6，6又分为4 + 2，有对应数字的二进制为1，没有为0</p>
<p>4 2 1 4 2 1</p>
<p>1 1 0 1 0 0</p>
<p>位数不足补零	0011 0100</p>
<h3 id="center-二进制转十进制-center"><center>二进制转十进制</center></h3>
<p>直接按1、2、4、8…分，二进制为1的数字相加</p>
<p>0 0 0 1  0 1 0 1</p>
<p>​         16 8 4 2 1</p>
<p>————————————</p>
<p>16+4+1 = 21</p>
<h3 id="center-十进制转二进制-center"><center>十进制转二进制</center></h3>
<p>十进制拆分，1，2，4，8…组合的数，无需分组</p>
<p>21 = 16 + 4 + 1</p>
<p>16 8 4 2 1</p>
<p>——————</p>
<p>1   0 1 0 1	位数不足补零，0001 0101</p>
<h3 id="center-二进制转十六进制-center"><center>二进制转十六进制</center></h3>
<p>四位为一组，一组按1，2，4，8分</p>
<p>0 0 1 1  0 1 0 0</p>
<p>8 4 2 1  8 4 2 1</p>
<p>————————</p>
<p>从左往右，四位一组，第一组四位中二进制为1的相加得十六进制的个位，第二组四位中二进制为1的相加得十六进制的十位，第三组四位中二进制为1的相加得十六进制的百位，以此类推</p>
<p>第一个四位二进制，0 1 0 0 则 8421，为1的只有4，则八进制个位数为4</p>
<p>第二个四位二进制，0 0 1 1 则 8421，为1的有1 和 2，则八进制十位数为1 + 2 = 3</p>
<p>则十六进制为：0x34</p>
<h3 id="center-十六进制转二进制-center"><center>十六进制转二进制</center></h3>
<p>十六进制数分开单个数字，一个数字对应四位，并拆分 1，2，4，8…数组成</p>
<p>0x2A =》分为两组(四位一组)，从左到右，第一组为A，A又分为8 + 2，第二组为2，有对应数字的二进制为1，没有为0</p>
<p>8 4 2 1  8 4 2 1</p>
<p>————————————————</p>
<p>0 0 1 0  1 0 1 0</p>
<h3 id="center-八进制转十进制-center"><center>八进制转十进制</center></h3>
<p>八转二，二转十</p>
<h3 id="center-十进制转八进制-center"><center>十进制转八进制</center></h3>
<p>十转二，二转八</p>
<h3 id="center-八进制转十六进制-center"><center>八进制转十六进制</center></h3>
<p>八转二，二转十六</p>
<h3 id="center-十六进制转八进制-center"><center>十六进制转八进制</center></h3>
<p>十六转二，二转八</p>
<h3 id="center-十进制转十六进制-center"><center>十进制转十六进制</center></h3>
<p>十转二，二转十六</p>
<h3 id="center-十六进制转十进制-center"><center>十六进制转十进制</center></h3>
<p>十六转二，二转十</p>
<h1><center>知识点八：(整型变量操作)取值、赋值</center></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test04</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//局部变量不初始化 内容随机</span></span><br><span class="line">    <span class="comment">//int num;</span></span><br><span class="line">    <span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>,num);	<span class="comment">//读 取值,0</span></span><br><span class="line"></span><br><span class="line">    num = <span class="number">100</span>;	<span class="comment">//写 赋值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>,num);	<span class="comment">//100</span></span><br><span class="line"></span><br><span class="line">    data = num;	<span class="comment">//num读 data写</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data = %d\n&quot;</span>,data);	<span class="comment">//100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取键盘输入</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个int数据:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data);		<span class="comment">//&amp;data 代表是data对应空间的起始地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data = %d\n&quot;</span>,data);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点九：数据输出</center></h1>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%d</td>
<td style="text-align:center">十进制有符号整数输出</td>
</tr>
<tr>
<td style="text-align:center">%u</td>
<td style="text-align:center">十进制无符号整数输出</td>
</tr>
<tr>
<td style="text-align:center">%ld</td>
<td style="text-align:center">有符号长整型输出</td>
</tr>
<tr>
<td style="text-align:center">%lu</td>
<td style="text-align:center">无符号long数据输出</td>
</tr>
<tr>
<td style="text-align:center">%hd/%hu</td>
<td style="text-align:center">有/无符号short数据输出</td>
</tr>
<tr>
<td style="text-align:center">%o</td>
<td style="text-align:center">以八进制表示的整数输出</td>
</tr>
<tr>
<td style="text-align:center">%x、%X、%#x、%#X</td>
<td style="text-align:center">以十六进制表示的整数输出</td>
</tr>
<tr>
<td style="text-align:center">%f</td>
<td style="text-align:center">float型浮点数输出</td>
</tr>
<tr>
<td style="text-align:center">%lf</td>
<td style="text-align:center">double型浮点数输出</td>
</tr>
<tr>
<td style="text-align:center">%e</td>
<td style="text-align:center">指数形式的浮点数输出</td>
</tr>
<tr>
<td style="text-align:center">%c</td>
<td style="text-align:center">单个字符输出</td>
</tr>
<tr>
<td style="text-align:center">%s</td>
<td style="text-align:center">字符串输出</td>
</tr>
<tr>
<td style="text-align:center">%p</td>
<td style="text-align:center">指针的值输出</td>
</tr>
</tbody>
</table>
<h2 id="输出的格式">输出的格式</h2>
<p>    %3d          %03d          %-3d          %5.2f</p>
<p>    %3d：要求宽度为3位，如果不足3位，前面<mark>空格</mark>补齐，如果足够3位，此语句无效</p>
<p>    %<font color="red">0</font>3d：要求宽度为3位，如果不足3位，前面<mark>0</mark>补齐，如果足够3位，此语句无效</p>
<p>    %<font color="red">-</font>3d：要求宽度为3位，如果不足3位，<font color="red">后</font>面<mark>空格</mark>补齐，如果足够3位，此语句无效</p>
<p>    %<font color="red">5.2</font>f：总宽度为5，<mark>.</mark>2表示：小数位保留2位</p>
<p>    但不能写 %-03d</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;##############\n&quot;</span>);</span><br><span class="line">    <span class="comment">//%5d 表示占5个终端位宽 右对齐</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;##%5d##\n&quot;</span>,<span class="number">123</span>);	<span class="comment">//###  123###</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//%‐5d 表示占5个终端位宽 左对齐</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;##%‐5d##\n&quot;</span>,<span class="number">123</span>);	<span class="comment">//###123  ###</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//%05d 表示占5个终端位宽 右对齐 不足补0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;##%05d##\n&quot;</span>,<span class="number">123</span>);	<span class="comment">//###00123###</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//千万不能写 %‐05d</span></span><br><span class="line">    <span class="comment">//printf(&quot;##%‐05d##\n&quot;,123);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//%5.2f 5表示总位宽为5 .2表示小数位保留2位</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;##%5.2f##\n&quot;</span>, <span class="number">3.14159f</span>);	<span class="comment">//### 3.14###</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实型-常量">实型 常量</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test06</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//赋值语句 = 两边的类型 尽量保证一致</span></span><br><span class="line">    <span class="type">float</span> f = <span class="number">3.14f</span>;<span class="comment">//有没有问题</span></span><br><span class="line">    <span class="type">double</span> d = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不以f结尾的 实型常量 为double类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(3.14) =%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="number">3.14</span>));	<span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//以f结尾的 实型常量 为float类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(3.14f) =%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="number">3.14f</span>));	<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//%f 输出 float数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f = %f\n&quot;</span>,f);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//%lf 输出 double数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d = %lf\n&quot;</span>, d);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;f);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十：字符(char)常量与变量</center></h1>
<p>用<font color="red"> ’ ’ </font>包裹字符</p>
<p><mark>%c</mark> 输出输出<font color="red">字符</font>，用 <mark>%d</mark> 输出字符的<font color="red">ascii值</font></p>
<p>本质：在内存保存的是字符对应的ASCII码值，字符与对应的ASCII值完全等价</p>
<p>使用<font color="red"> scanf </font>键盘输入字符用<font color="red"> %c </font>只能提取<mark>一个字符</mark></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test08</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//%c 输出的字符</span></span><br><span class="line">    <span class="comment">//printf(&quot;%c\n&quot;,&#x27;a&#x27;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符变量</span></span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;	<span class="comment">//ch 存储的是 ‘a’的ASCII值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %c\n&quot;</span>,ch);</span><br><span class="line">    <span class="comment">//%d 输出的字符的ASCII值11 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %d\n&quot;</span>,ch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&#x27;a&#x27; 单引号 表示的取 字符的ASCII</span></span><br><span class="line">    <span class="comment">//&#x27;a&#x27; == 97是完全等价</span></span><br><span class="line">    ch = <span class="number">97</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %c\n&quot;</span>,ch);</span><br><span class="line">    <span class="comment">//%d 输出的字符的ASCII值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %d\n&quot;</span>,ch);</span><br><span class="line"></span><br><span class="line">    ch = ch+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %c\n&quot;</span>,ch);</span><br><span class="line">    <span class="comment">//%d 输出的字符的ASCII值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %d\n&quot;</span>,ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符获取键盘输入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test09</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个字符:&quot;</span>);</span><br><span class="line">    <span class="comment">//scanf中%c只能提取一个字符</span></span><br><span class="line">    <span class="comment">//scanf(&quot;%c&quot;, &amp;ch);</span></span><br><span class="line">    ch = getchar();	<span class="comment">//获取一个字符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %c\n&quot;</span>,ch);	<span class="comment">//a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %d\n&quot;</span>,ch);	<span class="comment">//97</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十一：字符串</center></h1>
<p>用<font color="red"> &quot; &quot; </font>包裹字符，默认<code>结尾</code>自动添加<code>\0</code> 结尾（占一个字节），只要遇到 <code>\0</code> 就结束</p>
<p>描述：'a’和&quot;a&quot;的区别</p>
<p>    ‘a’字符 占1字节，&quot;a&quot;字符串 占2字节(多’\0’)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//%s 就是输出字符串</span></span><br><span class="line">    <span class="comment">//&#x27;&#x27;取的是字符的ASCII值 &quot;&quot;取的是字符串的首元素的地址</span></span><br><span class="line">    <span class="comment">//%s 从字符串的首元素 逐个字符输出 遇到&#x27;\0&#x27; （重要）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;hello&quot;</span>);	<span class="comment">//hello</span></span><br><span class="line">    <span class="comment">//系统会在字符串末尾自动添加一个结束字符&#x27;\0&#x27;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="string">&quot;hello&quot;</span>));	<span class="comment">//6</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;hello world&quot;</span>);	<span class="comment">//hello world</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;hello\0world&quot;</span>);	<span class="comment">//hello,\0：字符串结束符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;##%s##\n&quot;</span>,<span class="string">&quot;\0hello\0world&quot;</span>);	<span class="comment">//###</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十二：转义字符</center></h1>
<table>
<thead>
<tr>
<th style="text-align:center">字符形式</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">字符形式</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\n</td>
<td style="text-align:center">回车换行</td>
<td style="text-align:center">\\</td>
<td style="text-align:center">一个反斜杠字符(\)</td>
</tr>
<tr>
<td style="text-align:center">\t</td>
<td style="text-align:center">将当前位置移到下一个tab位置</td>
<td style="text-align:center">\’</td>
<td style="text-align:center">一个单引号(’)</td>
</tr>
<tr>
<td style="text-align:center">\v</td>
<td style="text-align:center">当前位置移到下一个垂直制表对齐点</td>
<td style="text-align:center">\&quot;</td>
<td style="text-align:center">一个双引号(&quot;)</td>
</tr>
<tr>
<td style="text-align:center">\r</td>
<td style="text-align:center">回车符</td>
<td style="text-align:center">\ddd</td>
<td style="text-align:center">三位八进制数代表一个ASCII字符</td>
</tr>
<tr>
<td style="text-align:center">\f</td>
<td style="text-align:center">换页符</td>
<td style="text-align:center">\xhh</td>
<td style="text-align:center">二位十六进制代表一个ASCII字符</td>
</tr>
<tr>
<td style="text-align:center">\b</td>
<td style="text-align:center">将当前位置后退一个字符</td>
<td style="text-align:center">\0</td>
<td style="text-align:center">空值，其ASCII码值为0</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>11.链表</title>
    <url>/post/9b06d854.html</url>
    <content><![CDATA[<h1><center>知识点一：链表基本概念</center></h1>
<p>定义：链表是一种物理存储上非连续，数据元素的逻辑顺序通过链表中的指针链接次序，实现的一种线性存储结构</p>
<p>特点：链表由一系列节点( 链表中每一个元素称为节点)组成，节点在运行时动态生成(malloc) ，每个节点包括两个部分：</p>
<p>    1）存储数据元素的数据域          2）存储下一个节点地址的指针域</p>
<p>链表分类及分析：</p>
<img src="https://s2.loli.net/2024/08/25/LYkyoxSGb2zAOZH.webp" alt="链表分类及分析" style="zoom:40%;">
<h1><center>知识点二：链表节点定义  </center></h1>
<blockquote>
<p>构成：链表由一个个节点构成，每个节点一般采用<code>结构体</code>的形式组织</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单向链表定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//数据域(自定义)</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">    <span class="comment">//指针域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">next</span>;</span>	<span class="comment">//保存 下一个节点的地址</span></span><br><span class="line">&#125;STU;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双向链表定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">pre</span>;</span></span><br><span class="line">&#125;STU;</span><br></pre></td></tr></table></figure>
<h1><center>知识点三：链表遍历</center></h1>
<img src="https://s2.loli.net/2024/08/25/vAJZbDetwfC2mEG.webp" alt="链表的基本概念" style="zoom:40%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//数据域(自定义)</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">    <span class="comment">//指针域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">next</span>;</span>	<span class="comment">//保存 下一个节点的地址</span></span><br><span class="line">&#125;STU;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单向链表遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    STU data1 = &#123;<span class="number">100</span>, <span class="string">&quot;德玛&quot;</span>, <span class="number">59</span>&#125;;</span><br><span class="line">    STU data2 = &#123;<span class="number">101</span>, <span class="string">&quot;小法&quot;</span>, <span class="number">79</span>&#125;;</span><br><span class="line">    STU data3 = &#123;<span class="number">102</span>, <span class="string">&quot;小泡&quot;</span>, <span class="number">49</span>&#125;;</span><br><span class="line">    STU data4 = &#123;<span class="number">103</span>, <span class="string">&quot;盲僧&quot;</span>, <span class="number">99</span>&#125;;</span><br><span class="line">    STU data5 = &#123;<span class="number">104</span>, <span class="string">&quot;快乐&quot;</span>, <span class="number">89</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链表头</span></span><br><span class="line">    STU *head = <span class="literal">NULL</span>;</span><br><span class="line">    head = &amp;data1;</span><br><span class="line">    data1.next = &amp;data2;</span><br><span class="line">    data2.next = &amp;data3;</span><br><span class="line">    data3.next = &amp;data4;</span><br><span class="line">    data4.next = &amp;data5;</span><br><span class="line">    data5.next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pb = head;</span><br><span class="line">    <span class="keyword">while</span>(pb != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s %f\n&quot;</span>, pb-&gt;num, pb-&gt;name, pb-&gt;score);</span><br><span class="line">        <span class="comment">//pb == head：即pb指向第一个节点，pb-&gt;next则为下一个节点地址</span></span><br><span class="line">        pb = pb-&gt;next;	<span class="comment">//pb指向下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双向遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_link</span><span class="params">(STU *head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断链表是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;link not found\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">//链表存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        STU *pb = head;	<span class="comment">//pb指向头结点</span></span><br><span class="line">        STU *pf = head‐&gt;pre;	<span class="comment">//pf指向了尾节点</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pb == pf)	<span class="comment">//相遇 只需要打印pf或pb中任何一个信息就够了</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;num=%d,name=%s,age=%d\n&quot;</span>, pb-&gt;num,pb-&gt;name,pb-&gt;age);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;num=%d,name=%s,age=%d\n&quot;</span>, pb-&gt;num,pb-&gt;name,pb-&gt;age);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;num=%d,name=%s,age=%d\n&quot;</span>, pf-&gt;num,pf-&gt;name,pf-&gt;age);</span><br><span class="line"></span><br><span class="line">            pb = pb-&gt;next;<span class="comment">//next方向的移动</span></span><br><span class="line">            pf = pf-&gt;pre;<span class="comment">//pre方向的移动</span></span><br><span class="line">        &#125;<span class="keyword">while</span>( pb‐&gt;pre != pf );	<span class="comment">//pf和pb不能 擦肩而过</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点四：链表插入</center></h1>
<blockquote>
<p>分析有无带头</p>
</blockquote>
<img src="https://s2.loli.net/2024/08/25/7cLo3lieFNY8hvb.webp" alt="有无带头结点分析" style="zoom: 33%;">
<h2 id="center-1-链表第一个节点之前插入-center"><center>1、链表<code>第一个节点之前</code>插入</center></h2>
<img src="https://s2.loli.net/2024/08/25/1R4DkTzBlute9wH.webp" alt="第一个节点插入" style="zoom: 45%;">
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;link.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">stu_help</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个链表头 注意 一定要赋值为NULL</span></span><br><span class="line">    STU *head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    stu_help();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> cmd[<span class="number">32</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入操作指令:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,cmd);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd, <span class="string">&quot;help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stu_help();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd, <span class="string">&quot;insert&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            STU tmp;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;请输入需要插入的数据:&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %s %f&quot;</span>,&amp;tmp.num, tmp.name, &amp;tmp.score);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将tmp数据 插入到head所指向的链表中</span></span><br><span class="line">            head = insert_link(head, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd,<span class="string">&quot;print&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            print_link(head);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd,<span class="string">&quot;search&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;‐‐‐‐‐search‐‐‐‐‐‐\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd,<span class="string">&quot;delete&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;‐‐‐‐‐delete‐‐‐‐‐‐\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd,<span class="string">&quot;free&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;‐‐‐‐‐free‐‐‐‐‐‐\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd,<span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            head = free_lin(head);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stu_help</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;################################\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;#help:打印帮助信息 #\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;#insert:插入链表节点 #\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;#print:遍历链表节点信息 #\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;#search:查询链表节点 #\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;#delete:删除链表节点 #\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;#free:释放链表 #\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;#quit:退出 #\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;################################\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>link.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span>	<span class="comment">//calloc</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;link.h&quot;</span></span></span><br><span class="line">STU* <span class="title function_">insert_link</span><span class="params">(STU *head, STU tmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1、从堆区申请一个待插入的节点空间</span></span><br><span class="line">    STU *pi = (STU *)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span>(STU));</span><br><span class="line">    <span class="keyword">if</span>(pi == <span class="literal">NULL</span>)	<span class="comment">//如果空间开辟成功则!=NULL</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc&quot;</span>);	<span class="comment">//打印错误信息</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、将tmp的值 赋值 给*pi</span></span><br><span class="line">    *pi = tmp;</span><br><span class="line">    pi‐&gt;next = <span class="literal">NULL</span>;<span class="comment">//注意</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、将pi插入到链表中</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)	<span class="comment">//链表不存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        head = pi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">//链表存在（头部之前插入）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1、让pi 指向就的头</span></span><br><span class="line">        pi-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、head指向新的头节点</span></span><br><span class="line">        head = pi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_link</span><span class="params">(STU *head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)	<span class="comment">//链表不存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;link not find\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        STU *pb = head;</span><br><span class="line">        <span class="keyword">while</span>(pb != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %s %f\n&quot;</span>, pb-&gt;num, pb-&gt;name,pb-&gt;score);</span><br><span class="line">            <span class="comment">//pb == head：即pb指向第一个节点，pb-&gt;next则为下一个节点地址</span></span><br><span class="line">            pb = pb-&gt;next;	<span class="comment">//pb指向下一个节点地址</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>link.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//防止头文件重复包含</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LINK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LINK_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//链表节点类型 定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//数据域</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指针域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;STU;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> STU* <span class="title function_">insert_link</span><span class="params">(STU *head, STU tmp)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">print_link</span><span class="params">(STU *head)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="center-2-链表最后一个节点插入-center"><center>2、链表<code>最后一个节点</code>插入</center></h2>
<img src="https://s2.loli.net/2024/08/25/UyP9vWKrQBlJf2H.webp" alt="最后一个节点插入" style="zoom:40%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表的尾部插入</span></span><br><span class="line">STU* <span class="title function_">insert_link</span><span class="params">(STU *head, STU tmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1、申请待插入的节点5 STU *pi = (STU *)calloc(1,sizeof(STU));</span></span><br><span class="line">    <span class="keyword">if</span>(pi == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="built_in">calloc</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、将tmp的数据 赋值到 *pi</span></span><br><span class="line">    *pi = tmp;</span><br><span class="line">    pi-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、将节点插入到链表的尾部</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)	<span class="comment">//链表不存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        head = pi;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">//链表存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//a、寻找链表的尾节点</span></span><br><span class="line">        STU *pb = head;</span><br><span class="line">        <span class="keyword">while</span>(pb-&gt;next != <span class="literal">NULL</span>)	<span class="comment">//如果不是尾节点</span></span><br><span class="line">            pb = pb‐&gt;next;	<span class="comment">//pb就指向下一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//b、用尾结点 pb 链接上 插入的节点pi</span></span><br><span class="line">        pb-&gt;next = pi;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-3-链表有序插入-center"><center>3、链表<code>有序</code>插入</center></h2>
<blockquote>
<p>根据顺序插入选择一种方式插入：第一个、中间、最后一个插入</p>
</blockquote>
<img src="https://s2.loli.net/2024/08/25/rtHbfaAensPiWqT.webp" alt="有序插入" style="zoom: 50%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表的有序插入 以num的顺序为准（小‐‐‐&gt;大）</span></span><br><span class="line">STU* <span class="title function_">insert_link</span><span class="params">(STU *head, STU tmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1、给待插入的节点pi 申请 堆区空间</span></span><br><span class="line">    STU *pi = (STU *)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span>(STU));</span><br><span class="line">    <span class="keyword">if</span>(pi == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、将tmp的内容 赋值给 *pi</span></span><br><span class="line">    *pi = tmp;</span><br><span class="line">    pi‐&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、链表节点pi的插入</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)	<span class="comment">//链表不存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        head = pi;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">//存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//a、寻找插入点</span></span><br><span class="line">        STU *pb = head, *pf = head;</span><br><span class="line">        <span class="comment">//pb-&gt;num 小于 pi-&gt;num 才会移动</span></span><br><span class="line">        <span class="keyword">while</span>(pb-&gt;num &lt; pi-&gt;num &amp;&amp; pb-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pf = pb;	<span class="comment">//pf先保存pb地址</span></span><br><span class="line">            pb = pb‐&gt;next;	<span class="comment">//pb-next即下一个节点地址赋给pb</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//b、插入点的判断</span></span><br><span class="line">        <span class="keyword">if</span>(pb-&gt;num &gt;= pi-&gt;num)	<span class="comment">//头部 中部插入</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pb == head)	<span class="comment">//头部之前插入</span></span><br><span class="line">            &#123;</span><br><span class="line">                pi-&gt;next = head;</span><br><span class="line">                head = pi;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>	<span class="comment">//中部插入</span></span><br><span class="line">            &#123;</span><br><span class="line">                pf-&gt;next = pi;</span><br><span class="line">                pi-&gt;next = pb;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">//尾部插入</span></span><br><span class="line">        &#123;</span><br><span class="line">            pb-&gt;next = pi;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-4-双向循环链表头部插入-center"><center>4、双向循环链表<code>头部</code>插入</center></h2>
<img src="https://s2.loli.net/2024/08/27/d8Ra9uDlLsk6Wno.webp" alt="双向循环链表头部插入" style="zoom:45%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头部之前插入</span></span><br><span class="line">STU* <span class="title function_">insert_link</span><span class="params">(STU *head, STU tmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1、为插入的节点pi申请空间</span></span><br><span class="line">    STU *pi = (STU *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(STU));</span><br><span class="line">    <span class="comment">//2、将tmp的值 赋值给 *pi7 *pi = tmp;</span></span><br><span class="line">    <span class="comment">//3、判断链表是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)	<span class="comment">//链表不存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        head = pi;</span><br><span class="line">        pi-&gt;next = head;</span><br><span class="line">        pi-&gt;pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">//链表存在(头部之前插入)</span></span><br><span class="line">    &#123;</span><br><span class="line">        pi-&gt;next = head;	<span class="comment">//新头结点的next指向旧的头结点</span></span><br><span class="line">        pi-&gt;pre = head-&gt;pre;	<span class="comment">//新头结点的pre指向尾结点</span></span><br><span class="line">        head-&gt;pre-&gt;next = pi;	<span class="comment">//让尾结点的next指向新的头结点</span></span><br><span class="line">        head-&gt;pre = pi;	<span class="comment">//旧的头结点pre指向新的头</span></span><br><span class="line">        head = pi;	<span class="comment">//head指向新的头</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点五：链表查询</center></h1>
<img src="https://s2.loli.net/2024/08/26/GSXqB6gWOEehmkU.webp" alt="链表查询" style="zoom:50%;">
<p>mian.c(整个程序在第一个节点之前插入中)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd, <span class="string">&quot;search&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>] = <span class="number">0</span>;</span><br><span class="line">    STU *ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要查找的用户名：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">    ret = search_link(head, name);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        prinf(<span class="string">&quot;num = %d, name = %s, score = %f\n&quot;</span>, ret-&gt;num, ret-&gt;name, ret-&gt;score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>link.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STU* <span class="title function_">search_link</span><span class="params">(STU *head, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1、判断链表是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)	<span class="comment">//不存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;link not found\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">//链表存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        STU *pb = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//逐个将节点中的name 和 name比较 如果不相等 pb=pb-&gt;next</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">strcmp</span>(pb-&gt;name, name) != <span class="number">0</span> &amp;&amp; pb-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">            pb = pb‐&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否找到</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(pb-&gt;name, name) == <span class="number">0</span>)	<span class="comment">//找到</span></span><br><span class="line">            <span class="keyword">return</span> pb;</span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">//没找到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双向链表查询</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STU* <span class="title function_">search_link</span><span class="params">(STU *head, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断链表是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">//链表存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        STU *pb = head;<span class="comment">//指向头结点</span></span><br><span class="line">        STU *pf = head‐&gt;pre;<span class="comment">//指向的是尾节点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pb = %p\n&quot;</span>, pb);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pf = %p\n&quot;</span>, pf);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pb‐&gt;pre = %p\n&quot;</span>, pb‐&gt;pre);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( (<span class="built_in">strcmp</span>(pb-&gt;name, name) != <span class="number">0</span>) &amp;&amp; (<span class="built_in">strcmp</span>(pf-&gt;name, name) != <span class="number">0</span>) &amp;&amp; (pb != pf) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;##pb‐&gt;name=%s##\n&quot;</span>,pb‐&gt;name);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;##pf‐&gt;name=%s##\n&quot;</span>,pf‐&gt;name);</span><br><span class="line">            pb = pb-&gt;next;	<span class="comment">//next方向移动</span></span><br><span class="line">            pf = pf-&gt;pre;	<span class="comment">//pf方向移动</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pb‐&gt;pre == pf)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(pb-&gt;name,name) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> pb;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(pf-&gt;name,name) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> pf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点六：删除链表节点</center></h1>
<blockquote>
<p>单向链表：删除思路与有序插入相似，可参考</p>
</blockquote>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd,<span class="string">&quot;delete&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入将要删除的姓名：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,name);</span><br><span class="line">    head = detele_link(head,name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>link.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STU* <span class="title function_">detele_link</span><span class="params">(STU *head,<span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1、判断链表是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)	<span class="comment">//不存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;link not found\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">//存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//2、寻找删除点</span></span><br><span class="line">        STU *pf=head, *pb = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">strcmp</span>(pb‐&gt;name,name)!=<span class="number">0</span> &amp;&amp; pb‐&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pf = pb;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、找到删除点</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(pb-&gt;name, name)==<span class="number">0</span>)	<span class="comment">//找到删除点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//4、判断删除的位置</span></span><br><span class="line">            <span class="keyword">if</span>(pb == head)	<span class="comment">//删除头结点</span></span><br><span class="line">            &#123;</span><br><span class="line">                head = pb‐&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(pb);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>	<span class="comment">//中部 或 尾部节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                pf-&gt;next = pb-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(pb);	<span class="comment">//释放pb节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;已成功删除%s的相关节点\n&quot;</span>,name);</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">//没找到删除点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;链表中没有%s相关的数据节点信息\n&quot;</span>,name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>双向链表删除节点</p>
</blockquote>
<img src="https://s2.loli.net/2024/08/27/vB81OMYrUaItfmx.webp" alt="双向链表删除节点" style="zoom:45%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STU* <span class="title function_">delete_link</span><span class="params">(STU *head, <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断链表是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;link not found\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        STU *pb = head;	<span class="comment">//指向头节点</span></span><br><span class="line">        STU *pf = head‐&gt;pre;	<span class="comment">//指向尾节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//逐个节点寻找删除点</span></span><br><span class="line">        <span class="keyword">while</span>((pb‐&gt;num != num) &amp;&amp; (pf‐&gt;num != num) &amp;&amp; (pf != pb))</span><br><span class="line">        &#123;</span><br><span class="line">            pb = pb‐&gt;next;	<span class="comment">//next方向移动</span></span><br><span class="line">            pf = pf‐&gt;pre;	<span class="comment">//pre方向移动</span></span><br><span class="line">            <span class="keyword">if</span>(pb‐&gt;pre == pf)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pb-&gt;num == num)	<span class="comment">//删除pb指向的节点</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pb == head)	<span class="comment">//删除头节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(head == head-&gt;next)	<span class="comment">//链表只有一个节点</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">free</span>(pb);</span><br><span class="line">                    head = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    head-&gt;next-&gt;pre = head-&gt;pre;</span><br><span class="line">                    head-&gt;pre-&gt;next = head-&gt;next;</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                    <span class="built_in">free</span>(pb);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>	<span class="comment">//删除中尾部节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                pb-&gt;pre-&gt;next = pb-&gt;next;</span><br><span class="line">                pb-&gt;next-&gt;pre = pb-&gt;pre;</span><br><span class="line">                <span class="built_in">free</span>(pb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pf-&gt;num == num)	<span class="comment">//删除pf指向的节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pf == head)	<span class="comment">//删除头节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(head == head‐&gt;next)	<span class="comment">//链表只有一个节点</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">free</span>(pf);</span><br><span class="line">                    head = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    head‐&gt;next‐&gt;pre = head‐&gt;pre;<span class="number">62</span> head‐&gt;pre‐&gt;next = head‐&gt;next;</span><br><span class="line">                    head = head‐&gt;next;</span><br><span class="line">                    <span class="built_in">free</span>(pf);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>	<span class="comment">//删除中尾部节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                pf‐&gt;pre‐&gt;next = pf‐&gt;next;</span><br><span class="line">                pf‐&gt;next‐&gt;pre = pf‐&gt;pre;</span><br><span class="line">                <span class="built_in">free</span>(pf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;未找到%d相关的节点信息&quot;</span>,num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点七：链表释放</center></h1>
<img src="https://s2.loli.net/2024/08/26/vQ8ZkNIEYsumax3.webp" alt="链表释放" style="zoom: 50%;">
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd,<span class="string">&quot;free&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    head = free_lin(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>link.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STU* <span class="title function_">free_link</span><span class="params">(STU *head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1、判断链表是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)	<span class="comment">//不存在 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;link not found\n&quot;</span>);</span><br><span class="line">        retrun head;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">//存在 </span></span><br><span class="line">    &#123;</span><br><span class="line">        STU *pb = head;</span><br><span class="line">        <span class="comment">//逐个节点释放</span></span><br><span class="line">        <span class="keyword">while</span>(pb != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//head保存下一个节点的位置</span></span><br><span class="line">            head = pb-&gt;next;</span><br><span class="line">            <span class="comment">//释放pb指向的节点</span></span><br><span class="line">            <span class="built_in">free</span>(pb);</span><br><span class="line">            <span class="comment">//pb指向head</span></span><br><span class="line">            pb = head; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;链表已经释放完毕\n&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点八：链表逆序</center></h1>
<img src="https://s2.loli.net/2024/08/26/NdCUYP62FtxpSXa.webp" alt="链表逆序" style="zoom:50%;">
<p>mian.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd,<span class="string">&quot;reverse&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    head = reverse_link(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>link.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STU* <span class="title function_">reverse_link</span><span class="params">(STU *head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1、判断链表是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)	<span class="comment">//不存在 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;link not found\n&quot;</span>);</span><br><span class="line">        retrun head;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span><span class="comment">//存在 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//int *p,num;     //p为int *, num为int</span></span><br><span class="line">        STU *pb,*pr;    <span class="comment">//pb为STU *,pr 为STU *</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//pb保存head-&gt;next ( 原因head-&gt;next会置NULL)</span></span><br><span class="line">        pb = head-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将head-&gt;next置NULL(原因:头节点变尾节点)</span></span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pb != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//pr 保存pb-&gt;next ( 原因:pb-&gt;next会指向head)</span></span><br><span class="line">            pr = pb -&gt; next;</span><br><span class="line">            <span class="comment">//pb-&gt;next指向head ( 原因:逆转方向)</span></span><br><span class="line">            pb-&gt;next = head ;</span><br><span class="line">            <span class="comment">//保存逆转方向的代码可以重复执行</span></span><br><span class="line">            head = pb;</span><br><span class="line">            pb = pr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点九：链表排序</center></h1>
<blockquote>
<p>选择法排序（以<code>数组</code>实现）：</p>
</blockquote>
<img src="https://s2.loli.net/2024/08/27/A5eg9kx1YzrUdwX.webp" alt="数组排序" style="zoom: 45%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>,min = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入%d个int数据\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,arr+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(min = i,j = min+<span class="number">1</span>;j &lt; n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[min] &gt; arr[j])</span><br><span class="line">                min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min != i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            tmp = arr[i];</span><br><span class="line">            arr[i] = arr[min];</span><br><span class="line">            arr [min] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>选择法排序（以<code>单向链表</code>实现）：</p>
<p>思路与数组排序相似，参考数组</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sort_link</span><span class="params">(STU *head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1、判断链表是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;link not found\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        STU *p_i = head;	<span class="comment">//i=0</span></span><br><span class="line">        <span class="keyword">while</span>(p_i‐&gt;next != <span class="literal">NULL</span>)	<span class="comment">//i&lt;n‐1 外层循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            STU *p_min = p_i;	<span class="comment">//min = i;</span></span><br><span class="line">            STU *p_j = p_min‐&gt;next;	<span class="comment">//j = min+1</span></span><br><span class="line">            <span class="keyword">while</span>(p_j != <span class="literal">NULL</span>)	<span class="comment">//j&lt;n 内层循环</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//寻找成员num最小值的 节点</span></span><br><span class="line">                <span class="keyword">if</span>(p_min-&gt;num &gt; p_j-&gt;num)	<span class="comment">//if(arr[min] &gt; arr[j])</span></span><br><span class="line">                    p_min = p_j;	<span class="comment">//min = j</span></span><br><span class="line">                p_j = p_j-&gt;next;	<span class="comment">//j++</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p_min != p_i)	<span class="comment">//min != i</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//只交换数据域（1、节点内容整体交换 2、只交换指针域）</span></span><br><span class="line">                <span class="comment">//1、节点内容整体交换(数据域交换第1次 指针域交换第1次)</span></span><br><span class="line">                STU tmp;</span><br><span class="line">                tmp = *p_i;</span><br><span class="line">                *p_i = *p_min;</span><br><span class="line">                *p_min = tmp;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//2、只交换指针域(指针域交换第2次)</span></span><br><span class="line">                tmp.next = p_i‐&gt;next;</span><br><span class="line">                p_i‐&gt;next = p_min‐&gt;next;</span><br><span class="line">                p_min‐&gt;next = tmp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p_i = p_i-&gt;next;	<span class="comment">//i++</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>12.文件</title>
    <url>/post/e2246be5.html</url>
    <content><![CDATA[<h1><center>知识点一：磁盘文件分类</center></h1>
<blockquote>
<p>物理上所有的磁盘文件都是二进制存储，以字节为单位顺序存储</p>
<p>缓冲区的目的：提高存储效率磁盘使用寿命</p>
</blockquote>
<p>逻辑上的文件分类:</p>
<ul>
<li>
<p>文本文件：基于字符编码的文件，如ASCII、UNICODE等，可以文件编辑器直接打开</p>
</li>
<li>
<p>二进制文件：基于值编码的文件，数据在内存原样输出到磁盘，需要自己判断或使用特定软件分析数据格式</p>
</li>
</ul>
<h1><center>知识点二：文件指针</center></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">short</span> level;			<span class="comment">//缓冲区“满”或“空”的程度</span></span><br><span class="line">    <span class="type">unsigned</span> flags;			<span class="comment">//文件状态标志</span></span><br><span class="line">    <span class="type">char</span> fd;			<span class="comment">//文件描述符</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> hold;		<span class="comment">//如无缓冲区不读取字符</span></span><br><span class="line">    <span class="type">short</span> bsize;			<span class="comment">//缓冲区大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *buffer;	<span class="comment">//数据缓冲区的位置</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *curp;	<span class="comment">//指针，当前的指向</span></span><br><span class="line">    <span class="type">unsigned</span> istemp;		<span class="comment">//临时文件，指示器</span></span><br><span class="line">    <span class="type">short</span> token;			<span class="comment">//用于有效性检查</span></span><br><span class="line">&#125;FILE;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：不要关心FILE的细节只需要会用FILE定义指针变量就行<code>FILE *fp=NULL;</code></p>
</blockquote>
<p>C语言有三个特殊的文件指针无需定义，打开直接使用：</p>
<p>（1）<code>stdin</code>：标准输入    默认为当前终端（键盘）</p>
<p>    使用的scanf、getchar函数默认从此终端获得数据</p>
<p>（2）<code>stdout</code>：标准输出  默认为当前终端（屏幕）</p>
<p>    使用的printf、puts函数默认输出信息到此终端</p>
<p>（3）<code>stderr</code>：标准出错   默认当前终端（屏幕）</p>
<p>    当我们程序出错或使用：perror函数时信息打印在此终端</p>
<h1><center>知识点三：打开一个文件</center></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">形式：</span><br><span class="line">	file* fp = null;	<span class="comment">//定义一个FILE类型的指针接收返回值</span></span><br><span class="line">	fp = fopen(文件名,文件使用方式);</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">	文件名：要打开的文件名字，可以包含路径信息</span><br><span class="line">	文件使用方式：“读”、“写”、“文本”或“二进制”等</span><br><span class="line">返回值：成功返回相应指针，失败返回<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>
<h1><center>知识点四：文件使用方式</center></h1>
<blockquote>
<p>+：以可读可写的方式打开</p>
<p>b：以二进制的方式打开文件</p>
<p>t：以文本的方式打开文件(省略)</p>
</blockquote>
<table>
<thead>
<tr>
<th>模式</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>r或rb</td>
<td style="text-align:left">以<code>只读</code>方式打开一个文本文件                                                           文件不存在：返回NULL                                                                    文件存在：返回文件指针，进行后续读操作</td>
</tr>
<tr>
<td>w或wb</td>
<td style="text-align:left">以<code>只写</code>方式打开文件                                                                        文件不存在：以指定文件名创建此文件                                           文件存在：清空文件内容，进行写操作                                           若文件打不开(如文件只读)，返回NULL</td>
</tr>
<tr>
<td>a或ab</td>
<td style="text-align:left">以追加方式打开文件，即在末尾添加内容                                       文件不存在：以指定文件名创建此文件(同w)                                 文件存在：从文件的结尾处进行写操作</td>
</tr>
<tr>
<td>r+或rb+</td>
<td style="text-align:left">以可读、可写的方式打开文件(不创建新文件)</td>
</tr>
<tr>
<td>w+或wb+</td>
<td style="text-align:left">以可读、可写的方式打开文件(使文件长度为0字节，创建一个文件)</td>
</tr>
<tr>
<td>a+或ab+</td>
<td style="text-align:left">以添加方式打开文件，打开文件并在未尾更改文件(如果文件不存在，则创建文件)</td>
</tr>
</tbody>
</table>
<h1><center>知识点五：关闭文件</center></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">形式：</span><br><span class="line">    fclose(文件指针);	<span class="comment">//文件指针：指向要关闭的文件</span></span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    关闭文件成功，返回值为<span class="number">0</span></span><br><span class="line">    关闭文件失败，返回值非零 </span><br></pre></td></tr></table></figure>
<h1><center>知识点六：文件的读写</center></h1>
<blockquote>
<p>EOF是在stdio.h文件中定义的符号常量，值为-1</p>
</blockquote>
<h2 id="center-1-字节读操作-center"><center>1、字节读操作</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ch = fgetc(fp);		<span class="comment">//读一个字节</span></span><br><span class="line"><span class="comment">//说明：从指定文件读一个字节赋给ch（以“读”或“读写”方式打开）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//文件文件：读到结尾返回EOF</span></span><br><span class="line"><span class="comment">//二进制文件：读到文件结尾，使用feof判断结尾</span></span><br></pre></td></tr></table></figure>
<p>事先本地创建a.text</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">127</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//1、 使用fopen打开一个文件获得文件指针</span></span><br><span class="line">    fp = fopen(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) ;</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>) ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2、对文件的操作</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//fgetc调用一次  读取到一个字节 </span></span><br><span class="line">        buf[i] = fgetc(fp);</span><br><span class="line">        <span class="keyword">if</span>(buf[i] == EOF)<span class="comment">//EOF表已经对到文件末尾</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf = %s\n&quot;</span>,buf);</span><br><span class="line">    <span class="comment">//3、 关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-2-字节写操作-center"><center>2、字节写操作</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">形式：</span><br><span class="line">    fputc(ch,fp);		<span class="comment">//写一个字符</span></span><br><span class="line"></span><br><span class="line">说明：把一个ch变量中的值(<span class="number">1</span>个字节)写到指定文件</span><br><span class="line">	如果输出成功，则返回输出的字节</span><br><span class="line">	如果输出失败，则返回一个EOF</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">127</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//1、 使用fopen打开一个文件获得文件指针</span></span><br><span class="line">    fp = fopen(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) ;</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>) ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2、使用fputc进行文件的数据写入</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要写入文件的字符串:&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先键盘获取字符串(会获取换行符)，再逐个写入文件</span></span><br><span class="line">    fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);</span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>;	<span class="comment">//去掉键盘输入的换行符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将字符串buf中的元素逐个写入文件中</span></span><br><span class="line">    <span class="keyword">while</span>(buf[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fputc(buf[i],fp);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3、 关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-3-字符串写操作-center"><center>3、字符串写操作</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;china&quot;</span>,fp);		<span class="comment">//写一个字符串</span></span><br><span class="line">说明：</span><br><span class="line">    向指定的文件写一个字符串</span><br><span class="line">	第一个参数可以是字符串常量，字符串数组名或字符指针，字符串末尾的<span class="string">&#x27;\0&#x27;</span>不会写到文件中</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *buf[] = &#123;<span class="string">&quot;床前明月光\n&quot;</span>,<span class="string">&quot;疑是地上霜\n&quot;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(buf)/<span class="keyword">sizeof</span>(buf[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//1、 使用fopen打开一个文件获得文件指针</span></span><br><span class="line">    fp = fopen(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(buf[i],fp);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//3、 关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-4-字符串读操作-center"><center>4、字符串读操作</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">形式：</span><br><span class="line">    fgets(str,n,fp);		<span class="comment">//读取一个字符串</span></span><br><span class="line"></span><br><span class="line">说明：从fp指向的文件读入n<span class="number">-1</span>个字符，在读入n<span class="number">-1</span>个字符之前遇到 换行符 或 EOF，读入提前结束，并读取换行符，在最后加一个<span class="string">&#x27;\0&#x27;</span></span><br><span class="line">    str为存放数据的首地址</span><br><span class="line">返回值：</span><br><span class="line">	成功：返回读到字符串的首元素地址</span><br><span class="line">	失败：返回<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *path = <span class="string">&quot;a.txt&quot;</span>;</span><br><span class="line">    <span class="comment">//int i = 0;</span></span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//1、 使用fopen打开一个文件获得文件指针</span></span><br><span class="line">    fp = fopen(path,<span class="string">&quot;r&quot;</span>);        <span class="comment">//fp = fopen(&quot;a.txt&quot;,&quot;r&quot;);</span></span><br><span class="line">    <span class="comment">//fp = fopen(&quot;path&quot;,&quot;r&quot;);    //err打开一个文件名叫&quot;path&quot;而不是path指向的文件名&quot;c. txt&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *ret = <span class="literal">NULL</span>;         </span><br><span class="line">        <span class="comment">//从文件中读取一行数据 </span></span><br><span class="line">        ret = fgets(buf,<span class="keyword">sizeof</span>(buf),fp);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//3、 关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-5-块读写-center"><center>5、块读写</center></h2>
<h3 id="fwrite数据块写操作">fwrite数据块写操作</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">形式：</span><br><span class="line">    fwrite(buffer, size , count, fp);</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">	buffer：指向存储数据空间的首地址的指针</span><br><span class="line">	size：一次写的数据块大小</span><br><span class="line">	count：要写的数据块个数</span><br><span class="line">	fp：指向要进行写操作的文件指针</span><br><span class="line">返回值：实际写的数据块数（不是总数据大小）</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];	<span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> deff;		<span class="comment">//防御</span></span><br><span class="line">    <span class="type">int</span> atk;		<span class="comment">//攻击</span></span><br><span class="line">&#125;HERO;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HERO hero[] = &#123;&#123;<span class="string">&quot;德玛西亚&quot;</span>,<span class="number">80</span>,<span class="number">60</span>&#125;,&#123;<span class="string">&quot;盲僧&quot;</span>,<span class="number">90</span>,<span class="number">80</span>&#125;,&#123;<span class="string">&quot;小法&quot;</span>, <span class="number">40</span>,<span class="number">85</span>&#125;,&#123;<span class="string">&quot;小炮&quot;</span>,<span class="number">50</span>,<span class="number">90</span>&#125;&#125;;</span><br><span class="line">    <span class="type">char</span> *path = <span class="string">&quot;a.txt&quot;</span>;</span><br><span class="line">    <span class="comment">//int i = 0;</span></span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(hero)/<span class="keyword">sizeof</span>(hero[<span class="number">0</span>]);</span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//1、 使用fopen打开一个文件获得文件指针</span></span><br><span class="line">    fp = fopen(path,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//fwrite将内存的数据原样的输出到文件中</span></span><br><span class="line">    <span class="comment">//写入文件的数据不便于用户查看但是不会影响程序的读</span></span><br><span class="line">    fwrite(hero,<span class="keyword">sizeof</span>(HERO),n,fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fread数据块读操作">fread数据块读操作</h3>
<p>使用 fread 从文件中读取数据块</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">形式：</span><br><span class="line">    fread(buffer,size,count,fp);</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">	buffer：指向存储数据空间的首地址的指针</span><br><span class="line">	size：一次读的数据块大小</span><br><span class="line">	count：要读的数据块个数</span><br><span class="line">	fp：指向要进行读操作的文件指针</span><br><span class="line">返回值：实际读的数据块数（不是总数据大小）</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];	<span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> deff;		<span class="comment">//防御</span></span><br><span class="line">    <span class="type">int</span> atk;		<span class="comment">//攻击</span></span><br><span class="line">&#125;HERO;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HERO hero[<span class="number">4</span>]= &#123;<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *path = <span class="string">&quot;a.txt&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//1、 使用fopen打开一个文件获得文件指针</span></span><br><span class="line">    fp = fopen(path,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    fread(hero,<span class="keyword">sizeof</span>(HERO),<span class="number">4</span>,fp);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot; 英雄姓名:《%s》,防御:%d》, 伤害:《%d》\n&quot;,hero[i].name,hero[i].deff,hero[i].atk);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;英雄姓名:《%s》, 防御:《%d》,伤害:《%d》\n&quot;</span>,(hero+i)-&gt;name,(hero+i)-&gt;deff,(hero+i)-&gt;atk);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//3、 关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-6-格式化读操作-center"><center>6、格式化读操作</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(文件指针,格式字符串,输出列表);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];<span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> deff;<span class="comment">//防 御</span></span><br><span class="line">    <span class="type">int</span> atk;<span class="comment">//攻击</span></span><br><span class="line">&#125;HERO;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HERO hero[]= &#123;&#123;<span class="string">&quot;德玛西亚&quot;</span>,<span class="number">80</span>,<span class="number">60</span>&#125;,&#123;<span class="string">&quot;盲僧&quot;</span>,<span class="number">90</span>,<span class="number">80</span>&#125;,&#123;<span class="string">&quot;小法&quot;</span>, <span class="number">40</span>,<span class="number">85</span>&#125;,&#123;<span class="string">&quot;小炮&quot;</span>,<span class="number">50</span>,<span class="number">90</span>&#125;&#125;;</span><br><span class="line">    <span class="type">char</span> *path = <span class="string">&quot;a.txt&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(hero)/<span class="keyword">sizeof</span>(hero[<span class="number">0</span>]);</span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//1、 使用fopen打开一个文件获得文件指针</span></span><br><span class="line">    fp = fopen(path,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i= <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(fp,<span class="string">&quot;英雄:%s 防御:%d 攻击:%d\n&quot;</span>,hero[i].name,hero[i].deff,hero[i].atk);</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="comment">//3、 关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-7-格式化写操作-center"><center>7、格式化写操作</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fscanf</span>(文件指针,格式字符串,输入列表);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];	<span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> deff;		<span class="comment">//防御</span></span><br><span class="line">    <span class="type">int</span> atk;		<span class="comment">//攻击</span></span><br><span class="line">&#125;HERO;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HERO hero[<span class="number">4</span>]= &#123;<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *path = <span class="string">&quot;a.txt&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//int n = sizeof(hero)/sizeof(hero[0]);</span></span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//1、 使用fopen打开一个文件获得文件指针</span></span><br><span class="line">    fp = fopen(path,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i= <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fscanf</span>(fp,<span class="string">&quot;英雄:%s 防御:%d 攻击:%d\n&quot;</span>, hero[i].name,&amp;hero[i].deff,&amp;hero[i].atk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d %d\n&quot;</span>,hero[i].name,hero[i].deff,hero[i].atk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、 关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>用 fprintf 和 fscanf 函数对磁盘文件读写使用方便，但在输入时要将ASCII码转换成二进制形式，在输出时将二进制形式转换成字符，花费时间较多</p>
<p>在内存与磁盘频繁交换数据的情况下，最好不用 fprintf 和 fscanf 函数，而用 fread 和 fwrite 函数</p>
</blockquote>
<h2 id="center-8-文件随机读写-center"><center>8、文件随机读写</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>] =<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *path = <span class="string">&quot;a.txt&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//int n = sizeof(hero)/sizeof(hero[0]);</span></span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//1、 使用fopen打开一个文件获得文件指针</span></span><br><span class="line">    fp = fopen(path,<span class="string">&quot;w+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先往文件中写入一个字符串&quot;hello file&quot;</span></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;hello file&quot;</span>,fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新打开文件让文件的流指针 回到文件首部</span></span><br><span class="line">    fp = fopen(path,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">//在从文件找那个读取该字符串    </span></span><br><span class="line">    fgets(buf,<span class="keyword">sizeof</span>(buf),fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf = %s\n&quot;</span>,buf);        </span><br><span class="line">    <span class="comment">//3、关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>     如果在写的步骤中没有关闭后再打开文件则会乱码</p>
<p>     所以需要文件写完后需要关闭文件然后重新打开文件，让文件流指针指向文件开始位置让变下次的文件读操作</p>
<h2 id="center-9-复位文件流指针-center"><center>9、复位文件流指针</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">形式：</span><br><span class="line">    rewind(文件指针);</span><br><span class="line"></span><br><span class="line">功能；把文件内部的位置指针移到文件开始位置</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>] =<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *path = <span class="string">&quot;a.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//1、 使用fopen打开一个文件获得文件指针</span></span><br><span class="line">    fp = fopen(path,<span class="string">&quot;w+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先往文件中写入一个字符串&quot;hello file&quot;</span></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;hello file&quot;</span>,fp);</span><br><span class="line">    <span class="comment">//复位文件流指针</span></span><br><span class="line">    rewind(fp); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//在从文件找那个读取该字符串    </span></span><br><span class="line">    fgets(buf,<span class="keyword">sizeof</span>(buf),fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf = %s\n&quot;</span>,buf);        </span><br><span class="line">    <span class="comment">//3、 关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-10-获得文件流指针距离文件首部的字节数-center"><center>10、获得文件流指针距离文件首部的字节数</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">形式：</span><br><span class="line">    ftell(文件指针);</span><br><span class="line"></span><br><span class="line">返回值：返回当前位置(距离文件起始位置的字节数)，出错返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *path = <span class="string">&quot;a.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> file_len = <span class="number">0</span>;</span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//1、 使用fopen打开一个文件获得文件指针</span></span><br><span class="line">    fp = fopen(path,<span class="string">&quot;w+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先往文件中写入一个字符串&quot;hello file&quot;</span></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;hello file&quot;</span>,fp);</span><br><span class="line">    <span class="comment">//获取文件流指针距离文件首部的字节数</span></span><br><span class="line">    file_len = ftell(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;file_len = %ld\n&quot;</span>,file_len);            </span><br><span class="line">    <span class="comment">//3、关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-11-定位文件的流指针-fseek函数-center"><center>11、定位文件的流指针 fseek函数</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">形式：</span><br><span class="line">    fseek(文件类型指针,位移量,起始点);	<span class="comment">//一般用于二进制文件</span></span><br><span class="line"></span><br><span class="line">功能：移动文件中位置指针的位置</span><br><span class="line">参数说明：</span><br><span class="line">    位移量：相对 起始点 的偏移量，向前、向后移动的字节数(<span class="number">-10</span>往左边移动<span class="number">10</span>字节，+<span class="number">10</span>往右边移动<span class="number">10</span>字节)</span><br><span class="line">    起始点：开始添加偏移 位移量 的位置</span><br><span class="line">    位置指针的位置说明：</span><br><span class="line">        在文件开头：<span class="number">0</span>		(SEEK_SET)</span><br><span class="line">        在文件当前位置：<span class="number">1</span>	(SEEK_CUR)</span><br><span class="line">        在文件末尾：<span class="number">2</span>		(SEEK_END)</span><br></pre></td></tr></table></figure>
<p>一次性读取文件总数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *file_data = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">long</span> file_len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *path = <span class="string">&quot;a.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//1、 使用fopen打开一个文件获得文件指针</span></span><br><span class="line">    fp = fopen(path,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//需求:一次性的将文件数据读取到内存中</span></span><br><span class="line">    <span class="comment">//1、得到文件的总大小</span></span><br><span class="line">    <span class="comment">//a、 使用 fseek 将文件指针定位到文件尾部</span></span><br><span class="line">    fseek(fp,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//b、使用 ftell 计算文件的偏移量==文件的总大小</span></span><br><span class="line">    file_len = ftell(fp);</span><br><span class="line">    <span class="comment">//c、使用rewind复位文件流指针</span></span><br><span class="line">    rewind(fp);</span><br><span class="line">    <span class="comment">//2、根据文件的总大小合理申请内存空间</span></span><br><span class="line">    file_data = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">1</span>,file_len+<span class="number">1</span>);    <span class="comment">//+1的目的 内存末尾存放&#x27;\0&#x27; </span></span><br><span class="line">    <span class="keyword">if</span>(file_data == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3、一次性将文件数据读入到内存空间</span></span><br><span class="line">    fread(file_data,file_len,<span class="number">1</span>,fp);</span><br><span class="line">    <span class="comment">//4、遍历读取到的文件内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;file_len = %ld\n&quot;</span>,file_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,file_data);</span><br><span class="line">    <span class="comment">//5、释放堆区空间</span></span><br><span class="line">    <span class="keyword">if</span>(file_len != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(file_len);</span><br><span class="line">        file_len = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点九：feof()函数判断文件是否到达文件末尾</center></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EOF宏：只能用于文本文文件</span><br><span class="line"></span><br><span class="line">feof函数：可以用于文本文文件 二进制文件</span><br><span class="line"><span class="comment">//判断文件是否结束：0：未结束，非0：表示结束</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">char</span> *path = <span class="string">&quot;a.txt&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//1、 使用fopen打开一个文件获得文件指针</span></span><br><span class="line">    fp = fopen(path,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//feof(fp)判断文件是否结束 0:未结束，非 0:表示结束</span></span><br><span class="line">    <span class="comment">//while(feof(fp) == 0)//文件未结束才循环</span></span><br><span class="line">    <span class="keyword">while</span>( !feof(fp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ch = fgetc(fp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十：文件加密器</center></h1>
<blockquote>
<p>加密过程：</p>
</blockquote>
<img src="https://s2.loli.net/2024/09/14/jMSYzciulGChFsL.webp" alt="加密过程" style="zoom:50%;">
<blockquote>
<p>解密过程：</p>
</blockquote>
<img src="https://s2.loli.net/2024/09/14/li5LeYBXpT7rjx1.webp" alt="解密过程" style="zoom:50%;">
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;fun.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cmd = <span class="number">0</span>;</span><br><span class="line">        print_help();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cmd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cmd == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> src_file[<span class="number">31</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">char</span> dst_file[<span class="number">31</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">char</span> *file_data = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> file_length = <span class="number">0</span>;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> passwd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//1、获取源文件 目的文件名(参考API实现)21 get_file_name(dst_file, src_file);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//2、获取源文件名 对应的文件 内容(参考API实现)</span></span><br><span class="line">            <span class="comment">//char * read_src_file(unsigned long *file_length,char *src_file_name)</span></span><br><span class="line">            file_data = read_src_file(&amp;file_length, src_file);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3、获取用户输入的密码（自定义实现）</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;请输入你的密码:&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%u&quot;</span>, &amp;passwd);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4、对文件内容加密(参考API实现)</span></span><br><span class="line">            file_data = file_text_encrypt(file_data,file_length,passwd);</span><br><span class="line">            <span class="comment">//char * file_text_encrypt(char * src_file_text,unsigned long int length,unsigned int password)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//5、对加密好的 文件内容 保存到 目的文件名中</span></span><br><span class="line">            save_file(file_data, file_length,dst_file);</span><br><span class="line">            <span class="comment">//void save_file(char* text,unsigned long int length,char * file_name)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmd == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> src_file[<span class="number">31</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">char</span> dst_file[<span class="number">31</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">char</span> *file_data = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> file_length = <span class="number">0</span>;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> passwd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//1、获取源文件 目的文件名(参考API实现)</span></span><br><span class="line">            get_file_name(dst_file, src_file);</span><br><span class="line">            <span class="comment">//void get_file_name(char * dest_file_name,char * src_file_name)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//2、获取源文件名 对应的文件 内容(参考API实现)</span></span><br><span class="line">            file_data = read_src_file(&amp;file_length, src_file);</span><br><span class="line">            <span class="comment">//char * read_src_file(unsigned long int *file_length,char *src_file_name)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//3、获取用户输入的密码（自定义实现）</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;请输入你的密码:&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%u&quot;</span>, &amp;passwd);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4、对文件内容解密(参考API实现)</span></span><br><span class="line">            file_data = file_text_decrypt(file_data, file_length,passwd);</span><br><span class="line">            <span class="comment">//char * file_text_decrypt(char * src_file_text,unsigned long int length,unsigned int password)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//5、对加密好的 文件内容 保存到 目的文件名中</span></span><br><span class="line">            save_file(file_data, file_length,dst_file);</span><br><span class="line">            <span class="comment">//void save_file(char* text,unsigned long int length,char * file_name)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmd == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;请输入一个正确的选项\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fun.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_help</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;**********1:加密文件**************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;**********2:解密文件**************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;**********3:退出程序**************\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">get_file_name</span><span class="params">(<span class="type">char</span> * dest_file_name,<span class="type">char</span> * src_file_name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你的源文件名称(30个字符):&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, src_file_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你的目的文件名称(30个字符):&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, dest_file_name);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * <span class="title function_">read_src_file</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> *file_length,<span class="type">char</span> *src_file_name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *data = <span class="literal">NULL</span>;</span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    fp = fopen(src_file_name,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件总长度</span></span><br><span class="line">    <span class="comment">//将文件流指针 定位 到文件 尾部</span></span><br><span class="line">    fseek(fp,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//获取文件长度</span></span><br><span class="line">    *file_length = ftell(fp);</span><br><span class="line">    <span class="comment">//复位文件流指针</span></span><br><span class="line">    rewind(fp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据 文件的长度 申请 堆区空间</span></span><br><span class="line">    data = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">1</span>,*file_length);</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一次性 读取文件内容</span></span><br><span class="line">    fread(data, *file_length,<span class="number">1</span>,fp);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="comment">//将空间首地址 返回</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> * <span class="title function_">file_text_encrypt</span><span class="params">(<span class="type">char</span> * src_file_text,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> length,<span class="type">unsigned</span> <span class="type">int</span> password)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        src_file_text[i] += password;	<span class="comment">//加密的过程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> src_file_text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_file</span><span class="params">(<span class="type">char</span>* text,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> length,<span class="type">char</span> * file_name)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    fp = fopen(file_name, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将data数据保存到 文件中</span></span><br><span class="line">    fwrite(text, length, <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放text指向堆区空间</span></span><br><span class="line">    <span class="keyword">if</span>(text != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(text);</span><br><span class="line">        text =<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;保存成功!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * <span class="title function_">file_text_decrypt</span><span class="params">(<span class="type">char</span> * src_file_text,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> length,<span class="type">unsigned</span> <span class="type">int</span> password)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        src_file_text[i] ‐= password;<span class="comment">//解密的过程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> src_file_text;<span class="number">99</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fun.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __FUN_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FUN_H__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">print_help</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">get_file_name</span><span class="params">(<span class="type">char</span> * dest_file_name,<span class="type">char</span> * src_file_name)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> * <span class="title function_">read_src_file</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> *file_length,<span class="type">char</span> *src_file_name)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> * <span class="title function_">file_text_encrypt</span><span class="params">(<span class="type">char</span> * src_file_text,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> length,<span class="type">unsigned</span> <span class="type">int</span> password)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">save_file</span><span class="params">(<span class="type">char</span>* text,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> length,<span class="type">char</span> * file_name)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>2.基本语句</title>
    <url>/post/6271a51c.html</url>
    <content><![CDATA[<h1><center>知识点一：数据类型转换</center></h1>
<h2 id="1-自动类型转换">1、自动类型转换</h2>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://s2.loli.net/2024/08/30/N5hPQ9B347ktOVT.webp" alt="自动类型转换关系图" style="zoom: 50%;"></th>
</tr>
</thead>
<tbody></tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有符号 和无符号的转换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test02</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data1 = ‐<span class="number">20</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> data2 = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//有符号data1和无符号data2参加计算的时候</span></span><br><span class="line">    <span class="comment">//会先将data1转换成无符号（‐20的补码很大的正数）</span></span><br><span class="line">    <span class="comment">//很大的数 + 10 必然 &gt;0</span></span><br><span class="line">    <span class="keyword">if</span>(data1+data2 &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt;0\n&quot;</span>);	<span class="comment">//&gt;0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(data1+data2&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;0\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int double的转换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test03</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data1 = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(data1+<span class="number">3.14</span>));	<span class="comment">//8字节</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//char 和 short的类型转换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test04</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="type">short</span> data = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于char short自身字节数 过小 很容易溢出</span></span><br><span class="line">    <span class="comment">//所以 只要char short参加运算 都会将自身转换成int</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(ch + ch));<span class="comment">//4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(ch + data));<span class="comment">//4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(data + data));<span class="comment">//4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-强制类型转换">2、强制类型转换    </h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">形式：</span><br><span class="line">   (类型说明符)(表达式)</span><br><span class="line"></span><br><span class="line">例：(<span class="type">int</span>)(x+y);	<span class="comment">// 把x+y的结果值转换为整型</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">test04</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x = <span class="number">3.14f</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//强制类型转换 只是临时的转换 当前语句有效，在后面的语句中不会更改x的值</span></span><br><span class="line">    j = (<span class="type">int</span>)x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;j = %d,x = %f\n&quot;</span>,j,x);	<span class="comment">//j = 3,x = 3.140000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    test04();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点二：运算符</center></h1>
<h2 id="1-运算符">1、运算符</h2>
<h3 id="算术运算符">算术运算符</h3>
<table>
<thead>
<tr>
<th style="text-align:center">+：加</th>
<th style="text-align:center">-：减</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">*：乘</td>
<td style="text-align:center">/ ：取整(a/b   a，b必须都为整数)(如果是浮点数是：除)</td>
</tr>
<tr>
<td style="text-align:center">%：取余(a%b   a，b必须都为整数)</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">test05</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">5</span>/<span class="number">2</span>);  <span class="comment">//取整,2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">5</span>%<span class="number">2</span>);  <span class="comment">//取余,1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">5</span>/<span class="number">2</span>);	<span class="comment">//2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,<span class="number">5</span>/<span class="number">2.0f</span>);	<span class="comment">//2.500000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    test05();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复合运算符">复合运算符</h3>
<table>
<thead>
<tr>
<th style="text-align:center">+=：变量 = 左边加右边</th>
<th style="text-align:center">-=：变量 = 左边减右边</th>
<th>*=： 变量 = 左边乘右边</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/=：变量 = 左边取整右边</td>
<td style="text-align:center">%=：变量 = 左边取余右边</td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">test13</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">3</span>;</span><br><span class="line">    data *= <span class="number">3</span>+<span class="number">5</span>;  <span class="comment">//data = data *(3+5);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data = %d\n&quot;</span>,data);	<span class="comment">//data = 24</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    test13();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-关系运算符">2、关系运算符</h2>
<table>
<thead>
<tr>
<th style="text-align:center">＞：大于</th>
<th style="text-align:center">＜：小于</th>
<th style="text-align:center">= =：等于</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&gt;=：大于等于</td>
<td style="text-align:center">&lt;=：小于等于</td>
<td style="text-align:center">!=：不等于</td>
</tr>
</tbody>
</table>
<h2 id="3-逻辑运算符">3、逻辑运算符</h2>
<p>    <mark>&amp;&amp;</mark>：逻辑<font color="red">与</font></p>
<p>         A &amp;&amp; B</p>
<p>         A B同时为真整个表达式结果为真， A B只要有一个为假整个表达式为假</p>
<p>         短路特性：如果第一个 A 就为假则后面不再执行 B</p>
<p>    <mark>||</mark>：逻辑<font color="red">或</font></p>
<p>         A || B 只要A B任意一个为真，整个表达式结果为真，A B同时为假时结果才为假</p>
<p>         短路特性：如果表达式 A 为真，则表达式 B 不会进行运算</p>
<p>    <mark>!</mark>：逻辑<font color="red">非</font></p>
<p>        含义：如果原本表达式为真，则为假，原本表达式为假，则为真</p>
<h2 id="4-位运算-二进制位操作">4、位运算（二进制位操作）</h2>
<p><mark>&amp;</mark>：按位<font color="red">与</font><br>
    语法：<font color="red">全1为1，其他为0</font></p>
<p>    例      1010 1010</p>
<p>    &amp;       1111 0000</p>
<p>————————————————————————</p>
<p>             1010 0000</p>
<p>    特点：和1 相与 保持不变，和0 相与 全清零</p>
<p>    应用场景：将固定位清零</p>
<p><mark>|</mark>： 按位<font color="red">或</font><br>
    语法：<font color="red">有1就为1，全0才为0</font></p>
<p>    例：     1010 1010</p>
<p>    |        1111 0000</p>
<p>————————————————————————————</p>
<p>             1111 1010</p>
<p>    特点：和0 相或 保持不变，和1 相或 全变1</p>
<p>    应用场景：将固定为1</p>
<p><mark>~</mark>：按位取<font color="red">反</font></p>
<p>    语法：<font color="red">0变1，1变0</font></p>
<p>    ~ 1010 1010 == 0101 0101</p>
<p>    应用场景：配合&amp;|操作</p>
<p><mark>^</mark>：按位<font color="red">异或</font></p>
<p>    语法：<font color="red">相同为0不同为1</font></p>
<p>    例：     1010 1010</p>
<p>    ^        0000 1111</p>
<p>——————————————————————</p>
<p>             1010 0101</p>
<p>     特点：和0 异或 保持不变，和1 异或 取反</p>
<p>     应用场景：将固定的为发生高低电频翻转</p>
<h2 id="5-左移和右移运算符">5、左移和右移运算符</h2>
<p>左移：<font color="red">左边丢弃，右边补0</font>（1010 1100 &lt;&lt; 2 == 1011 0000）</p>
<p>注意：移动的位数不要超过自身长度</p>
<p><mark>右移</mark>分类：</p>
<p>    <mark>逻辑</mark>右移：<font color="red">右边丢弃，左边补0</font></p>
<p>    <mark>算术</mark>右移：</p>
<p>        <mark>无</mark>符号数：<font color="red">右边丢弃，左边补0</font></p>
<p>        <mark>有</mark>符号数：</p>
<p>            正数：<font color="red">右边丢弃，左边补0</font></p>
<p>            负数：<font color="red">右边丟弃，左边补</font><mark>1</mark></p>
<p>总结：右移基本上是右边丢弃左边补0，只有负数且算术右移左边才会补1</p>
<p>逻辑右移和算术右移是编译器决定，但是我们可以检测</p>
<p><mark>位数</mark>：<font color="red">从右到左数</font></p>
<p>综合例：将data的第1、5清0，第3, 4位 置1其他为保持不变    data：1010 1010</p>
<p>将data的第1、5清0:</p>
<p>    data = data &amp; 1101 1101;</p>
<p>    1101 1101 = ~ (0010 0010) = ~ (0010 0000 | 0000 0010)</p>
<p>    0010 0000 = 0000 0001 &lt;&lt; 5</p>
<p>    0000 0010 = 0000 0001 &lt;&lt; 1</p>
<p>    1101 1101 = ~(0x01 &lt;&lt;5| 0x01&lt;&lt;1)</p>
<p>    data = data &amp; ~(0x01&lt;&lt;5 | 0x01&lt;&lt;1)</p>
<p>清零：&amp; ~（0x01&lt;&lt; 清零的位数(大)  |  0x01&lt;&lt;清零的位数(小)）</p>
<p>第3, 4位置1：</p>
<p>    data = data | 0001 1 000;</p>
<p>    0001 1000 = 0001 0000 | 0000 1000</p>
<p>              = 0x01&lt;&lt;4 | 0x01&lt;&lt;3</p>
<p>    data = data | (0x01&lt;&lt;4 | 0x01&lt;&lt;3);</p>
<p>    置1： | (0x01&lt;&lt; 置1的位数(大) | 0x01&lt;&lt; 置1的位数(小) )</p>
<h2 id="6-条件运算符">6、条件运算符</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">形式：</span><br><span class="line">    (表达式<span class="number">1</span>)?(值<span class="number">1</span>):(值<span class="number">2</span>)	<span class="comment">//（如果有嵌套看准 ? 分别）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：如果表达式1为真，整个表达式的值为“值1”，否则为“值2&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    ret = <span class="number">3</span> &gt; <span class="number">2</span> ? <span class="number">5</span> : <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);	<span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-逗号运算符">7、逗号运算符</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//形式：</span></span><br><span class="line">(..., ..., ...)</span><br><span class="line"></span><br><span class="line"><span class="comment">//从左向右依次执行，最后的表达式的值是整个运算的结果</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test02</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> data2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    data1 = <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;</span><br><span class="line">    data2 = (<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data1 = %d\n&quot;</span>, data1);	<span class="comment">//3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data2 = %d\n&quot;</span>, data2);	<span class="comment">//6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-自增自减运算符">8、自增自减运算符（++  --）</h2>
<blockquote>
<p><mark>++</mark>i 或 <mark>- -</mark>i  先加、减，后使用</p>
<p>i<mark>++</mark> 或 i<mark>- -</mark>   先使用，后加、减</p>
<p>注意: i++ 或 ++i 作为单独的指令没有区别</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">test14</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//++i</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    j = ++i;   <span class="comment">//++i == i=i+1     j=i</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;j=%d,i=%d\n&quot;</span>,j,i);	<span class="comment">//j=4,i=4</span></span><br><span class="line">    <span class="comment">//i++</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    j = i++;   <span class="comment">//j=i  i++ == i=i+1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;j=%d,i=%d\n&quot;</span>,j,i);	<span class="comment">//j=3,i=4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//i++ 或 ++i 作为单独的指令 没有区别</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>,i);	<span class="comment">//i = 4</span></span><br><span class="line">    ++j;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;j = %d\n&quot;</span>,j);	<span class="comment">//j = 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    test14();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点三：优先级</center></h1>
<blockquote>
<p>优先级 高 先执行，同级别的优先级要看结合性</p>
<p>自己写代码时尽量用 <code>()</code></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">优先级别</th>
<th style="text-align:center">运算符</th>
<th style="text-align:center">运算形式</th>
<th style="text-align:center">结合方向</th>
<th style="text-align:center">名称或含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">( )</td>
<td style="text-align:center">(e)</td>
<td style="text-align:center">自左至右</td>
<td style="text-align:center">圆括号</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">[ ]</td>
<td style="text-align:center">a[e]</td>
<td style="text-align:center">自左至右</td>
<td style="text-align:center">数组下标</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">.</td>
<td style="text-align:center">x.y</td>
<td style="text-align:center">自左至右</td>
<td style="text-align:center">成员运算符</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">-&gt;</td>
<td style="text-align:center">p-&gt;x</td>
<td style="text-align:center">自左至右</td>
<td style="text-align:center">指针访问成员的指向运算符</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">-  +</td>
<td style="text-align:center">-e</td>
<td style="text-align:center">自右至左</td>
<td style="text-align:center">负号和正号</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">++  –</td>
<td style="text-align:center">++x或x++</td>
<td style="text-align:center">自右至左</td>
<td style="text-align:center">自增和自减运算</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">!</td>
<td style="text-align:center">!e</td>
<td style="text-align:center">自右至左</td>
<td style="text-align:center">逻辑非</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">~</td>
<td style="text-align:center">~e</td>
<td style="text-align:center">自右至左</td>
<td style="text-align:center">按位取反</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">(t)</td>
<td style="text-align:center">(t)e</td>
<td style="text-align:center">自右至左</td>
<td style="text-align:center">类型转换</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*p</td>
<td style="text-align:center">自右至左</td>
<td style="text-align:center">指针运算，由地址求内容</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">&amp;x</td>
<td style="text-align:center">自右至左</td>
<td style="text-align:center">求变量地址</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">sizeof</td>
<td style="text-align:center">sizeof(t)</td>
<td style="text-align:center">自右至左</td>
<td style="text-align:center">求某类型变量长度</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">*  /  %</td>
<td style="text-align:center">e1 * e2</td>
<td style="text-align:center">自左至右</td>
<td style="text-align:center">乘、除、求余</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">+  -</td>
<td style="text-align:center">e1 + e2</td>
<td style="text-align:center">自左至右</td>
<td style="text-align:center">加和减</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">&lt;&lt;  &gt;&gt;</td>
<td style="text-align:center">e1 &lt;&lt; e2</td>
<td style="text-align:center">自左至右</td>
<td style="text-align:center">左移和右移</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">&lt;    &lt;=    &gt;    &gt;=</td>
<td style="text-align:center">e1&lt;e2</td>
<td style="text-align:center">自左至右</td>
<td style="text-align:center">关系运算符(比较)</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">==   !=</td>
<td style="text-align:center">e1 == e2</td>
<td style="text-align:center">自左至右</td>
<td style="text-align:center">等于、不等于</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">e1 &amp; e2</td>
<td style="text-align:center">自左至右</td>
<td style="text-align:center">按位与</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">^</td>
<td style="text-align:center">e1 ^ e2</td>
<td style="text-align:center">自左至右</td>
<td style="text-align:center">按位异或</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">|</td>
<td style="text-align:center">e1 | e2</td>
<td style="text-align:center">自左至右</td>
<td style="text-align:center">按位或</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">&amp;&amp;</td>
<td style="text-align:center">e1 &amp;&amp; e2</td>
<td style="text-align:center">自左至右</td>
<td style="text-align:center">逻辑与(并且)</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">||</td>
<td style="text-align:center">e1 || e2</td>
<td style="text-align:center">自左至右</td>
<td style="text-align:center">逻辑或(或者)</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">()?():()</td>
<td style="text-align:center">e1 ? e2 : e3</td>
<td style="text-align:center">自右至左</td>
<td style="text-align:center">条件运算</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">=</td>
<td style="text-align:center">x=e</td>
<td style="text-align:center">自右至左</td>
<td style="text-align:center">赋值运算</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">+=  -=  *=</td>
<td style="text-align:center"></td>
<td style="text-align:center">自右至左</td>
<td style="text-align:center">复合赋值运算</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">/=    %=   &gt;&gt;=</td>
<td style="text-align:center">x += e</td>
<td style="text-align:center">自右至左</td>
<td style="text-align:center">复合赋值运算</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">&lt;&lt;=   &amp;=   ^=   |=</td>
<td style="text-align:center"></td>
<td style="text-align:center">自右至左</td>
<td style="text-align:center">复合赋值运算</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">,</td>
<td style="text-align:center">e1,e2</td>
<td style="text-align:center">自左至右</td>
<td style="text-align:center">顺序求值运算</td>
</tr>
</tbody>
</table>
<h1><center>知识点四：键盘输入语句</center></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式：</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%相对应的字符输出格式&quot;</span>, 要输入对应变量的地址);</span><br><span class="line"></span><br><span class="line"><span class="comment">//若 % 前面有字符输入时需要把对应的字符一起输入</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;m%d\n&quot;</span>, &amp;i);	<span class="comment">//m数字</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个字符:&quot;</span>);</span><br><span class="line">    <span class="comment">//scanf中%c只能提取一个字符</span></span><br><span class="line">    <span class="comment">//scanf(&quot;%c&quot;,&amp;ch);</span></span><br><span class="line">    ch = getchar();  <span class="comment">//获取一个字符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %c\n&quot;</span>,ch);	<span class="comment">//ch = a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %d\n&quot;</span>,ch);	<span class="comment">//ch = 97</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点五：if条件语句</center></h1>
<h2 id="center-if-center"><center>if</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">形式：</span><br><span class="line">    <span class="keyword">if</span>(表达式)	<span class="comment">//项目只有一个结果</span></span><br><span class="line">    &#123;</span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//运行方式：表达式为真才会执行语句1;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test16</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一一个int数据:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;data);</span><br><span class="line">    <span class="comment">//判断能被2整除</span></span><br><span class="line">    <span class="keyword">if</span>(data % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;被2整除&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    test16();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-if-else-center"><center>if…else…</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式)		<span class="comment">//如果项目的只有两种结果 且不会同时出现</span></span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">2</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行方式：表达式为真，执行语句1，否则执行语句2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test16</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一一个int数据:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;data);</span><br><span class="line">    <span class="comment">//判断data对2的余数 结果：1或0</span></span><br><span class="line">    <span class="keyword">if</span>(data % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;余数为0\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;余数为1\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    test16();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-if-else-if-else-center"><center>if…else if…else…</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>)	<span class="comment">//如果一个项目有多个结果且不同时出现</span></span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(表达式<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">else</span>	<span class="comment">//可省略</span></span><br><span class="line">&#123;</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行方式：只有表达式1为真，执行语句1，只有表达式2为真，执行语句2，所有表达式都为假才执行语句n</span></span><br><span class="line"><span class="comment">//注意：只有前面的条件不满足才会判断后面的条件，如果前面的条件满足后面的条件不管真假都不会执行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test16</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一一个int数据:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;data);</span><br><span class="line">    <span class="comment">//判断data对3的余数  结果：0 1 2</span></span><br><span class="line">    <span class="keyword">if</span>(data % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;余数为0\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(data % <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;余数为1\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(data % <span class="number">3</span> == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;余数为2\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    test16();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-if单个重复使用-center"><center>if单个重复使用</center></h2>
<blockquote>
<p>一个项目有多个结果，不确定是否同时出现，其中每个if语句是独立的</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	语句<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(表达式<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(表达式<span class="number">3</span>)</span><br><span class="line">    语句<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点六：switch 选择语句</center></h1>
<blockquote>
<p>运行方式：将case后的值与switch后面的表达式的值对比，如果表达式的值刚好等于case后面的某一个值，就会立即去执行case后的语句，如果都不是，则会执行default后面的语句</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">形式：</span><br><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span>值<span class="number">1</span>:          <span class="comment">//值不能是浮点型、字符串</span></span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span> ;      <span class="comment">//break作用：跳出循环但只能跳出离它最近的一层循环</span></span><br><span class="line">    <span class="keyword">case</span>值<span class="number">2</span>:</span><br><span class="line">        语句<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span> ;</span><br><span class="line">    <span class="keyword">case</span>值<span class="number">3</span>:</span><br><span class="line">        语句<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">    <span class="keyword">default</span>:         <span class="comment">//可以省略</span></span><br><span class="line">        语句n;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test18</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你的方向：wsda\n&quot;</span>);</span><br><span class="line">    ch = getchar();</span><br><span class="line">    <span class="keyword">switch</span>(ch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span><span class="number">&#x27;</span>w<span class="number">&#x27;</span>:	<span class="comment">//break省略</span></span><br><span class="line">        <span class="keyword">case</span><span class="number">&#x27;</span>W<span class="number">&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;向上移动\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span><span class="number">&#x27;</span>A<span class="number">&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span><span class="number">&#x27;</span>a<span class="number">&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;向左移动\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span><span class="number">&#x27;</span>S<span class="number">&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span><span class="number">&#x27;</span>s<span class="number">&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;向下移动\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span><span class="number">&#x27;</span>d<span class="number">&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span><span class="number">&#x27;</span>D<span class="number">&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;向右移动\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    test18();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-continue-center"><center>continue</center></h2>
<blockquote>
<p>结束本次循环，立即从当前位置，进入下一次循环</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test02</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">50</span>)</span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">//结束本次循环，立即从当前位置，进入下一次循环 </span></span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>,sum);	<span class="comment">//sum = 5000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    test02();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点七：for循环</center></h1>
<blockquote>
<p>执行顺序：先执行初始语句，然后执行循环条件，如果循环条件成立，则执行循环语句，当语句块执行完毕之后，接着步进条件，然后再执行循环条件，如果循环条件成立，则继续执行循环语句，以此类推，直到循环条件不成立，循环结束</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始语句;循环条件;步进条件)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//循环语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始语句：只在循环开始时执行一-次</span></span><br><span class="line"><span class="comment">//循环条件: 每次循环都要执行，如果循环条件为 真 进入循环体，如果为 假 退出循环</span></span><br><span class="line"><span class="comment">//步进条件：每次循环结束的时候要执行的语句</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test02</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>,sum);	<span class="comment">//5050</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    test02();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>嵌套for循环：总结外层循环的次数 * 内层循环的次数 == 总循环次数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始语句;循环条件;步进条件)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(初始语句;循环条件;步进条件)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">//循环语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test07</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//总结 外层循环的次数 * 内层循环的次数 == 总循环次数</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)<span class="comment">//0~9 =10</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">10</span>; j++)<span class="comment">//0~9 =10</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i=%d, j=%d\n&quot;</span>, i,j);<span class="comment">//循环100次</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点八：whie循环</center></h1>
<p>执行顺序：如果“循环条件”为真就进入循环体执行循环语句，直到循环条件为假，循环结束</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//循环语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果“循环条件”为真就进入循环体执行循环语句</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>while没有初始化语句，用户提前初始化好</p>
<p>while没有步进语句，用户必须在循环语句中写好步进语句</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test04</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;	<span class="comment">//提前初始化</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;	<span class="comment">//局部变量如果不初始化 内容不确定</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">        i++;   <span class="comment">//步进条件 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>,sum);	<span class="comment">//sum = 5050</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    test04();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点九：do…while()循环</center></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//循环语句;</span></span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件);</span><br><span class="line"></span><br><span class="line"><span class="comment">//先执行循环语句，再判断循环条件是否为真，如果为真进行下次循环，如果为假，直接退出循环</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test05</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ok\n&quot;</span>);	<span class="comment">//输出一次ok</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(num&gt;<span class="number">0</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    test05();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十：goto 跳转</center></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">goto</span> 跳转名;    <span class="comment">//在需要跳转的语句插入</span></span><br><span class="line">    ....            <span class="comment">//中间是被调过的部分</span></span><br><span class="line">    跳转名:         <span class="comment">//跳转结束的地方插入</span></span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test6</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---001----\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---002----\n&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> here;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---003----\n&quot;</span>);		<span class="comment">//不输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---004----\n&quot;</span>);		<span class="comment">//不输出</span></span><br><span class="line">    here:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---005----\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---006----\n&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    test6();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果循环的次数是<mark>确定</mark>的，建议选择 <font color="red">for</font></p>
<p>如果循环的次数<mark>不确定</mark>，知道退出的条件建议选择 <font color="red">while</font></p>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>4.函数</title>
    <url>/post/3b48d11a.html</url>
    <content><![CDATA[<h1><center>函数的概述</center></h1>
<ul>
<li>
<p>函数的定义：实现函数功能、确定函数体、返回值类型、形参类型。让函数存在</p>
</li>
<li>
<p>函数的声明：不是实现函数功能仅仅是说明该函数有返回值类型、形参类型、函数名</p>
</li>
<li>
<p>函数的调用：函数的执行</p>
</li>
</ul>
<h2 id="center-1-函数的定义-center"><center>1、函数的定义</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回值类型:函数将来返回值的类型</span></span><br><span class="line"><span class="comment">//函数名:函数的入口地址</span></span><br><span class="line"><span class="comment">//形参:函数外部数据 传递到 函数内部的 桥梁</span></span><br><span class="line"><span class="comment">//函数体:具体的函数功能带</span></span><br><span class="line">返回值类型 函数名(形参类型 形参)        <span class="comment">//形参可以不止一个</span></span><br><span class="line">&#123;</span><br><span class="line">    函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-2-函数声明-center"><center>2、函数声明</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">返回值类型 函数名(形参类型 形参);        <span class="comment">//形参可以不止一个</span></span><br></pre></td></tr></table></figure>
<h2 id="center-3-函数调用-center"><center>3、函数调用</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数外部实际数据</span></span><br><span class="line">函数名(实参);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//函数声明:告诉编译器该函数存在请通过编译。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myfun</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *agrv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//函数的调用:函数名+()</span></span><br><span class="line">    myfun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数的定义 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myfun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my fun\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只有函数的<code>调用</code>在函数<code>定义的下方</code>(不推荐)，才可以不函数声明</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数的定义</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_fun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my fun\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//函数的调用：函数名+()</span></span><br><span class="line">    my_fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点二：函数参数</center></h1>
<blockquote>
<p>如果函数没有参数需要将 <mark>形参</mark> 写成 void</p>
</blockquote>
<h2 id="center-函数参数传递-center"><center>函数参数传递</center></h2>
<ul>
<li>
<p>函数形参本质：函数局部变量</p>
</li>
<li>
<p>形参在函数<code>定义</code>的时候不会开辟空间，只在函数<code>调用</code>的时候才开辟空间</p>
</li>
<li>
<p>形参在函数结束的时候才被释放</p>
</li>
<li>
<p><code>函数名</code>代表的是函数的<code>入口地址</code></p>
</li>
<li>
<p>函数返回值：</p>
<ul>
<li>
<p>&lt;=4 字节存放 <code>寄存器</code></p>
</li>
<li>
<p>大于4 字节存放 <code>栈区</code></p>
</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2024/08/31/p3wgyLxDlKX2nQz.webp" alt="函数参数传递过程" style="zoom:40%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data1 = <span class="number">10</span>, data2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需求：请定义一个函数 计算data1+data2</span></span><br><span class="line">    <span class="type">int</span> ret = my_add(data1,data2);	<span class="comment">//data1 data2 实参</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>,ret);	<span class="comment">//30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>	<span class="comment">//a b 形参</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点三：内联函数</center></h1>
<p>将项目中某些常用的简单逻辑的函数申请为内联函数，在编译之前，就会将主调函数中调用该内联函数的位置,直接替换为该函数体的内容，再进行编译，这样就省去了运行时，调用函数的CPU开销时间，大大的提升程序的执行效率。</p>
<p>大小端(字节序)：</p>
<p>大端：高字节存放在低地址</p>
<p>小端：高字节存放在高地址</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>3.数组</title>
    <url>/post/7422213c.html</url>
    <content><![CDATA[<p><strong><font color="red">任何数组的数组名代表数组首元素地址</font></strong></p>
<h1><center>知识点一：<mark>一维</mark>数组</center></h1>
<h2 id="center-1-数组概述-center"><center>1、数组概述</center></h2>
<blockquote>
<p>一维数组名 代表的是 数组第0个元素的地址</p>
</blockquote>
<img src="https://s2.loli.net/2024/08/30/bmfl2GsKHeXIarW.webp" alt="数组的概述" style="zoom:50%;">
<h2 id="center-2-一维数组定义-center"><center>2、一维数组定义</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式：</span></span><br><span class="line">    数据类型 数组名[数组元素个数];</span><br><span class="line"></span><br><span class="line"><span class="comment">//需求：请定义一个数组，该数组有10个元素每个元素为int</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>注意(int arr[10])：</p>
<ol>
<li>
<p>数组名arr不能和其他变量名同名</p>
</li>
<li>
<p>数组的元素小标是从0开始: 0~9</p>
</li>
<li>
<p>数组的元素分别是: arr[0]、 arr[1] ~ arr[9]，如果访问arr[10]数组越界</p>
</li>
<li>
<p>数组的元素等价于普通变量</p>
</li>
<li>
<p>在定义数组的时候，<mark>[]</mark>里面的值<mark>不能</mark>是<mark>变量</mark>（C89标准）</p>
</li>
</ol>
<h2 id="center-3-数组遍历-center"><center>3、数组遍历</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test7</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//局部变量，如果不初始化内容不确定 </span></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历数组 </span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,arr[i]);  <span class="comment">//输出的都是不确定的值 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="center-4-数组初始化-center"><center>4、数组初始化</center></h2>
<blockquote>
<p>初始化：定义的时候 给 变量 或 数组元素 赋值 的动作叫 初始化</p>
</blockquote>
<h3 id="1-mark-全部-mark-初始化">（1）<mark>全部</mark>初始化</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>,<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是全部初始化数组 元素的个数 可以省略 实际的元素个数 由初始化个数决定</span></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>, <span class="number">40</span>,<span class="number">50</span>&#125;;       <span class="comment">//少用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//错误显示</span></span><br><span class="line"><span class="type">int</span> arr[];<span class="comment">//错误无法确定数组的大小</span></span><br></pre></td></tr></table></figure>
<h3 id="2-mark-部分-mark-初始化">（2）<mark>部分</mark>初始化</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//部分初始化 未被初始化 部分自动补0</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">10</span>,<span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化数组 常见的操作 (将数组的所有元素清零)</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;	<span class="comment">//只初始化arr[0]=0,未被初始化部分 自动补0，则全部都为0</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">2</span>&#125;;<span class="comment">//2 0 0 0 0</span></span><br></pre></td></tr></table></figure>
<h3 id="3-扩展：初始化">（3）扩展：初始化</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;[<span class="number">2</span>] = <span class="number">3</span>, [<span class="number">4</span>] = <span class="number">7</span>&#125;;	<span class="comment">//0 030 7</span></span><br><span class="line"><span class="comment">//[2]=3将数组的第2个元素，初始化为3</span></span><br><span class="line"><span class="comment">//[4]=7将数组的第4个元素，初始化为7</span></span><br></pre></td></tr></table></figure>
<h2 id="center-5-数组空间大小-center"><center>5、数组空间大小</center></h2>
<ol>
<li>
<p>arr数组名作为数组类型时，代表的是数组空间的总大小</p>
</li>
<li>
<p>数组的总大小 = 元素的个数 * 每个元素的大小</p>
</li>
<li>
<p>数组元素的<code>个数</code> = <code>数组总大小 / 每个元素的大小</code></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//arr数组名作为数组类型代表的是数组空间的总大小 </span></span><br><span class="line">    <span class="type">int</span> arr [<span class="number">5</span>] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组的总大小 = 元素的个数 * 每个元素的大小 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数组的总大小:%d\n&quot;</span>,<span class="keyword">sizeof</span>(arr));	<span class="comment">//数组的总大小20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组：元素的大小    arr[0] 是数组的第0个元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数组元素的大小=%d\n&quot;</span>,<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));	<span class="comment">//数组元素大小=4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组元素的个数 = 数组总大小/每个元素的大小</span></span><br><span class="line">    n = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数组元素的个数=%d\n&quot;</span>,n);	<span class="comment">//数组元素的个数=5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    test1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-6-数组元素的操作-center"><center>6、数组元素的操作</center></h2>
<blockquote>
<p>数组的<mark>元素</mark>等价于<font color="red">普通变量</font></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test07</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="number">4</span> <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给数组元素 赋值</span></span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//num++</span></span><br><span class="line">    arr[<span class="number">1</span>]++;<span class="comment">//arr[1]=arr[1]+1;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//scanf(&quot;%d&quot;,&amp;num)</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;arr[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-7-键盘获取一维数组-center"><center>7、键盘获取一维数组</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr [<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点二：<mark>二维</mark>数组</center></h1>
<h2 id="center-1-二维数组定义-center"><center>1、二维数组定义</center></h2>
<blockquote>
<p>a 的地址 == &amp;a[0] 地址 == a[0]的地址 == &amp;a[0][0]的地址</p>
</blockquote>
<img src="https://s2.loli.net/2024/08/30/dwPEr8GJl6IM5q2.webp" alt="二维数组地址分析" style="zoom:50%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式：</span></span><br><span class="line">	数据类型 数组名[行数][列数];</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个数组，该数组有3个元素，每个元素又是一个数组，此数组有4个元素，每个元素为 int 类型</span></span><br><span class="line">    <span class="type">int</span> arr [<span class="number">3</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<h2 id="center-2-二维数组的遍历-center"><center>2、二维数组的遍历</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//遍历第i列</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//遍历第j行    </span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;<span class="number">4</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,arr[i][j] )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-3-二维数组初始化-center"><center>3、二维数组初始化</center></h2>
<blockquote>
<p>不管是数值还是字符的二维数组，在初始化的时候是可以<mark>省略行标</mark>的，行数由具体<font color="red">初始化元素个数</font>和<font color="red">列数</font>决定出所需要的行数</p>
</blockquote>
<blockquote>
<p><code>分段初始化</code>：用{}里面的{}明确的表示一行</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;, &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;, &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>连续初始化</code>：放满一行才能放下一行</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>, <span class="number">10</span>,<span class="number">11</span>, <span class="number">12</span>&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="center-4-键盘获取二维数组-center"><center>4、键盘获取二维数组</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i,j = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> arr [<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;arr[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点三：一维字符数组</center></h1>
<blockquote>
<p>字符数组：本质是数组，只是数组的每个元素是字符</p>
</blockquote>
<h2 id="center-1-字符数组初始化-center"><center>1、字符数组初始化</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化：逐个字符初始化 不推荐</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">6</span>] = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;	<span class="comment">//str[0] == &#x27;h&#x27;的ASCII值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化：以字符串的形式 初始化 推荐</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">6</span>] = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="center-2-逐个字符初始化和字符串初始化区别-center"><center>2、逐个字符初始化和字符串初始化区别</center></h2>
<blockquote>
<p>在没有确定 数组个数 的前提下，逐个字符初始化系统不会添加’\0’ ，以字符串初始化系统会给字符串添加  ‘\0’</p>
<p><code>%s</code>：输出的内容从数组的第0个元素开始逐个元素输出直到<mark>遇到 ‘\0’ 结束</mark>，逐个<mark>字符</mark>初始化用 %s 输出由于<mark>没有 ‘\0’ </mark>所以后面会导致出现乱码等情况，而用字符串初始化输出则不会</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str1[] = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;;	<span class="comment">//逐个字符初始化 系统不会添加&#x27;\0&#x27;</span></span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;hehe&quot;</span>;	<span class="comment">//以字符串初始化 系统会给字符串添加&#x27;\0&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//空间大小</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(str1)=%d\n&quot;</span>, <span class="keyword">sizeof</span>(str1));	<span class="comment">//4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(str2)=%d\n&quot;</span>, <span class="keyword">sizeof</span>(str2));	<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//%s输出的内容 从数组的第0个元素开始逐个元素输出 直到遇到&#x27;\0&#x27;结束</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str1 = ##%s##\n&quot;</span>, str1);	<span class="comment">//##hehe0  ##,出现乱码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str2 = ##%s##\n&quot;</span>, str2);	<span class="comment">//##hehe##</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-3-字符数组遍历-center"><center>3、字符数组遍历</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test02</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">6</span>]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法一：逐个字符遍历</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n---------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二：字符数组可以整体遍历推荐</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>，str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法三：使用puts输出</span></span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-4-获取键盘字符串-center"><center>4、获取键盘字符串</center></h2>
<blockquote>
<p>scanf 和 %s 使用缺点：遇到<font color="red">空格</font>会结束输入</p>
<p><mark>gets</mark>缺点：获取键盘输入的时候<mark>不会管buf的大小</mark>容易造成内存污染</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mian</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>] = <span class="string">&quot;&quot;</span>;	<span class="comment">//定义一个字符数组有足够大的空间</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">10</span>] = <span class="string">&quot;&quot;</span>;	</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入两个个字符串\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一种方式</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buf);	<span class="comment">//不能获取带空格的字符串</span></span><br><span class="line">    <span class="comment">//第二种方式</span></span><br><span class="line">    gets(buf1);	<span class="comment">//输入超出字符数组空间</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf = %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf = %s\n&quot;</span>, buf1);	<span class="comment">//照样获取打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>fgets：既可以获取带空格的字符串也可以保证buf的不越界</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio. h&gt;</span> </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* s：表示存放字符串的空间地址</span></span><br><span class="line"><span class="comment">* size 能够提取字符中的最大长度 size-1</span></span><br><span class="line"><span class="comment">* stream写成stdin（标准输入设备） 表示标准输入设备</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *S，<span class="type">int</span> size, FILE *stream )</span></span><br><span class="line"><span class="comment">//返回值：就是获取到的字符串的首元素地址</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个字符串\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);	<span class="comment">//推荐,12345 12345 12345</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf=%s\n&quot;</span>, buf);	<span class="comment">//12345 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点四：二维字符数组</center></h1>
<h2 id="center-1-字符数组初始化-center"><center>1、字符数组初始化</center></h2>
<blockquote>
<p><mark>一维</mark>字符数组是存放 多个<code>字符</code></p>
<p><mark>二维</mark>字符数组是存放 多个<code>字符串</code>，每个字符串占一行</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不管是数值还是字符 的二维数组 在初始化的时候 是可以省略行标的 行数由具体初始化决定</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">3</span>][<span class="number">16</span>] = &#123;<span class="string">&quot;hehe&quot;</span>,<span class="string">&quot;haha&quot;</span>,<span class="string">&quot;heihei&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//str[0]就是第一行存放hehe的首地址，输出整个字符str[0]，输出字符串里的某个字符str[0][3]</span></span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2024/08/31/u6EozV23lISc9iw.webp" alt="二维字符数组解析" style="zoom:50%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> arr [<span class="number">3</span>][<span class="number">16</span>] = &#123;<span class="string">&quot;hehe&quot;</span>,<span class="string">&quot;haha&quot;</span>,<span class="string">&quot;heihei&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出一个字符串  仅仅使用行标</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,arr[<span class="number">0</span>]);		<span class="comment">//hehe</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,arr[<span class="number">1</span>]);		<span class="comment">//haha</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,arr[<span class="number">2</span>]);		<span class="comment">//heihei</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出的是 字符串中的某个字符 必须用行标和列标 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,arr[<span class="number">1</span>][<span class="number">3</span>]);	<span class="comment">//a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-2-获取键盘字符串-center"><center>2、获取键盘字符串</center></h2>
<p>应用场景：</p>
<ul>
<li>
<p>将键盘需要输入 多个独立的字符串 用户必须单独存储好</p>
</li>
<li>
<p>输入的字符串个数决定了二维数组的行数输入</p>
</li>
<li>
<p>字符串中的最大长度决定了二维字符数组的列数</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//hehe haha xixi heihei</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4</span>][<span class="number">16</span>] = &#123;<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获取键盘字符串 </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,buf[i]);         <span class="comment">//buf[i]已经代表是第i行的首元素地址</span></span><br><span class="line">        <span class="comment">//scanf(&quot;%s&quot;,&amp;buf[i][0]);  </span></span><br><span class="line">        <span class="comment">//&amp;buf[i][O] == &amp; *(buf[i]+0) == buf[i] + 0 == buf[i]</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf[%d]=%s\n&quot;</span>,i,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *agrv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    test01();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>5.内存</title>
    <url>/post/df718222.html</url>
    <content><![CDATA[<h1><center>内存分区</center></h1>
<img src="https://s2.loli.net/2024/08/24/VURyauJWYjnsxt1.png" alt="内存分析" style="zoom: 50%;">
<h1><center>变量在内存分析</center></h1>
<h2 id="普通局部变量">普通<code>局部</code>变量</h2>
<blockquote>
<p>定义形式：在函数<code>里</code>面定义的普通变量</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test01</span> <span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> numl = <span class="number">10</span>;	<span class="comment">//普通局部变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>作用范围：离它<code>最近</code>的 <font color="red">{}</font> 之间有效</p>
<p>生命周期：离它最近的 <font color="red">{}</font> 之间有效，离开 {} 的局部变量系统自动回收</p>
<p>存储区域：<code>栈区</code></p>
<p>普通局部变量<code>不</code>初始化<font color="red">内容不确定</font></p>
<p>普通局部变量<code>同名</code> <font color="red">就近原则</font>（同一个{}里的）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//局部变量，不初始化 内容 不确定</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data = %d\n&quot;</span>,data);	<span class="comment">//-858993460</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test0l</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//局部变量同名就近原则</span></span><br><span class="line">    <span class="type">int</span> data= <span class="number">100</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> data = <span class="number">200</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;A:data = %d\n&quot;</span>, data) ;    <span class="comment">//200</span></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B:data = %d\n&quot;</span>, data) ;        <span class="comment">//100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="普通全局变量">普通<code>全局</code>变量</h2>
<blockquote>
<p>定义形式：定义在<code>函数外边</code>的变量就是普通全局变量</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> data;<span class="comment">//普通全局变量 在函数外边定义</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test02</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作用范围：</p>
<blockquote>
<p><code>当前源文件</code>都有效，全局变量声明的时候最好也加上extern（用于区别）</p>
<p><code>其他源文件</code>使用全局变量时，必须加 <font color="red">extern</font> 声明</p>
<p>生命周期：整个 进程 都有效(程序结束的时候全局变量才被释放)</p>
<p>存储区域：全局区</p>
<p>注意事项：</p>
<p>全局变量不初始化内容为 0</p>
<p>如果全局变量要在其他源文件中使用必须在所使用的源文件中加 extern 声明</p>
<p>如果<code>全局</code>变量和<code>局部</code>变量同名 在 {} 中优先使用<font color="red">局部</font>变量</p>
</blockquote>
<h2 id="静态局部变量">静态<code>局部</code>变量</h2>
<blockquote>
<p>定义形式：定义局部变量前面必须加 <code>static</code> 修饰</p>
</blockquote>
<blockquote>
<p>作用范围：离它<code>最近</code>的 <font color="red">{}</font> 之间有效</p>
<p>生命周期：整个进程（程序结束的时候静态局部变量才被释放）</p>
<p>存储区域：全局区</p>
<p>静态局部变量不初始化内容为 0（全局区）</p>
<p><code>只能被初始化一次（重要）下一次运算依据上一次的结果值</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test01</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num;	<span class="comment">//静态局部变量</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//静态局部变量只能被初始化一次</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">10</span>;    <span class="comment">//静态局部变量 </span></span><br><span class="line">    num++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>,num);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    fun1();</span><br><span class="line">    fun1();</span><br><span class="line">    fun1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态全局变量">静态<code>全局</code>变量</h2>
<blockquote>
<p>定义形式：在函数<code>外</code>边定义同时加 <font color="red">static</font> 这样的变量就是静态全局变量</p>
</blockquote>
<blockquote>
<p>作用范围：当前源文件有效 不能在其他源文件 中使用</p>
<p>生命周期：整个进程(程序结束 静态全局变量才被释放)</p>
<p>存储区域：全局区</p>
<p>静态全局变量不初始化内容为 0</p>
<p>静态全局变量只在<code>当前源文件有效</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> data = <span class="number">10</span>;	<span class="comment">//静态全局变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[ ])</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>函数在内存分析</center></h1>
<h2 id="全局函数-普通函数">全局函数(普通函数)</h2>
<blockquote>
<p>其他源文件可以使用全局函数，必须加 <font color="red">extern</font> 声明</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> my_ <span class="title function_">fun</span><span class="params">(<span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(全局函数)普通函数\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态函数-局部函数">静态函数(局部函数)</h2>
<blockquote>
<p><code>只能在当前源文件使用，不能在其他源文件使用</code></p>
<p>注意：如果想在其他源文件调用静态函数，需要将<font color="red">静态函数</font>封装在<font color="red">全局函数</font>中，同时全局函数和静态函数必须是同一个源文件</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_static_fun</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(静态丽数)局部函数\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>内存填充</h1>
<p>通常用于初始化内存区域，例如将数组的所有元素设置为零或某个特定值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *s, <span class="type">int</span> c, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">s：指向要填充的内存区域的指针。</span></span><br><span class="line"><span class="comment">c：要设置的值。虽然类型是 int，但只有低字节（即 c &amp; 0xFF）会被使用来填充内存区域。</span></span><br><span class="line"><span class="comment">n：要设置的字节数	*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">memset_teset</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">2</span>, <span class="keyword">sizeof</span>(buf));	<span class="comment">//将数组中8个字符替换成2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; <span class="keyword">sizeof</span>(buf)/<span class="keyword">sizeof</span>(<span class="type">char</span>); i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>内存比较</h1>
<p>逐字节比较从 s1 和 s2 开始的连续 n 个字节，并返回一个整数值来指示比较的结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *s1, <span class="type">const</span> <span class="type">void</span> *s2, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">s1：指向第一个要比较的内存区域的指针</span></span><br><span class="line"><span class="comment">s2：指向第二个要比较的内存区域的指针</span></span><br><span class="line"><span class="comment">n：要比较的字节数</span></span><br><span class="line"><span class="comment">小于 0， s1 中第一个字节小于 s2 中对应的字节</span></span><br><span class="line"><span class="comment">等于 0， s1 和 s2 在前 n 个字节中完全相同</span></span><br><span class="line"><span class="comment">大于 0， s1 中第一个字节大于 s2 中对应的字节	*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">memcmp_test</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> buf1[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	<span class="type">char</span> buf2[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	<span class="type">int</span> a1 = <span class="built_in">memcmp</span>(buf1, buf2, <span class="keyword">sizeof</span>(buf1));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>内存拷贝</h1>
<p>从 src 开始的连续 n 个字节复制到 dest 开始的内存区域，<code>dest</code> 和 <code>src</code> 所指向的内存区域不能重叠。如果需要处理重叠的内存区域，应该使用 <code>memmove</code> 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dest：指向目标内存区域的指针，即要复制到的位置</span></span><br><span class="line"><span class="comment">src：指向源内存区域的指针，即要从中复制数据的位置</span></span><br><span class="line"><span class="comment">n：要复制的字节数	*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">memcpy_test</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> buf1[<span class="number">6</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">67</span>&#125;;</span><br><span class="line">	<span class="type">char</span> buf2[<span class="number">6</span>];</span><br><span class="line">	<span class="built_in">memset</span>(buf2,<span class="number">2</span>,<span class="keyword">sizeof</span>(buf2));</span><br><span class="line">	<span class="built_in">memcpy</span>(buf2, buf1, <span class="keyword">sizeof</span>(buf1));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; <span class="keyword">sizeof</span>(buf2)/<span class="keyword">sizeof</span>(<span class="type">char</span>); i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,buf2[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>内存拷贝搬移</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memmove</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dest：指向目标内存区域的指针，即要复制到的位置</span></span><br><span class="line"><span class="comment">src：指向源内存区域的指针，即要从中复制数据的位置</span></span><br><span class="line"><span class="comment">n：要复制的字节数	*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">memmove_test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> overlap_src_dest[] = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将前 5 个字节复制到从第 3 个位置开始的目标位置</span></span><br><span class="line">    memmove(overlap_src_dest + <span class="number">2</span>, overlap_src_dest, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印重叠后的结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %s\n&quot;</span>, overlap_src_dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>6.预处理</title>
    <url>/post/804ae251.html</url>
    <content><![CDATA[<h1><center>知识点一：变量分类</center></h1>
<h2 id="1-普通局部变量">1、普通局部变量</h2>
<blockquote>
<ul>
<li>生命周期：离它最近的{}之间有效，离开{}的局部变量 系统自动回收</li>
<li>存储区域：栈区</li>
<li>普通局部变量不初始化 内容不确定</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义形式：在 &#123;&#125; 里面定义的普通变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;	<span class="comment">//普通局部变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>普通局部变量 同名 就近原则</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//局部变量 同名 就近原则</span></span><br><span class="line">    <span class="type">int</span> data = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> data = <span class="number">200</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;A:data = %d\n&quot;</span>,data);<span class="comment">//200</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B:data = %d\n&quot;</span>,data);<span class="comment">//100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-普通全局变量">2、普通全局变量</h2>
<p>定义形式：定义在函数外边的变量 就是普通全局变量</p>
<p>全局变量 不初始化 内容为0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前源文件(.c) 都有效</span></span><br><span class="line"><span class="type">int</span> data;	<span class="comment">//普通全局变量 在函数外边定义</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test02</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-静态局部变量">3、静态局部变量</h2>
<blockquote>
<p>定义形式：在{}中定义，前面 必须加static 修饰 这样的变量</p>
</blockquote>
<blockquote>
<ul>
<li>作用范围：离它最近的{}之间有效</li>
<li>生命周期：整个进程 （程序结束的时候 静态局部变量 才被释放）</li>
<li>静态局部变量 不初始化 内容为0</li>
<li>只能被定义一次（重要）</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num;	<span class="comment">//静态局部变量</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;<span class="comment">//普通的局部变量</span></span><br><span class="line">    num++;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>,num);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//静态局部变量 只能被初始化一次</span></span><br><span class="line">    <span class="comment">//静态局部变量 生命周期 是整个进程</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">10</span>;	<span class="comment">//静态局部变量</span></span><br><span class="line">    num++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>,num);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    fun1();	<span class="comment">//11</span></span><br><span class="line">    fun1();	<span class="comment">//11</span></span><br><span class="line">    fun1();	<span class="comment">//11</span></span><br><span class="line">    fun1();	<span class="comment">//11</span></span><br><span class="line"></span><br><span class="line">    fun2();	<span class="comment">//11</span></span><br><span class="line">    fun2();	<span class="comment">//12</span></span><br><span class="line">    fun2();	<span class="comment">//13</span></span><br><span class="line">    fun2();	<span class="comment">//14</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-静态全局变量">4、静态全局变量</h2>
<blockquote>
<p>定义形式：在函数外边定义 同时前面加static</p>
</blockquote>
<blockquote>
<ul>
<li>作用范围：当前源文件 有效 不能在其他源文件中使用</li>
<li>生命周期：整个进程，（程序结束 静态全局变量才被释放）</li>
<li>存储区域：全局区</li>
<li>静态全局变量 不初始化 内容为0</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> data = <span class="number">10</span>;	<span class="comment">//静态全局变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点二：变量分类</center></h1>
<h2 id="1-全局函数：普通函数">1、全局函数：普通函数</h2>
<blockquote>
<p>特点：其他源文件 可以使用 全局函数，必须加extern 声明</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_fun</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(全局函数)普通函数\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-静态函数-局部函数">2、静态函数（局部函数）</h2>
<blockquote>
<p>特点：只能在当前源文件使用 不能在其他源文件使用</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_static_fun</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(静态函数)局部函数\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果想在其他源文件 调用 静态函数 需要将静态函数 封装在 全局函数中。同时全局函数 和静态函数 必须是同一个源文件</p>
</blockquote>
<p>fun.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_static_fun</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(静态函数)局部函数\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_fun</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(全局函数)普通函数\n&quot;</span>);</span><br><span class="line">    my_static_fun();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">my_fun</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//static void my_static_fun(void);</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    my_fun();</span><br><span class="line">    <span class="comment">//my_static_fun();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点一：gcc编译过程</center></h1>
<blockquote>
<ul>
<li>
<p>预处理：头文件包含、宏替换、条件编译、删除注释  不做语法检查</p>
</li>
<li>
<p>编译：将预处理后的文件生成汇编文件语法检查</p>
</li>
<li>
<p>汇编：将汇编文件编译二进制文件</p>
</li>
<li>
<p>链接：将众多的二进制文件+库+启动代码生成可执行文件</p>
</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>gcc</th>
<th>-E</th>
<th>hel1o.c</th>
<th>-O</th>
<th>hel1o.i</th>
<th>1、预处理</th>
</tr>
</thead>
<tbody>
<tr>
<td>gcc</td>
<td>-S</td>
<td>hello.i</td>
<td>-O</td>
<td>hello.s</td>
<td>2、编译</td>
</tr>
<tr>
<td>gcc</td>
<td>-C</td>
<td>hello.s</td>
<td>-O</td>
<td>hello.o</td>
<td>3、汇编</td>
</tr>
<tr>
<td>gcc</td>
<td></td>
<td>hello.o</td>
<td>-O</td>
<td>hello_elf</td>
<td>4、链接</td>
</tr>
</tbody>
</table>
<h1><center>知识点二：头文件包含</center></h1>
<blockquote>
<p>&lt;&gt; ：用于包含<code>系统</code>头文件</p>
<p>&quot; &quot; ：用于包含<code>用户自定义</code>头文件</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hehe.h&gt;</span>	<span class="comment">//表示从系统的指定目录下寻找 hehe.h</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hehe.h&quot;</span>	<span class="comment">//表示先从源文件所在的目录寻找,如果找不到再到系统指定的目录下找</span></span></span><br></pre></td></tr></table></figure>
<h1><center>知识点三：宏定义</center></h1>
<blockquote>
<p>宏只在当前源文件有效</p>
<p>宏名 一般是大写，定义宏是后面不能加 <mark>;</mark> 号</p>
</blockquote>
<h2 id="1-不带参数宏">1、不带参数宏</h2>
<blockquote>
<p>形式：<font color="red">#define 宏名 需要代替的内容</font></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N <span class="string">&quot;hehe&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在预处理阶段 &quot;hehe&quot;替换 代码中所有出现的N ( 宏展开)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,N);	<span class="comment">//hehe</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><mark>终止宏</mark>的作用范围：</p>
<blockquote>
<p>形式：#undef 宏名</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//宏 后面不要加;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N <span class="string">&quot;hehe&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,N);	<span class="comment">//OK 识别的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用#undef N终止 N的作用</span></span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> N</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;%s\n&quot;,N);	//err 不识别N</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-带参数的宏-宏-函数">2、带参数的宏 （宏 函数）</h2>
<blockquote>
<p>形式：#define 宏名(参数1,参数2, …) 需要代替的内容</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//宏的参数a b 不能写类型</span></span><br><span class="line"><span class="comment">//#define MY_ ADD(int a, int b) a+b  //错误</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_ADD(a,b) a+b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用宏名(参数)</span></span><br><span class="line">MY_ <span class="title function_">ADD</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span>;     <span class="comment">// 10+20</span></span><br></pre></td></tr></table></figure>
<p>    加小括号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MY_MUL1(a,b) a*b </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_MUL2(a,b) ((a)*(b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MY_MUL1 = %d\n&quot;</span>,MY_MUL1(<span class="number">10</span>,<span class="number">20</span>));    <span class="comment">//200     //MY_ MULI (10,20)==10*20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//MY MUL1 ( 10+10 , 20+20 )==10+10*20+20</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MY_MUL1 = %d\n&quot;</span>,MY_MUL1(<span class="number">10</span>+<span class="number">10</span>,<span class="number">20</span>+<span class="number">20</span>));    <span class="comment">//230     //不能保证完整性 </span></span><br><span class="line">    <span class="comment">//MY_MUL2(10+10, 20+20) ==((10+10)*(20+20))</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MY_MUL2 = %d\n&quot;</span>,MY_MUL2(<span class="number">10</span>+<span class="number">10</span>,<span class="number">20</span>+<span class="number">20</span>));    <span class="comment">//800     //保证完整性 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-带参数的宏-宏函数-和普通函数的区别">3、带参数的宏(宏函数)和普通函数的区别</h2>
<p>    带参数的宏(宏函数)：调用多少次就会展开多少次，执行代码的时候没有函数调用的过程，也不需要函数的出入栈，所以带参数的<font color="red">宏浪费空间节省了时间</font></p>
<p>    代参的函数：代码只有一份，存在代码段，调用的时候去代码段读取函数指令 ，调用的时候要压栈(保存调用函数前的相关信息)，调用完出栈(恢复调用函数前的相关信息)，所以<font color="red">函数浪费了时间节省空间</font></p>
<h1><center>知识点四：条件编译</center></h1>
<p>    如果xxx为真则运行语句1，为假运行语句2</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试不存在</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XXX</span></span><br><span class="line">	语句<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	语句<span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试存在</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> XX</span></span><br><span class="line">	语句<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	语句<span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断条件是否成立</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 表达式</span></span><br><span class="line">	语句<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	语句<span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过条件编译控制大小写的转换</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符串&quot;</span>);</span><br><span class="line">    <span class="comment">// fgets 会获取换行符 </span></span><br><span class="line">    fgets(buf,<span class="keyword">sizeof</span>(buf),<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//去掉换行符  strlen返回的是字符串是长度 不包含&#x27;\0&#x27;</span></span><br><span class="line">    <span class="comment">//strlen(buf)-1 这是换行符的下标位置</span></span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//buf[i]是取数组中的第i个元素的值</span></span><br><span class="line">    <span class="comment">//while(buf[i] != &#x27;\0&#x27;)</span></span><br><span class="line">    <span class="keyword">while</span>(buf[i])   <span class="comment">//最后一一个元素是&#x27;\0&#x27; == 0==假循环进不去</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">        <span class="keyword">if</span>(buf[i]&gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; buf[i]&lt;=<span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            buf[i] = buf[i]+<span class="number">32</span>;</span><br><span class="line">        <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span>(buf[i]&lt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; buf[i]&lt;=<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            buf[i] = buf[i]<span class="number">-32</span>;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf = %s\n&quot;</span>,buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点五、防止头文件重复包含</center></h1>
<p>方式一：#pragma once 编译器决定</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once <span class="comment">//放在头文件的最前方</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含</span></span><br></pre></td></tr></table></figure>
<p>方式二：c/c++的标准制定</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __头文件名_H__     <span class="comment">//大写</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __头文件名_H__</span></span><br><span class="line">	<span class="comment">//头文件具体内容</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缺点：不同头文件中的宏名不小心“撞车”，可能就会导致你看到头文件明明存在，但编译器却硬说找不到声明的状况</span></span><br></pre></td></tr></table></figure>
<h1><center>知识点六：原码、补码、反码</center></h1>
<blockquote>
<ul>
<li>负数在计算机中存储的是补码</li>
<li>正数：原码 == 反码 ==  补码</li>
<li>负数：反码 = 原码的符号位不变其他位取反，补码 = 反+1</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>概念</th>
<th>正数(10)</th>
<th>概念</th>
<th>负数(-10)</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>原码</td>
<td>数据的二进制形式</td>
<td>0000 1010</td>
<td>数据的二进制形式</td>
<td>1000 1010</td>
<td>以1字节为例</td>
</tr>
<tr>
<td>反码</td>
<td>就是原码</td>
<td>0000 1010</td>
<td>原码符号位不变，其他为取反</td>
<td>1111 0101</td>
<td></td>
</tr>
<tr>
<td>补码</td>
<td>就是原码</td>
<td>0000 1010</td>
<td>反码 + 1</td>
<td>1111 0110</td>
<td></td>
</tr>
</tbody>
</table>
<p>计算机为啥要补码?</p>
<p>如果没有补码：</p>
<p>    6-10 == -4</p>
<p>    6+(-10) == -4</p>
<p>    0000 0110</p>
<p>    1000 1010</p>
<p>————————————————————————</p>
<p>    1001 0000 == -16 (错误)</p>
<p>如果有补码：</p>
<p>    0000 0110</p>
<p>    1111 0110</p>
<p>---------------------------------------          补码转原码：取反加一</p>
<p>    1111 1100-----&gt;1000 0011—&gt;1000 0100 ==&gt; -4</p>
<p>补码的意义：减法运算变加法运算</p>
<p>以1字节分析：</p>
<p>    有符号符: 1111 1111 ~ 1000 0000~0000 0000 ~ 0111 1111</p>
<p>                -127    ~     -0        ~    +0           ~   +127</p>
<p>计算机为了扩数据的表示范围:故意将 -0 看成-128</p>
<p>     -128~127</p>
<p>无符号数：0000 0000 ~ 1111 1111 == 0~255</p>
<p>总结：补码统一 0 的编码</p>
<p>    +0 == 0000 0000 == 0000 0000 (反码) == 0000 0000 (补码)</p>
<p>    -0 == 1000 0000 == 1111 1111 (反码) == 0000 0000 (补码)</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>7.指针</title>
    <url>/post/b70ae4e7.html</url>
    <content><![CDATA[<h1><center>内存地址概述</center></h1>
<p>系统给内存的每一个字节 分配一个编号 而这个编号 就是内存地址</p>
<p>变量、函数、数组、字符串等开辟空间，开辟空间也会给予一个起始地址(内存地址)</p>
<img src="https://s2.loli.net/2024/08/24/RoJbKhCkzwZdsc4.png" alt="内存地址" style="zoom:50%;">
<h1><center>指针变量</center></h1>
<p>指针变量：本质就是一个<code>变量</code>，只是这个变量 存放 是内存的地址编号，指针变量也有起始地址，二级指针就可以保存一级指针，依次嵌套</p>
<p>在32位平台，指针变量<code>任何类型</code>的地址编号都是 4 字节</p>
<h2 id="center-定义指针变量-center"><center>定义指针变量</center></h2>
<blockquote>
<p><code>*</code>：在<code>定义</code>指针变量时，起到<font color="red">标识作用</font>，<code>其他地方</code>表示获取一个指针变量保存的地址里面的<code>内容</code>，指针变量的解引用</p>
<p><code>&amp;</code>：取一个<mark>对应变量</mark>的<font color="red">地址</font>，若对指针变量取地址，则是指针变量的地址(而不是指针变量指向的地址)</p>
<p>如果 &amp; 和 * 同时存在 可以相互抵消</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//形式：</span></span><br><span class="line">    类型 *指针变量名</span><br><span class="line"></span><br><span class="line"><span class="comment">//p指向的类型为int =&gt; p保存int类型变量的地址</span></span><br><span class="line"><span class="comment">//指向......类型 == 保存......类型变量的地址</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = &amp;num;	<span class="comment">//p指向num ==p保存了num的地址</span></span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2024/09/01/jJY6E73oZL8CpiK.webp" alt="指针变量解析" style="zoom:50%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test02</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//num拥有一个合法的空间</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//需求：请定义一个指针变量 保存num的地址</span></span><br><span class="line">    <span class="comment">//p就是指针变量 变量名为p 不是*p</span></span><br><span class="line">    <span class="comment">//在定义的时候：*修饰p 表示p为指针变量</span></span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立p和num的关系：p保存num的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;num = %p\n&quot;</span>, &amp;num);	<span class="comment">//&amp;num = 0019FED8</span></span><br><span class="line">    p = &amp;num;	<span class="comment">//&amp;num 代表的是num变量起始地址（首地址）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %p\n&quot;</span>, p);	<span class="comment">//p = 0019FED8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-指针变量使用-center"><center>指针变量使用</center></h2>
<blockquote>
<p>通过过 p 对所保存的地址空间进行读写操作</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test01</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//num拥有一一个合法的空间 </span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//需求:请定义一个指针变量保存num的地址</span></span><br><span class="line">    <span class="comment">//p就是指针变量变量名为p不是*p</span></span><br><span class="line">    <span class="comment">//在定义的时候：*修饰p表示p为指针变量</span></span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line"></span><br><span class="line">    p = &amp;num;  <span class="comment">//&amp;num代表num变量起始地址(首地址)</span></span><br><span class="line">    <span class="comment">//指针变量指向变量p的起始地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;num = %p\n&quot;</span>,&amp;num);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %p\n&quot;</span>,p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//*p 等价 num</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>,*p);  <span class="comment">//10 == num</span></span><br><span class="line"></span><br><span class="line">    *p = <span class="number">100</span>;	<span class="comment">//*p == 100 == num</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>,num);	<span class="comment">//结果：num = 100</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,p);    <span class="comment">//如果此处为&amp;p表示键盘给p赋值而不是给num赋值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>,num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-指针变量初始化-center"><center>指针变量初始化</center></h2>
<blockquote>
<p>指针变量初始化为NULL</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;    <span class="comment">//不要对p进行*p操作，容易出段错误</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>指针变量初始化为 合法空间</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num = 10;</span><br><span class="line">int *p = &amp;num;    //第一步定义指针变量int *p    第二步给指针变量赋值: p=&amp;num </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test01</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果 局部指针变量 不初始化保存的是随机的地址编号(千万别取值)</span></span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不想让指针变量指向任何地方 应该初始化为NULL(千万别取值)</span></span><br><span class="line">    <span class="type">int</span> *pl = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将指针变量初始化为合法的地址(可以取值)</span></span><br><span class="line">    <span class="comment">//*修饰p2为指针变量，p2=&amp;num;</span></span><br><span class="line">    <span class="type">int</span> *p2 = &amp;num;		<span class="comment">//第一步: int *p2;   第二步: p2=&amp;num;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p2);	<span class="comment">//num==10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//指针变量p2本质是一个变量  可以更改指向</span></span><br><span class="line">    p2 = &amp;data;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p2);	<span class="comment">//data==200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-指针强制类型转换-center"><center>指针强制类型转换</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//形式：</span></span><br><span class="line">    (需要强转的类型 *)变量名;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通变量：</span></span><br><span class="line">    (需要强转的类型)变量名;</span><br></pre></td></tr></table></figure>
<h2 id="center-指针变量取值-mark-宽度-mark-center"><center>指针变量取值<mark>宽度</mark></center></h2>
<p>宽度：指针变量指向的类型长度决定</p>
<img src="https://s2.loli.net/2024/09/01/HR1NIzXhxaD3urv.webp" alt="指针变量取值宽度解析" style="zoom:50%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>  num = <span class="number">0x01020304</span>;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="type">short</span> *p1;</span><br><span class="line">    <span class="type">char</span> *p2;</span><br><span class="line">    p = &amp;num;</span><br><span class="line">    p1 = &amp;num;</span><br><span class="line">    p2 = &amp;num; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %#x\n&quot;</span>,*p);	<span class="comment">//*p = 0x1020304</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p1 = %#x\n&quot;</span>,*p1);	<span class="comment">//*p1 = 0x0304</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p2 = %#x\n&quot;</span>,*p2);	<span class="comment">//*p2 = 0x04</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-指针变量的-mark-跨度-mark-center"><center>指针变量的<mark>跨度</mark></center></h2>
<p>跨度：指针变量指向的类型长度决定</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>  num = <span class="number">0x01020304</span>;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="type">short</span> *p2;</span><br><span class="line">    <span class="type">char</span> *p1;</span><br><span class="line"></span><br><span class="line">    p2 = &amp;num;</span><br><span class="line">    p = &amp;num;</span><br><span class="line">    p1 = &amp;num;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %u\n&quot;</span>,p);			<span class="comment">//*p = 6356608</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p+1 = %u\n&quot;</span>,p+<span class="number">1</span>);		<span class="comment">//*p+1 = 635612</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p1 = %u\n&quot;</span>,p1);		<span class="comment">//*p1 = 6356608</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p1+1 = %u\n&quot;</span>,p1+<span class="number">1</span>);	<span class="comment">//*p1+1 = 6356609</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p2 = %u\n&quot;</span>,p2);		<span class="comment">//*p2 = 6356608</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p2+1 = %u\n&quot;</span>,p2+<span class="number">1</span>);	<span class="comment">//*p2+1 = 6356610</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例：int  num = 0x01020304，自定义指针变量p 取出 0x0102</p>
<img src="https://s2.loli.net/2024/09/01/8JA6WKYLfrdUT5Q.webp" alt="分析" style="zoom:50%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(intargc, <span class="type">char</span>*argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0x01020304</span>;</span><br><span class="line">    <span class="type">short</span> *p;</span><br><span class="line">    p = &amp;num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#x\n&quot;</span>, *(p+<span class="number">1</span>));	<span class="comment">//0102</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果跨度和宽度不等时，需要类型转换</span></span><br><span class="line"><span class="comment">//选择min(跨度、宽度)定义指针变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(intargc, <span class="type">char</span>*argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0x01020304</span>;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="type">short</span> *p2;</span><br><span class="line"></span><br><span class="line">    p = &amp;num;</span><br><span class="line">    p2 = &amp;num;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#x\n&quot;</span>, *(<span class="type">short</span> *)(p+<span class="number">1</span>));	<span class="comment">//0x0203</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#x\n&quot;</span>, *(<span class="type">short</span> *)((<span class="type">char</span> *)p+<span class="number">1</span>));	<span class="comment">//0x0203</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-指针注意事项-center"><center>指针注意事项</center></h2>
<p>void 不能定义变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> num;    <span class="comment">//错误的 系统不知道num的大小</span></span><br></pre></td></tr></table></figure>
<p>void <mark>*</mark> 可以定义变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *p;    <span class="comment">//p的类型为 void * 而void *指针类型32为平台4字节，系统知道给p开辟4字节</span></span><br><span class="line"><span class="comment">//p叫万能指针，p可以保存任意类型的一级指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于 p 不能直接使用 *p 操作，必须实现对 p 进行强制类型转换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test01</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="type">void</span> *p;</span><br><span class="line">    p = &amp;num;</span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;, *p);    //错误：因为p的指向类型为void 系统确定不了宽度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(<span class="type">int</span> *)p);    <span class="comment">//p临时的指向类型为int 系统确定宽度4B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要对<mark>没有初始化</mark>的指针变量 取<font color="red">*</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);    <span class="comment">//不能这样取*输出</span></span><br><span class="line"><span class="comment">//因为p没有初始化 内容随机 也就足p指向了一个未知空间系统不允许用户 取值*p操作</span></span><br></pre></td></tr></table></figure>
<p>不要对<mark>初始化</mark>为<font color="red"> NULL </font>的指针变量 <mark>取*</mark></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NULL就是(void *) 0 地址，也是内存的起始地址受系统保护</span></span><br><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>,*p);    <span class="comment">//也不能 *p</span></span><br></pre></td></tr></table></figure>
<p>不要给指针变量赋<mark>普通的数值</mark></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="number">1000</span>;    <span class="comment">// 此时的1000对于p来说是地址编号1000</span></span><br><span class="line"><span class="comment">//*p表示在地址编号为1000的位置 取值，而地址编号1000不是合法的空间所以不能*p</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>,*p);    <span class="comment">//也不能*p</span></span><br></pre></td></tr></table></figure>
<p>指针变量不要操作<mark>越界</mark>的空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> num=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;num;</span><br><span class="line"><span class="comment">//num只占1B空间，而p的指向类型为int 所以*p取值宽度为4B ，所以越界3B</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p =%d\n&quot;</span>, *p);    <span class="comment">//操作非法空间</span></span><br></pre></td></tr></table></figure>
<h1><center>数组元素指针</center></h1>
<p>通过数组元素的指针变量 遍历  数组的元素</p>
<img src="https://s2.loli.net/2024/09/01/sMfIgRAXHEyUhoz.webp" alt="数组元素指针解析" style="zoom:50%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test05</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>]=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//p保存了 第0个元素的地址（首元素的地址）</span></span><br><span class="line">    <span class="type">int</span> *p = &amp;arr[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);	<span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">    p++;	<span class="comment">//p=p+1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);	<span class="comment">//20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//前提是p保存的是第0个元素的地址</span></span><br><span class="line">    p=&amp;arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;%d &quot;, arr[i]);</span></span><br><span class="line">        <span class="comment">//p+i代表的是第i个元素的地址</span></span><br><span class="line">        <span class="comment">//*(p+i)代表的是第i个元素的值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p+i));	<span class="comment">//10 20 30 40 50</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过数组元素的指针变量给数组的元素获取键盘输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(num)/<span class="keyword">sizeof</span>(num[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *p = &amp;num[<span class="number">0</span>]; <span class="comment">//或int *p = num;</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//scanf(&quot;%d&quot;, &amp;num[i]);</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,p + i);    <span class="comment">//p + i == &amp;num[i];</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>数组的[]和*()的关系</center></h1>
<blockquote>
<p>数组名arr 作为<mark>类型</mark>，代表的是数组的总大小sizeof (arr)</p>
<p>数组名arr 作为<code>地址</code>，代表的是<code>首元素地址</code>(第0个元素的地址)</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;arr[<span class="number">0</span>] == &amp;*(arr+<span class="number">0</span>) == arr+<span class="number">0</span> == arr</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在使用中本质：<code>[] 是 *( ) 缩写</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">arr[<span class="number">1</span>] 	*(arr + <span class="number">1</span>)	<span class="comment">//缩写规则：+ 左边的值放在[]左边，+ 右边的值放在[]里面</span></span><br></pre></td></tr></table></figure>
<h1><center>数组 arr 和 &amp;arr区别</center></h1>
<blockquote>
<p>arr：数组的<code>首元素地址</code>，&amp;arr：数组的<code>首地址</code></p>
<p>数组名arr是一个符号常量，不能被赋值</p>
</blockquote>
<img src="https://s2.loli.net/2024/09/10/p643QCt1gnqzsvl.webp" alt="区别分析" style="zoom:50%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test10</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>]=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line">    <span class="comment">//arr = 1000;	//err arr符号常量 不能被赋值</span></span><br><span class="line">    <span class="comment">//arr++;	//arr=arr+1; err</span></span><br><span class="line">    arr+<span class="number">1</span>;	<span class="comment">//ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>指向同一数组的两个元素指针变量间关系</center></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">testll</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>]=&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>,<span class="number">50</span>&#125; ;</span><br><span class="line">    <span class="type">int</span> *p1 = arr;</span><br><span class="line">    <span class="type">int</span> *p2 = arr+<span class="number">3</span>;</span><br><span class="line">    <span class="comment">//1、指向同一数组的两个指针变量相减，返回的是相差元素的个数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p2 - p1);	<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、指向同一数组的两个指针变量可以比较大小</span></span><br><span class="line">    <span class="keyword">if</span>(p2 &gt; p1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt;\n&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、 指向同一数组的两个指针变量 可以赋值</span></span><br><span class="line">    p1 = p2;    <span class="comment">//p1 和 p2指向同一处地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、指问同一数组的两个指针变量尽量不要相加</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p2 = %u\n&quot;</span>, p2);</span><br><span class="line">    p1 + p2;    <span class="comment">//错误：越界很厉害了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、[]里面在不越界的情况下 可以为负数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p2[<span class="number">-2</span>]);	<span class="comment">//20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>指针数组</center></h1>
<blockquote>
<p>指针数组：本质是<mark>数组</mark>，只是数组的每个元素是指针</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//形式：</span></span><br><span class="line">    类型 *数组名[元素个数];</span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2024/09/01/ZVOh5cxJnuFGXLB.webp" alt="指针数组解析" style="zoom:50%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> num3 = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//指针数组</span></span><br><span class="line">    <span class="type">int</span> *arr[<span class="number">3</span>] = &#123;&amp;num1, &amp;num2, &amp;num3&#125;;</span><br><span class="line">    <span class="type">char</span> *arr2[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">//arr[0] = &amp;num1, arr[1]=&amp;num2, arr[2]=&amp;num3</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *arr[<span class="number">1</span>]);	<span class="comment">//*arr[1] == *&amp;num2 == num2 == 20</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(arr));		<span class="comment">//12</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(arr2));	<span class="comment">//12</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test02</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *arr[<span class="number">3</span>] = &#123;<span class="string">&quot;hehehe&quot;</span>,<span class="string">&quot;hahaha&quot;</span>,<span class="string">&quot;heiheihei&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr));	<span class="comment">//12</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//%s输出是要求要字符串首元素地址，而arr[1]就是保存了字符串的首元素地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, arr[<span class="number">1</span>]);	<span class="comment">//hahaha</span></span><br><span class="line">    <span class="comment">//arr[1]首元素地址(h) 再加一就是字符a的地址 再取值就是打印a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, *(arr[<span class="number">1</span>]+<span class="number">1</span>));	<span class="comment">//a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>数组指针</center></h1>
<blockquote>
<p>本质是：<mark>指针变量</mark>，只是保存的是数组的首地址</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//形式：</span></span><br><span class="line">	指向的数组的类型 (*指针变量名)[指向的数组的元素个数];</span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2024/09/01/t4CILfEhQPJau8S.webp" alt="数组指针分析" style="zoom:50%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test03</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>]=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>, <span class="number">40</span>&#125;;</span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">5</span>];	<span class="comment">//数组指针: 本质是一个指针变量只是该变量保存的是数组的首地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(p));	<span class="comment">//4 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p=  %u\n&quot;</span>,p);		<span class="comment">//p = 3612672</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p+1 = %u\n&quot;</span>,p+<span class="number">1</span>);	<span class="comment">//p+2 = 3612692</span></span><br><span class="line"></span><br><span class="line">    p = &amp;arr;    <span class="comment">//&amp;arr 才代表数组的首地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(*p+<span class="number">3</span>));	<span class="comment">//40</span></span><br><span class="line">    <span class="comment">//*(*p+3) == *(*(p+0)+3) == *(p[0]+3) == p[0][3]      </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p[<span class="number">0</span>][<span class="number">3</span>]);	<span class="comment">//40</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>数组指针与二维数组的关系</center></h1>
<img src="https://s2.loli.net/2024/09/01/OCgdl21xBYXLksh.webp" alt="数组指针与二维数组分析" style="zoom:50%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test03</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> i,j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">4</span>] = arr;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//printf(&quot;%d\n&quot;,*(*(p+i)+j));</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,arr[i][j]);	<span class="comment">//1 2 3 4 5 6 7 8 9 10 11 12</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>任何维度的数组在物理存储上都是一维</p>
</blockquote>
<img src="https://s2.loli.net/2024/09/02/DQYjBye95woTNnx.webp" alt="数组存储分析" style="zoom:50%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test05</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;arr[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>*<span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;%d &quot;, *(p+i));</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p[i]);	<span class="comment">//1 2 3 4 5 6 7 8 9 10 11 12</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>多级指针</center></h1>
<blockquote>
<p>指针变量存放的是地址，但指针变量本身还有对应的地址，如果对<code>指针变量</code>取地址，就是指针变量本身的地址</p>
</blockquote>
<img src="https://s2.loli.net/2024/09/02/zeawKsnYES5dGhi.webp" alt="多级指针分析" style="zoom:50%;">
<h1><center><mark>指针变量</mark>作函数参数</center></h1>
<blockquote>
<p>如果想在函数内部 修改 外部变量的值，需要将外部变量的 地址 传递给 函数(以指针变量作为函数的参数)</p>
<p>由于p1和p2分别保存了data1和data2的地址，可以通过p1和p2间接的修改data1和data2的值</p>
</blockquote>
<img src="https://s2.loli.net/2024/09/02/qh7PLVaIosjr6Ul.webp" alt="指针变量作函数参数分析" style="zoom:50%;">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_set_p</span><span class="params">(<span class="type">int</span> **tmp_p)</span>	<span class="comment">//tmp_p = &amp;p;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//*tmp_p == p</span></span><br><span class="line">    *tmp_p = &amp;num;	<span class="comment">//p = &amp; num;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//在函数内部 更改p的指向(在函数内部 给p赋值 就必须传递p的地址)</span></span><br><span class="line">    my_set_p(&amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);	<span class="comment">//100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span> *a1;</span><br><span class="line">    <span class="type">int</span> *b1;</span><br><span class="line">    <span class="type">int</span> *a2;</span><br><span class="line">    <span class="type">int</span> *b2;</span><br><span class="line">    a1 = &amp;a;</span><br><span class="line">    b1 = &amp;b;</span><br><span class="line">    a2 = a1;</span><br><span class="line">    b2 = b1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//情况一：指针变量相互赋值的话，只是地址转换，只能影响交换地址之间的值</span></span><br><span class="line">    <span class="comment">//a2 = b2;</span></span><br><span class="line">    <span class="comment">//printf(&quot;a2 = %d,b2 = %d\n&quot;,*a2,*b2);	//a2 = 200,b2 = 200</span></span><br><span class="line">    <span class="comment">//printf(&quot;a1 = %d,b1 = %d\n&quot;,*a1,*b1);	//a1 = 100,b1 = 200</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//情况二：交换的是 *变量，所对应的赋值的地址对应的值都会随着改变</span></span><br><span class="line">    *a2 = *b2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a2 = %d,b2 = %d\n&quot;</span>,*a2,*b2);	<span class="comment">//a2 = 200,b2 = 200</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a1 = %d,b1 = %d\n&quot;</span>,*a1,*b1);	<span class="comment">//a1 = 200,b1 = 200</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d,b = %d\n&quot;</span>,a,b);			<span class="comment">//a = 200,b = 200</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center><mark>一维数组名</mark>作函数参数</center></h1>
<blockquote>
<p>如果函数内部想操作(读、写)外部数组的元素，请将外部数组的数组名传递函数</p>
<p><code>一维数组</code>作为函数形参会被优化成<code>一级指针变量</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//int my_input_array(int arr[5],int n)</span></span><br><span class="line"><span class="comment">//一维数组作为函数的形参会被优化成指针变量，arr[0] == *(arr + 0) == *arr</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_input_array</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B:%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr));    <span class="comment">//4</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入%d个int数据\n&quot;</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, arr+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">my_print_array</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;%d &quot;, *(arr+i));</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A:%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr));    <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个函数给arr获取键盘输入</span></span><br><span class="line">    my_input_array(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个函数遍历数组元素</span></span><br><span class="line">    my_print_array(arr, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center><mark>二维数组名</mark>作函数参数</center></h1>
<blockquote>
<p>如果函数内部想操作(读、写)外部数组的元素，请将外部数组的数组名传递函数</p>
<p><code>二维数组名</code>作为函数的形参会被优化成<code>数组指针</code>(参考数组指针解析)</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">5</span>] -----&gt; <span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> arr2[<span class="number">3</span>][<span class="number">4</span>] ----&gt; <span class="type">int</span> (*p1)[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> arr3[<span class="number">3</span>][<span class="number">4</span>][<span class="number">5</span>] ---&gt; <span class="type">int</span> (*p2)[<span class="number">4</span>][<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//void my_print_tow_array(int arr[3][4],int cow,int col)</span></span><br><span class="line"><span class="comment">//当二维数组作为函数形参会被优化成数组指针</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_print_tow_array</span><span class="params">(<span class="type">int</span> (*arr)[<span class="number">4</span>], <span class="type">int</span> cow, <span class="type">int</span> col)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A = %d\n&quot;</span>,<span class="keyword">sizeof</span>(arr));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; cow; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j =<span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;arr = %d &quot;</span>, arr[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="type">int</span> cow = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);		<span class="comment">//行数 </span></span><br><span class="line">    <span class="type">int</span> col = <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]);	<span class="comment">//列数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A = %d\n&quot;</span>,<span class="keyword">sizeof</span>(arr));	<span class="comment">//48</span></span><br><span class="line">    my_print_tow_array(arr,cow,col);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>指针函数</center></h1>
<blockquote>
<p>该函数的返回值是一个指针，指针作为函数的<font color="red">返回值</font></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指针函数形式：</span></span><br><span class="line">    函数返回值类型 *函数名(函数形参<span class="number">1</span>, 函数形参<span class="number">2</span> .....)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">get_addr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//int num = 1000;</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">1000</span>;    <span class="comment">//静态变量 程序结束前不会被释放</span></span><br><span class="line">    <span class="keyword">return</span> &amp;num;    <span class="comment">//不要返回普通局部变量地址（局部变量可能执行后会被释放而存放其他则返回的并不是原来的内容） </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    p = get_addr();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>,*p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>函数指针</center></h1>
<blockquote>
<p><code>函数名</code>代表的是<code>函数入口地址</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数指针形式：</span></span><br><span class="line">	函数返回值类型 (*变量名)(形参类型, 形参类型 .....)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//my_add代表的是函数的入口地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, my_add);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//函数指针本质：指针变量保存的是函数的入口地址</span></span><br><span class="line">    <span class="type">int</span> (*p)(<span class="type">int</span> ,<span class="type">int</span> ) = <span class="literal">NULL</span>;		<span class="comment">//函数指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相当于函数指针指向函数地址 p == my_add</span></span><br><span class="line">    p = my_add;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//函数调用：函数入口地址+()</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,my_add(<span class="number">10</span>,<span class="number">20</span>));	<span class="comment">//30</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p(<span class="number">100</span>,<span class="number">200</span>));	<span class="comment">//300</span></span><br><span class="line">    <span class="comment">//对函数指针变量取*无意义</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center><mark>函数指针</mark>作函数形参</center></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">my_sub</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">my_mul</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个函数实现，上述函数的功能</span></span><br><span class="line"><span class="comment">//将实参10，20传给形参a，b、函数地址（my_add）传给函数指针（fun_pointer）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_calc</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> ((*fun_pointer)(<span class="type">int</span> ,<span class="type">int</span>))</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> fun_pointer(a,b);    <span class="comment">//返回计算后的结果</span></span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">int</span> main(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,my_calc(<span class="number">10</span>,<span class="number">20</span>, my_add));    <span class="comment">//30</span></span></span><br><span class="line"><span class="params">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,my_calc(<span class="number">10</span>,<span class="number">20</span>, my_sub));    <span class="comment">//-10</span></span></span><br><span class="line"><span class="params">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,my_calc(<span class="number">10</span>,<span class="number">20</span>, my_mul));    <span class="comment">//200</span></span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>9.字符串</title>
    <url>/post/bec635c1.html</url>
    <content><![CDATA[<blockquote>
<p>头文件：<code>#include &lt;string&gt;</code></p>
</blockquote>
<h1><center>指针保存字符串</center></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* a = <span class="string">&quot;hello111&quot;</span>;	<span class="comment">//指针变量a 指向 字符串首地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>测量字符串长度</center></h1>
<blockquote>
<p>返回值为字符串的长度不包含 ‘\0’</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//s：被测量的字符串首元素地址</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>	<span class="comment">//strlen(被测量的字符串首元素地址(一般是数组名))</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">128</span>] = <span class="string">&quot;hehehe&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buf2[] = <span class="string">&quot;hehehe&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buf3[] = <span class="string">&quot;hehe\0he&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// \123 代表一个字符，\hhh 八进制转义h: 0~7</span></span><br><span class="line">    <span class="comment">//\\表示&#x27;\&#x27;</span></span><br><span class="line">    <span class="type">char</span> buf4[]=<span class="string">&quot;hehe\123\\he&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//\\x2f表示一个字符 \xdd 十六进制转义 d:0~9 a~f</span></span><br><span class="line">    <span class="type">char</span> buf5[]=<span class="string">&quot;hehe\x2fhe&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(buf1));	<span class="comment">//128</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(buf1));	<span class="comment">//6</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(buf2));	<span class="comment">//7</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(buf2));	<span class="comment">//6</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(buf3));	<span class="comment">//8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(buf3));	<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(buf4));	<span class="comment">//9</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(buf4));	<span class="comment">//8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf4);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(buf5));	<span class="comment">//8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(buf5));	<span class="comment">//7</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf6[]=<span class="string">&quot;\0hehe\0hehe&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(buf6));	<span class="comment">//0</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点三：字符串拷贝</center></h1>
<h2 id="center-1-strcpy-center"><center>1、strcpy</center></h2>
<blockquote>
<p>遇到’\0’会结束，只是’\0’也会拷贝过去</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//功能：把 src 所指向的字符串 复制 到dest 所指向的空间中</span></span><br><span class="line">原型：</span><br><span class="line">    <span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：返回dest字符串的首地址</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> src[] = &#123;<span class="string">&quot;hello\0string&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">//保证dst足够大</span></span><br><span class="line">    <span class="type">char</span> dst[<span class="number">128</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(dst,src);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dst = %s\n&quot;</span>,dst); <span class="comment">//hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-2-strncpy-center"><center>2、strncpy</center></h2>
<blockquote>
<p>'\0’不拷贝</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//功能：把 src 指向字符串的前 num 个复制到 dest 所指向的空间中</span></span><br><span class="line">原型：</span><br><span class="line">    <span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">( <span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">int</span> num)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：返回dest字符串的首地址</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> src[] = &#123;<span class="string">&quot;hello string&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">//保证dst足够大</span></span><br><span class="line">    <span class="type">char</span> dst[<span class="number">128</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">strncpy</span>(dst,src,<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dst = %s\n&quot;</span>,dst);     <span class="comment">//&quot;hel&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点四：字符串拼接</center></h1>
<h2 id="center-1-strcat-center"><center>1、strcat</center></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"><span class="comment">//将 src 的字符串拼接到 dst 的末尾(dst第一个&#x27;\0&#x27;的位置 )</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> src[] = &#123;<span class="string">&quot;wor\0ld&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> dst[<span class="number">128</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">strcat</span>(dst, src);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dst = %s\n&quot;</span>, dst);     <span class="comment">//hellowor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-2-strncat-center"><center>2、strncat</center></h2>
<blockquote>
<p>'\0’一起拷贝过去</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//功能：将str2前num个字母连接到str1后面</span></span><br><span class="line">原型：</span><br><span class="line">    <span class="type">char</span> *<span class="title function_">strncat</span> <span class="params">(<span class="type">char</span> *str1, <span class="type">char</span> *str2, <span class="type">int</span> num)</span></span><br><span class="line"></span><br><span class="line">返回值：返回str1字符串的首地址</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> src[] = &#123;<span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> dst[<span class="number">128</span>]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">strncat</span>(dst,src,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dst = %s\n&quot;</span>,dst); <span class="comment">//hellowo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点五：字符串比较</center></h1>
<h2 id="center-1-strcmp-center"><center>1、strcmp</center></h2>
<p><mark>整个</mark>字符串的比较</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//功能：将s1和s2指向的字符串逐个字符比较</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *S1,<span class="type">const</span> <span class="type">char</span> *s2)</span>;</span><br><span class="line"></span><br><span class="line">返回值:</span><br><span class="line">    &gt;<span class="number">0</span>：表示s1 &gt; s2</span><br><span class="line">    &lt;<span class="number">0</span>：表示s1 &lt; s2</span><br><span class="line">    ==<span class="number">0</span>：表示s1 == s2</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s1[] = <span class="string">&quot;hehe haha&quot;</span>;</span><br><span class="line">    <span class="type">char</span> s2[] = <span class="string">&quot;hehe xixi&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(s1,s2) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 &gt; s2\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(s1,s2) &lt; <span class="number">0</span>)	<span class="comment">//&lt;0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 &lt; s2\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(s1,s2) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 == s2\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-2-strncmp-center"><center>2、strncmp</center></h2>
<p>    <mark>局部</mark>字符串的比较，比较两个字符串的<mark>前</mark> n 个字节是否一样</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s1[] = <span class="string">&quot;hehe haha&quot;</span>;</span><br><span class="line">    <span class="type">char</span> s2[] = <span class="string">&quot;hehe xixi&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strncmp</span>(s1,s2,<span class="number">3</span>) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 &gt; s2\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strncmp</span>(s1,s2,<span class="number">3</span>) &lt; <span class="number">0</span>)        </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 &lt; s2\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strncmp</span>(s1,s2,<span class="number">3</span>) == <span class="number">0</span>)    <span class="comment">//== 0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 == s2\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点六：字符查找函数</center></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//功能：在字符串 str1 中查找字母 ch 出现的位置</span></span><br><span class="line">原型：</span><br><span class="line">    <span class="type">char</span>* <span class="title function_">strchr</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">char</span> ch)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：返回 第一次 出现的 ch地址，如果找不到，返回NULL</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;www.1000phone.com&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line">    ret = <span class="built_in">strchr</span>(str,<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *ret = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str=%s\n&quot;</span>,str);	<span class="comment">//&quot;www.1000ph#ne.com&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点七：字符串查找</center></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从 s1 中查找字符串 s2，返回 第一次 s2 出现的地址</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1,<span class="type">const</span> <span class="type">char</span> *s2)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//查找失败返回NULL</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s1[] = <span class="string">&quot;www.sex.777.sex.com&quot;</span>;</span><br><span class="line">    <span class="type">char</span> s2[] = <span class="string">&quot;sex&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line">    ret = <span class="built_in">strstr</span>(s1,s2);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,ret);	<span class="comment">//sex.777.sex.com</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点八：替换字符函数</center></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">原型: <span class="type">void</span>* <span class="title function_">memset</span> <span class="params">(<span class="type">void</span> *str, <span class="type">char</span> C, <span class="type">int</span> n)</span>  </span><br><span class="line">功能：将 str 所指向的内存区的 前n个 全部用 c 填充</span><br><span class="line">    常用于清除指定空间，比如 数组 或 <span class="built_in">malloc</span> 的空间</span><br><span class="line">返回值：返回 str 的地址</span><br></pre></td></tr></table></figure>
<h1><center>知识点九：字符串转化数值</center></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//功能：将 str 所指向的数字字符串转化为 int、long、double</span></span><br><span class="line"><span class="comment">//头文件：</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//转int</span></span><br><span class="line">atoi(需要转的字符串)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//转long</span></span><br><span class="line">atol(需要转的字符串)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//转double</span></span><br><span class="line">atof(需要转的字符串)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, atoi(<span class="string">&quot;123&quot;</span>));	<span class="comment">//123</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, atol(<span class="string">&quot;12356&quot;</span>));	<span class="comment">//12345</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, atof(<span class="string">&quot;12.3&quot;</span>));	<span class="comment">//12.300000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十：字符串切割函数</center></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一次切割：str必须指向要切割的字符串首元素地址，delim指向要切割的符号</span></span><br><span class="line"><span class="comment">//第2~n次切割: str必须指向NULL  delim指向要切割的符号</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strtok</span><span class="params">(<span class="type">char</span> *str，<span class="type">const</span> <span class="type">char</span> *delim)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：切割成功返回切割到字符换片段的首元素地址，失败: NULL</span></span><br><span class="line"><span class="comment">//注意: strtok 不能切割字符串常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&quot;hehe:haha:xixi:lala&quot;</span></span><br><span class="line"><span class="comment">如果切制完成会产生 &quot;hehe&quot; &quot;haha&quot; &quot;xixi&quot; &quot;lala&quot;</span></span><br><span class="line"><span class="comment">一般选择char *arr[] 指针数组来存放上面独立的字符串的首元素地址</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[] =<span class="string">&quot;hehehe:haha:xixi:lala:heihei:henhen&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *arr [<span class="number">32</span>]= &#123;<span class="literal">NULL</span>&#125; ;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//第1次切割</span></span><br><span class="line">    arr[i] = strtok(buf,<span class="string">&quot;:@#&quot;</span>) ;</span><br><span class="line">    <span class="comment">//第2~n切割</span></span><br><span class="line">    <span class="keyword">while</span>(arr[i] != <span class="literal">NULL</span>)	<span class="comment">//保证上一次切割正常才有进行下一次切割的必要</span></span><br><span class="line">    &#123;</span><br><span class="line">        i++ ;</span><br><span class="line">        arr[i] = strtok (<span class="literal">NULL</span>,<span class="string">&quot;:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历切割的内容</span></span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(arr[i] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%s\n&quot;</span>,arr[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十一：格式化输出</center></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//str :用来存放组装好的数据</span></span><br><span class="line"><span class="comment">//&quot;格式&quot;：组装格式</span></span><br><span class="line"><span class="comment">//数据: 各个零散的数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="string">&quot;格式&quot;</span>，数据)</span></span><br><span class="line"></span><br><span class="line">返回值：返回值的是组好的报文的实际长度<span class="params">(不包含<span class="string">&#x27;\0&#x27;</span>)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> year = <span class="number">2020</span>;</span><br><span class="line">    <span class="type">int</span> mon = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> day = <span class="number">24</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//需求：将2020 2 24组 成一个&quot;2020年2月24日&quot;</span></span><br><span class="line">    <span class="type">char</span> buf[ <span class="number">128</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//%d 和 year 类型要一一对应</span></span><br><span class="line">    len = <span class="built_in">sprintf</span> (buf, <span class="string">&quot;%d年%d月%d日&quot;</span>, year, mon, day);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;len = %d\n&quot;</span>,len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf=%s\n&quot;</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十二：提取格式字符串</center></h1>
<blockquote>
<p>从一个字符串中提取字符串，浮点数，整数等值，并将其保存到指定的变量中</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sscanf</span>(被提取的字符串,<span class="string">&quot;提取格式&quot;</span>,保存的地址,....);</span><br><span class="line"></span><br><span class="line"><span class="comment">//成功，该函数返回成功匹配和赋值的个数。如果到达文件末尾或发生读错误，则返回 EOF</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test09</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[] = <span class="string">&quot;2020年2月24日&quot;</span>;</span><br><span class="line">    <span class="type">int</span> year = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mon = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> day = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> str_year[<span class="number">32</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str_mon[<span class="number">32</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str_day[<span class="number">32</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//%d 只能提取&#x27;0&#x27;~&#x27;9&#x27;</span></span><br><span class="line">    <span class="built_in">sscanf</span>(buf,<span class="string">&quot;%d年%d月%d日&quot;</span>, &amp;year, &amp;mon, &amp;day );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;year = %d\n&quot;</span>, year);	<span class="comment">//2020</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mon = %d\n&quot;</span>, mon);	<span class="comment">//2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;day = %d\n&quot;</span>, day);	<span class="comment">//24</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//%c 提取一个字符 %f 提取提取浮点数</span></span><br><span class="line">    <span class="built_in">sscanf</span>(buf,<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;##%c##\n&quot;</span>,ch);	<span class="comment">//&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//%s 提取一个字符串 遇到空格、回车、&#x27;\0&#x27; 停止获取</span></span><br><span class="line">    <span class="comment">//buf==&gt;&quot;2020年2月24日&quot;</span></span><br><span class="line">    <span class="built_in">sscanf</span>(buf,<span class="string">&quot;%s年%s月%s日&quot;</span>, str_year, str_mon,str_day );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str_year=%s\n&quot;</span>, str_year);	<span class="comment">//&quot;2020年2月24日&quot;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str_mon=%s\n&quot;</span>, str_mon);	<span class="comment">//null</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str_day=%s\n&quot;</span>, str_day);	<span class="comment">//null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="center-sscanf高级用法-center"><center>sscanf高级用法</center></h2>
<blockquote>
<p>使用%*s %*d 跳过提取的内容(不要提取的内容)</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> datal = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//sscanf(&quot;1234 5678&quot;, &quot;1234 %d&quot;, &amp;datal);    //5678</span></span><br><span class="line">    <span class="comment">//sscanf(&quot;1234 5678&quot;,&quot;%*d %d&quot;, &amp;datal);    //5678</span></span><br><span class="line">    <span class="built_in">sscanf</span>(<span class="string">&quot;1234 5678&quot;</span>,<span class="string">&quot;%*s %d&quot;</span>, &amp;datal);    <span class="comment">//5678</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;datal = %d\n&quot;</span>, datal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用%*ns  %*nd提取指定宽度n的字符串或数据	n：需要的字节数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> datal = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> data2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">16</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">sscanf</span> (<span class="string">&quot;12abc5678&quot;</span>,<span class="string">&quot;%*5s%d&quot;</span>,&amp;datal) ;<span class="comment">//5678</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;datal=%d\n&quot;</span>, datal);</span><br><span class="line">    <span class="built_in">sscanf</span> (<span class="string">&quot;12345678&quot;</span>, <span class="string">&quot;%*2s%2d%*2d%s&quot;</span>,&amp;data2,buf);    <span class="comment">//data2=34 buf=&quot;78&quot;;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data2 = %d\n&quot;</span>, data2);    <span class="comment">//34</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf=%s\n&quot;</span>,buf);    <span class="comment">//&quot;78&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>%[a-z]提取a-z的<code>字符串</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//%[]都是按 字符串 提取</span></span><br><span class="line">    <span class="built_in">sscanf</span>(<span class="string">&quot;abcDefABC&quot;</span>, <span class="string">&quot;%[a-z]&quot;</span>,buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf=%s\n&quot;</span>,buf);    <span class="comment">//&quot;abc&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>%[aBc] 提取 a B c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//%[]都是按 字符串 提取</span></span><br><span class="line">    <span class="built_in">sscanf</span>(<span class="string">&quot;aaBBcEdef&quot;</span>, <span class="string">&quot;%[aBc]&quot;</span>,buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf=%s\n&quot;</span>,buf);        <span class="comment">//aaBBc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>%[^abc]提取不是a b c其中一个的字符串</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//%[]都是按 字符串 提取</span></span><br><span class="line">    <span class="built_in">sscanf</span>(<span class="string">&quot;ABCcABC&quot;</span>, <span class="string">&quot;%[^abc]&quot;</span>,buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf=%s\n&quot;</span>,buf);	<span class="comment">//ABC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点十三：const关键字</center></h1>
<blockquote>
<p>const修饰 变量 为只读</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//const修饰num为只读变量 num 只能取值 num不能被赋值</span></span><br><span class="line">    <span class="comment">//const 修饰的变量 尽量 初始化</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>,num) ;<span class="comment">//ok</span></span><br><span class="line">    <span class="comment">//num = 100;	//err num不能被赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;num = %p\n&quot;</span>,&amp;num);	<span class="comment">//0019FED8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//但是如果知道num的地址也可以间接的修改num的值(一般不这么做)</span></span><br><span class="line">    *(<span class="type">int</span> *)(&amp;num) = <span class="number">1000</span>;	<span class="comment">//少干</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>,num);	<span class="comment">//结果：num = 1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>const * int p</p>
<p>const在*的左边表示const修饰的是<code>*</code>而不是p</p>
<p>用户不能借助*p更改空间的内容,但是p可以指向其他空间(*p只读，p可读可写)</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num1=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//const在*的左边 *p只读 p可读可写</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *p = &amp;num1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>,*p);    <span class="comment">//10 </span></span><br><span class="line">    <span class="comment">//*p = 1000;    //err *p只读</span></span><br><span class="line"></span><br><span class="line">    p = &amp;num2;    <span class="comment">//ok p可读可写</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>,*p);	<span class="comment">//20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>int * const p</p>
<p>const在*的右边const修饰的是<code>p</code>而不是*</p>
<p>用户可以通过*p修改p所指向空间的内容，但是不能再更改p的指向(*p可读可写，p只读)</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//const在*的右边 *p可读可写  p只读</span></span><br><span class="line">    <span class="type">int</span> * <span class="type">const</span> p = &amp;num1;    <span class="comment">//p一旦初始化 就不能更改指向</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>,*p);    <span class="comment">//10</span></span><br><span class="line">    *p = <span class="number">1000</span>;    <span class="comment">//ok *p可读可写</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>,*p);    <span class="comment">// 1000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//p=&amp;num2;    //err p只读    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>const int * const p	(*p只读，p只读)</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p = &amp;num1;    <span class="comment">//*p和p都是只读</span></span><br><span class="line">    <span class="comment">//*p = 1000;    //err *p只读</span></span><br><span class="line">    <span class="comment">//p = &amp;num2;    //err p只读</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>8.动态内存申请</title>
    <url>/post/3ec1fd44.html</url>
    <content><![CDATA[<h1><center>知识点一：申请和释放空间</center></h1>
<h2 id="malloc函数">malloc函数</h2>
<blockquote>
<p>用于申请一块连续的指定大小的内存空间(堆区)，并返回一个指向它的指针</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">头文件：<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_ size)</span>;</span><br><span class="line"><span class="comment">//形参: num_ size需要申请空间大小的字节数</span></span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">	成功：返回空间的起始地址</span><br><span class="line">	失败: <span class="literal">NULL</span>    </span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>对于malloc的返回值一般要强制类型转换再赋值保存（返回值就是开辟对应的空间）</li>
<li>malloc申请的空间内容不确定，一般使用<code>memset</code>进行清空</li>
<li>多次调用malloc第1次malloc 和 第2次malloc的地址不一定连续</li>
</ul>
</blockquote>
<h2 id="free函数">free函数</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *addr)</span>;        ()里面是保存<span class="built_in">malloc</span>保存返回值的指针变量名</span><br><span class="line"><span class="comment">//功能：释放堆区空间</span></span><br></pre></td></tr></table></figure>
<p>从堆区申请 一个 int 空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_n</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入元素的个数:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>* <span class="title function_">get_addr</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span> *)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">my_input_array</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//记得将arr指向的空间清0</span></span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0</span>, n*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取键盘输入</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入%d个int数据\n&quot;</span>,n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, arr+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">my_print_array</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *arr=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到用户输入的元素个数</span></span><br><span class="line">    <span class="comment">//1、获取用户大小</span></span><br><span class="line">    n = get_n();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义函数 给arr申请堆区空间</span></span><br><span class="line">    arr = get_addr(n);</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;get_addr&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对空间读写操作</span></span><br><span class="line">    my_input_array(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对空间数组遍历</span></span><br><span class="line">    my_print_array(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放空间</span></span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点二：内存块清零</center></h1>
<blockquote>
<p>将指定的值 c 复制到 str 所指向的内存区域的前 n 个字节中，这可以用于将内存块清零或设置为特定值</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *str, <span class="type">int</span> c, <span class="type">size_t</span> n)</span></span><br><span class="line"></span><br><span class="line">形参：</span><br><span class="line">    str：指向要填充的内存区域的指针</span><br><span class="line">    c：要设置的值，通常是一个无符号字符</span><br><span class="line">    n：要被设置为该值的字节数</span><br><span class="line">    </span><br><span class="line">返回值：返回一个指向存储区 str 的指针</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;This is string.h library function&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(str);	<span class="comment">//This is string.h library function</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将str前7个字符，替换成$&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">memset</span>(str, <span class="string">&#x27;$&#x27;</span>, <span class="number">7</span>);	<span class="comment">//$$$$$$$ string.h library function</span></span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点二：calloc函数</center></h1>
<blockquote>
<p>申请的空间自动清零，不需要memset清零</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">头文件：<span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">// (强转类型 *)calloc(n,sizeof(类型))  n：无符号整数，()里面的字节数是n乘类型的字节数</span></span><br><span class="line"><span class="type">void</span> * <span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> nmemb,size_ t size)</span>;</span><br><span class="line">参数:</span><br><span class="line">    <span class="number">1</span>、nmemb：申请的数据块数</span><br><span class="line">    <span class="number">2</span>、size：每一块大小</span><br><span class="line">申请总大小 = nmemb*size</span><br><span class="line"></span><br><span class="line">返回值:</span><br><span class="line">    成功：返回空问的起始地址</span><br><span class="line">    失败：返回<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test04</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *arr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、获取用户大小</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入元素的个数:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、根据大小从堆区申请空间</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    arr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == arr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//perror 错误输出</span></span><br><span class="line">        perror(<span class="string">&quot;mallac&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(arr,<span class="number">0</span>,n*<span class="keyword">sizeof</span>(<span class="type">int</span>));	<span class="comment">//清零</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">    arr=(<span class="type">int</span> *)<span class="built_in">calloc</span>(n, <span class="keyword">sizeof</span>(<span class="type">int</span>));	<span class="comment">//自动清零 不需要使用memset</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == arr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//perror 错误输出</span></span><br><span class="line">        perror(<span class="string">&quot;calloc&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对arr的读写操作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入%d个int数据\n&quot;</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, arr+i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放空间</span></span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点三：realloc动态追加或减少空间</center></h1>
<blockquote>
<p>在原先s指向的内存基础.上重新申请内存，新的内存的大小为new_ size 个字节，如果原先内存后面有足够大的空间，就追加，如果后边的内存不够用，则relloc函数会在堆区找一个newsize个字节大小的内存申请，将原先内存中的内容拷贝过来，然后释放原先的内存，最后返回新内存的地址</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//(强转类型 *)realloc(保存原先开辟内存的指针名, (原先空间+新增空间)*sizeof(类型))</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *S,<span class="type">unsigned</span> <span class="type">int</span> newsize)</span>;</span><br><span class="line"></span><br><span class="line">参数: </span><br><span class="line">    s：原先开辟内存的首地址</span><br><span class="line">    newsize: 新申请的空间的总大小（原先+新增部分大小）（如果新申请的空间比原先大，则是追加，如果比原先小，则是减少）</span><br><span class="line">        </span><br><span class="line">返回值：新申请的内存的首地址</span><br><span class="line"><span class="built_in">realloc</span>的返回值一般要强制类型转换再赋值保存（返回值就是开辟对应的空间）</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *arr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n_new = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、获取用户大小</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入元素的个数:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    arr = (<span class="type">int</span> *)<span class="built_in">calloc</span>(n, <span class="keyword">sizeof</span>(<span class="type">int</span>));	<span class="comment">//自动清零 不需要使用memset</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == arr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//perror 错误输出</span></span><br><span class="line">        perror(<span class="string">&quot;calloc&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入%d个int数据\n&quot;</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, arr+i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//再追加5个元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入新增的元素个数:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n_new);</span><br><span class="line">    arr = (<span class="type">int</span> *)<span class="built_in">realloc</span>(arr, (n+n_new)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入新增的%d个int数据\n&quot;</span>,n_new);</span><br><span class="line">    <span class="keyword">for</span>(i = n; i &lt; (n+n_new); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,arr+i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; (n+n_new); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><center>知识点四：堆区空间使用注意事项</center></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p2 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> *p3 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//1、指向堆区空间的指针变量不要随意的更改指向</span></span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>)) ;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    p = &amp;num;    <span class="comment">//p指向num导致calloc申请的空间泄露</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、不要操作已经释放的空间</span></span><br><span class="line">    p2 = (<span class="type">int</span> *)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *p2 = <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">//释放该空间</span></span><br><span class="line">    <span class="built_in">free</span>(p2) ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p2 = %d\n, *p2);	//不确定</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    //3、不要对堆区空间重复释放</span></span><br><span class="line"><span class="string">    p3 = (int *)calloc(1, sizeof(int));</span></span><br><span class="line"><span class="string">    free(p3);</span></span><br><span class="line"><span class="string">    free(p3);	//多次释放</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h1><center>知识点五：防止多次释放</center></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test09</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)    <span class="comment">//防止多次释放</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
</search>
